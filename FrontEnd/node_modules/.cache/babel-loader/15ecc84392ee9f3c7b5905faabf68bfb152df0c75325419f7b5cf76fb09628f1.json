{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nvar Co = Object.defineProperty,\n  Oo = Object.defineProperties;\nvar To = Object.getOwnPropertyDescriptors;\nvar sn = Object.getOwnPropertySymbols;\nvar zo = Object.prototype.hasOwnProperty,\n  Io = Object.prototype.propertyIsEnumerable;\nvar ae = Math.pow,\n  rn = (e, t, n) => t in e ? Co(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: n\n  }) : e[t] = n,\n  se = (e, t) => {\n    for (var n in t || (t = {})) zo.call(t, n) && rn(e, n, t[n]);\n    if (sn) for (var n of sn(t)) Io.call(t, n) && rn(e, n, t[n]);\n    return e;\n  },\n  Fe = (e, t) => Oo(e, To(t));\nvar Ee = (e, t, n) => new Promise((o, i) => {\n  var s = c => {\n      try {\n        a(n.next(c));\n      } catch (u) {\n        i(u);\n      }\n    },\n    r = c => {\n      try {\n        a(n.throw(c));\n      } catch (u) {\n        i(u);\n      }\n    },\n    a = c => c.done ? o(c.value) : Promise.resolve(c.value).then(s, r);\n  a((n = n.apply(e, t)).next());\n});\nimport { isReactive as Lo, reactive as Ce, provide as Ae, inject as Ze, watch as F, toRef as Me, watchEffect as ge, computed as C, unref as b, ref as _, onMounted as We, onUnmounted as Je, nextTick as Dt, defineComponent as W, openBlock as M, createElementBlock as $, createBlock as R, resolveDynamicComponent as Mn, createCommentVNode as ce, Fragment as q, renderList as J, mergeProps as Pe, renderSlot as K, normalizeClass as ve, withModifiers as xe, normalizeStyle as et, useAttrs as $o, createElementVNode as Cn, createTextVNode as Ao, toDisplayString as an, createVNode as _e, withCtx as te, normalizeProps as ue, guardReactiveProps as de, useSlots as ft, createSlots as Nt, TransitionGroup as Ye, toHandlers as Zo, readonly as Xe } from \"vue\";\nimport { isEqual as Ie, round as ln, merge as On, mergeWith as Do, isPlainObject as No, debounce as _o, uniq as Bo, chunk as _t } from \"lodash-es\";\nconst jo = [\"paths\", \"node-labels\", \"nodes\", \"focusring\", \"edge-labels\", \"edges\", \"base\", \"grid\", \"background\", \"root\"];\nfunction ze(e) {\n  return Lo(e) ? e : Ce(e);\n}\nfunction G(e, t = \"Parameter\") {\n  if (e == null) throw new Error(`${t} is null`);\n  return e;\n}\nconst Tn = Symbol(\"containers\");\nfunction Vo(e) {\n  Ae(Tn, e);\n}\nfunction Bt() {\n  const e = G(Ze(Tn), \"containers\");\n  return {\n    container: e.container,\n    svg: e.svg,\n    viewport: e.viewport,\n    svgPanZoom: e.svgPanZoom\n  };\n}\nclass L {\n  static value(t, n) {\n    return t instanceof Function ? t(n) : t;\n  }\n  static values(t, n) {\n    return Object.values(t).filter(o => o instanceof Function).length === 0 ? t : Object.fromEntries(Object.entries(t).map(([o, i]) => [o, i instanceof Function ? i(n) : i]));\n  }\n}\nvar Z = /* @__PURE__ */(e => (e.CENTER = \"center\", e.NORTH = \"north\", e.NORTH_EAST = \"north-east\", e.EAST = \"east\", e.SOUTH_EAST = \"south-east\", e.SOUTH = \"south\", e.SOUTH_WEST = \"south-west\", e.WEST = \"west\", e.NORTH_WEST = \"north-west\", e))(Z || {});\nfunction St(e) {\n  const t = {};\n  return Object.assign(t, e(t));\n}\nfunction Ar(e) {\n  return e;\n}\nfunction Zr(e) {\n  return e;\n}\nfunction cn(e, t, n) {\n  const o = L.values(t.normal, e);\n  return o.type == \"circle\" ? {\n    width: o.radius * 2 * n,\n    height: o.radius * 2 * n\n  } : {\n    width: o.width * n,\n    height: o.height * n\n  };\n}\nfunction Ro(e, t, n, o) {\n  const s = Math.abs(e.x - n.x) < t.width / 2 + o.width / 2,\n    a = Math.abs(e.y - n.y) < t.height / 2 + o.height / 2;\n  return s && a;\n}\nfunction tt(e, t) {\n  let n = 0;\n  return t === 1 || e === void 0 || e === \"none\" ? n = e != null ? e : 0 : typeof e == \"string\" ? n = e.split(/\\s+/).map(o => parseInt(o) * t).filter(o => !isNaN(o)).join(\" \") : n = e * t, n && n !== \"0\" ? n : void 0;\n}\nfunction ht(e) {\n  let t = 0;\n  if (e === void 0 || e === \"none\") t = 0;else if (typeof e == \"string\") {\n    const n = e.split(/\\s+/).map(o => parseInt(o)).filter(o => !isNaN(o));\n    n.length % 2 === 0 ? t = n.reduce((o, i) => o + i, 0) : t = n.reduce((o, i) => o + i, 0) * 2;\n  } else t = e * 2;\n  return t;\n}\nconst un = 20;\nclass zn {\n  activate(t) {\n    const {\n        nodePositions: n,\n        nodes: o,\n        configs: i,\n        emitter: s,\n        scale: r,\n        svgPanZoom: a\n      } = t,\n      c = h => {\n        for (const [d, v] of Object.entries(h)) {\n          const x = this.getOrCreateNodePosition(n, d);\n          this.setNodePosition(x, v);\n        }\n      },\n      u = h => {\n        const d = h.filter(k => !(k in n.value)),\n          v = a.getViewArea(),\n          x = r.value;\n        for (const k of d) {\n          const E = o.value[k],\n            p = cn(E, i.node, x),\n            y = se({}, v.center);\n          for (;;) {\n            let m = !1;\n            for (const [f, g] of Object.entries(n.value)) {\n              if (k === f) continue;\n              const S = o.value[f];\n              if (!S) continue;\n              const O = cn(S, i.node, x);\n              if (m = Ro(y, p, g, O), m) break;\n            }\n            if (m) y.x += p.width + un * x, y.x + p.width / 2 > v.box.right && (y.x = v.center.x, y.y += p.height + un * x);else break;\n          }\n          const w = this.getOrCreateNodePosition(n, k);\n          this.setNodePosition(w, y);\n        }\n      };\n    u(Object.keys(o.value));\n    const l = F(() => Ie(new Set(Object.keys(o.value)), new Set(Object.keys(n.value))), h => {\n      h || u(Object.keys(o.value));\n    });\n    s.on(\"node:dragstart\", c), s.on(\"node:pointermove\", c), s.on(\"node:dragend\", c), this.onDeactivate = () => {\n      l(), s.off(\"node:dragstart\", c), s.off(\"node:pointermove\", c), s.off(\"node:dragend\", c);\n    };\n  }\n  deactivate() {\n    this.onDeactivate && this.onDeactivate();\n  }\n  setNodePosition(t, n) {\n    t.value.x = ln(n.x, 3), t.value.y = ln(n.y, 3);\n  }\n  getOrCreateNodePosition(t, n) {\n    const o = Me(t.value, n);\n    return o.value || (o.value = {\n      x: 0,\n      y: 0\n    }), o;\n  }\n}\nfunction In() {\n  return {\n    view: {\n      scalingObjects: !1,\n      panEnabled: !0,\n      zoomEnabled: !0,\n      minZoomLevel: 0.1,\n      maxZoomLevel: 64,\n      doubleClickZoomEnabled: !0,\n      mouseWheelZoomEnabled: !0,\n      boxSelectionEnabled: !1,\n      autoPanAndZoomOnLoad: \"center-content\",\n      autoPanOnResize: !0,\n      layoutHandler: new zn(),\n      onSvgPanZoomInitialized: void 0,\n      grid: {\n        visible: !1,\n        interval: 10,\n        thickIncrements: 5,\n        line: {\n          color: \"#e0e0e0\",\n          width: 1,\n          dasharray: 1\n        },\n        thick: {\n          color: \"#cccccc\",\n          width: 1,\n          dasharray: 0\n        }\n      },\n      selection: {\n        box: {\n          color: \"#0000ff20\",\n          strokeWidth: 1,\n          strokeColor: \"#aaaaff\",\n          strokeDasharray: 0\n        },\n        detector: e => {\n          const t = /Mac OS/.test(navigator.userAgent) ? e.metaKey : e.ctrlKey;\n          return e.type === \"keydown\" ? t : !t;\n        }\n      },\n      builtInLayerOrder: [],\n      onBeforeInitialDisplay: void 0\n    },\n    node: St(e => ({\n      normal: {\n        type: \"circle\",\n        radius: 16,\n        // for rect -->\n        width: 32,\n        height: 32,\n        borderRadius: 4,\n        // <-- for rect\n        color: \"#4466cc\",\n        strokeWidth: 0,\n        strokeColor: \"#000000\",\n        strokeDasharray: 0\n      },\n      hover: {\n        type: t => L.value(e.normal.type, t),\n        radius: t => {\n          var n;\n          return ((n = L.value(e.normal.radius, t)) != null ? n : 0) + 2;\n        },\n        width: t => {\n          var n;\n          return ((n = L.value(e.normal.width, t)) != null ? n : 0) + 2;\n        },\n        height: t => {\n          var n;\n          return ((n = L.value(e.normal.height, t)) != null ? n : 0) + 2;\n        },\n        borderRadius: t => {\n          var n;\n          return (n = L.value(e.normal.borderRadius, t)) != null ? n : 0;\n        },\n        strokeWidth: t => L.value(e.normal.strokeWidth, t),\n        strokeColor: t => L.value(e.normal.strokeColor, t),\n        strokeDasharray: t => L.value(e.normal.strokeDasharray, t),\n        color: \"#3355bb\"\n      },\n      selected: void 0,\n      draggable: !0,\n      selectable: !1,\n      label: {\n        visible: !0,\n        fontFamily: void 0,\n        fontSize: 11,\n        lineHeight: 1.1,\n        color: \"#000000\",\n        background: void 0,\n        // background: {\n        //   visible: true,\n        //   color: \"#ffffff\",\n        //   padding: {\n        //     vertical: 1,\n        //     horizontal: 4,\n        //   },\n        //   borderRadius: 2\n        // },\n        margin: 4,\n        direction: Z.SOUTH,\n        directionAutoAdjustment: !1,\n        text: \"name\",\n        handleNodeEvents: !0\n      },\n      focusring: {\n        visible: !0,\n        width: 4,\n        padding: 3,\n        color: \"#eebb00\"\n      },\n      zOrder: {\n        enabled: !1,\n        zIndex: 0,\n        bringToFrontOnHover: !0,\n        bringToFrontOnSelected: !0\n      },\n      transition: void 0\n    })),\n    edge: St(e => ({\n      normal: {\n        width: 2,\n        color: \"#4466cc\",\n        dasharray: 0,\n        linecap: \"butt\",\n        animate: !1,\n        animationSpeed: 50\n      },\n      hover: {\n        width: t => L.value(e.normal.width, t) + 1,\n        color: \"#3355bb\",\n        dasharray: t => L.value(e.normal.dasharray, t),\n        linecap: t => L.value(e.normal.linecap, t),\n        animate: t => L.value(e.normal.animate, t),\n        animationSpeed: t => L.value(e.normal.animationSpeed, t)\n      },\n      selected: {\n        width: t => L.value(e.normal.width, t) + 1,\n        color: \"#dd8800\",\n        dasharray: t => {\n          const n = L.value(e.normal.width, t);\n          return `${n * 1.5} ${n * 2}`;\n        },\n        linecap: t => L.value(e.normal.linecap, t),\n        animate: t => L.value(e.normal.animate, t),\n        animationSpeed: t => L.value(e.normal.animationSpeed, t)\n      },\n      selectable: !1,\n      gap: 3,\n      type: \"straight\",\n      marker: {\n        source: {\n          type: \"none\",\n          width: 5,\n          height: 5,\n          margin: -1,\n          offset: 0,\n          units: \"strokeWidth\",\n          color: null\n        },\n        target: {\n          type: \"none\",\n          width: 5,\n          height: 5,\n          margin: -1,\n          offset: 0,\n          units: \"strokeWidth\",\n          color: null\n        }\n      },\n      margin: null,\n      summarize: (t, n) => n.edge.type == \"curve\" ? !1 : null,\n      summarized: {\n        label: {\n          fontSize: 10,\n          lineHeight: 1,\n          color: \"#4466cc\"\n        },\n        shape: {\n          type: \"rect\",\n          // for circle -->\n          radius: 6,\n          // <-- for circle\n          width: 12,\n          height: 12,\n          borderRadius: 3,\n          color: \"#ffffff\",\n          strokeWidth: 1,\n          strokeColor: \"#4466cc\",\n          strokeDasharray: void 0\n        },\n        stroke: {\n          width: 5,\n          color: \"#4466cc\",\n          dasharray: void 0,\n          linecap: void 0,\n          animate: !1,\n          animationSpeed: 50\n        }\n      },\n      selfLoop: {\n        radius: 12,\n        isClockwise: !0,\n        offset: 10,\n        angle: 270\n      },\n      keepOrder: \"clock\",\n      label: {\n        fontFamily: void 0,\n        fontSize: 11,\n        lineHeight: 1.1,\n        color: \"#000000\",\n        background: void 0,\n        // background: {\n        //   visible: true,\n        //   color: \"#ffffff\",\n        //   padding: {\n        //     vertical: 1,\n        //     horizontal: 4,\n        //   },\n        //   borderRadius: 2\n        // },\n        margin: 4,\n        padding: 4\n      },\n      zOrder: {\n        enabled: !1,\n        zIndex: 0,\n        bringToFrontOnHover: !0,\n        bringToFrontOnSelected: !0\n      }\n    })),\n    path: St(e => ({\n      visible: !1,\n      clickable: !1,\n      hoverable: !1,\n      curveInNode: !1,\n      end: \"centerOfNode\",\n      margin: 0,\n      // @Deprecated\n      path: Ce({\n        width: 6,\n        color: t => {\n          const n = [\"#d5000088\", \"#c5116288\", \"#aa00ff88\", \"#6200ea88\", \"#304ffe88\", \"#2962ff88\", \"#0091ea88\", \"#00b8d488\", \"#00bfa588\", \"#00c85388\", \"#64dd1788\", \"#aeea0088\", \"#ffd60088\", \"#ffab0088\", \"#ff6d0088\", \"#dd2c0088\"],\n            o = t.edges.map(i => i.split(\"\").reduce((s, r) => (s = (s << 5) - s + r.charCodeAt(0), s & s), 0)).reduce((i, s) => i + s, 0);\n          return n[Math.abs(o) % n.length];\n        },\n        dasharray: void 0,\n        linecap: \"round\",\n        linejoin: \"round\",\n        animate: !1,\n        animationSpeed: 50\n      }),\n      normal: {\n        width: t => L.value(e.path.width, t),\n        color: t => L.value(e.path.color, t),\n        dasharray: t => L.value(e.path.dasharray, t),\n        linecap: t => L.value(e.path.linecap, t),\n        linejoin: t => L.value(e.path.linejoin, t),\n        animate: t => L.value(e.path.animate, t),\n        animationSpeed: t => L.value(e.path.animationSpeed, t)\n      },\n      hover: {\n        width: t => L.value(e.normal.width, t) + 2,\n        color: t => L.value(e.normal.color, t),\n        dasharray: t => L.value(e.normal.dasharray, t),\n        linecap: t => L.value(e.normal.linecap, t),\n        linejoin: t => L.value(e.normal.linejoin, t),\n        animate: t => L.value(e.normal.animate, t),\n        animationSpeed: t => L.value(e.normal.animationSpeed, t)\n      },\n      selected: {\n        width: t => L.value(e.normal.width, t) + 2,\n        color: t => L.value(e.normal.color, t),\n        dasharray: \"6 12\",\n        linecap: t => L.value(e.normal.linecap, t),\n        linejoin: t => L.value(e.normal.linejoin, t),\n        animate: t => L.value(e.normal.animate, t),\n        animationSpeed: t => L.value(e.normal.animationSpeed, t)\n      },\n      selectable: !1,\n      zOrder: {\n        enabled: !1,\n        zIndex: 0,\n        bringToFrontOnHover: !0,\n        bringToFrontOnSelected: !0\n      },\n      transition: void 0\n    }))\n  };\n}\nfunction Dr(e) {\n  const t = In();\n  return e && On(t, e), t;\n}\nconst Ln = Symbol(\"style\");\nfunction Ho(e, t) {\n  return No(e) ? On(e, t) : t;\n}\nfunction Wo(e) {\n  const t = Ce(In()),\n    n = Object.keys(t);\n  for (const o of n) F(() => e.value[o], () => {\n    Do(t[o], e.value[o] || {}, Ho);\n  }, {\n    immediate: !0,\n    deep: !0\n  });\n  return Ae(Ln, t), t;\n}\nfunction vt(e) {\n  return G(Ze(Ln), `Configs(${e})`)[e];\n}\nfunction Uo() {\n  return vt(\"view\");\n}\nfunction pt() {\n  return vt(\"node\");\n}\nfunction gt() {\n  return vt(\"edge\");\n}\nfunction $n() {\n  return vt(\"path\");\n}\nlet Fo = 1;\nfunction Xo() {\n  return Fo++;\n}\nfunction he(e) {\n  return Object.entries(e);\n}\nfunction at(e, t) {\n  const n = new Set(Object.keys(e));\n  he(t).forEach(([o, i]) => {\n    Ie(e[o], i) || (e[o] = i), n.delete(o);\n  }), n.forEach(o => delete e[o]);\n}\nfunction qo(e) {\n  return e instanceof Promise || e && typeof e.then == \"function\";\n}\nfunction Go(e, t, n) {\n  const o = ze({\n    edgeLayoutPoints: {},\n    edgeGroups: {},\n    summarizedEdges: {}\n  });\n  return ge(() => {\n    const {\n      edgeLayoutPoints: i,\n      edgeGroups: s\n    } = Yo(n, e.value, t.value);\n    at(o.edgeLayoutPoints, i), at(o.edgeGroups, s);\n  }), ge(() => {\n    const i = {};\n    for (const [s, {\n      edges: r,\n      groupWidth: a\n    }] of Object.entries(o.edgeGroups)) {\n      let c = !1;\n      if (a == 0) c = !1;else if (n.edge.summarize instanceof Function) {\n        const u = n.edge.summarize(r, n);\n        u === null ? c = dn(e.value, r, n, a) : c = u;\n      } else n.edge.summarize ? c = dn(e.value, r, n, a) : c = !1;\n      o.edgeGroups[s].summarize = c, c && Object.keys(r).forEach(u => i[u] = !0);\n    }\n    at(o.summarizedEdges, i);\n  }), o;\n}\nfunction Ko(e, t, n, o, i, s) {\n  return e ? t ? fn(e.edge, n, o, i, 0, 0, s) : fn(e.edge, n, o, i, e.groupWidth, e.pointInGroup, s) : {\n    p1: {\n      x: 0,\n      y: 0\n    },\n    p2: {\n      x: 0,\n      y: 0\n    }\n  };\n}\nfunction Yo(e, t, n) {\n  const o = {},\n    i = {},\n    s = {};\n  for (const [a, c] of Object.entries(n)) {\n    if (!(c.source in t && c.target in t)) continue;\n    const u = [c.source, c.target].sort().join(\"<=>\"),\n      l = s[u] || {};\n    l[a] = c, s[u] = l;\n  }\n  const r = e.edge.gap instanceof Function ? e.edge.gap : (a, c) => e.edge.gap;\n  for (const [a, c] of Object.entries(s)) {\n    const u = Object.keys(c).length;\n    if (u == 0) continue;\n    const l = r(c, e),\n      [h, d] = Object.entries(c)[0];\n    if (u === 1) o[h] = {\n      edge: d,\n      pointInGroup: 0,\n      groupWidth: 0\n    }, i[a] = {\n      edges: c,\n      groupWidth: 0,\n      summarize: !1\n    };else {\n      let v = 0;\n      const x = Object.entries(c).map(([p, y]) => {\n          let w = L.value(e.edge.normal.width, y);\n          return isNaN(+w) && (console.warn(\"[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]\", p, w), w = 1), w / 2;\n        }),\n        k = Object.entries(c).map(([p, y], w) => (w > 0 && (v += x[w - 1] + l + x[w]), [p, y, v])),\n        E = v;\n      k.forEach(([p, y, w]) => {\n        o[p] = {\n          edge: y,\n          pointInGroup: w,\n          groupWidth: E\n        };\n      }), i[a] = {\n        edges: c,\n        groupWidth: E,\n        summarize: !1\n      };\n    }\n  }\n  return {\n    edgeLayoutPoints: o,\n    edgeGroups: i\n  };\n}\nfunction dn(e, t, n, o) {\n  if (Object.entries(t).length === 1) return !1;\n  const s = Math.min(...Object.values(t).flatMap(r => [e[r.source], e[r.target]]).filter(r => r).map(r => {\n    const a = L.values(n.node.normal, r);\n    return a.type === \"circle\" ? a.radius * 2 : Math.min(a.width, a.height);\n  }));\n  return o > s;\n}\nfunction fn(e, t, n, o, i, s, r) {\n  var h, d, v, x, k, E, p, y;\n  let a, c, u, l;\n  return e.source < e.target ? [a, c, u, l] = hn((h = t == null ? void 0 : t.x) != null ? h : 0, (d = t == null ? void 0 : t.y) != null ? d : 0, (v = n == null ? void 0 : n.x) != null ? v : 0, (x = n == null ? void 0 : n.y) != null ? x : 0, o, i, s, r) : [u, l, a, c] = hn((k = n == null ? void 0 : n.x) != null ? k : 0, (E = n == null ? void 0 : n.y) != null ? E : 0, (p = t == null ? void 0 : t.x) != null ? p : 0, (y = t == null ? void 0 : t.y) != null ? y : 0, o, i, s, r), {\n    p1: {\n      x: a,\n      y: c\n    },\n    p2: {\n      x: u,\n      y: l\n    }\n  };\n}\nfunction hn(e, t, n, o, i, s, r, a) {\n  const c = n - e,\n    u = o - t;\n  let l = (s / 2 - r) * i;\n  if (l !== 0 && a !== \"clock\") {\n    const h = Math.atan2(o - t, n - e);\n    if (a === \"vertical\") {\n      const d = Math.PI / 2;\n      (h < -d || h >= d) && (l *= -1);\n    } else a === \"horizontal\" && h < 0 && (l *= -1);\n  }\n  if (c === 0) {\n    const h = u < 0 ? -1 : 1;\n    return [e + l * h, t, n + l * h, o];\n  } else if (u === 0) {\n    const h = c < 0 ? 1 : -1;\n    return [e, t + l * h, n, o + l * h];\n  } else {\n    const d = -1 / (u / c);\n    u < 0 && (l = -l);\n    const v = l / Math.sqrt(1 + Math.pow(d, 2));\n    return [e + v, t + v * d, n + v, o + v * d];\n  }\n}\nfunction An(e, t, n) {\n  return n || (n = {\n    x: 0,\n    y: 0\n  }), n.x = e.x + t.x, n.y = e.y + t.y, n;\n}\nfunction jt(e, t, n) {\n  return n || (n = {\n    x: 0,\n    y: 0\n  }), n.x = e.x - t.x, n.y = e.y - t.y, n;\n}\nfunction Zn(e, t, n) {\n  return n || (n = {\n    x: 0,\n    y: 0\n  }), n.x = e.x * t.x, n.y = e.y * t.y, n;\n}\nfunction Dn(e, t, n) {\n  return n || (n = {\n    x: 0,\n    y: 0\n  }), n.x = e.x * t, n.y = e.y * t, n;\n}\nfunction Vt(e, t, n) {\n  return n || (n = {\n    x: 0,\n    y: 0\n  }), n.x = e.x / t.x, n.y = e.y / t.y, n;\n}\nfunction Nn(e, t) {\n  return e.x * t.x + e.y * t.y;\n}\nfunction _n(e, t) {\n  return e.x * t.y - e.y * t.x;\n}\nfunction Rt(e) {\n  return e.x * e.x + e.y * e.y;\n}\nfunction Ht(e) {\n  return Math.sqrt(Rt(e));\n}\nfunction Wt(e, t) {\n  const n = e.x - t.x,\n    o = e.y - t.y;\n  return n * n + o * o;\n}\nfunction Bn(e, t) {\n  return Math.sqrt(Wt(e, t));\n}\nfunction jn(e, t) {\n  t || (t = {\n    x: 0,\n    y: 0\n  });\n  const n = Ht(e);\n  return n === 0 ? (t.x = 1, t.y = 0) : Vt(e, {\n    x: n,\n    y: n\n  }, t), t;\n}\nfunction ct(e, t, n) {\n  n || (n = {\n    x: 0,\n    y: 0\n  });\n  const o = e.x * Math.cos(t) - e.y * Math.sin(t),\n    i = e.x * Math.sin(t) + e.y * Math.cos(t);\n  return n.x = o, n.y = i, n;\n}\nconst Qo = 180 / Math.PI;\nfunction Jo(e) {\n  return e * Qo;\n}\nfunction Ut(e) {\n  return Math.atan2(e.y, e.x);\n}\nfunction Ft(e) {\n  return Jo(Ut(e));\n}\nconst ei = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  add: An,\n  angle: Ut,\n  angleDegree: Ft,\n  cross: _n,\n  distance: Bn,\n  distanceSquared: Wt,\n  divide: Vt,\n  dot: Nn,\n  length: Ht,\n  lengthSquared: Rt,\n  multiply: Zn,\n  multiplyScalar: Dn,\n  normalize: jn,\n  rotate: ct,\n  subtract: jt\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nclass V {\n  static fromArray(t) {\n    return new V(t[0] || 0, t[1] || 0);\n  }\n  static fromObject(t) {\n    return new V(t.x, t.y);\n  }\n  constructor(t, n) {\n    this.x = t, this.y = n;\n  }\n  // instance methods\n  add(t) {\n    return An(this, t, this);\n  }\n  subtract(t) {\n    return jt(this, t, this);\n  }\n  multiply(t) {\n    return Zn(this, t, this);\n  }\n  multiplyScalar(t) {\n    return Dn(this, t, this);\n  }\n  divide(t) {\n    return Vt(this, t, this);\n  }\n  dot(t) {\n    return Nn(this, t);\n  }\n  cross(t) {\n    return _n(this, t);\n  }\n  lengthSquared() {\n    return Rt(this);\n  }\n  length() {\n    return Ht(this);\n  }\n  distanceSquared(t) {\n    return Wt(this, t);\n  }\n  distance(t) {\n    return Bn(this, t);\n  }\n  normalize() {\n    return jn(this, this);\n  }\n  angle() {\n    return Ut(this);\n  }\n  angleDegree() {\n    return Ft(this);\n  }\n  rotate(t) {\n    return ct(this, t, this);\n  }\n  isEqualTo(t) {\n    return this.x === t.x && this.y === t.y;\n  }\n  clone() {\n    return new V(this.x, this.y);\n  }\n  toObject() {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  }\n  toArray() {\n    return [this.x, this.y];\n  }\n}\nconst ee = se({\n  Vector2D: V\n}, ei);\nclass Q {\n  constructor(t, n, o) {\n    this.source = t, this.target = n, this.v = o;\n  }\n  static fromLinePosition(t) {\n    const n = V.fromObject(t.p1),\n      o = V.fromObject(t.p2);\n    return new Q(n, o, Re(n, o));\n  }\n  static fromPositions(t, n) {\n    const o = V.fromObject(t),\n      i = V.fromObject(n);\n    return new Q(o, i, Re(o, i));\n  }\n  static fromVectors(t, n) {\n    return new Q(t, n, Re(t, n));\n  }\n}\nfunction Re(e, t) {\n  return t.clone().subtract(e);\n}\nfunction ti(e) {\n  return [V.fromObject(e.p1), V.fromObject(e.p2)];\n}\nfunction ni(e) {\n  return new V((e.p1.x + e.p2.x) / 2, (e.p1.y + e.p2.y) / 2);\n}\nfunction ut(e, t) {\n  return {\n    p1: e,\n    p2: t\n  };\n}\nfunction zt(e, t, n) {\n  const o = Q.fromLinePosition(e);\n  return oi(o, t, n);\n}\nfunction oi(e, t, n) {\n  const o = e.v.clone().normalize(),\n    i = e.source.clone().add(o.clone().multiplyScalar(t)),\n    s = e.target.clone().subtract(o.clone().multiplyScalar(n));\n  let r = i.toObject(),\n    a = s.toObject();\n  const c = Re(i, s);\n  if (e.v.angle() * c.angle() < 0) {\n    const u = new V((r.x + a.x) / 2, (r.y + a.y) / 2),\n      l = u.clone().add(o.multiplyScalar(0.5));\n    r = u.toObject(), a = l.toObject();\n  }\n  return {\n    p1: r,\n    p2: a\n  };\n}\nfunction ii(e) {\n  return {\n    p1: e.p2,\n    p2: e.p1\n  };\n}\nfunction qe(e) {\n  const t = e.v.clone().normalize().rotate(Math.PI / 2);\n  return Q.fromVectors(e.target, e.target.clone().add(t));\n}\nfunction Xt(e, t) {\n  const n = t.v.clone().normalize(),\n    o = t.source,\n    i = ee.subtract(e, o),\n    s = n.dot(i);\n  return o.clone().add(n.multiplyScalar(s));\n}\nfunction mt(e, t, n, o) {\n  if (!(ee.lengthSquared(ee.subtract(t, n)) - o * o <= Math.pow(1, -10))) return null;\n  const r = Q.fromVectors(e, t),\n    a = Xt(n, r),\n    c = ee.length(ee.subtract(a, n));\n  if (o < c) return null;\n  if (o === c) return a;\n  const u = Math.sqrt(ae(o, 2) - ae(c, 2)),\n    l = r.v.normalize().multiplyScalar(u);\n  return a.subtract(l);\n}\nfunction si(e, t, n, o, i) {\n  if (!(ee.lengthSquared(ee.subtract(t, n)) - o * o <= Math.pow(1, -10))) return null;\n  const a = Q.fromVectors(e, t),\n    c = Xt(n, a),\n    u = ee.length(ee.subtract(c, n));\n  if (o < u) return null;\n  if (o === u) return c;\n  const l = Math.sqrt(ae(o, 2) - ae(u, 2)),\n    h = a.v.normalize().multiplyScalar(l),\n    d = c.clone().add(h),\n    v = c.clone().subtract(h),\n    x = i.distance(d),\n    k = i.distance(v);\n  return Math.abs(x - k) < 2 ? v : x < k ? d : v;\n}\nfunction Ne(e, t) {\n  const n = ee.subtract(t.source, e.source),\n    o = e.v,\n    i = t.v,\n    s = ee.cross(n, o) / ee.cross(o, i);\n  return t.source.clone().add(i.clone().multiplyScalar(s));\n}\nfunction Qe(e, t, n, o, i) {\n  const s = e,\n    a = n.clone().subtract(s),\n    c = a.length(),\n    u = t + o;\n  if (u < c) return null;\n  const l = Math.abs(t - o);\n  if (c < l) return null;\n  if (c === u) {\n    const g = a.clone().normalize(),\n      S = e.clone().add(g.multiplyScalar(t));\n    return i ? S : [S, S];\n  }\n  if (c === l) {\n    const g = a.clone().normalize(),\n      S = t > o,\n      O = e.clone().add(g.multiplyScalar(S ? t : -t));\n    return i ? O : [O, O];\n  }\n  const h = t,\n    d = o,\n    v = (ae(c, 2) + ae(h, 2) - ae(d, 2)) / (2 * c * h),\n    x = h * v,\n    k = Math.sqrt(ae(h, 2) - ae(x, 2)),\n    E = a.clone().normalize(),\n    p = new V(-E.y, E.x),\n    y = E.clone().multiplyScalar(x),\n    w = p.clone().multiplyScalar(k),\n    m = e.clone().add(y).add(w),\n    f = e.clone().add(y).subtract(w);\n  if (i) {\n    const g = m.distance(i),\n      S = f.distance(i);\n    return g < S ? m : f;\n  } else return [m, f];\n}\nfunction vn(e, t, n, o) {\n  const i = Q.fromPositions(e, t),\n    s = (n.width + n.strokeWidth) / 2 * o,\n    r = (n.height + n.strokeWidth) / 2 * o,\n    a = n.borderRadius > 0 ? (n.borderRadius + n.strokeWidth / 2) * o : 0,\n    c = (i.v.angle() - Math.PI / 2) % Math.PI,\n    u = Math.PI / 2 - c % Math.PI,\n    l = r * Math.abs(Math.tan(c)),\n    h = s * Math.abs(Math.tan(u)),\n    d = l <= s - a,\n    v = h <= r - a;\n  if (d || v || a === 0) return Math.sqrt(d ? ae(r, 2) + ae(l, 2) : ae(s, 2) + ae(h, 2));\n  {\n    const x = t.x - s + a,\n      k = t.y - r + a,\n      E = t.x + s - a,\n      p = t.y + r - a,\n      y = [new V(x, k), new V(E, k), new V(E, p), new V(x, p)],\n      w = Math.floor((i.v.angleDegree() + 360) % 360 / 90),\n      m = y[w],\n      f = mt(i.source, Xt(m, i), m, a);\n    return f ? Re(f, i.target).length() : Re(m, i.target).length() + a;\n  }\n}\nfunction Vn(e, t, n, o, i) {\n  const s = Q.fromLinePosition(e),\n    r = s.v.clone().normalize(),\n    a = o === 0 ? s.source : s.source.clone().add(r.clone().multiplyScalar(o * i)),\n    c = o === 0 ? s.target : s.target.clone().subtract(r.clone().multiplyScalar(o * i)),\n    u = (t.width / 2 + n) * i,\n    l = new V(-r.y, r.x).multiplyScalar(u);\n  let h = ee.subtract(a, l),\n    d = ee.add(a, l),\n    v = ee.subtract(c, l),\n    x = ee.add(c, l);\n  const k = s.v.angleDegree();\n  return (k < -90 || k >= 90) && ([h, d] = [d, h], [v, x] = [x, v]), {\n    source: {\n      above: h,\n      below: d\n    },\n    target: {\n      above: v,\n      below: x\n    }\n  };\n}\nfunction ri(e, t, n, o) {\n  let i;\n  n.type === \"circle\" ? i = n.radius + n.strokeWidth / 2 : i = vn(t, e, n, 1\n  // scale\n  );\n\n  let s;\n  return o.type === \"circle\" ? s = o.radius + o.strokeWidth / 2 : s = vn(e, t, o, 1\n  // scale\n  ), [i, s];\n}\nfunction Le(e, t, n) {\n  const {\n      x: o,\n      y: i\n    } = e,\n    s = o - t.x,\n    r = i - t.y;\n  return {\n    x: s * Math.cos(n) - r * Math.sin(n) + t.x,\n    y: s * Math.sin(n) + r * Math.cos(n) + t.y\n  };\n}\nfunction It(e) {\n  return e > 0 ? -(Math.PI * 2 - e) : Math.PI * 2 + e;\n}\nfunction Lt(e, t, n, o) {\n  const i = [],\n    s = Q.fromVectors(t, e),\n    r = Q.fromVectors(t, n);\n  let a = He(s, r);\n  o * a < 0 && (a = It(a));\n  const c = V.fromObject(Le(e, t, -a / 2)),\n    u = Q.fromVectors(t, c),\n    l = qe(u),\n    h = He(s, u);\n  let d = qe(s);\n  if (Math.abs(h) < Math.PI / 2) {\n    const x = Ne(d, l);\n    i.push(x);\n  } else {\n    const x = V.fromObject(Le(c, t, h / 2)),\n      k = qe(Q.fromVectors(t, V.fromObject(x))),\n      E = Ne(d, k),\n      p = Ne(k, l);\n    i.push(E, x, p);\n  }\n  i.push(c);\n  const v = He(r, u);\n  if (d = qe(r), Math.abs(v) < Math.PI / 2) {\n    const x = Ne(d, l);\n    i.push(x);\n  } else {\n    const x = V.fromObject(Le(c, t, v / 2)),\n      k = qe(Q.fromVectors(t, V.fromObject(x))),\n      E = Ne(l, k),\n      p = Ne(k, d);\n    i.push(E, x, p);\n  }\n  return i;\n}\nfunction He(e, t) {\n  return Math.atan2(e.v.y * t.v.x - e.v.x * t.v.y, e.v.x * t.v.x + e.v.y * t.v.y);\n}\nfunction ai(e, t, n) {\n  const o = e.x,\n    i = e.y,\n    s = t.x,\n    r = t.y,\n    a = n.x,\n    c = n.y,\n    u = o - s,\n    l = i - r,\n    h = a - s,\n    d = c - r;\n  if (u === 0 && l === 0 || h === 0 && d === 0) return [e, 0];\n  const v = (d * (u * (o + s) + l * (i + r)) - l * (h * (a + s) + d * (c + r))) / (2 * u * d - 2 * l * h),\n    x = (-h * (u * (o + s) + l * (i + r)) + u * (h * (a + s) + d * (c + r))) / (2 * u * d - 2 * l * h),\n    k = Math.sqrt(Math.pow(o - v, 2) + Math.pow(i - x, 2));\n  return [new V(v, x), k];\n}\nfunction Ve(e) {\n  return e.type == \"circle\" ? e.radius : Math.min(e.width, e.height) / 2;\n}\nfunction it(...e) {\n  return e.find(t => !!t);\n}\nconst li = Number.EPSILON * 100;\nfunction ci(e, t, n, o, i, s, r, a) {\n  var k, E;\n  const c = e.edges,\n    u = e.directions,\n    l = c.map((p, y) => di(p, u[y], o[p.edgeId])),\n    h = [];\n  let d = !1,\n    v = !1;\n  {\n    const p = l[0];\n    let y = Ve(t[p.source].shape) * i;\n    const w = a + (r === \"edgeOfNode\" ? y : 0),\n      m = w <= 0 ? p.line.source : gn(p, w, n, !0);\n    h.push(m), y = Ve(t[p.target].shape) * i, a > 0 && ee.distance(p.line.source, p.line.target) <= w + y && (d = !0);\n  }\n  const x = c.length;\n  for (let p = 1; p < x; p++) {\n    const y = l[p - 1],\n      w = l[p],\n      m = w.source,\n      f = V.fromObject((k = n[m]) != null ? k : {\n        x: 0,\n        y: 0\n      }),\n      g = ui(y, w, f),\n      S = Ve(t[m].shape) * i,\n      O = Math.max(S * (2 / 3), S - 4 * i),\n      I = $t(y),\n      T = $t(w),\n      z = st(y, f, O, I),\n      A = st(w, f, O, !T),\n      j = st(y, f, S, I),\n      Y = st(w, f, S, !T);\n    let B;\n    if (g) {\n      const U = ee.distance(g, f);\n      if (U < O) B = [it(z, j, y.line.target), g, it(A, Y, w.line.source)];else if (U <= S) {\n        let be, oe;\n        j && z ? be = ee.distance(g, z) < ee.distance(g, j) ? z : j : be = j || y.line.target, Y && A ? oe = ee.distance(g, A) < ee.distance(g, Y) ? A : Y : oe = Y || w.line.source, B = [be, g, oe];\n      } else z && A ? B = [z, f, A] : j && Y ? B = [j, f, Y] : B = [it(z, j, y.line.target), f, it(A, Y, w.line.source)];\n    } else z && A ? B = [z, f, A] : j && Y ? B = [j, f, Y] : B = [y.line.target, f, w.line.source];\n    if (y.curve) {\n      const U = h[h.length - 1];\n      if (U) {\n        const be = U instanceof Array ? U[U.length - 1] : U;\n        let oe;\n        B instanceof Array ? oe = s ? B[0] : B[1] : oe = B;\n        const ke = Lt(be, y.curve.circle.center, oe, y.curve.theta);\n        B instanceof Array && s ? h.push([...ke, ...B]) : h.push([...ke, oe]);\n      }\n    } else if (y.loop) {\n      const [U, be, oe] = bn(f, y, S);\n      h.push(U), h.push(oe), B instanceof Array && s ? h.push([be, B[1], B[2]]) : h.push(B[2]);\n    } else s || !(B instanceof Array) ? h.push(B) : w.curve ? h.push(B[1]) : w.loop ? h.push(B[0]) : h.push(B[0], B[2]);\n  }\n  {\n    const p = l[l.length - 1];\n    let y = Ve(t[p.target].shape) * i;\n    const w = a + (r === \"edgeOfNode\" ? y : 0),\n      m = w <= 0 ? p.line.target : gn(p, w, n, !1);\n    if (y = Ve(t[p.source].shape) * i, p.loop) {\n      const f = V.fromObject((E = n[p.target]) != null ? E : {\n          x: 0,\n          y: 0\n        }),\n        [g, S, O] = bn(f, p, y);\n      h.push(g), h.push(O);\n    } else if (p.curve) {\n      const f = h[h.length - 1],\n        g = f instanceof Array ? f[f.length - 1] : f,\n        S = Lt(g, p.curve.circle.center, m, p.curve.theta);\n      h.push([...S, m]);\n    } else h.push(m);\n    a > 0 && ee.distance(p.line.source, p.line.target) <= w + y && (v = !0);\n  }\n  return d && (h.shift(), h[0] instanceof Array && h.unshift(h[0][0])), v && h.pop(), h;\n}\nfunction pn(e) {\n  const t = e.length;\n  if (t === 0) return [];\n  if (t <= 1) return [!0];\n  const n = [];\n  let o = null,\n    i = !0;\n  for (let s = 0; s < t; s++) {\n    const r = e[s].edge.source,\n      a = e[s].edge.target;\n    if (s === 0) {\n      if (t > 2) {\n        const c = Rn(e, 0);\n        c === null ? i = !0 : i = c === a;\n      } else i = [e[1].edge.source, e[1].edge.target].includes(a);\n    } else r === a ? i = !0 : i = o === r;\n    n.push(i), o = i ? a : r;\n  }\n  return n;\n}\nfunction Rn(e, t) {\n  const n = e[t],\n    o = e[t + 1],\n    i = [n.edge.source, n.edge.target].sort(),\n    s = [o.edge.source, o.edge.target].sort();\n  if (i[0] === i[1]) return i[0];\n  if (s[0] === s[1]) return s[0];\n  if (n.edgeId === o.edgeId || i[0] === s[0] && i[1] === s[1]) {\n    if (t >= e.length - 2) return null;\n    {\n      const r = Rn(e, t + 1);\n      return r === null ? null : r === i[1] ? i[0] : i[1];\n    }\n  } else return s.includes(i[1]) ? i[1] : i[0];\n}\nfunction gn(e, t, n, o) {\n  const i = o ? e.source : e.target,\n    s = e.curve;\n  if (s) {\n    let r = t / s.circle.radius;\n    return s.theta > 0 && (r *= -1), o || (r *= -1), V.fromObject(Le(o ? e.line.source : e.line.target, s.circle.center, r));\n  } else {\n    let r, a;\n    if (o ? (r = e.line.target, a = e.line.source) : (r = e.line.source, a = e.line.target), n[i]) {\n      const c = mt(r, a, V.fromObject(n[i]), t);\n      return c === null ? r : c;\n    } else return r;\n  }\n}\nfunction ui(e, t, n) {\n  let o = null;\n  if (e.loop || t.loop) o = null;else if (e.curve) {\n    if (t.curve) {\n      if (e.line.target.isEqualTo(t.line.source)) return e.line.target.clone();\n      o = Qe(e.curve.circle.center, e.curve.circle.radius, t.curve.circle.center, t.curve.circle.radius, e.curve.center);\n    } else o = si(t.line.target, t.line.source, e.curve.circle.center, e.curve.circle.radius, n);\n  } else if (t.curve) o = mt(e.line.source, e.line.target, t.curve.circle.center, t.curve.circle.radius);else {\n    const i = mn(e.line),\n      s = mn(t.line);\n    !isFinite(i) && !isFinite(s) || Math.abs(i - s) < li ? o = null : o = Ne(e.line, t.line);\n  }\n  return o;\n}\nfunction st(e, t, n, o) {\n  if (e.loop) {\n    const i = Qe(t, n, e.loop.center, e.loop.radius[0]);\n    return i ? o ? i[0] : i[1] : null;\n  } else return e.curve ? Qe(t, n, e.curve.circle.center, e.curve.circle.radius, V.fromObject(e.curve.center)) : mt(o ? e.line.source : e.line.target, o ? e.line.target : e.line.source, t, n);\n}\nfunction di(e, t, n) {\n  let o = n.origin,\n    i = e.edge.source,\n    s = e.edge.target,\n    r = n.curve;\n  const a = n.loop;\n  a ? o = n.position : t || (o = ii(o), i = e.edge.target, s = e.edge.source, r && (r = Fe(se({}, r), {\n    theta: -r.theta\n  })));\n  const c = Q.fromLinePosition(o);\n  return {\n    edgeId: e.edgeId,\n    source: i,\n    target: s,\n    line: c,\n    direction: t,\n    curve: r,\n    loop: a\n  };\n}\nfunction mn(e) {\n  return (e.target.y - e.source.y) / (e.target.x - e.source.x);\n}\nfunction bn(e, t, n) {\n  const {\n      radius: o,\n      center: i\n    } = G(t.loop, \"Loop of edge parameter\"),\n    [s, r] = o,\n    a = Qe(e, n, i, o[0]);\n  let [c, u] = a ? a.reverse() : [t.line.source, t.line.target];\n  const l = $t(t);\n  l || ([c, u] = [u, c]);\n  const h = c,\n    d = u,\n    v = V.fromObject(h).subtract(i).angleDegree();\n  let E = (V.fromObject(d).subtract(i).angleDegree() + 360 - v) % 360 >= 180;\n  return E = l ? E : !E, [h, d, `A ${s} ${r} 0 ${E ? 1 : 0} ${l ? 1 : 0} ${d.x} ${d.y}`];\n}\nfunction $t(e) {\n  return e.loop ? e.direction ? e.loop.isClockwise : !e.loop.isClockwise : !0;\n}\nfunction Mt(e, t, n, o, i, s, r) {\n  const a = Ce({});\n  F(() => new Set(Object.keys(e.value)), (u, l) => {\n    l || (l = /* @__PURE__ */new Set([]));\n    for (const h of u) l.has(h) || fi(e, a, h, !1, t, i);\n    for (const h of l) u.has(h) || (n.delete(h), o.delete(h), s == null || s(h, a[h]), delete a[h]);\n  }, {\n    immediate: !0\n  }), F(() => [...n], (u, l) => {\n    const h = l ? u.filter(v => !l.includes(v)) : u,\n      d = l ? l.filter(v => !u.includes(v)) : [];\n    h.forEach(v => {\n      const x = a[v];\n      x && !x.selected && (x.selected = !0);\n    }), d.forEach(v => {\n      const x = a[v];\n      x && x.selected && (x.selected = !1);\n    });\n  }, {\n    immediate: !0\n  }\n  // for specified from the beginning\n  ), F(() => [...o], (u, l) => {\n    const h = u.filter(v => !l.includes(v)),\n      d = l.filter(v => !u.includes(v));\n    h.forEach(v => {\n      const x = a[v];\n      x && !x.hovered && (x.hovered = !0);\n    }), d.forEach(v => {\n      const x = a[v];\n      x && x.hovered && (x.hovered = !1);\n    });\n  });\n  const c = C(() => {\n    const u = r ? r() : Object.values(a);\n    return t.zOrder.enabled ? hi(u, t.zOrder, o, n) : u;\n  });\n  return {\n    states: a,\n    zOrderedList: c\n  };\n}\nfunction fi(e, t, n, o, i, s) {\n  const r = {\n    id: n,\n    selected: o,\n    hovered: !1,\n    selectable: C(() => e.value[n] ? L.value(i.selectable, e.value[n]) : b(r.selectable)),\n    zIndex: C(() => e.value[n] ? L.value(i.zOrder.zIndex, e.value[n]) : b(r.zIndex))\n  };\n  t[n] = r, s(e, n, t[n]\n  /* get reactive object */);\n}\n\nfunction hi(e, t, n, o) {\n  return t.bringToFrontOnHover && t.bringToFrontOnSelected ? e.sort((i, s) => {\n    const r = n.has(i.id),\n      a = n.has(s.id);\n    if (r != a) return r ? 1 : -1;\n    const c = o.has(i.id),\n      u = o.has(s.id);\n    return c != u ? c ? 1 : -1 : i.zIndex - s.zIndex;\n  }) : t.bringToFrontOnHover ? e.sort((i, s) => {\n    const r = n.has(i.id),\n      a = n.has(s.id);\n    return r != a ? r ? 1 : -1 : i.zIndex - s.zIndex;\n  }) : t.bringToFrontOnSelected ? e.sort((i, s) => {\n    const r = o.has(i.id),\n      a = o.has(s.id);\n    return r != a ? r ? 1 : -1 : i.zIndex - s.zIndex;\n  }) : e.sort((i, s) => i.zIndex - s.zIndex);\n}\nfunction vi(e) {\n  return typeof btoa === void 0 ? Buffer.from(e).toString(\"base64\").replaceAll(\"=\", \"\") : btoa(e).replaceAll(\"=\", \"\");\n}\nfunction pi() {\n  return {\n    markers: Ce({}),\n    referenceCount: {}\n  };\n}\nfunction gi(e) {\n  const {\n    markers: t,\n    referenceCount: n\n  } = e;\n  function o(a, c) {\n    var l;\n    const u = (l = n[a]) != null ? l : 0;\n    n[a] = u + 1, u || (t[a] = c);\n  }\n  function i(a) {\n    var u;\n    const c = (u = n[a]) != null ? u : 0;\n    c && (c - 1 === 0 ? (delete t[a], delete n[a]) : n[a] = c - 1);\n  }\n  function s(a) {\n    a && i(a);\n  }\n  function r(a, c, u, l, h) {\n    if (a.type === \"none\") {\n      s(u);\n      return;\n    }\n    if (a.type === \"custom\") return s(u), a.customId;\n    const d = mi(a, c, l),\n      v = bi(d, h);\n    return v === u || (s(u), o(v, d)), v;\n  }\n  return {\n    makeMarker: r,\n    clearMarker: s\n  };\n}\nfunction mi(e, t, n) {\n  var o;\n  return Fe(se({}, e), {\n    color: (o = e.color) != null ? o : n,\n    isSource: t\n  });\n}\nfunction bi(e, t) {\n  const n = vi(e.color),\n    o = e.isSource ? \"L\" : \"R\",\n    i = e.units === \"strokeWidth\" ? \"rel\" : \"abs\";\n  return `marker_${t}_${e.type}_${e.width}_${e.height}_${e.margin}_${e.offset}_${n}_${o}_${i}`;\n}\nfunction Ct(e, t, n) {\n  return {\n    objects: e,\n    selected: t,\n    hovered: n\n  };\n}\nconst Hn = Symbol(\"states\"),\n  yi = {\n    type: \"none\",\n    width: 0,\n    height: 0,\n    margin: 0,\n    offset: 0,\n    units: \"strokeWidth\",\n    color: null\n  };\nfunction wi(e, t, n, o, i, s, r) {\n  const a = Ce({}),\n    c = ze({});\n  ge(() => {\n    const w = Object.fromEntries(Object.keys(e.objects.value).map(m => [m, {}]));\n    Object.entries(t.objects.value).forEach(([m, f]) => {\n      w != null && w[f.source] || (w[f.source] = {}), w != null && w[f.target] || (w[f.target] = {}), w[f.source][m] = f.target, w[f.target][m] = f.source;\n    }), at(c, w);\n  });\n  const {\n      states: u,\n      zOrderedList: l\n      //\n    } = Mt(e.objects, o.node, e.selected, e.hovered, (w, m, f) => {\n      ki(w, m, f, o.node, c, i);\n    }, (w, m) => {\n      const f = i.nodes;\n      delete f[w];\n    }),\n    h = Xo(),\n    d = Go(e.objects, t.objects, o),\n    v = _([]),\n    {\n      states: x,\n      zOrderedList: k\n      //\n    } = Mt(t.objects, o.edge, t.selected, t.hovered, (w, m, f) => {\n      Si(w, m, f, o.edge, s, u, d, i, r, h);\n    }, (w, m) => {\n      var f;\n      (f = m.stopWatchHandle) == null || f.call(m);\n    }, () => v.value);\n  ge(() => {\n    v.value = Mi(d.edgeGroups, x);\n  }), F(d.edgeGroups, w => Ti(a, d, o), {\n    immediate: !0\n  });\n  const {\n      states: E,\n      zOrderedList: p\n      //\n    } = Mt(n.objects, o.path, n.selected, n.hovered, (w, m, f) => {\n      const g = f;\n      g.clickable = C(() => w.value[m] ? L.value(o.path.clickable, w.value[m]) : !1), g.hoverable = C(() => w.value[m] ? L.value(o.path.hoverable, w.value[m]) : !1), g.path = w.value[m], g.edges = wn(g.path, t), g.directions = pn(g.edges), g.stopWatchHandle = F(() => w.value[m].edges, () => {\n        g.edges = wn(g.path, t), g.directions = pn(g.edges);\n      });\n    }, (w, m) => {\n      var f;\n      (f = m.stopWatchHandle) == null || f.call(m);\n    }),\n    y = {\n      nodeStates: u,\n      edgeStates: x,\n      edgeGroupStates: d,\n      summarizedEdgeStates: a,\n      pathStates: E,\n      layouts: i,\n      nodeZOrderedList: l,\n      edgeZOrderedList: k,\n      pathZOrderedList: p\n    };\n  return Ae(Hn, y), y;\n}\nfunction Ei(e) {\n  return e.summarized;\n}\nfunction Se() {\n  return G(Ze(Hn), \"states\");\n}\nfunction xi(e, t, n, o) {\n  return n && o.hover ? L.values(o.hover, e) : Wn(e, t, o);\n}\nfunction Wn(e, t, n) {\n  return t && n.selected ? L.values(n.selected, e) : L.values(n.normal, e);\n}\nfunction ki(e, t, n, o, i, s) {\n  n.shape = C(() => e.value[t] ? xi(e.value[t], n.selected, n.hovered, o) : b(n.shape)), n.staticShape = C(() => e.value[t] ? Wn(e.value[t], n.selected, o) : b(n.staticShape)), n.label = C(() => e.value[t] ? L.values(o.label, e.value[t]) : b(n.label)), n.labelText = C(() => {\n    var r, a;\n    return o.label.text instanceof Function ? b(n.label).text : e.value[t] ? (a = (r = e.value[t]) == null ? void 0 : r[b(n.label).text]) != null ? a : \"\" : b(n.labelText);\n  }), n.draggable = C(() => e.value[t] ? L.value(o.draggable, e.value[t]) : b(n.draggable)), n.oppositeNodeIds = Me(i, t), n.oppositeNodes = C(() => Object.entries(n.oppositeNodeIds).reduce((r, a) => {\n    const [c, u] = a,\n      l = s.nodes[u];\n    return l && (r[c] = {\n      nodeId: u,\n      pos: se({}, l)\n    }), r;\n  }, {}));\n}\nfunction Pi(e, t, n, o) {\n  return t ? L.values(o.selected, e) : n && o.hover ? L.values(o.hover, e) : L.values(o.normal, e);\n}\nfunction yn(e) {\n  return e.type === \"none\" ? yi : e;\n}\nfunction Si(e, t, n, o, i, s, r, a, c, u) {\n  const {\n    makeMarker: l,\n    clearMarker: h\n  } = gi(i);\n  Object.assign(n, {\n    origin: {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 0,\n        y: 0\n      }\n    },\n    labelPosition: {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 0,\n        y: 0\n      }\n    },\n    position: {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 0,\n        y: 0\n      }\n    }\n  }), n.label = C(() => e.value[t] ? L.values(o.label, e.value[t]) : b(n.label));\n  const d = C(() => {\n    const p = e.value[t],\n      y = Pi(p, n.selected, n.hovered, o);\n    isNaN(+y.width) && (console.warn(\"[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]\", t, y.width), y.width = 1), (y.color === void 0 || y.color === null) && (console.warn(\"[v-network-graph] Edge color is invalid value. id=[%s] value=[%s]\", t, y.color), y.color = \"#000000\");\n    let w = L.value(o.normal.width, p);\n    isNaN(+w) && (w = 1);\n    const m = yn(L.values(o.marker.source, [p, y])),\n      f = yn(L.values(o.marker.target, [p, y]));\n    return {\n      stroke: y,\n      normalWidth: w,\n      source: m,\n      target: f\n    };\n  });\n  n.line = d;\n  const v = Me(r.edgeLayoutPoints, t),\n    x = Me(r.summarizedEdges, t),\n    k = ge(() => {\n      var B, U, be, oe, ke, De, Ue;\n      const p = e.value[t];\n      if (!p) return;\n      const y = (B = s[p.source]) == null ? void 0 : B.staticShape,\n        w = (U = s[p.target]) == null ? void 0 : U.staticShape;\n      if (!y || !w) return;\n      const m = (be = a.nodes[p == null ? void 0 : p.source]) != null ? be : {\n          x: 0,\n          y: 0\n        },\n        f = (oe = a.nodes[p == null ? void 0 : p.target]) != null ? oe : {\n          x: 0,\n          y: 0\n        },\n        g = Ko(v.value, (ke = x.value) != null ? ke : !1, m, f, c.value, o.keepOrder),\n        [S, O] = ri(m, f, y, w),\n        I = c.value;\n      n.labelPosition = zt(g, S * I, O * I);\n      let T = 0,\n        z = 0;\n      const A = d.value;\n      if (A.source.type !== \"none\") {\n        const le = A.source;\n        T = le.margin + le.width, le.units === \"strokeWidth\" && (T *= A.normalWidth);\n      }\n      if (A.target.type !== \"none\") {\n        const le = A.target;\n        z = le.margin + le.width, le.units === \"strokeWidth\" && (z *= A.normalWidth);\n      }\n      o.margin && (T += o.margin, z += o.margin);\n      const j = !!o.margin || A.source.type !== \"none\" || A.target.type !== \"none\";\n      if (p.source === p.target) {\n        n.origin = ut(m, f);\n        const le = L.values(o.selfLoop, p),\n          [Be, ye] = Oi(m, y, le, j, T, z, (Ue = (De = v.value) == null ? void 0 : De.pointInGroup) != null ? Ue : 0, I);\n        n.position = Be, n.loop = ye, n.curve = void 0;\n        return;\n      } else n.loop = void 0;\n      if (j && (T += S, z += O), o.type === \"straight\" || x.value) n.origin = g, n.curve = void 0, T === 0 && z === 0 ? n.position = n.origin : n.position = zt(n.origin, T * I, z * I);else {\n        n.origin = ut(m, f);\n        const le = v.value ? v.value.groupWidth / 2 - v.value.pointInGroup : 0,\n          [Be, ye] = Ci(n.origin, g, le, T * I, z * I);\n        n.position = Be, n.curve = ye;\n      }\n    }),\n    E = ge(() => {\n      e.value[t] && (n.sourceMarkerId = l(d.value.source, !0, n.sourceMarkerId, d.value.stroke.color, u), n.targetMarkerId = l(d.value.target, !1, n.targetMarkerId, d.value.stroke.color, u));\n    });\n  n.stopWatchHandle = () => {\n    k(), E(), h(n.sourceMarkerId), h(n.targetMarkerId);\n  };\n}\nfunction Mi(e, t) {\n  return Object.entries(e).map(([n, o]) => {\n    var i;\n    return o.summarize ? {\n      id: (i = Object.keys(o.edges)[0]) != null ? i : n,\n      summarized: !0,\n      key: n,\n      group: o,\n      zIndex: Object.keys(o.edges).map(s => {\n        var r, a;\n        return (a = (r = t[s]) == null ? void 0 : r.zIndex) != null ? a : 0;\n      }).reduce((s, r) => Math.max(s, r))\n    } : Object.entries(o.edges).map(([s, r]) => {\n      var a, c;\n      return {\n        id: s,\n        summarized: !1,\n        key: s,\n        edge: r,\n        zIndex: (c = (a = t[s]) == null ? void 0 : a.zIndex) != null ? c : 0\n      };\n    });\n  }).flat();\n}\nfunction Ci(e, t, n, o, i) {\n  const s = Q.fromLinePosition(e),\n    r = Q.fromLinePosition(t),\n    a = ni(t),\n    [c, u] = ai(s.source, s.target, a);\n  let l, h;\n  if (u === 0) return [e, h];\n  if (n === 0) return o === 0 && i === 0 ? l = e : l = zt(e, o, i), [l, h];\n  const d = Q.fromVectors(c, a),\n    v = He(Q.fromVectors(c, s.source), d);\n  if (o === 0 && i === 0) l = e;else {\n    let p = o / u,\n      y = i / u;\n    v > 0 && (p *= -1, y *= -1), l = ut(Le(s.source, c, p), Le(s.target, c, -y));\n    let w = He(Q.fromVectors(c, s.source), Q.fromVectors(c, s.target)),\n      m = He(Q.fromPositions(c, l.p1), Q.fromPositions(c, l.p2));\n    if (v * w < 0 && (w = It(w), v * m < 0 && (m = It(m))), w * m < 0) {\n      const f = a.clone().add(r.v.normalize().multiplyScalar(0.5));\n      return l = ut(a, f), [l, h];\n    }\n  }\n  const [x, k] = ti(l),\n    E = Lt(x, c, k, v).map(p => p.toObject());\n  return h = {\n    center: a,\n    theta: v,\n    circle: {\n      center: c,\n      radius: u\n    },\n    control: E\n  }, [l, h];\n}\nfunction Oi(e, t, n, o, i, s, r, a) {\n  const c = a,\n    u = (n.radius + r / 2) * c,\n    l = n.offset * c + u,\n    h = (n.angle - 90) * (Math.PI / 180),\n    d = V.fromObject({\n      x: e.x + l * Math.cos(h),\n      y: e.y + l * Math.sin(h)\n    }),\n    v = n.isClockwise;\n  let x, k;\n  if (o) {\n    const m = Qe(d, u, V.fromObject(e), Ve(t) * c);\n    if (m) {\n      [x, k] = m;\n      let f = 1;\n      if (v || ([x, k] = [k, x], f = -1), i !== 0 || s !== 0) {\n        const g = i * c / u * f,\n          S = s * c / u * f;\n        x = Le(x, d, g), k = Le(k, d, -S);\n      }\n    }\n  }\n  if (x === void 0 || k === void 0) {\n    const m = V.fromObject(e).subtract(d).normalize().multiplyScalar(u);\n    let f = 1 * (Math.PI / 180);\n    v || (f *= -1), x = d.clone().add(ct(m, f)), k = d.clone().add(ct(m, -f));\n  }\n  const E = V.fromObject(x).subtract(d).angleDegree(),\n    w = (V.fromObject(k).subtract(d).angleDegree() + 360 - E) % 360 >= 180;\n  return [{\n    p1: x,\n    p2: k\n  }, {\n    center: d,\n    radius: [u, u],\n    isLargeArc: v ? w : !w,\n    isClockwise: v\n  }];\n}\nfunction Ti(e, t, n) {\n  const o = t.edgeGroups;\n  Object.entries(o).filter(([i, s]) => s.summarize && !(i in e)).forEach(([i, s]) => {\n    const r = {\n      stroke: void 0\n    };\n    r.stroke = C(() => L.values(n.edge.summarized.stroke, s.edges)), e[i] = r;\n  }), Object.keys(e).forEach(i => {\n    var s;\n    (s = t.edgeGroups[i]) != null && s.summarize || delete e[i];\n  });\n}\nfunction wn(e, t) {\n  return e.edges.map(n => ({\n    edgeId: n,\n    edge: t.objects.value[n]\n  })).filter(n => n.edge);\n}\nclass Ke {\n  static valueOf(t) {\n    return Array.from(t.values());\n  }\n}\nconst zi = 3,\n  Ii = 6,\n  Un = 500;\nfunction lt(e) {\n  return e === \"touch\" ? Ii : zi;\n}\nfunction qt(e, t, n, o) {\n  let i = e.get(t);\n  if (i) i.id !== n && (i = void 0);else {\n    const a = Array.from(e.entries()).find(([c, u]) => u.id === n);\n    if (a) {\n      const [c, u] = a;\n      e.delete(c), i = u;\n    }\n  }\n  let s, r;\n  return [i, s, r] = Fn(i, o, n), e.set(t, i), [s, r];\n}\nfunction Fn(e, t, n) {\n  const o = Date.now();\n  e && o - e.lastTime <= Un ? (e.count++, e.lastTime = o) : e = {\n    count: 1,\n    lastTime: o,\n    id: n\n  };\n  const i = {\n    view: window,\n    screenX: t.screenX,\n    screenY: t.screenY,\n    clientX: t.clientX,\n    clientY: t.clientY,\n    ctrlKey: t.ctrlKey,\n    shiftKey: t.shiftKey,\n    altKey: t.altKey,\n    metaKey: t.metaKey,\n    button: t.button,\n    buttons: t.buttons,\n    detail: e.count\n  };\n  let s, r;\n  return t instanceof PointerEvent ? (Object.assign(i, {\n    pointerId: t.pointerId,\n    width: t.width,\n    height: t.height,\n    pressure: t.pressure,\n    tangentialPressure: t.tangentialPressure,\n    tiltX: t.tiltX,\n    tiltY: t.tiltY,\n    twist: t.twist,\n    pointerType: t.pointerType,\n    isPrimary: t.isPrimary\n  }), s = new PointerEvent(\"click\", i), e.count === 2 && (r = new PointerEvent(\"dblclick\", i))) : (s = new MouseEvent(\"click\", i), e.count === 2 && (r = new MouseEvent(\"dblclick\", i))), [e, s, r];\n}\nfunction Gt(e) {\n  const t = Date.now();\n  Array.from(e.entries()).filter(([n, o]) => t - o.lastTime > Un).map(([n, o]) => e.delete(n));\n}\nfunction Li(e, t, n, o, i, s, r) {\n  const a = {\n      pointers: /* @__PURE__ */new Map(),\n      follow: {\n        followedPointerId: -1,\n        nodeBasePositions: {}\n      },\n      hoveredNodesPre: /* @__PURE__ */new Set(),\n      clicks: /* @__PURE__ */new Map()\n    },\n    c = {\n      pointermove: v,\n      pointerup: k,\n      pointercancel: x\n    };\n  function u(m) {\n    const f = a.follow.followedPointerId === m.pointerId,\n      g = i.has(m.nodeId),\n      S = !(m.pointerId in a.pointers);\n    if (f && S || f && !g) {\n      const O = Ke.valueOf(a.pointers).find(I => i.has(I.nodeId));\n      if (!O) {\n        a.follow = {\n          followedPointerId: -1,\n          nodeBasePositions: {}\n        };\n        return;\n      }\n      m = O, a.follow.followedPointerId = m.pointerId;\n    } else {\n      const O = a.pointers.get(a.follow.followedPointerId);\n      if (!O) {\n        a.follow = {\n          followedPointerId: -1,\n          nodeBasePositions: {}\n        };\n        return;\n      }\n      m = O;\n    }\n    if (f || g) {\n      const O = Ke.valueOf(a.pointers).map(I => I.nodeId);\n      a.follow.nodeBasePositions = Object.fromEntries(Array.from(i).filter(I => !O.includes(I)).filter(I => {\n        var T;\n        return (T = e[I]) == null ? void 0 : T.draggable;\n      }).map(I => [I, Ot(t.nodes, I)])), m.dragBasePosition = se({}, m.latestPosition), m.nodeBasePosition = Ot(t.nodes, m.nodeId);\n    }\n  }\n  F(i, m => {\n    const f = a.pointers.get(a.follow.followedPointerId);\n    f && u(f), m.size > 0 && n.selectionMode.value !== \"node\" ? n.selectionMode.value = \"node\" : m.size === 0 && n.selectionMode.value === \"node\" && (n.selectionMode.value = \"container\");\n  }), F(n.selectionMode, m => {\n    m !== \"node\" && i.clear();\n  });\n  function l(m, f) {\n    const g = m.dragBasePosition.x - f.pageX,\n      S = m.dragBasePosition.y - f.pageY,\n      O = a.follow.followedPointerId == m.pointerId ? se({\n        [m.nodeId]: m.nodeBasePosition\n      }, a.follow.nodeBasePositions) : {\n        [m.nodeId]: m.nodeBasePosition\n      },\n      I = s.value;\n    return Object.fromEntries(Object.entries(O).map(([T, z]) => [T, {\n      x: z.x - g / I,\n      y: z.y - S / I\n    }]));\n  }\n  function h(m, f) {\n    var S, O;\n    if (f.isTrusted || f.shiftKey && ![\"container\", \"node\"].includes(n.selectionMode.value)) return;\n    n.selectionMode.value = \"node\";\n    const g = (O = (S = e[m]) == null ? void 0 : S.selectable) != null ? O : !1;\n    if (g) {\n      const I = Ke.valueOf(a.pointers).filter(T => i.has(T.nodeId)).length > 0;\n      f.shiftKey || I ? i.has(m) ? i.delete(m) : typeof g == \"number\" && i.size >= g || i.add(m) : i.has(m) || (i.clear(), i.add(m));\n    }\n    r.emit(\"node:click\", {\n      node: m,\n      event: f\n    });\n  }\n  function d(m, f) {\n    f.isTrusted || r.emit(\"node:dblclick\", {\n      node: m,\n      event: f\n    });\n  }\n  function v(m) {\n    var O;\n    m.stopPropagation();\n    const f = a.pointers.get(m.pointerId);\n    if (!f) return;\n    f.latestPosition = {\n      x: m.pageX,\n      y: m.pageY\n    }, f.moveCounter++;\n    const g = lt(m.pointerType);\n    if (f.moveCounter <= g || !((O = e[f.nodeId]) != null && O.draggable)) return;\n    if (f.moveCounter === g + 1) {\n      const I = l(f, {\n        pointerId: f.pointerId,\n        pageX: f.dragBasePosition.x,\n        pageY: f.dragBasePosition.y\n      });\n      r.emit(\"node:dragstart\", I);\n    }\n    const S = l(f, m);\n    r.emit(\"node:pointermove\", S);\n  }\n  function x(m) {\n    m.stopPropagation();\n    let f = a.pointers.get(m.pointerId);\n    if (f) {\n      for (f of a.pointers.values()) {\n        const g = f.nodeId,\n          S = lt(m.pointerType);\n        if (f.moveCounter > S) {\n          const I = l(f, {\n            pointerId: f.pointerId,\n            pageX: f.latestPosition.x,\n            pageY: f.latestPosition.y\n          });\n          r.emit(\"node:dragend\", I);\n        }\n        r.emit(\"node:pointerup\", {\n          node: g,\n          event: m\n        });\n      }\n      a.pointers.clear(), a.follow = {\n        followedPointerId: -1,\n        nodeBasePositions: {}\n      }, he(c).forEach(([g, S]) => {\n        document.removeEventListener(g, S);\n      }), n.viewMode.value = \"default\";\n    }\n  }\n  function k(m) {\n    var I, T, z;\n    m.stopPropagation();\n    const f = a.pointers.get(m.pointerId);\n    if (!f) return;\n    a.pointers.delete(m.pointerId);\n    const g = f.nodeId,\n      S = lt(m.pointerType),\n      O = f.moveCounter > S;\n    if (O) {\n      if ((I = e[f.nodeId]) != null && I.draggable) {\n        const A = l(f, m);\n        r.emit(\"node:dragend\", A), r.emit(\"node:pointerup\", {\n          node: g,\n          event: m\n        });\n      }\n    } else r.emit(\"node:pointerup\", {\n      node: g,\n      event: m\n    });\n    if (!O) {\n      const [A, j] = qt(a.clicks, f.pointerId, g, m);\n      (T = f.eventTarget) == null || T.dispatchEvent(A), j && ((z = f.eventTarget) == null || z.dispatchEvent(j));\n    }\n    a.pointers.size === 0 ? (a.follow = {\n      followedPointerId: -1,\n      nodeBasePositions: {}\n    }, he(c).forEach(([A, j]) => {\n      document.removeEventListener(A, j);\n    }), Gt(a.clicks), n.viewMode.value = \"default\") : u(f), o.clear(), a.hoveredNodesPre.forEach(o.add, o);\n  }\n  function E(m, f) {\n    if (f.button == 2 || (f.stopPropagation(), ![\"default\", \"node\"].includes(n.viewMode.value))) return;\n    a.pointers.size == 0 && (n.viewMode.value = \"node\", he(c).forEach(([S, O]) => {\n      document.addEventListener(S, O);\n    }));\n    const g = {\n      pointerId: f.pointerId,\n      nodeId: m,\n      moveCounter: 0,\n      nodeBasePosition: Ot(t.nodes, m),\n      dragBasePosition: {\n        x: f.pageX,\n        y: f.pageY\n      },\n      latestPosition: {\n        x: f.pageX,\n        y: f.pageY\n      },\n      eventTarget: f.currentTarget\n    };\n    a.pointers.set(f.pointerId, g), i.has(m) && (a.follow.followedPointerId < 0 ? (a.follow.followedPointerId = f.pointerId, u(g)) : delete a.follow.nodeBasePositions[g.nodeId]), r.emit(\"node:pointerdown\", {\n      node: m,\n      event: f\n    });\n  }\n  function p(m, f) {\n    a.hoveredNodesPre.add(m), !(a.pointers.size > 0) && (o.add(m), r.emit(\"node:pointerover\", {\n      node: m,\n      event: f\n    }));\n  }\n  function y(m, f) {\n    a.hoveredNodesPre.delete(m), !(a.pointers.size > 0) && (o.delete(m), r.emit(\"node:pointerout\", {\n      node: m,\n      event: f\n    }));\n  }\n  function w(m, f) {\n    f.stopPropagation(), r.emit(\"node:contextmenu\", {\n      node: m,\n      event: f\n    });\n  }\n  return {\n    handleNodePointerDownEvent: E,\n    handleNodePointerOverEvent: p,\n    handleNodePointerOutEvent: y,\n    handleNodeClickEvent: h,\n    handleNodeDoubleClickEvent: d,\n    handleNodeContextMenu: w\n  };\n}\nfunction Ot(e, t) {\n  var o;\n  const n = (o = e[t]) != null ? o : {\n    x: 0,\n    y: 0\n  };\n  return se({}, n);\n}\nfunction $i(e, t, n, o, i) {\n  const s = {\n      pointers: /* @__PURE__ */new Map(),\n      // <PointerId, ...>\n      pointerPeekCount: 0,\n      clicks: /* @__PURE__ */new Map()\n    },\n    r = {\n      pointerup: c,\n      pointercancel: u\n    };\n  F(o, f => {\n    f.size > 0 && t.selectionMode.value !== \"edge\" ? t.selectionMode.value = \"edge\" : f.size === 0 && t.selectionMode.value === \"edge\" && (t.selectionMode.value = \"container\");\n  }), F(t.selectionMode, f => {\n    f !== \"edge\" && o.clear();\n  });\n  function a(f, g) {\n    if (g.button == 2 || (g.stopPropagation(), ![\"default\", \"edge\"].includes(t.viewMode.value))) return;\n    s.pointers.size == 0 && (t.viewMode.value = \"edge\", he(r).forEach(([O, I]) => {\n      document.addEventListener(O, I);\n    }), s.pointerPeekCount = 0), s.pointerPeekCount++;\n    const S = {\n      pointerId: g.pointerId,\n      id: f,\n      eventTarget: g.currentTarget\n    };\n    s.pointers.set(g.pointerId, S), i.emit(\"edge:pointerdown\", we(f, g));\n  }\n  function c(f) {\n    var T, z;\n    f.stopPropagation();\n    const g = s.pointers.get(f.pointerId);\n    if (!g) return;\n    s.pointers.delete(f.pointerId);\n    const S = g.id;\n    i.emit(\"edge:pointerup\", we(S, f));\n    const [O, I] = qt(s.clicks, g.pointerId, S instanceof Array ? S.join(\",\") : S, f);\n    (T = g.eventTarget) == null || T.dispatchEvent(O), I && ((z = g.eventTarget) == null || z.dispatchEvent(I)), s.pointers.size === 0 && (s.pointerPeekCount = 0, he(r).forEach(([A, j]) => {\n      document.removeEventListener(A, j);\n    }), Gt(s.clicks), t.viewMode.value = \"default\");\n  }\n  function u(f) {\n    if (f.stopPropagation(), !!s.pointers.get(f.pointerId)) {\n      for (const S of s.pointers.values()) {\n        const O = S.id;\n        i.emit(\"edge:pointerup\", we(O, f));\n      }\n      s.pointers.clear(), s.pointerPeekCount = 0, he(r).forEach(([S, O]) => {\n        document.removeEventListener(S, O);\n      }), i.emit(\"view:mode\", \"default\");\n    }\n  }\n  function l(f, g) {\n    var I;\n    if (g.isTrusted || g.shiftKey && ![\"container\", \"edge\"].includes(t.selectionMode.value)) return;\n    t.selectionMode.value = \"edge\";\n    const S = f instanceof Array ? f : [f],\n      O = Ke.valueOf(s.pointers).filter(T => (T.id instanceof Array ? T.id : [T.id]).every(A => o.has(A))).length > 0;\n    if (f instanceof Array) S.find(z => {\n      var A;\n      return (A = e[z]) == null ? void 0 : A.selectable;\n    }) && (g.shiftKey || O ? S.some(z => o.has(z)) ? S.forEach(z => o.delete(z)) : S.forEach(z => {\n      var j;\n      const A = (j = e[z]) == null ? void 0 : j.selectable;\n      typeof A == \"number\" && o.size >= A || o.add(z);\n    }) : (o.clear(), S.forEach(z => o.add(z))));else {\n      const T = (I = e[f]) == null ? void 0 : I.selectable;\n      T && (g.shiftKey || O ? o.has(f) ? o.delete(f) : typeof T == \"number\" && o.size >= T || o.add(f) : o.has(f) || (o.clear(), o.add(f)));\n    }\n    i.emit(\"edge:click\", we(f, g));\n  }\n  function h(f, g) {\n    g.isTrusted || i.emit(\"edge:dblclick\", we(f, g));\n  }\n  function d(f, g) {\n    n.add(f), i.emit(\"edge:pointerover\", we(f, g));\n  }\n  function v(f, g) {\n    n.delete(f), i.emit(\"edge:pointerout\", we(f, g));\n  }\n  function x(f, g) {\n    g.stopPropagation(), i.emit(\"edge:contextmenu\", we(f, g));\n  }\n  function k(f, g) {\n    if (g.button == 2 || (g.stopPropagation(), ![\"default\", \"edge\"].includes(t.viewMode.value))) return;\n    s.pointers.size == 0 && (t.viewMode.value = \"edge\", he(r).forEach(([O, I]) => {\n      document.addEventListener(O, I);\n    }), s.pointerPeekCount = 0), s.pointerPeekCount++;\n    const S = {\n      pointerId: g.pointerId,\n      id: f,\n      eventTarget: g.currentTarget\n    };\n    s.pointers.set(g.pointerId, S), i.emit(\"edge:pointerdown\", we(f, g));\n  }\n  function E(f, g) {\n    f.forEach(S => n.add(S)), i.emit(\"edge:pointerover\", we(f, g));\n  }\n  function p(f, g) {\n    f.forEach(S => n.delete(S)), i.emit(\"edge:pointerout\", we(f, g));\n  }\n  function y(f, g) {\n    l(f, g);\n  }\n  function w(f, g) {\n    h(f, g);\n  }\n  function m(f, g) {\n    g.stopPropagation(), i.emit(\"edge:contextmenu\", we(f, g));\n  }\n  return {\n    handleEdgePointerDownEvent: a,\n    handleEdgePointerOverEvent: d,\n    handleEdgePointerOutEvent: v,\n    handleEdgeClickEvent: l,\n    handleEdgeDoubleClickEvent: h,\n    handleEdgeContextMenu: x,\n    handleEdgesPointerDownEvent: k,\n    handleEdgesPointerOverEvent: E,\n    handleEdgesPointerOutEvent: p,\n    handleEdgesClickEvent: y,\n    handleEdgesDoubleClickEvent: w,\n    handleEdgesContextMenu: m\n  };\n}\nfunction we(e, t) {\n  return e instanceof Array ? {\n    edges: e,\n    event: t,\n    summarized: !0\n  } : {\n    edge: e,\n    edges: [e],\n    event: t,\n    summarized: !1\n  };\n}\nfunction Ai(e, t, n, o) {\n  const i = {\n      moveCounter: 0,\n      pointerCounter: 0,\n      clickState: void 0\n    },\n    s = {\n      pointermove: a,\n      pointerup: c,\n      pointercancel: c\n    };\n  function r(v) {\n    i.moveCounter = 0, i.pointerCounter === 0 && he(s).forEach(([x, k]) => {\n      document.addEventListener(x, k, {\n        passive: !0\n      });\n    }), i.pointerCounter++;\n  }\n  function a(v) {\n    i.moveCounter++;\n  }\n  function c(v) {\n    if (i.pointerCounter--, i.pointerCounter <= 0) {\n      i.pointerCounter = 0, he(s).forEach(([k, E]) => {\n        document.removeEventListener(k, E);\n      });\n      const x = lt(v.pointerType);\n      if (i.moveCounter <= x) {\n        if (v.shiftKey && t.selectionMode.value !== \"container\") return;\n        t.selectionMode.value = \"container\";\n        const [k, E, p] = Fn(i.clickState, v, \"view\");\n        i.clickState = k, e.value.dispatchEvent(E), p && e.value.dispatchEvent(p);\n      }\n    }\n  }\n  function u(v) {\n    v.isTrusted || (v.stopPropagation(), o.emit(\"view:click\", {\n      event: v\n    }));\n  }\n  function l(v) {\n    v.isTrusted || (v.stopPropagation(), o.emit(\"view:dblclick\", {\n      event: v\n    }));\n  }\n  function h(v) {\n    o.emit(\"view:contextmenu\", {\n      event: v\n    }), i.pointerCounter > 0 && (i.pointerCounter = 0, he(s).forEach(([x, k]) => {\n      var E;\n      (E = e.value) == null || E.removeEventListener(x, k);\n    }));\n  }\n  const d = v => {\n    v.preventDefault();\n  };\n  We(() => {\n    const v = e.value;\n    v && (v.addEventListener(\"pointerdown\", r, {\n      passive: !0\n    }), v.addEventListener(\"click\", u, {\n      passive: !1\n    }), v.addEventListener(\"dblclick\", l, {\n      passive: !1\n    }), v.addEventListener(\"contextmenu\", h, {\n      passive: !1\n    }), n.value && v.addEventListener(\"wheel\", d, {\n      passive: !1\n    }));\n  }), Je(() => {\n    const v = e.value;\n    v && (v.removeEventListener(\"pointerdown\", r), v.removeEventListener(\"click\", u), v.removeEventListener(\"dblclick\", l), v.removeEventListener(\"contextmenu\", h), n.value && v.removeEventListener(\"wheel\", d));\n  }), F(n, (v, x) => {\n    const k = e.value;\n    !k || v === x || (v ? k.addEventListener(\"wheel\", d, {\n      passive: !1\n    }) : k.removeEventListener(\"wheel\", d));\n  });\n}\nfunction Zi(e, t, n, o, i, s) {\n  const r = {\n    pointers: /* @__PURE__ */new Map(),\n    // <PointerId, ...>\n    pointerPeekCount: 0,\n    clicks: /* @__PURE__ */new Map()\n  };\n  function a(p, y) {\n    var w, m;\n    return i.value ? {\n      path: (m = (w = e[p]) == null ? void 0 : w.path) != null ? m : p,\n      event: y\n    } : {\n      path: p,\n      event: y\n    };\n  }\n  const c = {\n    pointerup: l,\n    pointercancel: h\n  };\n  F(o, p => {\n    p.size > 0 && t.selectionMode.value !== \"path\" ? t.selectionMode.value = \"path\" : p.size === 0 && t.selectionMode.value === \"path\" && (t.selectionMode.value = \"container\");\n  }), F(t.selectionMode, p => {\n    p !== \"path\" && o.clear();\n  });\n  function u(p, y) {\n    var m;\n    if (!((m = e[p]) != null && m.clickable) || y.button == 2 || (y.stopPropagation(), ![\"default\", \"path\"].includes(t.viewMode.value))) return;\n    r.pointers.size == 0 && (t.viewMode.value = \"path\", he(c).forEach(([f, g]) => {\n      document.addEventListener(f, g);\n    }), r.pointerPeekCount = 0), r.pointerPeekCount++;\n    const w = {\n      pointerId: y.pointerId,\n      id: p,\n      eventTarget: y.currentTarget\n    };\n    r.pointers.set(y.pointerId, w), s.emit(\"path:pointerdown\", a(p, y));\n  }\n  function l(p) {\n    var g, S;\n    const y = r.pointers.get(p.pointerId);\n    if (!y) return;\n    p.stopPropagation(), r.pointers.delete(p.pointerId);\n    const w = y.id;\n    s.emit(\"path:pointerup\", a(w, p));\n    const [m, f] = qt(r.clicks, y.pointerId, w, p);\n    (g = y.eventTarget) == null || g.dispatchEvent(m), f && ((S = y.eventTarget) == null || S.dispatchEvent(f)), r.pointers.size === 0 && (r.pointerPeekCount = 0, he(c).forEach(([O, I]) => {\n      document.removeEventListener(O, I);\n    }), Gt(r.clicks), t.viewMode.value = \"default\");\n  }\n  function h(p) {\n    if (r.pointers.get(p.pointerId)) {\n      p.stopPropagation();\n      for (const w of r.pointers.values()) {\n        const m = w.id;\n        s.emit(\"path:pointerup\", a(m, p));\n      }\n      r.pointers.clear(), r.pointerPeekCount = 0, he(c).forEach(([w, m]) => {\n        document.removeEventListener(w, m);\n      }), s.emit(\"view:mode\", \"default\");\n    }\n  }\n  function d(p, y) {\n    var w;\n    (w = e[p]) != null && w.hoverable && (n.add(p), s.emit(\"path:pointerover\", a(p, y)));\n  }\n  function v(p, y) {\n    var w;\n    (w = e[p]) != null && w.hoverable && (n.delete(p), s.emit(\"path:pointerout\", a(p, y)));\n  }\n  function x(p, y) {\n    var m, f, g;\n    if (y.isTrusted || !((m = e[p]) != null && m.clickable) || y.shiftKey && ![\"container\", \"path\"].includes(t.selectionMode.value)) return;\n    t.selectionMode.value = \"path\";\n    const w = (g = (f = e[p]) == null ? void 0 : f.selectable) != null ? g : !1;\n    if (w) {\n      const S = Ke.valueOf(r.pointers).filter(O => o.has(O.id)).length > 0;\n      y.shiftKey || S ? o.has(p) ? o.delete(p) : typeof w == \"number\" && o.size >= w || o.add(p) : o.has(p) || (o.clear(), o.add(p));\n    }\n    s.emit(\"path:click\", a(p, y));\n  }\n  function k(p, y) {\n    var w;\n    y.isTrusted || (w = e[p]) != null && w.clickable && s.emit(\"path:dblclick\", a(p, y));\n  }\n  function E(p, y) {\n    var w;\n    (w = e[p]) != null && w.clickable && (y.stopPropagation(), s.emit(\"path:contextmenu\", a(p, y)));\n  }\n  return {\n    handlePathPointerDownEvent: u,\n    handlePathPointerOverEvent: d,\n    handlePathPointerOutEvent: v,\n    handlePathClickEvent: x,\n    handlePathDoubleClickEvent: k,\n    handlePathContextMenu: E\n  };\n}\nfunction Di(e) {\n  return Ee(this, null, function* () {\n    const n = yield (yield fetch(e)).blob();\n    return new Promise((o, i) => {\n      try {\n        const s = new FileReader();\n        s.onload = function () {\n          o(this.result);\n        }, s.readAsDataURL(n);\n      } catch (s) {\n        i(s);\n      }\n    });\n  });\n}\nfunction At(e, t, n) {\n  var s;\n  const o = e.createSVGPoint();\n  o.x = n.x, o.y = n.y;\n  const i = o.matrixTransform((s = t.getCTM()) == null ? void 0 : s.inverse());\n  return {\n    x: i.x,\n    y: i.y\n  };\n}\nfunction Ni(e, t, n) {\n  const o = e.createSVGPoint();\n  o.x = n.x, o.y = n.y;\n  const i = o.matrixTransform(t.getCTM());\n  return {\n    x: i.x,\n    y: i.y\n  };\n}\nfunction Xn(e, t, n) {\n  var u;\n  const o = e.cloneNode(!0),\n    i = t.getBBox(),\n    s = 1 / n,\n    r = {\n      x: Math.floor((i.x - 10) * s),\n      y: Math.floor((i.y - 10) * s),\n      width: Math.ceil((i.width + 20) * s),\n      height: Math.ceil((i.height + 20) * s)\n    };\n  o.setAttribute(\"width\", r.width.toString()), o.setAttribute(\"height\", r.height.toString());\n  const a = o.querySelector(\".v-ng-viewport\");\n  a.setAttribute(\"transform\", `translate(${-r.x} ${-r.y}), scale(${s})`), a.removeAttribute(\"style\"), o.setAttribute(\"viewBox\", `0 0 ${r.width} ${r.height}`), o.removeAttribute(\"style\");\n  const c = document.createNodeIterator(o, NodeFilter.SHOW_COMMENT);\n  for (; c.nextNode();) {\n    const l = c.referenceNode;\n    (u = l.parentNode) == null || u.removeChild(l);\n  }\n  return o;\n}\nfunction _i(e) {\n  return Ee(this, null, function* () {\n    let t = !1,\n      n = e.getAttribute(\"href\");\n    if (n || (t = !0, n = e.getAttribute(\"xlink:href\")), !(!n || n.startsWith(\"data:\"))) try {\n      const o = yield Di(n);\n      e.setAttribute(t ? \"xlink:href\" : \"href\", o);\n    } catch (o) {\n      console.warn(\"Image download failed.\", n);\n      return;\n    }\n  });\n}\nfunction Bi(i, s, r) {\n  return Ee(this, arguments, function* (e, t, n, o = {}) {\n    const a = Xn(e, t, n);\n    if (o.embedImages) {\n      const u = Array.from(a.querySelectorAll(\"image\")).map(l => _i(l));\n      yield Promise.all(u);\n    }\n    return a;\n  });\n}\nfunction ji(e, t, n, o, i, s) {\n  const r = C(() => !!s.node.selectable && s.view.boxSelectionEnabled),\n    a = C(() => t.viewMode.value === \"box-selection\"),\n    c = _(),\n    u = _(),\n    l = {\n      pointers: /* @__PURE__ */new Set(),\n      // Set of pointers being pressed\n      points: /* @__PURE__ */new Map(),\n      // Point indicated by each pointer\n      startPoint: null,\n      // Point where the drag started\n      selectedNodesAtSelectStarted: /* @__PURE__ */new Set(),\n      // Nodes selected at the start of the selection\n      selectionType: \"append\",\n      // Selection method for nodes included in the dragged range\n      options: {\n        // options specified by user at start of selection mode\n        stopTrigger: \"pointerup\",\n        selectionType: \"append\",\n        selectionTypeWithShiftKey: \"same\"\n      }\n    },\n    h = _o(() => {\n      Vi(G(e.value, \"container\"), G(c.value, \"viewport\"), u, n.nodes, o, i, l.selectedNodesAtSelectStarted, l.selectionType);\n    }, 50, {\n      maxWait: 100\n    }),\n    d = new Ri(e, x, k, E, v, p);\n  function v(g) {\n    if (l.options.stopTrigger !== \"click\" || l.pointers.size > 0) return;\n    const S = {\n      x: g.offsetX,\n      y: g.offsetY\n    };\n    l.startPoint && V.fromObject(l.startPoint).distance(S) > 10 || f();\n  }\n  function x(g) {\n    g.stopPropagation();\n    const S = {\n      x: g.offsetX,\n      y: g.offsetY\n    };\n    l.pointers.size === 0 && (l.startPoint = S, d.activate(), l.selectedNodesAtSelectStarted.clear(), i.forEach(O => l.selectedNodesAtSelectStarted.add(O)), l.options.selectionTypeWithShiftKey === \"same\" ? l.selectionType = l.options.selectionType : l.selectionType = g.shiftKey ? l.options.selectionTypeWithShiftKey : l.options.selectionType), l.pointers.has(g.pointerId) || l.pointers.add(g.pointerId), l.points.set(g.pointerId, S), y();\n  }\n  function k(g) {\n    if (l.pointers.delete(g.pointerId), l.pointers.size === 1) {\n      const S = G(e.value).getBoundingClientRect(),\n        O = {\n          x: g.x - S.x,\n          y: g.y - S.y\n        };\n      l.startPoint = O;\n    } else l.pointers.size === 0 && (d.deactivate(), l.options.stopTrigger === \"pointerup\" && f(), l.selectedNodesAtSelectStarted.clear());\n    y();\n  }\n  function E(g) {\n    const S = G(e.value).getBoundingClientRect(),\n      O = {\n        x: g.x - S.x,\n        y: g.y - S.y\n      };\n    l.points.set(g.pointerId, O), y(), h();\n  }\n  function p(g) {\n    g.key === \"Escape\" && l.options.stopTrigger !== \"manual\" && (g.stopPropagation(), f());\n  }\n  function y() {\n    let g, S;\n    const O = Array.from(l.pointers);\n    if (O.length >= 2) {\n      const I = O[0],\n        T = O[O.length - 1];\n      g = l.points.get(I), S = l.points.get(T);\n    } else if (l.startPoint && O.length === 1) {\n      const I = O[0];\n      g = l.startPoint, S = l.points.get(I);\n    } else g = void 0, S = void 0;\n    g && S ? (u.value = {\n      pos: {\n        x: Math.min(g.x, S.x),\n        y: Math.min(g.y, S.y)\n      },\n      size: {\n        width: Math.abs(S.x - g.x),\n        height: Math.abs(S.y - g.y)\n      }\n    }, u.value.size.width === 0 && (u.value.size.width = 1), u.value.size.height === 0 && (u.value.size.height = 1)) : u.value && (u.value = void 0);\n  }\n  const w = new Hi(e,\n  // key down\n  g => {\n    r.value && s.view.selection.detector(g) && (m({\n      stop: \"manual\",\n      type: \"append\",\n      withShiftKey: \"invert\"\n    }), w.activate());\n  },\n  // key up\n  g => {\n    r.value && s.view.selection.detector(g) && (l.pointers.size === 0 ? f() : l.options.stopTrigger = \"pointerup\", w.deactivate());\n  });\n  F(r, g => {\n    g ? w.register() : w.unregister();\n  }), We(() => {\n    var g;\n    c.value = (g = e.value) == null ? void 0 : g.querySelector(\".v-ng-viewport\"), r.value && w.register();\n  }), Je(() => {\n    f(), r.value && w.unregister();\n  });\n  function m(g = {}) {\n    var S, O, I;\n    l.options = {\n      stopTrigger: (S = g.stop) != null ? S : \"pointerup\",\n      selectionType: (O = g.type) != null ? O : \"append\",\n      selectionTypeWithShiftKey: (I = g.withShiftKey) != null ? I : \"same\"\n    }, t.viewMode.value !== \"box-selection\" && (t.viewMode.value = \"box-selection\", l.pointers.clear(), d.register());\n  }\n  function f() {\n    t.viewMode.value === \"box-selection\" && (t.viewMode.value = \"default\", d.unregister());\n  }\n  return {\n    isBoxSelectionMode: a,\n    selectionBox: u,\n    startBoxSelection: m,\n    stopBoxSelection: f\n  };\n}\nfunction Vi(e, t, n, o, i, s, r, a) {\n  if (!n.value) return;\n  const c = n.value,\n    u = At(e, t, c.pos),\n    l = At(e, t, {\n      x: c.pos.x + c.size.width,\n      y: c.pos.y + c.size.height\n    }),\n    h = new Set(Object.entries(o).filter(([d, v]) => u.x <= v.x && v.x <= l.x && u.y <= v.y && v.y <= l.y).map(([d, v]) => d));\n  if (a === \"append\") s.forEach(d => {\n    h.has(d) || s.delete(d);\n  }), h.forEach(d => {\n    var x, k;\n    const v = (k = (x = i[d]) == null ? void 0 : x.selectable) != null ? k : !1;\n    (v === !0 || typeof v == \"number\" && s.size < v) && s.add(d);\n  });else {\n    const d = new Set(r);\n    d.forEach(v => {\n      h.has(v) && d.delete(v);\n    }), h.forEach(v => {\n      var x, k;\n      if (!r.has(v)) {\n        const E = (k = (x = i[v]) == null ? void 0 : x.selectable) != null ? k : !1;\n        (E === !0 || typeof E == \"number\" && d.size < E) && d.add(v);\n      }\n    }), s.clear(), d.forEach(v => s.add(v));\n  }\n}\nclass Ri {\n  constructor(t, n, o, i, s, r) {\n    this._container = t, this._handlePointerDownEvent = n, this._handlePointerUpEvent = o, this._handlePointerMoveEvent = i, this._handleClickEvent = s, this._handleKeyDownEvent = r, this._ignoreEvent = a => a.stopPropagation();\n  }\n  register() {\n    const t = {\n        capture: !0,\n        passive: !1\n      },\n      n = G(this._container.value, \"container\");\n    n.addEventListener(\"pointerdown\", this._handlePointerDownEvent, t), n.addEventListener(\"click\", this._handleClickEvent, t), n.addEventListener(\"pointerenter\", this._ignoreEvent, t), n.addEventListener(\"pointerleave\", this._ignoreEvent, t), document.addEventListener(\"keydown\", this._handleKeyDownEvent, t);\n  }\n  activate() {\n    const t = {\n      capture: !0,\n      passive: !1\n    };\n    document.addEventListener(\"pointermove\", this._handlePointerMoveEvent, t), document.addEventListener(\"pointerup\", this._handlePointerUpEvent, t);\n  }\n  deactivate() {\n    const t = {\n      capture: !0\n    };\n    document.removeEventListener(\"pointermove\", this._handlePointerMoveEvent, t), document.removeEventListener(\"pointerup\", this._handlePointerUpEvent, t);\n  }\n  unregister() {\n    this.deactivate();\n    const t = {\n      capture: !0\n    };\n    if (this._container.value) {\n      const n = this._container.value;\n      n.removeEventListener(\"pointerdown\", this._handlePointerDownEvent, t), n.removeEventListener(\"click\", this._handleClickEvent, t), n.removeEventListener(\"pointerenter\", this._ignoreEvent, t), n.removeEventListener(\"pointerleave\", this._ignoreEvent, t), document.removeEventListener(\"keydown\", this._handleKeyDownEvent, t);\n    }\n  }\n}\nclass Hi {\n  constructor(t, n, o) {\n    this._container = t, this._handleKeyDownEvent = n, this._handleKeyUpEvent = o, this._preventDefault = i => {\n      i.stopPropagation(), i.preventDefault();\n    };\n  }\n  register() {\n    document.addEventListener(\"keydown\", this._handleKeyDownEvent, {\n      capture: !0,\n      passive: !0\n    });\n  }\n  activate() {\n    document.addEventListener(\"keyup\", this._handleKeyUpEvent, {\n      capture: !0,\n      passive: !0\n    }), G(this._container.value, \"container\").addEventListener(\"contextmenu\", this._preventDefault, {\n      passive: !1\n    });\n  }\n  deactivate() {\n    document.removeEventListener(\"keyup\", this._handleKeyUpEvent, {\n      capture: !0\n    }), this._container.value && this._container.value.removeEventListener(\"contextmenu\", this._preventDefault);\n  }\n  unregister() {\n    this.deactivate(), document.removeEventListener(\"keydown\", this._handleKeyDownEvent, {\n      capture: !0\n    });\n  }\n}\nconst qn = Symbol(\"mouseEventHandlers\");\nfunction Wi(e, t, n, o, i, s, r, a, c, u, l, h, d, v, x, k) {\n  const E = {\n    selectionMode: _(\"container\"),\n    viewMode: _(\"default\")\n  };\n  r.size > 0 ? E.selectionMode.value = \"node\" : a.size > 0 ? E.selectionMode.value = \"edge\" : c.size > 0 && (E.selectionMode.value = \"path\"), F(E.viewMode, y => {\n    k.emit(\"view:mode\", y);\n  }), Ai(e, E, v, k);\n  const p = se(se(se(se({\n    selectedNodes: r,\n    hoveredNodes: u,\n    selectedEdges: a,\n    hoveredEdges: l,\n    selectedPaths: c,\n    hoveredPaths: h\n  }, Li(o, t, E, u, r, n, k)), $i(i, E, l, a, k)), Zi(s, E, h, c, d, k)), ji(e, E, t, o, r, x));\n  return Ae(qn, p), p;\n}\nfunction nt() {\n  return G(Ze(qn), \"mouseEventHandlers\");\n}\nfunction Ui(e) {\n  return {\n    all: e = e || /* @__PURE__ */new Map(),\n    on: function (t, n) {\n      var o = e.get(t);\n      o ? o.push(n) : e.set(t, [n]);\n    },\n    off: function (t, n) {\n      var o = e.get(t);\n      o && (n ? o.splice(o.indexOf(n) >>> 0, 1) : e.set(t, []));\n    },\n    emit: function (t, n) {\n      var o = e.get(t);\n      o && o.slice().map(function (i) {\n        i(n);\n      }), (o = e.get(\"*\")) && o.slice().map(function (i) {\n        i(t, n);\n      });\n    }\n  };\n}\nconst Gn = Symbol(\"emitter\");\nfunction Fi() {\n  const e = Ui();\n  return Ae(Gn, e), e;\n}\nfunction Xi() {\n  return G(Ze(Gn), \"event emitter\");\n}\nvar dt = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : {};\nfunction qi(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nvar bt = {\n  /**\n   * Get global this object\n   *\n   * @return {Object}        global this object\n   */\n  getGlobalThis: function () {\n    if (typeof globalThis != \"undefined\") return globalThis;\n    if (typeof self != \"undefined\") return self;\n    if (typeof window != \"undefined\") return window;\n    if (typeof dt != \"undefined\") return dt;\n    if (typeof this != \"undefined\") return this;\n    throw new Error(\"Unable to locate global `this`\");\n  },\n  /**\n   * Extends an object\n   *\n   * @param  {Object} target object to extend\n   * @param  {Object} source object to take properties from\n   * @return {Object}        extended object\n   */\n  extend: function (e, t) {\n    e = e || {};\n    for (var n in t) this.isObject(t[n]) ? e[n] = this.extend(e[n], t[n]) : e[n] = t[n];\n    return e;\n  },\n  /**\n   * Checks if an object is a DOM element\n   *\n   * @param  {Object}  o HTML element or String\n   * @return {Boolean}   returns true if object is a DOM element\n   */\n  isElement: function (e) {\n    return e instanceof HTMLElement || e instanceof SVGElement || e instanceof SVGSVGElement ||\n    //DOM2\n    e && typeof e == \"object\" && e !== null && e.nodeType === 1 && typeof e.nodeName == \"string\";\n  },\n  /**\n   * Checks if an object is an Object\n   *\n   * @param  {Object}  o Object\n   * @return {Boolean}   returns true if object is an Object\n   */\n  isObject: function (e) {\n    return Object.prototype.toString.call(e) === \"[object Object]\";\n  },\n  /**\n   * Checks if variable is Number\n   *\n   * @param  {Integer|Float}  n\n   * @return {Boolean}   returns true if variable is Number\n   */\n  isNumber: function (e) {\n    return !isNaN(parseFloat(e)) && isFinite(e);\n  },\n  /**\n   * Search for an SVG element\n   *\n   * @param  {Object|String} elementOrSelector DOM Element or selector String\n   * @return {Object|Null}                   SVG or null\n   */\n  getSvg: function (e) {\n    var t, n;\n    if (this.isElement(e)) t = e;else if (typeof e == \"string\" || e instanceof String) {\n      if (t = document.querySelector(e), !t) throw new Error(\"Provided selector did not find any elements. Selector: \" + e);\n    } else throw new Error(\"Provided selector is not an HTML object nor String\");\n    if (t.tagName.toLowerCase() === \"svg\") n = t;else if (t.tagName.toLowerCase() === \"object\") n = t.contentDocument.documentElement;else if (t.tagName.toLowerCase() === \"embed\") n = t.getSVGDocument().documentElement;else throw t.tagName.toLowerCase() === \"img\" ? new Error('Cannot script an SVG in an \"img\" element. Please use an \"object\" element or an in-line SVG.') : new Error(\"Cannot get SVG.\");\n    return n;\n  },\n  /**\n   * Attach a given context to a function\n   * @param  {Function} fn      Function\n   * @param  {Object}   context Context\n   * @return {Function}           Function with certain context\n   */\n  proxy: function (e, t) {\n    return function () {\n      return e.apply(t, arguments);\n    };\n  },\n  /**\n   * Returns object type\n   * Uses toString that returns [object SVGPoint]\n   * And than parses object type from string\n   *\n   * @param  {Object} o Any object\n   * @return {String}   Object type\n   */\n  getType: function (e) {\n    return Object.prototype.toString.apply(e).replace(/^\\[object\\s/, \"\").replace(/\\]$/, \"\");\n  },\n  /**\n   * If it is a touch event than add clientX and clientY to event object\n   *\n   * @param  {Event} evt\n   * @param  {SVGSVGElement} svg\n   */\n  mouseAndTouchNormalize: function (e, t) {\n    if (e.clientX === void 0 || e.clientX === null) if (e.clientX = 0, e.clientY = 0, e.touches !== void 0 && e.touches.length) {\n      if (e.touches[0].clientX !== void 0) e.clientX = e.touches[0].clientX, e.clientY = e.touches[0].clientY;else if (e.touches[0].pageX !== void 0) {\n        var n = t.getBoundingClientRect();\n        e.clientX = e.touches[0].pageX - n.left, e.clientY = e.touches[0].pageY - n.top;\n      }\n    } else e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY);\n  },\n  /**\n   * If it is a touch event than add clientX and clientY to event object\n   *\n   * @param  {Event} evt\n   * @param  {SVGSVGElement} svg\n   * @param  {Number} touch\n   */\n  touchNormalize: function (e, t, n) {\n    if (e.touches !== void 0 && e.touches.length) {\n      if (e.touches[n].clientX !== void 0) e.clientX = e.touches[n].clientX, e.clientY = e.touches[n].clientY;else if (e.touches[n].pageX !== void 0) {\n        var o = t.getBoundingClientRect();\n        e.clientX = e.touches[n].pageX - o.left, e.clientY = e.touches[n].pageY - o.top;\n      }\n    } else (e.clientX === void 0 || e.clientX === null) && (e.clientX = 0, e.clientY = 0, e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY));\n  },\n  /**\n   * Check if an event is a double click/tap\n   * TODO: For touch gestures use a library (hammer.js) that takes in account other events\n   * (touchmove and touchend). It should take in account tap duration and traveled distance\n   *\n   * @param  {Event}  evt\n   * @param  {Event}  prevEvt Previous Event\n   * @return {Boolean}\n   */\n  isDblClick: function (e, t) {\n    if (e.detail === 2) return !0;\n    if (t != null) {\n      var n = e.timeStamp - t.timeStamp,\n        o = Math.sqrt(Math.pow(e.clientX - t.clientX, 2) + Math.pow(e.clientY - t.clientY, 2));\n      return n < 250 && o < 10;\n    }\n    return !1;\n  },\n  /**\n   * Returns current timestamp as an integer\n   *\n   * @return {Number}\n   */\n  now: Date.now || function () {\n    return /* @__PURE__ */new Date().getTime();\n  },\n  // From underscore.\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  throttle: function (e, t, n) {\n    var o = this,\n      i,\n      s,\n      r,\n      a = null,\n      c = 0;\n    n || (n = {});\n    var u = function () {\n      c = n.leading === !1 ? 0 : o.now(), a = null, r = e.apply(i, s), a || (i = s = null);\n    };\n    return function () {\n      var l = o.now();\n      !c && n.leading === !1 && (c = l);\n      var h = t - (l - c);\n      return i = this, s = arguments, h <= 0 || h > t ? (clearTimeout(a), a = null, c = l, r = e.apply(i, s), a || (i = s = null)) : !a && n.trailing !== !1 && (a = setTimeout(u, h)), r;\n    };\n  },\n  /**\n   * Create a requestAnimationFrame simulation\n   *\n   * @param  {Number|String} refreshRate\n   * @return {Function}\n   */\n  createRequestAnimationFrame: function (e) {\n    var t = null;\n    return e !== \"auto\" && e < 60 && e > 1 && (t = Math.floor(1e3 / e)), t === null ? window.requestAnimationFrame || En(33) : En(t);\n  },\n  /**\n   * Calculate distance of points\n   *\n   * @param  {SVGPoint} point1\n   * @param  {SVGPoint} point2\n   * @return {Number}\n   */\n  calculateDistance: function (e, t) {\n    var n = e.x - t.x,\n      o = e.y - t.y;\n    return Math.sqrt(n * n + o * o);\n  }\n};\nfunction En(e) {\n  return function (t) {\n    window.setTimeout(t, e);\n  };\n}\nvar Gi = bt,\n  Ki = function () {\n    var e = \"\",\n      t,\n      n,\n      o,\n      i = [],\n      s = {\n        passive: !0\n      },\n      r = {\n        passive: !1\n      };\n    Gi.getGlobalThis().addEventListener ? (t = \"addEventListener\", n = \"removeEventListener\") : (t = \"attachEvent\", n = \"detachEvent\", e = \"on\");\n    function a() {\n      return o || (o = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : document.onmousewheel !== void 0 ? \"mousewheel\" : \"DOMMouseScroll\"), o;\n    }\n    function c(k, E) {\n      var p = function (y) {\n        !y && (y = window.event);\n        var w = {\n          // keep a ref to the original event object\n          originalEvent: y,\n          target: y.target || y.srcElement,\n          type: \"wheel\",\n          deltaMode: y.type == \"MozMousePixelScroll\" ? 0 : 1,\n          deltaX: 0,\n          delatZ: 0,\n          preventDefault: function () {\n            y.preventDefault ? y.preventDefault() : y.returnValue = !1;\n          }\n        };\n        return a() == \"mousewheel\" ? (w.deltaY = -0.025 * y.wheelDelta, y.wheelDeltaX && (w.deltaX = -0.025 * y.wheelDeltaX)) : w.deltaY = y.detail, E(w);\n      };\n      return i.push({\n        element: k,\n        fn: p\n      }), p;\n    }\n    function u(k) {\n      for (var E = 0; E < i.length; E++) if (i[E].element === k) return i[E].fn;\n      return function () {};\n    }\n    function l(k) {\n      for (var E = 0; E < i.length; E++) if (i[E].element === k) return i.splice(E, 1);\n    }\n    function h(k, E, p, y) {\n      var w;\n      a() === \"wheel\" ? w = p : w = c(k, p), k[t](e + E, w, y ? s : r);\n    }\n    function d(k, E, p, y) {\n      var w;\n      a() === \"wheel\" ? w = p : w = u(k), k[n](e + E, w, y ? s : r), l(k);\n    }\n    function v(k, E, p) {\n      h(k, a(), E, p), a() == \"DOMMouseScroll\" && h(k, \"MozMousePixelScroll\", E, p);\n    }\n    function x(k, E, p) {\n      d(k, a(), E, p), a() == \"DOMMouseScroll\" && d(k, \"MozMousePixelScroll\", E, p);\n    }\n    return {\n      on: v,\n      off: x\n    };\n  }(),\n  rt = bt,\n  Kn = \"unknown\";\n/*@cc_on!@*/\ntypeof document != \"undefined\" && document.documentMode && (Kn = \"ie\");\nvar Kt = {\n    svgNS: \"http://www.w3.org/2000/svg\",\n    xmlNS: \"http://www.w3.org/XML/1998/namespace\",\n    xmlnsNS: \"http://www.w3.org/2000/xmlns/\",\n    xlinkNS: \"http://www.w3.org/1999/xlink\",\n    evNS: \"http://www.w3.org/2001/xml-events\",\n    /**\n     * Get svg dimensions: width and height\n     *\n     * @param  {SVGSVGElement} svg\n     * @return {Object}     {width: 0, height: 0}\n     */\n    getBoundingClientRectNormalized: function (e) {\n      if (e.clientWidth && e.clientHeight) return {\n        width: e.clientWidth,\n        height: e.clientHeight\n      };\n      if (e.getBoundingClientRect()) return e.getBoundingClientRect();\n      throw new Error(\"Cannot get BoundingClientRect for SVG.\");\n    },\n    /**\n     * Gets g element with class of \"viewport\" or creates it if it doesn't exist\n     *\n     * @param  {SVGSVGElement} svg\n     * @return {SVGElement}     g (group) element\n     */\n    getOrCreateViewport: function (e, t) {\n      var n = null;\n      if (rt.isElement(t) ? n = t : n = e.querySelector(t), !n) {\n        var o = Array.prototype.slice.call(e.childNodes || e.children).filter(function (c) {\n          return c.nodeName !== \"defs\" && c.nodeName !== \"#text\";\n        });\n        o.length === 1 && o[0].nodeName === \"g\" && o[0].getAttribute(\"transform\") === null && (n = o[0]);\n      }\n      if (!n) {\n        var i = \"viewport-\" + /* @__PURE__ */new Date().toISOString().replace(/\\D/g, \"\");\n        n = document.createElementNS(this.svgNS, \"g\"), n.setAttribute(\"id\", i);\n        var s = e.childNodes || e.children;\n        if (s && s.length > 0) for (var r = s.length; r > 0; r--) s[s.length - r].nodeName !== \"defs\" && n.appendChild(s[s.length - r]);\n        e.appendChild(n);\n      }\n      var a = [];\n      return n.getAttribute(\"class\") && (a = n.getAttribute(\"class\").split(\" \")), ~a.indexOf(\"svg-pan-zoom_viewport\") || (a.push(\"svg-pan-zoom_viewport\"), n.setAttribute(\"class\", a.join(\" \"))), n;\n    },\n    /**\n     * Set SVG attributes\n     *\n     * @param  {SVGSVGElement} svg\n     */\n    setupSvgAttributes: function (e) {\n      if (e.setAttribute(\"xmlns\", this.svgNS), e.setAttributeNS(this.xmlnsNS, \"xmlns:xlink\", this.xlinkNS), e.setAttributeNS(this.xmlnsNS, \"xmlns:ev\", this.evNS), e.parentNode !== null) {\n        var t = e.getAttribute(\"style\") || \"\";\n        t.toLowerCase().indexOf(\"overflow\") === -1 && e.setAttribute(\"style\", \"overflow: hidden; \" + t);\n      }\n    },\n    /**\n     * How long Internet Explorer takes to finish updating its display (ms).\n     */\n    internetExplorerRedisplayInterval: 300,\n    /**\n     * Forces the browser to redisplay all SVG elements that rely on an\n     * element defined in a 'defs' section. It works globally, for every\n     * available defs element on the page.\n     * The throttling is intentionally global.\n     *\n     * This is only needed for IE. It is as a hack to make markers (and 'use' elements?)\n     * visible after pan/zoom when there are multiple SVGs on the page.\n     * See bug report: https://connect.microsoft.com/IE/feedback/details/781964/\n     * also see svg-pan-zoom issue: https://github.com/ariutta/svg-pan-zoom/issues/62\n     */\n    refreshDefsGlobal: rt.throttle(function () {\n      for (var e = document.querySelectorAll(\"defs\"), t = e.length, n = 0; n < t; n++) {\n        var o = e[n];\n        o.parentNode.insertBefore(o, o);\n      }\n    }, dt ? dt.internetExplorerRedisplayInterval : null),\n    /**\n     * Sets the current transform matrix of an element\n     *\n     * @param {SVGElement} element\n     * @param {SVGMatrix} matrix  CTM\n     * @param {SVGElement} defs\n     */\n    setCTM: function (e, t, n) {\n      var o = this,\n        i = \"matrix(\" + t.a + \",\" + t.b + \",\" + t.c + \",\" + t.d + \",\" + t.e + \",\" + t.f + \")\";\n      e.setAttributeNS(null, \"transform\", i), \"transform\" in e.style ? e.style.transform = i : \"-ms-transform\" in e.style ? e.style[\"-ms-transform\"] = i : \"-webkit-transform\" in e.style && (e.style[\"-webkit-transform\"] = i), Kn === \"ie\" && n && (n.parentNode.insertBefore(n, n), window.setTimeout(function () {\n        o.refreshDefsGlobal();\n      }, o.internetExplorerRedisplayInterval));\n    },\n    /**\n     * Instantiate an SVGPoint object with given event coordinates\n     *\n     * @param {Event} evt\n     * @param  {SVGSVGElement} svg\n     * @return {SVGPoint}     point\n     */\n    getEventPoint: function (e, t) {\n      var n = t.createSVGPoint();\n      return rt.mouseAndTouchNormalize(e, t), n.x = e.clientX, n.y = e.clientY, n;\n    },\n    /**\n     * Instantiate an SVGPoint object with given touch event coordinates\n     *\n     * @param {Event} evt\n     * @param  {SVGSVGElement} svg\n     * @param  {Number} touch\n     * @return {SVGPoint}     point\n     */\n    getTouchPoint: function (e, t, n) {\n      var o = t.createSVGPoint();\n      return rt.touchNormalize(e, t, n), o.x = e.clientX, o.y = e.clientY, o;\n    },\n    /**\n     * Get SVG center point\n     *\n     * @param  {SVGSVGElement} svg\n     * @return {SVGPoint}\n     */\n    getSvgCenterPoint: function (e, t, n) {\n      return this.createSVGPoint(e, t / 2, n / 2);\n    },\n    /**\n     * Create a SVGPoint with given x and y\n     *\n     * @param  {SVGSVGElement} svg\n     * @param  {Number} x\n     * @param  {Number} y\n     * @return {SVGPoint}\n     */\n    createSVGPoint: function (e, t, n) {\n      var o = e.createSVGPoint();\n      return o.x = t, o.y = n, o;\n    }\n  },\n  pe = Kt,\n  Yi = {\n    enable: function (e) {\n      var t = e.svg.querySelector(\"defs\");\n      t || (t = document.createElementNS(pe.svgNS, \"defs\"), e.svg.appendChild(t));\n      var n = t.querySelector(\"style#svg-pan-zoom-controls-styles\");\n      if (!n) {\n        var o = document.createElementNS(pe.svgNS, \"style\");\n        o.setAttribute(\"id\", \"svg-pan-zoom-controls-styles\"), o.setAttribute(\"type\", \"text/css\"), o.textContent = \".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }\", t.appendChild(o);\n      }\n      var i = document.createElementNS(pe.svgNS, \"g\");\n      i.setAttribute(\"id\", \"svg-pan-zoom-controls\"), i.setAttribute(\"transform\", \"translate(\" + (e.width - 70) + \" \" + (e.height - 76) + \") scale(0.75)\"), i.setAttribute(\"class\", \"svg-pan-zoom-control\"), i.appendChild(this._createZoomIn(e)), i.appendChild(this._createZoomReset(e)), i.appendChild(this._createZoomOut(e)), e.svg.appendChild(i), e.controlIcons = i;\n    },\n    _createZoomIn: function (e) {\n      var t = document.createElementNS(pe.svgNS, \"g\");\n      t.setAttribute(\"id\", \"svg-pan-zoom-zoom-in\"), t.setAttribute(\"transform\", \"translate(30.5 5) scale(0.015)\"), t.setAttribute(\"class\", \"svg-pan-zoom-control\"), t.addEventListener(\"click\", function () {\n        e.getPublicInstance().zoomIn();\n      }, !1), t.addEventListener(\"touchstart\", function () {\n        e.getPublicInstance().zoomIn();\n      }, !1);\n      var n = document.createElementNS(pe.svgNS, \"rect\");\n      n.setAttribute(\"x\", \"0\"), n.setAttribute(\"y\", \"0\"), n.setAttribute(\"width\", \"1500\"), n.setAttribute(\"height\", \"1400\"), n.setAttribute(\"class\", \"svg-pan-zoom-control-background\"), t.appendChild(n);\n      var o = document.createElementNS(pe.svgNS, \"path\");\n      return o.setAttribute(\"d\", \"M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z\"), o.setAttribute(\"class\", \"svg-pan-zoom-control-element\"), t.appendChild(o), t;\n    },\n    _createZoomReset: function (e) {\n      var t = document.createElementNS(pe.svgNS, \"g\");\n      t.setAttribute(\"id\", \"svg-pan-zoom-reset-pan-zoom\"), t.setAttribute(\"transform\", \"translate(5 35) scale(0.4)\"), t.setAttribute(\"class\", \"svg-pan-zoom-control\"), t.addEventListener(\"click\", function () {\n        e.getPublicInstance().reset();\n      }, !1), t.addEventListener(\"touchstart\", function () {\n        e.getPublicInstance().reset();\n      }, !1);\n      var n = document.createElementNS(pe.svgNS, \"rect\");\n      n.setAttribute(\"x\", \"2\"), n.setAttribute(\"y\", \"2\"), n.setAttribute(\"width\", \"182\"), n.setAttribute(\"height\", \"58\"), n.setAttribute(\"class\", \"svg-pan-zoom-control-background\"), t.appendChild(n);\n      var o = document.createElementNS(pe.svgNS, \"path\");\n      o.setAttribute(\"d\", \"M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z\"), o.setAttribute(\"class\", \"svg-pan-zoom-control-element\"), t.appendChild(o);\n      var i = document.createElementNS(pe.svgNS, \"path\");\n      return i.setAttribute(\"d\", \"M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z\"), i.setAttribute(\"class\", \"svg-pan-zoom-control-element\"), t.appendChild(i), t;\n    },\n    _createZoomOut: function (e) {\n      var t = document.createElementNS(pe.svgNS, \"g\");\n      t.setAttribute(\"id\", \"svg-pan-zoom-zoom-out\"), t.setAttribute(\"transform\", \"translate(30.5 70) scale(0.015)\"), t.setAttribute(\"class\", \"svg-pan-zoom-control\"), t.addEventListener(\"click\", function () {\n        e.getPublicInstance().zoomOut();\n      }, !1), t.addEventListener(\"touchstart\", function () {\n        e.getPublicInstance().zoomOut();\n      }, !1);\n      var n = document.createElementNS(pe.svgNS, \"rect\");\n      n.setAttribute(\"x\", \"0\"), n.setAttribute(\"y\", \"0\"), n.setAttribute(\"width\", \"1500\"), n.setAttribute(\"height\", \"1400\"), n.setAttribute(\"class\", \"svg-pan-zoom-control-background\"), t.appendChild(n);\n      var o = document.createElementNS(pe.svgNS, \"path\");\n      return o.setAttribute(\"d\", \"M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z\"), o.setAttribute(\"class\", \"svg-pan-zoom-control-element\"), t.appendChild(o), t;\n    },\n    disable: function (e) {\n      e.controlIcons && (e.controlIcons.parentNode.removeChild(e.controlIcons), e.controlIcons = null);\n    }\n  },\n  Qi = Kt,\n  $e = bt,\n  ne = function (e, t) {\n    this.init(e, t);\n  };\nne.prototype.init = function (e, t) {\n  this.viewport = e, this.options = t, this.originalState = {\n    zoom: 1,\n    x: 0,\n    y: 0\n  }, this.activeState = {\n    zoom: 1,\n    x: 0,\n    y: 0\n  }, this.updateCTMCached = $e.proxy(this.updateCTM, this), this.requestAnimationFrame = $e.createRequestAnimationFrame(this.options.refreshRate), this.viewBox = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  }, this.cacheViewBox();\n  var n = this.processCTM();\n  this.setCTM(n), this.updateCTM();\n};\nne.prototype.cacheViewBox = function () {\n  var e = this.options.svg.getAttribute(\"viewBox\");\n  if (e) {\n    var t = e.split(/[\\s\\,]/).filter(function (o) {\n      return o;\n    }).map(parseFloat);\n    this.viewBox.x = t[0], this.viewBox.y = t[1], this.viewBox.width = t[2], this.viewBox.height = t[3];\n    var n = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);\n    this.activeState.zoom = isFinite(n) ? n : 1, this.activeState.x = (this.options.width - this.viewBox.width * n) / 2, this.activeState.y = (this.options.height - this.viewBox.height * n) / 2, this.updateCTMOnNextFrame(), this.options.svg.removeAttribute(\"viewBox\");\n  } else this.simpleViewBoxCache();\n};\nne.prototype.simpleViewBoxCache = function () {\n  var e = this.viewport.getBBox();\n  this.viewBox.x = e.x, this.viewBox.y = e.y, this.viewBox.width = e.width, this.viewBox.height = e.height;\n};\nne.prototype.getViewBox = function () {\n  return $e.extend({}, this.viewBox);\n};\nne.prototype.processCTM = function () {\n  var e = this.getCTM();\n  if (this.options.fit || this.options.contain) {\n    var t;\n    this.options.fit ? t = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height) : t = Math.max(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height), t = isFinite(t) ? t : 1, e.a = t, e.d = t, e.e = -this.viewBox.x * t, e.f = -this.viewBox.y * t;\n  }\n  if (this.options.center) {\n    var n = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * e.a) * 0.5,\n      o = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * e.a) * 0.5;\n    e.e = n, e.f = o;\n  }\n  return this.originalState.zoom = e.a, this.originalState.x = e.e, this.originalState.y = e.f, e;\n};\nne.prototype.getOriginalState = function () {\n  return $e.extend({}, this.originalState);\n};\nne.prototype.getState = function () {\n  return $e.extend({}, this.activeState);\n};\nne.prototype.getZoom = function () {\n  return this.activeState.zoom;\n};\nne.prototype.getRelativeZoom = function () {\n  return this.activeState.zoom / this.originalState.zoom;\n};\nne.prototype.computeRelativeZoom = function (e) {\n  return e / this.originalState.zoom;\n};\nne.prototype.getPan = function () {\n  return {\n    x: this.activeState.x,\n    y: this.activeState.y\n  };\n};\nne.prototype.getCTM = function () {\n  var e = this.options.svg.createSVGMatrix();\n  return e.a = this.activeState.zoom, e.b = 0, e.c = 0, e.d = this.activeState.zoom, e.e = this.activeState.x, e.f = this.activeState.y, e;\n};\nne.prototype.setCTM = function (e) {\n  var t = this.isZoomDifferent(e),\n    n = this.isPanDifferent(e);\n  if (t || n) {\n    if (t && (this.options.beforeZoom(this.getRelativeZoom(), this.computeRelativeZoom(e.a)) === !1 ? (e.a = e.d = this.activeState.zoom, t = !1) : (this.updateCache(e), this.options.onZoom(this.getRelativeZoom()))), n) {\n      var o = this.options.beforePan(this.getPan(), {\n          x: e.e,\n          y: e.f\n        }),\n        i = !1,\n        s = !1;\n      o === !1 ? (e.e = this.getPan().x, e.f = this.getPan().y, i = s = !0) : $e.isObject(o) && (o.x === !1 ? (e.e = this.getPan().x, i = !0) : $e.isNumber(o.x) && (e.e = o.x), o.y === !1 ? (e.f = this.getPan().y, s = !0) : $e.isNumber(o.y) && (e.f = o.y)), i && s || !this.isPanDifferent(e) ? n = !1 : (this.updateCache(e), this.options.onPan(this.getPan()));\n    }\n    (t || n) && this.updateCTMOnNextFrame();\n  }\n};\nne.prototype.isZoomDifferent = function (e) {\n  return this.activeState.zoom !== e.a;\n};\nne.prototype.isPanDifferent = function (e) {\n  return this.activeState.x !== e.e || this.activeState.y !== e.f;\n};\nne.prototype.updateCache = function (e) {\n  this.activeState.zoom = e.a, this.activeState.x = e.e, this.activeState.y = e.f;\n};\nne.prototype.pendingUpdate = !1;\nne.prototype.updateCTMOnNextFrame = function () {\n  this.pendingUpdate || (this.pendingUpdate = !0, this.requestAnimationFrame.call(window, this.updateCTMCached));\n};\nne.prototype.updateCTM = function () {\n  var e = this.getCTM();\n  Qi.setCTM(this.viewport, e, this.defs), this.pendingUpdate = !1, this.options.onUpdatedCTM && this.options.onUpdatedCTM(e);\n};\nvar Ji = function (e, t) {\n    return new ne(e, t);\n  },\n  Yn = Ki,\n  Zt = Yi,\n  fe = bt,\n  re = Kt,\n  es = Ji,\n  X = function (e, t) {\n    this.init(e, t);\n  },\n  ts = {\n    viewportSelector: \".svg-pan-zoom_viewport\",\n    // Viewport selector. Can be querySelector string or SVGElement\n    panEnabled: !0,\n    // enable or disable panning (default enabled)\n    controlIconsEnabled: !1,\n    // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)\n    zoomEnabled: !0,\n    // enable or disable zooming (default enabled)\n    dblClickZoomEnabled: !0,\n    // enable or disable zooming by double clicking (default enabled)\n    mouseWheelZoomEnabled: !0,\n    // enable or disable zooming by mouse wheel (default enabled)\n    preventMouseEventsDefault: !0,\n    // enable or disable preventDefault for mouse events\n    zoomScaleSensitivity: 0.1,\n    // Zoom sensitivity\n    minZoom: 0.5,\n    // Minimum Zoom level\n    maxZoom: 10,\n    // Maximum Zoom level\n    fit: !0,\n    // enable or disable viewport fit in SVG (default true)\n    contain: !1,\n    // enable or disable viewport contain the svg (default false)\n    center: !0,\n    // enable or disable viewport centering in SVG (default true)\n    refreshRate: \"auto\",\n    // Maximum number of frames per second (altering SVG's viewport)\n    beforeZoom: null,\n    onZoom: null,\n    beforePan: null,\n    onPan: null,\n    customEventsHandler: null,\n    eventsListenerElement: null,\n    onUpdatedCTM: null\n  },\n  Qn = {\n    passive: !0\n  },\n  Jn = {\n    passive: !1\n  };\nX.prototype.init = function (e, t) {\n  var n = this;\n  this.svg = e, this.defs = e.querySelector(\"defs\"), re.setupSvgAttributes(this.svg), this.options = fe.extend(fe.extend({}, ts), t), this.state = \"none\";\n  var o = re.getBoundingClientRectNormalized(e);\n  this.width = o.width, this.height = o.height, this.viewport = es(re.getOrCreateViewport(this.svg, this.options.viewportSelector), {\n    svg: this.svg,\n    width: this.width,\n    height: this.height,\n    fit: this.options.fit,\n    contain: this.options.contain,\n    center: this.options.center,\n    refreshRate: this.options.refreshRate,\n    // Put callbacks into functions as they can change through time\n    beforeZoom: function (s, r) {\n      if (n.viewport && n.options.beforeZoom) return n.options.beforeZoom(s, r);\n    },\n    onZoom: function (s) {\n      if (n.viewport && n.options.onZoom) return n.options.onZoom(s);\n    },\n    beforePan: function (s, r) {\n      if (n.viewport && n.options.beforePan) return n.options.beforePan(s, r);\n    },\n    onPan: function (s) {\n      if (n.viewport && n.options.onPan) return n.options.onPan(s);\n    },\n    onUpdatedCTM: function (s) {\n      if (n.viewport && n.options.onUpdatedCTM) return n.options.onUpdatedCTM(s);\n    }\n  });\n  var i = this.getPublicInstance();\n  i.setBeforeZoom(this.options.beforeZoom), i.setOnZoom(this.options.onZoom), i.setBeforePan(this.options.beforePan), i.setOnPan(this.options.onPan), i.setOnUpdatedCTM(this.options.onUpdatedCTM), this.options.controlIconsEnabled && Zt.enable(this), this.lastMouseWheelEventTime = Date.now(), this.setupHandlers();\n};\nX.prototype.setupHandlers = function () {\n  var e = this,\n    t = null;\n  if (this.eventListeners = {\n    // Mouse down group\n    pointerdown: function (s) {\n      if (s.pointerType !== \"touch\") {\n        var r = e.handleMouseDown(s, t);\n        return t = s, r;\n      }\n    },\n    touchstart: function (s) {\n      var r = e.handleTouchStart(s, t);\n      return t = s, r;\n    },\n    // Mouse up group\n    pointerup: function (s) {\n      if (s.pointerType !== \"touch\") return e.handleMouseUp(s);\n    },\n    touchend: function (s) {\n      return e.handleTouchEnd(s);\n    },\n    // Mouse move group\n    pointermove: function (s) {\n      if (s.pointerType !== \"touch\") return e.handleMouseMove(s);\n    },\n    touchmove: function (s) {\n      return e.handleTouchMove(s);\n    },\n    // Mouse leave group\n    pointerleave: function (s) {\n      if (s.pointerType !== \"touch\") return e.handleMouseUp(s);\n    },\n    pointercancel: function (s) {\n      if (s.pointerType !== \"touch\") return e.handleMouseUp(s);\n    },\n    touchleave: function (s) {\n      return e.handleTouchEnd(s);\n    },\n    touchcancel: function (s) {\n      return e.handleTouchEnd(s);\n    }\n  }, this.options.customEventsHandler != null) {\n    this.options.customEventsHandler.init({\n      svgElement: this.svg,\n      eventsListenerElement: this.options.eventsListenerElement,\n      instance: this.getPublicInstance()\n    });\n    var n = this.options.customEventsHandler.haltEventListeners;\n    if (n && n.length) for (var o = n.length - 1; o >= 0; o--) this.eventListeners.hasOwnProperty(n[o]) && delete this.eventListeners[n[o]];\n  }\n  for (var i in this.eventListeners) (this.options.eventsListenerElement || this.svg).addEventListener(i, this.eventListeners[i], this.options.preventMouseEventsDefault ? Jn : Qn);\n  this.options.mouseWheelZoomEnabled && (this.options.mouseWheelZoomEnabled = !1, this.enableMouseWheelZoom());\n};\nX.prototype.enableMouseWheelZoom = function () {\n  if (!this.options.mouseWheelZoomEnabled) {\n    var e = this;\n    this.wheelListener = function (n) {\n      return e.handleMouseWheel(n);\n    };\n    var t = !this.options.preventMouseEventsDefault;\n    Yn.on(this.options.eventsListenerElement || this.svg, this.wheelListener, t), this.options.mouseWheelZoomEnabled = !0;\n  }\n};\nX.prototype.disableMouseWheelZoom = function () {\n  if (this.options.mouseWheelZoomEnabled) {\n    var e = !this.options.preventMouseEventsDefault;\n    Yn.off(this.options.eventsListenerElement || this.svg, this.wheelListener, e), this.options.mouseWheelZoomEnabled = !1;\n  }\n};\nX.prototype.handleMouseWheel = function (e) {\n  if (!(!this.options.zoomEnabled || this.state !== \"none\")) {\n    this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1);\n    var t = e.deltaY || 1,\n      n = Date.now() - this.lastMouseWheelEventTime,\n      o = 3 + Math.max(0, 30 - n);\n    this.lastMouseWheelEventTime = Date.now(), \"deltaMode\" in e && e.deltaMode === 0 && e.wheelDelta && (t = e.deltaY === 0 ? 0 : Math.abs(e.wheelDelta) / e.deltaY), t = -0.3 < t && t < 0.3 ? t : (t > 0 ? 1 : -1) * Math.log(Math.abs(t) + 10) / o;\n    var i = this.svg.getScreenCTM().inverse(),\n      s = re.getEventPoint(e, this.svg).matrixTransform(i),\n      r = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * t);\n    this.zoomAtPoint(r, s);\n  }\n};\nX.prototype.zoomAtPoint = function (e, t, n) {\n  var o = this.viewport.getOriginalState();\n  n ? (e = Math.max(this.options.minZoom * o.zoom, Math.min(this.options.maxZoom * o.zoom, e)), e = e / this.getZoom()) : this.getZoom() * e < this.options.minZoom * o.zoom ? e = this.options.minZoom * o.zoom / this.getZoom() : this.getZoom() * e > this.options.maxZoom * o.zoom && (e = this.options.maxZoom * o.zoom / this.getZoom());\n  var i = this.viewport.getCTM(),\n    s = t.matrixTransform(i.inverse()),\n    r = this.svg.createSVGMatrix().translate(s.x, s.y).scale(e).translate(-s.x, -s.y),\n    a = i.multiply(r);\n  a.a !== i.a && this.viewport.setCTM(a);\n};\nX.prototype.zoom = function (e, t) {\n  this.zoomAtPoint(e, re.getSvgCenterPoint(this.svg, this.width, this.height), t);\n};\nX.prototype.publicZoom = function (e, t) {\n  t && (e = this.computeFromRelativeZoom(e)), this.zoom(e, t);\n};\nX.prototype.publicZoomAtPoint = function (e, t, n) {\n  if (n && (e = this.computeFromRelativeZoom(e)), fe.getType(t) !== \"SVGPoint\") if (\"x\" in t && \"y\" in t) t = re.createSVGPoint(this.svg, t.x, t.y);else throw new Error(\"Given point is invalid\");\n  this.zoomAtPoint(e, t, n);\n};\nX.prototype.getZoom = function () {\n  return this.viewport.getZoom();\n};\nX.prototype.getRelativeZoom = function () {\n  return this.viewport.getRelativeZoom();\n};\nX.prototype.computeFromRelativeZoom = function (e) {\n  return e * this.viewport.getOriginalState().zoom;\n};\nX.prototype.resetZoom = function () {\n  var e = this.viewport.getOriginalState();\n  this.zoom(e.zoom, !0);\n};\nX.prototype.resetPan = function () {\n  this.pan(this.viewport.getOriginalState());\n};\nX.prototype.reset = function () {\n  this.resetZoom(), this.resetPan();\n};\nX.prototype.handleDblClick = function (e) {\n  if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.options.controlIconsEnabled) {\n    var t = e.target.getAttribute(\"class\") || \"\";\n    if (t.indexOf(\"svg-pan-zoom-control\") > -1) return !1;\n  }\n  var n;\n  e.shiftKey ? n = 1 / ((1 + this.options.zoomScaleSensitivity) * 2) : n = (1 + this.options.zoomScaleSensitivity) * 2;\n  var o = re.getEventPoint(e, this.svg).matrixTransform(this.svg.getScreenCTM().inverse());\n  this.zoomAtPoint(n, o);\n};\nX.prototype.handleMouseDown = function (e, t) {\n  this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), fe.mouseAndTouchNormalize(e, this.svg), this.options.dblClickZoomEnabled && fe.isDblClick(e, t) ? this.handleDblClick(e) : (this.state = \"pan\", this.firstEventCTM = this.viewport.getCTM(), this.stateOrigin = re.getEventPoint(e, this.svg).matrixTransform(this.firstEventCTM.inverse()));\n};\nX.prototype.handleMouseMove = function (e) {\n  if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.state === \"pan\" && this.options.panEnabled) {\n    var t = re.getEventPoint(e, this.svg).matrixTransform(this.firstEventCTM.inverse()),\n      n = this.firstEventCTM.translate(t.x - this.stateOrigin.x, t.y - this.stateOrigin.y);\n    this.viewport.setCTM(n);\n  }\n};\nX.prototype.handleMouseUp = function (e) {\n  this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.state === \"pan\" && (this.state = \"none\");\n};\nX.prototype.handleTouchStart = function (e, t) {\n  if (e.touches.length == 1) this.handleMouseDown(e, t);else {\n    this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.firstEventCTM = this.viewport.getCTM();\n    var n = re.getTouchPoint(e, this.svg, 0),\n      o = re.getTouchPoint(e, this.svg, 1);\n    this.firstDistance = fe.calculateDistance(n, o), n.x = (n.x + o.x) / 2, n.y = (n.y + o.y) / 2, this.stateOrigin = n.matrixTransform(this.firstEventCTM.inverse()), this.firstZoomLevel = this.getZoom();\n  }\n};\nX.prototype.handleTouchMove = function (e) {\n  if (e.touches.length == 1) this.handleMouseMove(e);else {\n    if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), !this.options.panEnabled && !this.options.zoomEnabled) return;\n    var t = re.getTouchPoint(e, this.svg, 0),\n      n = re.getTouchPoint(e, this.svg, 1),\n      o = this.svg.createSVGPoint();\n    if (o.x = (t.x + n.x) / 2, o.y = (t.y + n.y) / 2, this.state === \"pan\" && this.options.panEnabled) {\n      var i = o.matrixTransform(this.firstEventCTM.inverse()),\n        s = this.firstEventCTM.translate(i.x - this.stateOrigin.x, i.y - this.stateOrigin.y);\n      this.viewport.setCTM(s);\n    }\n    if (this.options.zoomEnabled) {\n      var r = fe.calculateDistance(t, n),\n        a = r / this.firstDistance,\n        c = this.svg.getScreenCTM().inverse(),\n        u = o.matrixTransform(c);\n      this.zoomAtPoint(this.firstZoomLevel * a, u, !0);\n    }\n  }\n};\nX.prototype.handleTouchEnd = function (e) {\n  if (e.touches.length == 0) this.handleMouseUp(e);else if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.firstEventCTM = this.viewport.getCTM(), e.touches.length == 1) this.stateOrigin = re.getEventPoint(e, this.svg).matrixTransform(this.firstEventCTM.inverse());else {\n    var t = re.getTouchPoint(e, this.svg, 0),\n      n = re.getTouchPoint(e, this.svg, 1);\n    this.firstDistance = fe.calculateDistance(t, n), t.x = (t.x + n.x) / 2, t.y = (t.y + n.y) / 2, this.stateOrigin = t.matrixTransform(this.firstEventCTM.inverse());\n  }\n};\nX.prototype.fit = function () {\n  var e = this.viewport.getViewBox(),\n    t = Math.min(this.width / e.width, this.height / e.height);\n  this.zoom(t, !0);\n};\nX.prototype.contain = function () {\n  var e = this.viewport.getViewBox(),\n    t = Math.max(this.width / e.width, this.height / e.height);\n  this.zoom(t, !0);\n};\nX.prototype.center = function () {\n  var e = this.viewport.getViewBox(),\n    t = (this.width - (e.width + e.x * 2) * this.getZoom()) * 0.5,\n    n = (this.height - (e.height + e.y * 2) * this.getZoom()) * 0.5;\n  this.getPublicInstance().pan({\n    x: t,\n    y: n\n  });\n};\nX.prototype.updateBBox = function () {\n  this.viewport.simpleViewBoxCache();\n};\nX.prototype.pan = function (e) {\n  var t = this.viewport.getCTM();\n  t.e = e.x, t.f = e.y, this.viewport.setCTM(t);\n};\nX.prototype.panBy = function (e) {\n  var t = this.viewport.getCTM();\n  t.e += e.x, t.f += e.y, this.viewport.setCTM(t);\n};\nX.prototype.getPan = function () {\n  var e = this.viewport.getState();\n  return {\n    x: e.x,\n    y: e.y\n  };\n};\nX.prototype.resize = function () {\n  var e = re.getBoundingClientRectNormalized(this.svg);\n  this.width = e.width, this.height = e.height;\n  var t = this.viewport;\n  t.options.width = this.width, t.options.height = this.height, t.processCTM(), this.options.controlIconsEnabled && (this.getPublicInstance().disableControlIcons(), this.getPublicInstance().enableControlIcons());\n};\nX.prototype.destroy = function () {\n  var e = this;\n  this.beforeZoom = null, this.onZoom = null, this.beforePan = null, this.onPan = null, this.onUpdatedCTM = null, this.options.customEventsHandler != null && this.options.customEventsHandler.destroy({\n    svgElement: this.svg,\n    eventsListenerElement: this.options.eventsListenerElement,\n    instance: this.getPublicInstance()\n  });\n  for (var t in this.eventListeners) (this.options.eventsListenerElement || this.svg).removeEventListener(t, this.eventListeners[t], this.options.preventMouseEventsDefault ? Jn : Qn);\n  this.disableMouseWheelZoom(), this.getPublicInstance().disableControlIcons(), Te = Te.filter(function (n) {\n    return n.svg !== e.svg;\n  }), delete this.options, delete this.viewport, delete this.publicInstance, delete this.pi, this.getPublicInstance = function () {\n    return null;\n  };\n};\nX.prototype.getPublicInstance = function () {\n  var e = this;\n  return this.publicInstance || (this.publicInstance = this.pi = {\n    // Pan\n    enablePan: function () {\n      return e.options.panEnabled = !0, e.pi;\n    },\n    disablePan: function () {\n      return e.options.panEnabled = !1, e.pi;\n    },\n    isPanEnabled: function () {\n      return !!e.options.panEnabled;\n    },\n    pan: function (t) {\n      return e.pan(t), e.pi;\n    },\n    panBy: function (t) {\n      return e.panBy(t), e.pi;\n    },\n    getPan: function () {\n      return e.getPan();\n    },\n    // Pan event\n    setBeforePan: function (t) {\n      return e.options.beforePan = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;\n    },\n    setOnPan: function (t) {\n      return e.options.onPan = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;\n    },\n    // Zoom and Control Icons\n    enableZoom: function () {\n      return e.options.zoomEnabled = !0, e.pi;\n    },\n    disableZoom: function () {\n      return e.options.zoomEnabled = !1, e.pi;\n    },\n    isZoomEnabled: function () {\n      return !!e.options.zoomEnabled;\n    },\n    enableControlIcons: function () {\n      return e.options.controlIconsEnabled || (e.options.controlIconsEnabled = !0, Zt.enable(e)), e.pi;\n    },\n    disableControlIcons: function () {\n      return e.options.controlIconsEnabled && (e.options.controlIconsEnabled = !1, Zt.disable(e)), e.pi;\n    },\n    isControlIconsEnabled: function () {\n      return !!e.options.controlIconsEnabled;\n    },\n    // Double click zoom\n    enableDblClickZoom: function () {\n      return e.options.dblClickZoomEnabled = !0, e.pi;\n    },\n    disableDblClickZoom: function () {\n      return e.options.dblClickZoomEnabled = !1, e.pi;\n    },\n    isDblClickZoomEnabled: function () {\n      return !!e.options.dblClickZoomEnabled;\n    },\n    // Mouse wheel zoom\n    enableMouseWheelZoom: function () {\n      return e.enableMouseWheelZoom(), e.pi;\n    },\n    disableMouseWheelZoom: function () {\n      return e.disableMouseWheelZoom(), e.pi;\n    },\n    isMouseWheelZoomEnabled: function () {\n      return !!e.options.mouseWheelZoomEnabled;\n    },\n    // Zoom scale and bounds\n    setZoomScaleSensitivity: function (t) {\n      return e.options.zoomScaleSensitivity = t, e.pi;\n    },\n    setMinZoom: function (t) {\n      return e.options.minZoom = t, e.pi;\n    },\n    setMaxZoom: function (t) {\n      return e.options.maxZoom = t, e.pi;\n    },\n    // Zoom event\n    setBeforeZoom: function (t) {\n      return e.options.beforeZoom = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;\n    },\n    setOnZoom: function (t) {\n      return e.options.onZoom = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;\n    },\n    // Zooming\n    zoom: function (t) {\n      return e.publicZoom(t, !0), e.pi;\n    },\n    zoomBy: function (t) {\n      return e.publicZoom(t, !1), e.pi;\n    },\n    zoomAtPoint: function (t, n) {\n      return e.publicZoomAtPoint(t, n, !0), e.pi;\n    },\n    zoomAtPointBy: function (t, n) {\n      return e.publicZoomAtPoint(t, n, !1), e.pi;\n    },\n    zoomIn: function () {\n      return this.zoomBy(1 + e.options.zoomScaleSensitivity), e.pi;\n    },\n    zoomOut: function () {\n      return this.zoomBy(1 / (1 + e.options.zoomScaleSensitivity)), e.pi;\n    },\n    getZoom: function () {\n      return e.getRelativeZoom();\n    },\n    // CTM update\n    setOnUpdatedCTM: function (t) {\n      return e.options.onUpdatedCTM = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;\n    },\n    // Reset\n    resetZoom: function () {\n      return e.resetZoom(), e.pi;\n    },\n    resetPan: function () {\n      return e.resetPan(), e.pi;\n    },\n    reset: function () {\n      return e.reset(), e.pi;\n    },\n    // Fit, Contain and Center\n    fit: function () {\n      return e.fit(), e.pi;\n    },\n    contain: function () {\n      return e.contain(), e.pi;\n    },\n    center: function () {\n      return e.center(), e.pi;\n    },\n    // Size and Resize\n    updateBBox: function () {\n      return e.updateBBox(), e.pi;\n    },\n    resize: function () {\n      return e.resize(), e.pi;\n    },\n    getSizes: function () {\n      return {\n        width: e.width,\n        height: e.height,\n        realZoom: e.getZoom(),\n        viewBox: e.viewport.getViewBox()\n      };\n    },\n    // Destroy\n    destroy: function () {\n      return e.destroy(), e.pi;\n    }\n  }), this.publicInstance;\n};\nvar Te = [],\n  ns = function (e, t) {\n    var n = fe.getSvg(e);\n    if (n === null) return null;\n    for (var o = Te.length - 1; o >= 0; o--) if (Te[o].svg === n) return Te[o].instance.getPublicInstance();\n    return Te.push({\n      svg: n,\n      instance: new X(n, t)\n    }), Te[Te.length - 1].instance.getPublicInstance();\n  },\n  os = ns;\nconst is = /* @__PURE__ */qi(os),\n  ss = {\n    fitToContents() {\n      return this.fit().center().zoomOut().zoomOut(), this;\n    },\n    getViewArea() {\n      const e = this.getSizes(),\n        t = this.getPan(),\n        n = e.realZoom;\n      t.x /= n, t.y /= n;\n      const o = {\n        width: e.width / n,\n        height: e.height / n\n      };\n      return {\n        box: {\n          top: -t.y,\n          bottom: o.height - t.y,\n          left: -t.x,\n          right: o.width - t.x\n        },\n        center: {\n          x: o.width / 2 - t.x,\n          y: o.height / 2 - t.y\n        }\n      };\n    },\n    getViewBox() {\n      return this.getViewArea().box;\n    },\n    setViewBox(e) {\n      const t = e.right - e.left,\n        n = e.bottom - e.top,\n        {\n          width: o,\n          height: i\n        } = this.getSizes(),\n        s = t / n,\n        r = o / i,\n        a = s < r ? n * r : t,\n        c = s > r ? t / r : n,\n        u = Math.min(o / a, i / c),\n        l = this.getRealZoom(),\n        h = this.getZoom(),\n        d = l / h;\n      this.zoom(u / d);\n      const v = {\n        x: (e.left + t / 2) * u,\n        y: (e.top + n / 2) * u\n      };\n      this.pan({\n        x: -v.x + a / 2 * u,\n        y: -v.y + c / 2 * u\n      });\n    },\n    getRealZoom() {\n      return this.getSizes().realZoom;\n    },\n    applyAbsoluteZoomLevel(e, t, n) {\n      const o = Math.max(1e-4, t),\n        i = Math.max(o, n),\n        s = Math.max(Math.min(i, e), o),\n        r = this.getRealZoom(),\n        a = this.getZoom(),\n        c = r / a;\n      this.setMinZoom(o / c).setMaxZoom(i / c).zoom(s / c);\n    },\n    isPanEnabled() {\n      return this._isPanEnabled;\n    },\n    enablePan() {\n      return this._isPanEnabled = !0, this._internalEnablePan(), this;\n    },\n    disablePan() {\n      return this._isPanEnabled = !1, this._internalDisablePan(), this;\n    },\n    isZoomEnabled() {\n      return this._isZoomEnabled;\n    },\n    enableZoom() {\n      return this._isZoomEnabled = !0, this._internalEnableZoom(), this;\n    },\n    disableZoom() {\n      return this._isZoomEnabled = !1, this._internalDisableZoom(), this;\n    },\n    setPanEnabled(e) {\n      return e ? this.enablePan() : this.disablePan(), this;\n    },\n    setZoomEnabled(e) {\n      return e ? (this.enableZoom(), this.enableDblClickZoom()) : (this.disableZoom(), this.disableDblClickZoom()), this;\n    }\n  };\nfunction rs(e, t) {\n  var o, i;\n  const n = e;\n  return n._isPanEnabled = (o = t.panEnabled) != null ? o : !0, n._isZoomEnabled = (i = t == null ? void 0 : t.zoomEnabled) != null ? i : !0, n._internalIsPanEnabled = n.isPanEnabled, n._internalEnablePan = n.enablePan, n._internalDisablePan = n.disablePan, n._internalIsZoomEnabled = n.isZoomEnabled, n._internalEnableZoom = n.enableZoom, n._internalDisableZoom = n.disableZoom, Object.assign(e, ss), n;\n}\nfunction as(e, t) {\n  var s, r, a, c, u, l;\n  const n = (r = (s = t.customEventsHandler) == null ? void 0 : s.init) != null ? r : h => {},\n    o = (c = (a = t.customEventsHandler) == null ? void 0 : a.destroy) != null ? c : h => {},\n    i = (l = (u = t.customEventsHandler) == null ? void 0 : u.haltEventListeners) != null ? l : [];\n  return t.mouseWheelZoomEnabled === void 0 && (t.mouseWheelZoomEnabled = t.zoomEnabled), t.customEventsHandler = {\n    init: h => {\n      rs(h.instance, t), n(h);\n    },\n    destroy: h => o(h),\n    haltEventListeners: i\n  }, is(e, t);\n}\nfunction ls(e, t) {\n  const n = _();\n  let o = 0;\n  const i = [],\n    s = [],\n    r = () => {\n      o = 1, i.forEach(l => l()), i.length = 0;\n    },\n    a = () => {\n      o = 2, s.forEach(l => l()), s.length = 0;\n    };\n  return We(() => {\n    var k, E, p, y, w, m;\n    const l = G(e.value, \"<svg>\"),\n      h = (E = (k = t.customEventsHandler) == null ? void 0 : k.init) != null ? E : f => {},\n      d = (y = (p = t.customEventsHandler) == null ? void 0 : p.destroy) != null ? y : f => {},\n      v = (m = (w = t.customEventsHandler) == null ? void 0 : w.haltEventListeners) != null ? m : [];\n    t.customEventsHandler = {\n      init: f => {\n        n.value = f.instance, h(f), r();\n      },\n      destroy: f => {\n        a(), d(f);\n      },\n      haltEventListeners: v\n    };\n    const x = () => {\n      const f = l.getBoundingClientRect();\n      f.width !== 0 && f.height !== 0 ? as(l, t) : setTimeout(x, 200);\n    };\n    x();\n  }), Je(() => {\n    var l;\n    (l = n.value) == null || l.destroy(), n.value = void 0;\n  }), {\n    svgPanZoom: n,\n    onSvgPanZoomMounted: l => {\n      o === 0 ? i.push(l) : o === 1 && l();\n    },\n    onSvgPanZoomUnmounted: l => {\n      o === 0 || o === 1 ? s.push(l) : l();\n    }\n  };\n}\nconst eo = Symbol(\"zoomLevel\");\nfunction cs(e, t) {\n  const n = C(() => t.scalingObjects ? 1 : 1 / e.value);\n  return Ae(eo, {\n    zoomLevel: e,\n    scale: n\n  }), {\n    scale: n\n  };\n}\nfunction me() {\n  return G(Ze(eo), \"zoomLevel\");\n}\nfunction us(e) {\n  return e instanceof Promise || e && typeof e.then == \"function\";\n}\nfunction ds() {\n  let e = null;\n  const t = _({\n    enabled: !1,\n    duration: 300,\n    timingFunction: \"linear\"\n  });\n  function n(o, i = 300, s = \"linear\") {\n    e && (clearTimeout(e), e = null), t.value = {\n      enabled: !0,\n      duration: i,\n      timingFunction: s\n    }, Dt(() => Ee(this, null, function* () {\n      const r = o();\n      us(r) && (yield r), e && clearTimeout(e), e = window == null ? void 0 : window.setTimeout(() => {\n        t.value.enabled = !1, e = null;\n      }, i);\n    }));\n  }\n  return {\n    transitionWhile: n,\n    transitionOption: t\n  };\n}\nfunction fs(e) {\n  const t = _({}),\n    n = _(!1);\n  let o = 1;\n  const i = /* @__PURE__ */new Map();\n  return ge(() => {\n    if (e.value instanceof Array) {\n      const s = /* @__PURE__ */new Set([]);\n      if (t.value = Object.fromEntries(e.value.map(r => {\n        let a = r.id;\n        return a || (n.value || (n.value = !0, console.warn(\"[v-network-graph] Please specify the `id` field for the `Path` object. Currently, this works for compatibility, but in the future, the id field will be required.\")), a = i.get(r), a || (a = \"path-\" + o++, i.set(r, a))), s.add(a), [a, r];\n      })), n.value) for (const [r, a] of Array.from(i.entries())) s.has(a) || i.delete(r);\n    } else t.value = e.value;\n  }), {\n    objects: t,\n    isInCompatibilityModeForPath: n\n  };\n}\nfunction hs(e, t, n, o) {\n  if (o) {\n    const s = _(o(e[t])),\n      r = a => {\n        Ie(a, s.value) || (s.value = a), Ie(a, e[t]) || n(`update:${t}`, a);\n      };\n    return F(() => o(s.value), r), F(() => e[t], a => r(o(a))), s.value !== e[t] && n(`update:${t}`, s.value), s;\n  }\n  const i = _(e[t]);\n  return F(() => e[t], s => {\n    Ie(s, i.value) || (i.value = s);\n  }), F(i, s => {\n    Ie(s, e[t]) || n(`update:${t}`, s);\n  }), i;\n}\nfunction Tt(e, t, n, o) {\n  const i = Ce( /* @__PURE__ */new Set());\n  return F(() => e[t], () => {\n    const r = e[t].filter(a => a in n.value);\n    Ie(r, Array.from(i)) || (i.clear(), r.forEach(i.add, i));\n  }, {\n    deep: !0,\n    immediate: !0\n  }), F(i, () => {\n    const s = Array.from(i);\n    Ie(e[t], s) || o(`update:${t}`, s);\n  }), ze(i);\n}\nconst to = Symbol(\"selection\");\nfunction vs(e, t, n) {\n  Ae(to, {\n    selectedNodes: e,\n    selectedEdges: t,\n    selectedPaths: n\n  });\n}\nfunction ps() {\n  return G(Ze(to), \"Selections\");\n}\nconst no = Symbol(\"layouts\");\nfunction gs(e) {\n  Ae(no, e);\n}\nfunction Yt() {\n  return G(Ze(no), \"Layouts\");\n}\nfunction ms(e, t) {\n  for (let n = 0; n < e.length - 1; n++) t(e[n], e[n + 1]);\n}\nfunction Ge(e, t) {\n  const n = e.indexOf(t);\n  n >= 0 && e.splice(n, 1);\n}\nfunction bs(e, t, n) {\n  const o = e.indexOf(t);\n  o < 0 || e.splice(o + 1, 0, n);\n}\nfunction ys(e, t) {\n  const n = [\"edges\", \"edge-labels\", \"focusring\", \"nodes\", \"node-labels\", \"paths\"];\n  return C(() => {\n    const o = Bo(e.view.builtInLayerOrder).filter(s => {\n        const r = n.includes(s);\n        return r || console.warn(`Layer ${s} is not a built-in layer.`), r;\n      }).reverse(),\n      i = [...n];\n    return ms(o, (s, r) => {\n      Ge(i, r), bs(i, s, r);\n    }), \"edge-label\" in t || \"edges-label\" in t || Ge(i, \"edge-labels\"), e.node.focusring.visible || Ge(i, \"focusring\"), e.node.label.visible === !1 && Ge(i, \"node-labels\"), e.path.visible || Ge(i, \"paths\"), i;\n  });\n}\nconst xn = () => new Promise(e => Dt(e)),\n  ws = [\"x\", \"y\", \"width\", \"height\", \"fill\", \"stroke\", \"stroke-width\", \"stroke-dasharray\"],\n  Es = /* @__PURE__ */W({\n    __name: \"VSelectionBox\",\n    props: {\n      box: null,\n      config: null\n    },\n    setup(e) {\n      return (t, n) => (M(), $(\"rect\", {\n        class: \"v-ng-selection-box\",\n        x: Math.round(e.box.pos.x),\n        y: Math.round(e.box.pos.y),\n        width: Math.ceil(e.box.size.width),\n        height: Math.ceil(e.box.size.height),\n        fill: e.config.color,\n        stroke: e.config.strokeColor,\n        \"stroke-width\": e.config.strokeWidth,\n        \"stroke-dasharray\": e.config.strokeDasharray\n      }, null, 8, ws));\n    }\n  });\nconst xs = [\"points\", \"fill\"],\n  ks = /* @__PURE__ */W({\n    __name: \"VMarkerHeadArrow\",\n    props: {\n      width: null,\n      height: null,\n      refX: null,\n      color: null,\n      isSource: {\n        type: Boolean\n      },\n      units: null\n    },\n    setup(e) {\n      const t = e,\n        n = C(() => {\n          const o = t.width,\n            i = t.height;\n          return t.isSource ? `${o} ${i}, 0 ${i / 2}, ${o} 0` : `0 0, ${o} ${i / 2}, 0 ${i}`;\n        });\n      return (o, i) => (M(), $(\"polygon\", {\n        points: b(n),\n        fill: e.color\n      }, null, 8, xs));\n    }\n  }),\n  Ps = [\"points\", \"stroke-width\", \"stroke\"],\n  Ss = /* @__PURE__ */W({\n    __name: \"VMarkerHeadAngle\",\n    props: {\n      width: null,\n      height: null,\n      refX: null,\n      color: null,\n      isSource: {\n        type: Boolean\n      },\n      units: null\n    },\n    setup(e) {\n      const t = e,\n        n = C(() => t.units === \"strokeWidth\" ? 1 : Math.min(t.width, t.height) / 5),\n        o = C(() => {\n          const i = n.value / 2,\n            s = t.width,\n            r = t.height;\n          return t.isSource ? `${s - i} ${r - i}, ${i} ${r / 2}, ${s - i} ${i}` : `${i} ${i}, ${s - i} ${r / 2}, ${i} ${r - i}`;\n        });\n      return (i, s) => (M(), $(\"polyline\", {\n        points: b(o),\n        fill: \"none\",\n        \"stroke-width\": b(n),\n        stroke: e.color,\n        \"stroke-linecap\": \"round\",\n        \"stroke-linejoin\": \"round\"\n      }, null, 8, Ps));\n    }\n  }),\n  Ms = [\"fill\", \"cx\", \"cy\", \"rx\", \"ry\"],\n  Cs = /* @__PURE__ */W({\n    __name: \"VMarkerHeadCircle\",\n    props: {\n      width: null,\n      height: null,\n      refX: null,\n      color: null,\n      isSource: {\n        type: Boolean\n      },\n      units: null\n    },\n    setup(e) {\n      return (t, n) => (M(), $(\"ellipse\", {\n        fill: e.color,\n        cx: e.width / 2,\n        cy: e.height / 2,\n        rx: e.width / 2,\n        ry: e.height / 2\n      }, null, 8, Ms));\n    }\n  }),\n  Os = [\"id\", \"markerWidth\", \"markerHeight\", \"refX\", \"refY\", \"markerUnits\"],\n  Ts = /* @__PURE__ */W({\n    __name: \"VMarkerHead\",\n    props: {\n      id: null,\n      marker: null,\n      scale: null\n    },\n    setup(e) {\n      const t = e,\n        n = {\n          arrow: ks,\n          angle: Ss,\n          circle: Cs\n        },\n        o = C(() => t.marker.width * (t.marker.units === \"strokeWidth\" ? 1 : t.scale)),\n        i = C(() => t.marker.height * (t.marker.units === \"strokeWidth\" ? 1 : t.scale)),\n        s = C(() => {\n          const a = t.marker.margin * (t.marker.units === \"strokeWidth\" ? 1 : t.scale);\n          return t.marker.isSource ? o.value + a : -a;\n        }),\n        r = C(() => {\n          const a = t.marker.offset * (t.marker.units === \"strokeWidth\" ? 1 : t.scale);\n          return t.marker.isSource ? a : -a;\n        });\n      return (a, c) => e.marker.type !== \"none\" && e.marker.type !== \"custom\" ? (M(), $(\"marker\", {\n        key: 0,\n        id: e.id,\n        markerWidth: b(o),\n        markerHeight: b(i),\n        refX: b(s),\n        refY: b(i) / 2 + b(r),\n        orient: \"auto\",\n        markerUnits: e.marker.units,\n        class: \"v-ng-marker\"\n      }, [(M(), R(Mn(n[e.marker.type]), {\n        width: b(o),\n        height: b(i),\n        refX: b(s),\n        color: e.marker.color,\n        \"is-source\": e.marker.isSource,\n        units: e.marker.units\n      }, null, 8, [\"width\", \"height\", \"refX\", \"color\", \"is-source\", \"units\"]))], 8, Os)) : ce(\"\", !0);\n    }\n  }),\n  zs = {\n    class: \"v-ng-background-grid\",\n    \"shape-rendering\": \"crispEdges\"\n  },\n  Is = [\"d\"],\n  Ls = [\"d\"],\n  $s = [\"d\"],\n  As = [\"d\"],\n  Zs = /* @__PURE__ */W({\n    __name: \"VBackgroundGrid\",\n    setup(e) {\n      const {\n          container: t,\n          svgPanZoom: n\n        } = Bt(),\n        {\n          zoomLevel: o\n        } = me(),\n        i = Xi(),\n        s = Uo(),\n        r = _({\n          x: 0,\n          y: 0\n        }),\n        a = _({\n          width: 500,\n          height: 500\n        });\n      We(() => {\n        var x;\n        const d = (x = n.value) == null ? void 0 : x.getPan();\n        d && (r.value = {\n          x: -d.x,\n          y: -d.y\n        });\n        const v = t.value.getBoundingClientRect();\n        a.value = {\n          width: v.width,\n          height: v.height\n        };\n      }), i.on(\"view:resize\", d => {\n        a.value = {\n          width: d.width,\n          height: d.height\n        };\n      }), i.on(\"view:pan\", d => {\n        r.value = {\n          x: -d.x,\n          y: -d.y\n        };\n      }), i.on(\"view:zoom\", () => {\n        var v;\n        const d = (v = n.value) == null ? void 0 : v.getPan();\n        d && (r.value = {\n          x: -d.x,\n          y: -d.y\n        });\n      });\n      const c = _([]),\n        u = _([]),\n        l = _([]),\n        h = _([]);\n      return ge(() => {\n        const d = [],\n          v = [],\n          x = [],\n          k = [],\n          E = 1 / o.value,\n          p = s.grid.interval,\n          y = r.value.x * E,\n          w = r.value.y * E,\n          m = Math.floor(a.value.width / p + 1) * p,\n          f = Math.floor(a.value.height / p + 1) * p,\n          g = (r.value.x + m) * E,\n          S = (r.value.y + f) * E,\n          O = s.grid.thickIncrements,\n          I = s.grid.line.dasharray,\n          T = s.grid.thick.dasharray;\n        let z = {\n            stroke: s.grid.thick.color,\n            \"stroke-width\": s.grid.thick.width,\n            \"stroke-dasharray\": T,\n            \"stroke-dashoffset\": T ? y / E : void 0\n          },\n          A = {\n            stroke: s.grid.line.color,\n            \"stroke-width\": s.grid.line.width,\n            \"stroke-dasharray\": I,\n            \"stroke-dashoffset\": I ? y / E : void 0\n          };\n        const j = (r.value.x + m) * E;\n        for (let B = w; B <= S; B += p) {\n          const U = Math.floor(B / p);\n          O && U % O === 0 ? d.push([U, U * p, y, j, z]) : x.push([U, U * p, y, j, A]);\n        }\n        z = se({}, z), z[\"stroke-dashoffset\"] = T ? w / E : void 0, A = se({}, A), A[\"stroke-dashoffset\"] = I ? w / E : void 0;\n        const Y = (r.value.y + f) * E;\n        for (let B = y; B <= g; B += p) {\n          const U = Math.floor(B / p);\n          O && U % O === 0 ? v.push([U, U * p, w, Y, z]) : k.push([U, U * p, w, Y, A]);\n        }\n        u.value = d, c.value = v, h.value = x, l.value = k;\n      }), (d, v) => (M(), $(\"g\", zs, [(M(!0), $(q, null, J(h.value, ([x, k, E, p, y]) => (M(), $(\"path\", Pe({\n        key: `nv${x}`,\n        d: `M ${E} ${k} L ${p} ${k}`\n      }, y, {\n        style: {\n          \"vector-effect\": \"non-scaling-stroke\"\n        }\n      }), null, 16, Is))), 128)), (M(!0), $(q, null, J(l.value, ([x, k, E, p, y]) => (M(), $(\"path\", Pe({\n        key: `nh${x}`,\n        d: `M ${k} ${E} L ${k} ${p}`\n      }, y, {\n        style: {\n          \"vector-effect\": \"non-scaling-stroke\"\n        }\n      }), null, 16, Ls))), 128)), (M(!0), $(q, null, J(u.value, ([x, k, E, p, y]) => (M(), $(\"path\", Pe({\n        key: `tv${x}`,\n        d: `M ${E} ${k} L ${p} ${k}`\n      }, y, {\n        style: {\n          \"vector-effect\": \"non-scaling-stroke\"\n        }\n      }), null, 16, $s))), 128)), (M(!0), $(q, null, J(c.value, ([x, k, E, p, y]) => (M(), $(\"path\", Pe({\n        key: `th${x}`,\n        d: `M ${k} ${E} L ${k} ${p}`\n      }, y, {\n        style: {\n          \"vector-effect\": \"non-scaling-stroke\"\n        }\n      }), null, 16, As))), 128))]));\n    }\n  });\nconst Ds = /* @__PURE__ */W({\n    __name: \"VBackgroundViewport\",\n    setup(e) {\n      const {\n          viewport: t\n        } = Bt(),\n        n = _(),\n        o = (s, r, a) => {\n          s.forEach(c => {\n            var u;\n            return r.setAttribute(c, (u = a.getAttribute(c)) != null ? u : \"\");\n          });\n        },\n        i = new MutationObserver(s => {\n          if (!n.value) return;\n          const r = s.map(a => {\n            var c;\n            return (c = a.attributeName) != null ? c : \"\";\n          }).filter(Boolean);\n          o(r, n.value, t.value);\n        });\n      return We(() => {\n        const s = [\"transform\", \"style\"];\n        i.observe(t.value, {\n          attributes: !0,\n          attributeFilter: s\n        }), n.value && o(s, n.value, t.value);\n      }), Je(() => {\n        i.disconnect();\n      }), (s, r) => (M(), $(\"g\", {\n        ref_key: \"background\",\n        ref: n,\n        class: \"v-ng-background-viewport\"\n      }, [K(s.$slots, \"default\")], 512));\n    }\n  }),\n  Ns = [\"d\", \"stroke-width\"],\n  _s = /* @__PURE__ */W({\n    __name: \"VEdgeBackground\",\n    props: {\n      id: null,\n      state: null,\n      sourcePos: {\n        default: void 0\n      },\n      targetPos: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        {\n          scale: n\n        } = me(),\n        o = gt(),\n        {\n          handleEdgePointerDownEvent: i,\n          handleEdgePointerOverEvent: s,\n          handleEdgePointerOutEvent: r,\n          handleEdgeClickEvent: a,\n          handleEdgeDoubleClickEvent: c,\n          handleEdgeContextMenu: u\n        } = nt(),\n        l = C(() => {\n          const d = t.state.position;\n          if (t.state.loop) {\n            const {\n                radius: v,\n                isLargeArc: x,\n                isClockwise: k\n              } = t.state.loop,\n              [E, p] = v,\n              y = x ? 1 : 0,\n              w = k ? 1 : 0;\n            return `M ${d.p1.x} ${d.p1.y} A ${E} ${p} 0 ${y} ${w} ${d.p2.x} ${d.p2.y}`;\n          } else {\n            if (o.type === \"straight\" || !t.state.curve) return `M ${d.p1.x} ${d.p1.y} L ${d.p2.x} ${d.p2.y}`;\n            {\n              const v = [...t.state.curve.control, {\n                  x: d.p2.x,\n                  y: d.p2.y\n                }],\n                x = [];\n              return x.push(`M ${d.p1.x} ${d.p1.y}`), _t(v, 2).forEach(([k, E]) => x.push(`Q ${k.x} ${k.y} ${E.x} ${E.y}`)), x.join(\" \");\n            }\n          }\n        }),\n        h = C(() => (t.state.line.stroke.width + 10) * n.value);\n      return (d, v) => (M(), $(\"path\", {\n        class: ve({\n          \"v-ng-line-background\": !0,\n          selectable: e.state.selectable\n        }),\n        d: b(l),\n        stroke: \"transparent\",\n        \"stroke-width\": b(h),\n        fill: \"none\",\n        onPointerdown: v[0] || (v[0] = xe(x => b(i)(e.id, x), [\"stop\"])),\n        onPointerenterPassive: v[1] || (v[1] = x => b(s)(e.id, x)),\n        onPointerleavePassive: v[2] || (v[2] = x => b(r)(e.id, x)),\n        onClick: v[3] || (v[3] = xe(x => b(a)(e.id, x), [\"stop\"])),\n        onDblclick: v[4] || (v[4] = xe(x => b(c)(e.id, x), [\"stop\"])),\n        onContextmenu: v[5] || (v[5] = x => b(u)(e.id, x))\n      }, null, 42, Ns));\n    }\n  });\nconst Bs = /* @__PURE__ */W({\n    __name: \"VEdgeBackgrounds\",\n    setup(e) {\n      const {\n        edgeStates: t,\n        edgeGroupStates: n,\n        layouts: o\n      } = Se();\n      return (i, s) => (M(!0), $(q, null, J(b(n).edgeGroups, ({\n        summarize: r,\n        edges: a\n      }) => (M(), $(q, null, [r ? ce(\"\", !0) : (M(!0), $(q, {\n        key: 0\n      }, J(a, (c, u) => (M(), R(_s, {\n        key: u,\n        id: u,\n        state: b(t)[u],\n        \"source-pos\": b(o).nodes[c.source],\n        \"target-pos\": b(o).nodes[c.target]\n      }, null, 8, [\"id\", \"state\", \"source-pos\", \"target-pos\"]))), 128))], 64))), 256));\n    }\n  }),\n  js = [\"d\", \"stroke\", \"stroke-width\", \"stroke-dasharray\", \"stroke-linecap\"],\n  oo = /* @__PURE__ */W({\n    __name: \"VLine\",\n    props: {\n      p1: null,\n      p2: null,\n      config: null\n    },\n    setup(e) {\n      const t = e,\n        {\n          scale: n\n        } = me(),\n        o = C(() => t.config.width * n.value),\n        i = C(() => tt(t.config.dasharray, n.value)),\n        s = C(() => {\n          const r = t.config.animate ? ht(t.config.dasharray) * t.config.animationSpeed * n.value : !1;\n          return r ? {\n            \"--animation-speed\": r\n          } : void 0;\n        });\n      return (r, a) => (M(), $(\"path\", {\n        class: ve({\n          \"v-ng-line\": !0,\n          animate: e.config.animate\n        }),\n        d: `M ${e.p1.x} ${e.p1.y} L ${e.p2.x} ${e.p2.y}`,\n        stroke: e.config.color,\n        \"stroke-width\": b(o),\n        \"stroke-dasharray\": b(i),\n        \"stroke-linecap\": e.config.linecap,\n        style: et(b(s))\n      }, null, 14, js));\n    }\n  }),\n  Vs = [\"d\", \"stroke\", \"stroke-width\", \"stroke-dasharray\", \"stroke-linecap\"],\n  Rs = /* @__PURE__ */W({\n    __name: \"VArc\",\n    props: {\n      p1: null,\n      p2: null,\n      radius: null,\n      isLargeArc: {\n        type: Boolean\n      },\n      isClockwise: {\n        type: Boolean\n      },\n      config: null\n    },\n    setup(e) {\n      const t = e,\n        {\n          scale: n\n        } = me(),\n        o = C(() => t.config.width * n.value),\n        i = C(() => tt(t.config.dasharray, n.value)),\n        s = C(() => {\n          const a = t.config.animate ? ht(t.config.dasharray) * t.config.animationSpeed * n.value : !1;\n          return a ? {\n            \"--animation-speed\": a\n          } : void 0;\n        }),\n        r = C(() => {\n          const {\n              p1: a,\n              p2: c,\n              radius: u,\n              isLargeArc: l,\n              isClockwise: h\n            } = t,\n            [d, v] = u,\n            x = l ? 1 : 0,\n            k = h ? 1 : 0;\n          return `M ${a.x} ${a.y} A ${d} ${v} 0 ${x} ${k} ${c.x} ${c.y}`;\n        });\n      return (a, c) => (M(), $(\"path\", {\n        class: ve({\n          \"v-ng-line\": !0,\n          animate: e.config.animate\n        }),\n        d: b(r),\n        stroke: e.config.color,\n        \"stroke-width\": b(o),\n        \"stroke-dasharray\": b(i),\n        \"stroke-linecap\": e.config.linecap,\n        style: et(b(s)),\n        fill: \"none\"\n      }, null, 14, Vs));\n    }\n  }),\n  Hs = [\"d\", \"stroke\", \"stroke-width\", \"stroke-dasharray\", \"stroke-linecap\", \"marker-start\", \"marker-end\"],\n  Ws = /* @__PURE__ */W({\n    __name: \"VEdgeCurved\",\n    props: {\n      state: null,\n      config: null,\n      markerStart: {\n        default: void 0\n      },\n      markerEnd: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        {\n          scale: n\n        } = me(),\n        o = C(() => {\n          var l, h;\n          const a = t.state.position,\n            c = [...((h = (l = t.state.curve) == null ? void 0 : l.control) != null ? h : []), {\n              x: a.p2.x,\n              y: a.p2.y\n            }],\n            u = [];\n          return u.push(`M ${a.p1.x} ${a.p1.y}`), _t(c, 2).forEach(([d, v]) => u.push(`Q ${d.x} ${d.y} ${v.x} ${v.y}`)), u.join(\" \");\n        }),\n        i = C(() => t.config.width * n.value),\n        s = C(() => tt(t.config.dasharray, n.value)),\n        r = C(() => {\n          const a = t.config.animate ? ht(t.config.dasharray) * t.config.animationSpeed * n.value : !1;\n          return a ? {\n            \"--animation-speed\": a\n          } : void 0;\n        });\n      return (a, c) => (M(), $(\"path\", {\n        class: ve({\n          \"v-ng-line\": !0,\n          animate: e.config.animate\n        }),\n        d: b(o),\n        fill: \"none\",\n        stroke: e.config.color,\n        \"stroke-width\": b(i),\n        \"stroke-dasharray\": b(s),\n        \"stroke-linecap\": e.config.linecap,\n        style: et(b(r)),\n        \"marker-start\": e.markerStart,\n        \"marker-end\": e.markerEnd\n      }, null, 14, Hs));\n    }\n  }),\n  Us = /* @__PURE__ */W({\n    __name: \"VEdge\",\n    props: {\n      id: null,\n      state: null,\n      sourcePos: {\n        default: void 0\n      },\n      targetPos: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = gt();\n      return (n, o) => e.state.loop ? (M(), R(Rs, Pe({\n        key: 0\n      }, e.state.position, {\n        radius: e.state.loop.radius,\n        \"is-large-arc\": e.state.loop.isLargeArc,\n        \"is-clockwise\": e.state.loop.isClockwise,\n        class: [{\n          selectable: e.state.selectable,\n          hover: e.state.hovered,\n          selected: e.state.selected\n        }, \"v-ng-edge\"],\n        config: e.state.line.stroke,\n        \"marker-start\": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,\n        \"marker-end\": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0\n      }), null, 16, [\"radius\", \"is-large-arc\", \"is-clockwise\", \"class\", \"config\", \"marker-start\", \"marker-end\"])) : b(t).type == \"straight\" || !e.state.curve ? (M(), R(oo, Pe({\n        key: 1,\n        \"data-edge-id\": e.id\n      }, e.state.position, {\n        class: [{\n          selectable: e.state.selectable,\n          hover: e.state.hovered,\n          selected: e.state.selected\n        }, \"v-ng-edge\"],\n        config: e.state.line.stroke,\n        \"marker-start\": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,\n        \"marker-end\": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0\n      }), null, 16, [\"data-edge-id\", \"class\", \"config\", \"marker-start\", \"marker-end\"])) : (M(), R(Ws, {\n        key: 2,\n        \"data-edge-id\": e.id,\n        class: ve([{\n          selectable: e.state.selectable,\n          hover: e.state.hovered,\n          selected: e.state.selected\n        }, \"v-ng-edge\"]),\n        state: e.state,\n        config: e.state.line.stroke,\n        \"marker-start\": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,\n        \"marker-end\": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0\n      }, null, 8, [\"data-edge-id\", \"class\", \"state\", \"config\", \"marker-start\", \"marker-end\"]));\n    }\n  });\nconst Fs = [\"cx\", \"cy\", \"r\", \"fill\", \"stroke\", \"stroke-width\", \"stroke-dasharray\"],\n  Xs = [\"x\", \"y\", \"width\", \"height\", \"rx\", \"ry\", \"fill\", \"stroke\", \"stroke-width\", \"stroke-dasharray\"],\n  yt = /* @__PURE__ */W({\n    __name: \"VShape\",\n    props: {\n      baseX: {\n        default: 0\n      },\n      baseY: {\n        default: 0\n      },\n      config: null\n    },\n    setup(e) {\n      const t = e,\n        {\n          scale: n\n        } = me(),\n        o = _(t.baseX),\n        i = _(t.baseY),\n        s = _(0),\n        r = _(\"#000000\"),\n        a = _(void 0),\n        c = _(0),\n        u = _(0),\n        l = _(0),\n        h = _(0);\n      return ge(() => {\n        var v;\n        const d = n.value;\n        s.value = t.config.strokeWidth * d, r.value = (v = t.config.strokeColor) != null ? v : \"none\", a.value = tt(t.config.strokeDasharray, d), t.config.type === \"circle\" ? (o.value = t.baseX, i.value = t.baseY, c.value = t.config.radius * d) : (u.value = t.config.width * d, l.value = t.config.height * d, h.value = t.config.borderRadius * d, o.value = t.baseX - u.value / 2, i.value = t.baseY - l.value / 2);\n      }), (d, v) => e.config.type === \"circle\" ? (M(), $(\"circle\", {\n        key: 0,\n        class: \"v-ng-shape-circle\",\n        cx: o.value,\n        cy: i.value,\n        r: c.value,\n        fill: e.config.color,\n        stroke: r.value,\n        \"stroke-width\": s.value,\n        \"stroke-dasharray\": a.value\n      }, null, 8, Fs)) : (M(), $(\"rect\", {\n        key: 1,\n        class: \"v-ng-shape-rect\",\n        x: o.value,\n        y: i.value,\n        width: u.value,\n        height: l.value,\n        rx: h.value,\n        ry: h.value,\n        fill: e.config.color,\n        stroke: r.value,\n        \"stroke-width\": s.value,\n        \"stroke-dasharray\": a.value\n      }, null, 8, Xs));\n    }\n  }),\n  qs = [\"rx\", \"ry\", \"fill\", \"transform\"],\n  Gs = [\"x\", \"y\", \"dominant-baseline\", \"font-family\", \"font-size\", \"fill\"],\n  Ks = [\"x\", \"dy\", \"dominant-baseline\"],\n  wt = /* @__PURE__ */W({\n    __name: \"VLabelText\",\n    props: {\n      text: null,\n      x: {\n        default: 0\n      },\n      y: {\n        default: 0\n      },\n      dominantBaseline: {\n        default: \"central\"\n      },\n      config: null\n    },\n    setup(e) {\n      const t = e,\n        n = $o(),\n        {\n          scale: o\n        } = me(),\n        i = C(() => {\n          var E, p;\n          return (p = (E = t.text) == null ? void 0 : E.toString().split(/\\r?\\n/)) != null ? p : \"\";\n        }),\n        s = C(() => {\n          var E;\n          return (E = n[\"font-size\"]) != null ? E : t.config.fontSize * o.value;\n        }),\n        r = C(() => s.value * t.config.lineHeight),\n        a = C(() => {\n          const E = t.dominantBaseline;\n          return E === \"hanging\" ? 0 : E === \"central\" ? -(r.value * (i.value.length - 1)) / 2 : -r.value * (i.value.length - 1);\n        }),\n        c = _(),\n        u = _(\"\"),\n        l = Ce({\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        }),\n        h = C(() => {\n          var m, f;\n          const E = t.config.background;\n          if (!E) return l;\n          let p, y;\n          E.padding instanceof Object ? (p = E.padding.vertical, y = E.padding.horizontal) : (p = (m = E.padding) != null ? m : 0, y = (f = E.padding) != null ? f : 0);\n          const w = r.value - s.value;\n          return {\n            x: l.x - y * o.value,\n            y: l.y - p * o.value - w / 2,\n            width: l.width + y * 2 * o.value,\n            height: l.height + p * 2 * o.value + w\n          };\n        });\n      let d;\n      const v = () => {\n        t.config.background && t.config.background.visible ? !d && c.value && (d = k(c.value, l, u)) : (d == null || d.disconnect(), d = void 0);\n      };\n      We(() => v()), F(() => t.config.background && t.config.background.visible, (E, p) => {\n        E != p && v();\n      }), Je(() => {\n        d == null || d.disconnect(), d = void 0;\n      });\n      function x(E, p, y) {\n        var m;\n        const w = E.getBBox();\n        p.x = w.x, p.y = w.y, p.width = w.width, p.height = w.height, y.value = (m = E.getAttribute(\"transform\")) != null ? m : void 0;\n      }\n      function k(E, p, y) {\n        const w = new MutationObserver(() => {\n          x(E, p, y);\n        });\n        return w.observe(E, {\n          attributes: !0,\n          attributeFilter: [\"x\", \"y\", \"transform\", \"font-size\"]\n        }), x(E, p, y), w;\n      }\n      return (E, p) => {\n        var y, w, m, f, g, S;\n        return M(), $(q, null, [e.config.background && e.config.background.visible ? (M(), $(\"rect\", Pe({\n          key: 0,\n          class: \"v-ng-text-background\"\n        }, b(h), {\n          rx: ((w = (y = e.config.background) == null ? void 0 : y.borderRadius) != null ? w : 0) * b(o),\n          ry: ((f = (m = e.config.background) == null ? void 0 : m.borderRadius) != null ? f : 0) * b(o),\n          fill: (S = (g = e.config.background) == null ? void 0 : g.color) != null ? S : \"#ffffff\",\n          transform: u.value\n        }), null, 16, qs)) : ce(\"\", !0), Cn(\"text\", Pe({\n          ref_key: \"element\",\n          ref: c,\n          class: \"v-ng-text\"\n        }, E.$attrs, {\n          x: e.x,\n          y: e.y,\n          \"dominant-baseline\": e.dominantBaseline,\n          \"font-family\": E.$attrs[\"font-family\"] ? `${E.$attrs[\"font-family\"]}` : e.config.fontFamily,\n          \"font-size\": b(s),\n          fill: E.$attrs.fill ? `${E.$attrs.fill}` : e.config.color\n        }), [b(i).length <= 1 ? (M(), $(q, {\n          key: 0\n        }, [Ao(an(e.text), 1)], 64)) : (M(!0), $(q, {\n          key: 1\n        }, J(b(i), (O, I) => (M(), $(\"tspan\", {\n          key: I,\n          x: e.x,\n          dy: I == 0 ? b(a) : b(r),\n          \"dominant-baseline\": e.dominantBaseline\n        }, an(O), 9, Ks))), 128))], 16, Gs)], 64);\n      };\n    }\n  }),\n  Ys = /* @__PURE__ */W({\n    __name: \"VEdgeSummarized\",\n    props: {\n      edges: null,\n      layouts: null\n    },\n    setup(e) {\n      const t = e,\n        n = gt(),\n        {\n          handleEdgesPointerDownEvent: o,\n          handleEdgesPointerOverEvent: i,\n          handleEdgesPointerOutEvent: s,\n          handleEdgesClickEvent: r,\n          handleEdgesDoubleClickEvent: a,\n          handleEdgesContextMenu: c\n        } = nt(),\n        {\n          edgeStates: u\n        } = Se(),\n        l = _({\n          p1: {\n            x: 0,\n            y: 0\n          },\n          p2: {\n            x: 0,\n            y: 0\n          }\n        }),\n        h = _({\n          x: 0,\n          y: 0\n        });\n      ge(() => {\n        const w = Object.keys(t.edges).find(m => m in u);\n        w && (l.value = u[w].position, h.value = {\n          x: (l.value.p1.x + l.value.p2.x) / 2,\n          y: (l.value.p1.y + l.value.p2.y) / 2\n        });\n      });\n      const d = C(() => Object.keys(t.edges)),\n        v = C(() => L.values(n.summarized.label, t.edges)),\n        x = C(() => L.values(n.summarized.shape, t.edges)),\n        k = C(() => L.values(n.summarized.stroke, t.edges)),\n        E = C(() => d.value.some(w => u[w].hovered)),\n        p = C(() => d.value.some(w => u[w].selectable)),\n        y = C(() => d.value.some(w => u[w].selected));\n      return (w, m) => (M(), $(\"g\", {\n        class: ve({\n          \"v-ng-line-summarized\": !0,\n          hovered: b(E),\n          selectable: b(p),\n          selected: b(y)\n        }),\n        onPointerdown: m[0] || (m[0] = xe(f => b(o)(b(d), f), [\"stop\"])),\n        onPointerenterPassive: m[1] || (m[1] = f => b(i)(b(d), f)),\n        onPointerleavePassive: m[2] || (m[2] = f => b(s)(b(d), f)),\n        onClick: m[3] || (m[3] = xe(f => b(r)(b(d), f), [\"stop\"])),\n        onDblclick: m[4] || (m[4] = xe(f => b(a)(b(d), f), [\"stop\"])),\n        onContextmenu: m[5] || (m[5] = f => b(c)(b(d), f))\n      }, [_e(oo, Pe(l.value, {\n        config: b(k),\n        \"data-edge-id\": b(d)[0]\n      }), null, 16, [\"config\", \"data-edge-id\"]), _e(yt, {\n        \"base-x\": h.value.x,\n        \"base-y\": h.value.y,\n        config: b(x)\n      }, null, 8, [\"base-x\", \"base-y\", \"config\"]), _e(wt, {\n        text: Object.keys(e.edges).length.toString(),\n        x: h.value.x,\n        y: h.value.y,\n        config: b(v),\n        \"text-anchor\": \"middle\",\n        \"dominant-baseline\": \"central\"\n      }, null, 8, [\"text\", \"x\", \"y\", \"config\"])], 34));\n    }\n  });\nconst Qs = {\n    class: \"v-ng-edge-overlay\"\n  },\n  kn = /* @__PURE__ */W({\n    __name: \"VEdgeOverlay\",\n    props: {\n      edgeId: {\n        default: void 0\n      },\n      edge: {\n        default: void 0\n      },\n      edges: {\n        default: () => ({})\n      },\n      state: null,\n      isSummarized: {\n        type: Boolean\n      }\n    },\n    setup(e) {\n      const t = e,\n        {\n          svg: n\n        } = Bt(),\n        {\n          scale: o\n        } = me(),\n        i = gt();\n      function s() {\n        return t.isSummarized ? L.values(i.summarized.stroke, t.edges) : t.state.line.stroke;\n      }\n      function r(l) {\n        return {\n          source: l.p1,\n          target: l.p2\n        };\n      }\n      function a(l) {\n        if (l.curve) return l.curve.center;\n        {\n          const h = l.origin.p1,\n            d = l.origin.p2;\n          return {\n            x: (h.x + d.x) / 2,\n            y: (h.y + d.y) / 2\n          };\n        }\n      }\n      function c() {\n        var d;\n        if (!n.value) return 0;\n        const l = (d = t.edgeId) != null ? d : Object.keys(t.edges)[0],\n          h = n.value.querySelector(`path[data-edge-id=\"${l}\"]`);\n        return h ? h.getTotalLength() : 0;\n      }\n      function u(l) {\n        var x;\n        if (!n.value || !isFinite(l)) return t.state.position.p1;\n        t.state;\n        const h = (x = t.edgeId) != null ? x : Object.keys(t.edges)[0],\n          d = n.value.querySelector(`path[data-edge-id=\"${h}\"]`);\n        if (!d) return t.state.position.p1;\n        const v = d.getPointAtLength(l);\n        return {\n          x: v.x,\n          y: v.y\n        };\n      }\n      return (l, h) => (M(), $(\"g\", Qs, [e.isSummarized ? K(l.$slots, \"default\", {\n        key: 0,\n        edges: e.edges,\n        isSummarized: e.isSummarized,\n        stroke: s(),\n        position: r(e.state.origin),\n        center: a(e.state),\n        hovered: e.state.hovered,\n        selected: e.state.selected,\n        scale: b(o),\n        length: c(),\n        pointAtLength: u\n      }) : K(l.$slots, \"default\", {\n        key: 1,\n        edgeId: e.edgeId,\n        edge: e.edge,\n        edges: {\n          [e.edgeId]: e.edge\n        },\n        isSummarized: e.isSummarized,\n        stroke: s(),\n        position: r(e.state.origin),\n        center: a(e.state),\n        hovered: e.state.hovered,\n        selected: e.state.selected,\n        scale: b(o),\n        length: c(),\n        pointAtLength: u\n      })]));\n    }\n  }),\n  Js = /* @__PURE__ */W({\n    __name: \"VEdgeGroups\",\n    props: {\n      hasEdgeOverlaySlot: {\n        type: Boolean\n      }\n    },\n    setup(e) {\n      const {\n        edgeStates: t,\n        edgeZOrderedList: n,\n        layouts: o\n      } = Se();\n      return (i, s) => (M(!0), $(q, null, J(b(n), r => (M(), $(q, null, [b(Ei)(r) ? (M(), $(q, {\n        key: 0\n      }, [(M(), R(Ys, {\n        key: r.key,\n        edges: r.group.edges,\n        layouts: b(o).nodes\n      }, null, 8, [\"edges\", \"layouts\"])), e.hasEdgeOverlaySlot ? (M(), R(kn, {\n        key: r.key,\n        edges: r.group.edges,\n        state: b(t)[Object.keys(r.group.edges)[0]],\n        \"is-summarized\": !0\n      }, {\n        default: te(a => [K(i.$slots, \"default\", ue(de(a)))]),\n        _: 2\n      }, 1032, [\"edges\", \"state\"])) : ce(\"\", !0)], 64)) : (M(), $(q, {\n        key: 1\n      }, [(M(), R(Us, {\n        id: r.key,\n        key: r.key,\n        state: b(t)[r.key],\n        \"source-pos\": b(o).nodes[r.edge.source],\n        \"target-pos\": b(o).nodes[r.edge.target]\n      }, null, 8, [\"id\", \"state\", \"source-pos\", \"target-pos\"])), e.hasEdgeOverlaySlot ? (M(), R(kn, {\n        key: r.key,\n        \"edge-id\": r.key,\n        edge: r.edge,\n        state: b(t)[r.key],\n        \"is-summarized\": !1\n      }, {\n        default: te(a => [K(i.$slots, \"default\", ue(de(a)))]),\n        _: 2\n      }, 1032, [\"edge-id\", \"edge\", \"state\"])) : ce(\"\", !0)], 64))], 64))), 256));\n    }\n  }),\n  er = {\n    class: \"v-ng-layer-edges\"\n  },\n  tr = /* @__PURE__ */W({\n    __name: \"VEdgesLayer\",\n    setup(e) {\n      const t = ft(),\n        n = C(() => \"edge-overlay\" in t);\n      return (o, i) => (M(), $(\"g\", er, [_e(Bs), _e(Js, {\n        \"has-edge-overlay-slot\": b(n)\n      }, Nt({\n        _: 2\n      }, [b(n) ? {\n        name: \"default\",\n        fn: te(s => [K(o.$slots, \"edge-overlay\", ue(de(s)))]),\n        key: \"0\"\n      } : void 0]), 1032, [\"has-edge-overlay-slot\"])]));\n    }\n  }),\n  nr = /* @__PURE__ */W({\n    __name: \"VEdgeLabelPlace\",\n    props: {\n      edgeId: null,\n      edge: null,\n      state: null\n    },\n    setup(e) {\n      const t = e,\n        {\n          scale: n\n        } = me(),\n        o = C(() => Vn(t.state.labelPosition, t.state.line.stroke, t.state.label.margin, t.state.label.padding, n.value));\n      return (i, s) => e.state.loop ? ce(\"\", !0) : K(i.$slots, \"default\", {\n        key: 0,\n        edgeId: e.edgeId,\n        edge: e.edge,\n        config: e.state.label,\n        area: b(o),\n        hovered: e.state.hovered,\n        selected: e.state.selected,\n        scale: b(n)\n      });\n    }\n  }),\n  or = /* @__PURE__ */W({\n    __name: \"VEdgeLabelsPlace\",\n    props: {\n      edges: null,\n      state: null,\n      summarizeState: null\n    },\n    setup(e) {\n      const t = e,\n        {\n          scale: n\n        } = me(),\n        o = C(() => {\n          var i, s;\n          return Vn(t.state.labelPosition, (s = (i = t.summarizeState) == null ? void 0 : i.stroke) != null ? s : t.state.line.stroke, t.state.label.margin, t.state.label.padding, n.value);\n        });\n      return (i, s) => e.state.loop ? ce(\"\", !0) : K(i.$slots, \"default\", {\n        key: 0,\n        edges: e.edges,\n        config: e.state.label,\n        area: b(o),\n        hovered: e.state.hovered,\n        selected: e.state.selected,\n        scale: b(n)\n      });\n    }\n  }),\n  ir = {\n    class: \"v-ng-edge-labels\"\n  },\n  sr = /* @__PURE__ */W({\n    __name: \"VEdgeLabels\",\n    props: {\n      enableEdgeLabel: {\n        type: Boolean,\n        default: !1\n      },\n      enableEdgesLabel: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(e) {\n      const {\n          edgeStates: t,\n          edgeGroupStates: n,\n          summarizedEdgeStates: o\n        } = Se(),\n        i = C(() => {\n          const r = {},\n            a = {};\n          return Object.entries(n.edgeGroups).forEach(([c, u]) => {\n            Object.keys(u.edges).length > 0 && (u.summarize ? a[c] = u : r[c] = u);\n          }), {\n            individual: r,\n            summarized: a\n          };\n        });\n      function s(r) {\n        return Object.keys(r.edges)[0];\n      }\n      return (r, a) => (M(), $(\"g\", ir, [e.enableEdgeLabel ? (M(!0), $(q, {\n        key: 0\n      }, J(b(i).individual, (c, u) => (M(), $(q, {\n        key: u\n      }, [(M(!0), $(q, null, J(c.edges, (l, h) => (M(), R(nr, {\n        key: h,\n        \"edge-id\": h,\n        edge: l,\n        state: b(t)[h]\n      }, {\n        default: te(d => [K(r.$slots, \"edge-label\", ue(de(d)))]),\n        _: 2\n      }, 1032, [\"edge-id\", \"edge\", \"state\"]))), 128))], 64))), 128)) : ce(\"\", !0), e.enableEdgesLabel ? (M(!0), $(q, {\n        key: 1\n      }, J(b(i).summarized, (c, u) => (M(), R(or, {\n        key: u,\n        edges: c.edges,\n        state: b(t)[s(c)],\n        \"summarize-state\": b(o)[s(c)]\n      }, {\n        default: te(l => [K(r.$slots, \"edges-label\", ue(de(l)))]),\n        _: 2\n      }, 1032, [\"edges\", \"state\", \"summarize-state\"]))), 128)) : ce(\"\", !0)]));\n    }\n  });\nconst rr = /* @__PURE__ */W({\n    __name: \"VEdgeLabelsLayer\",\n    props: {\n      enableEdgeLabel: {\n        type: Boolean,\n        default: !1\n      },\n      enableEdgesLabel: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(e) {\n      return (t, n) => (M(), R(sr, {\n        \"enable-edge-label\": e.enableEdgeLabel,\n        \"enable-edges-label\": e.enableEdgesLabel,\n        class: \"v-ng-layer-edge-labels\"\n      }, Nt({\n        _: 2\n      }, [e.enableEdgeLabel ? {\n        name: \"edge-label\",\n        fn: te(o => [K(t.$slots, \"edge-label\", ue(de(o)))]),\n        key: \"0\"\n      } : void 0, e.enableEdgesLabel ? {\n        name: \"edges-label\",\n        fn: te(o => [K(t.$slots, \"edges-label\", ue(de(o)))]),\n        key: \"1\"\n      } : void 0]), 1032, [\"enable-edge-label\", \"enable-edges-label\"]));\n    }\n  }),\n  ar = /* @__PURE__ */W({\n    __name: \"VNodeFocusRing\",\n    props: {\n      id: null,\n      state: null,\n      pos: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        n = C(() => {\n          var r;\n          return ((r = t.pos) == null ? void 0 : r.x) || 0;\n        }),\n        o = C(() => {\n          var r;\n          return ((r = t.pos) == null ? void 0 : r.y) || 0;\n        }),\n        i = pt(),\n        s = Ce({});\n      return ge(() => {\n        var a, c, u;\n        const r = t.state.shape;\n        if (r.type === \"circle\") {\n          const l = {\n            type: \"circle\",\n            radius: r.radius + ((a = r.strokeWidth) != null ? a : 0) / 2 + i.focusring.padding + i.focusring.width / 2,\n            color: \"none\",\n            strokeWidth: i.focusring.width,\n            strokeColor: i.focusring.color,\n            strokeDasharray: i.focusring.dasharray\n          };\n          Object.assign(s, l);\n        } else {\n          const l = {\n            type: \"rect\",\n            width: r.width + ((c = r.strokeWidth) != null ? c : 0) + i.focusring.padding * 2 + i.focusring.width,\n            height: r.height + ((u = r.strokeWidth) != null ? u : 0) + i.focusring.padding * 2 + i.focusring.width,\n            borderRadius: r.borderRadius > 0 ? r.borderRadius + i.focusring.padding : 0,\n            color: \"none\",\n            strokeWidth: i.focusring.width,\n            strokeColor: i.focusring.color,\n            strokeDasharray: i.focusring.dasharray\n          };\n          Object.assign(s, l);\n        }\n      }), (r, a) => (M(), R(yt, {\n        class: \"v-ng-node-focusring\",\n        \"base-x\": b(n),\n        \"base-y\": b(o),\n        config: s\n      }, null, 8, [\"base-x\", \"base-y\", \"config\"]));\n    }\n  });\nconst lr = {\n    class: \"v-ng-layer-nodes-selections\"\n  },\n  cr = /* @__PURE__ */W({\n    __name: \"VFocusringLayer\",\n    setup(e) {\n      const {\n          nodeStates: t\n        } = Se(),\n        {\n          selectedNodes: n\n        } = ps(),\n        o = Yt();\n      return (i, s) => (M(), $(\"g\", lr, [(M(!0), $(q, null, J(b(n), r => (M(), R(ar, {\n        id: r,\n        key: r,\n        state: b(t)[r],\n        pos: b(o).nodes[r]\n      }, null, 8, [\"id\", \"state\", \"pos\"]))), 128))]));\n    }\n  }),\n  ur = [\"transform\"],\n  Pn = /* @__PURE__ */W({\n    __name: \"VNode\",\n    props: {\n      id: null,\n      state: null,\n      pos: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        n = C(() => {\n          var h;\n          return ((h = t.pos) == null ? void 0 : h.x) || 0;\n        }),\n        o = C(() => {\n          var h;\n          return ((h = t.pos) == null ? void 0 : h.y) || 0;\n        }),\n        {\n          scale: i\n        } = me(),\n        {\n          handleNodePointerDownEvent: s,\n          handleNodePointerOverEvent: r,\n          handleNodePointerOutEvent: a,\n          handleNodeClickEvent: c,\n          handleNodeDoubleClickEvent: u,\n          handleNodeContextMenu: l\n        } = nt();\n      return (h, d) => (M(), $(\"g\", {\n        class: ve({\n          \"v-ng-node\": !0,\n          hover: e.state.hovered,\n          selected: e.state.selected\n        }),\n        transform: `translate(${b(n)} ${b(o)})`,\n        onPointerdown: d[0] || (d[0] = xe(v => b(s)(e.id, v), [\"stop\"])),\n        onPointerenterPassive: d[1] || (d[1] = v => b(r)(e.id, v)),\n        onPointerleavePassive: d[2] || (d[2] = v => b(a)(e.id, v)),\n        onClick: d[3] || (d[3] = xe(v => b(c)(e.id, v), [\"stop\"])),\n        onDblclick: d[4] || (d[4] = xe(v => b(u)(e.id, v), [\"stop\"])),\n        onContextmenu: d[5] || (d[5] = v => b(l)(e.id, v))\n      }, [K(h.$slots, \"override-node\", {\n        nodeId: e.id,\n        scale: b(i),\n        config: e.state.shape,\n        class: ve({\n          draggable: e.state.draggable,\n          selectable: e.state.selectable\n        })\n      }, () => [_e(yt, {\n        config: e.state.shape,\n        class: ve({\n          \"v-ng-node-default\": !0,\n          draggable: e.state.draggable,\n          selectable: e.state.selectable\n        })\n      }, null, 8, [\"config\", \"class\"])])], 42, ur));\n    }\n  });\nconst dr = /* @__PURE__ */W({\n    __name: \"VNodesLayer\",\n    setup(e) {\n      const t = ft(),\n        n = C(() => \"override-node\" in t),\n        {\n          nodeZOrderedList: o\n        } = Se(),\n        i = pt(),\n        s = Yt();\n      return (r, a) => b(n) ? (M(), R(Ye, {\n        key: 0,\n        name: b(i).transition,\n        css: !!b(i).transition,\n        tag: \"g\",\n        class: \"v-ng-layer-nodes\"\n      }, {\n        default: te(() => [(M(!0), $(q, null, J(b(o), c => (M(), R(Pn, {\n          id: c.id,\n          key: c.id,\n          state: c,\n          pos: b(s).nodes[c.id]\n        }, {\n          \"override-node\": te(u => [K(r.$slots, \"override-node\", ue(de(u)))]),\n          _: 2\n        }, 1032, [\"id\", \"state\", \"pos\"]))), 128))]),\n        _: 3\n      }, 8, [\"name\", \"css\"])) : (M(), R(Ye, {\n        key: 1,\n        name: b(i).transition,\n        css: !!b(i).transition,\n        tag: \"g\",\n        class: \"v-ng-layer-nodes\"\n      }, {\n        default: te(() => [(M(!0), $(q, null, J(b(o), c => (M(), R(Pn, {\n          id: c.id,\n          key: c.id,\n          state: c,\n          pos: b(s).nodes[c.id]\n        }, null, 8, [\"id\", \"state\", \"pos\"]))), 128))]),\n        _: 1\n      }, 8, [\"name\", \"css\"]));\n    }\n  }),\n  io = {\n    [Z.NORTH]: 0,\n    [Z.NORTH_EAST]: 1,\n    [Z.EAST]: 2,\n    [Z.SOUTH_EAST]: 3,\n    [Z.SOUTH]: 4,\n    [Z.SOUTH_WEST]: 5,\n    [Z.WEST]: 6,\n    [Z.NORTH_WEST]: 7,\n    [Z.CENTER]: -1\n  },\n  fr = [/* N */\n  (e, t) => Oe(e, 0, t ? 90 : 60), /* NE */\n  (e, t) => Oe(e, 45, t ? 90 : 45), /* E */\n  (e, t) => Oe(e, 90, t ? 60 : 30), /* SE */\n  (e, t) => Oe(e, 135, t ? 90 : 45), /* S */\n  (e, t) => Oe(e, 180, t ? 90 : 60), /* SW */\n  (e, t) => Oe(e, 225, t ? 90 : 45), /* W */\n  (e, t) => Oe(e, 270, t ? 60 : 30), /* NW */\n  (e, t) => Oe(e, 315, t ? 90 : 45)];\nfunction hr(e, t, n, o, i) {\n  if (i === Z.CENTER) return Z.CENTER;\n  const s = [];\n  Object.entries(n).forEach(([u, l]) => {\n    let h = !1;\n    if (l.nodeId === e) {\n      const v = o(u);\n      v && (h = !0, l = Fe(se({}, l), {\n        pos: {\n          x: v.x,\n          y: v.y\n        }\n      }));\n    }\n    const d = (Ft(jt(l.pos, t)) + 360 + 90) % 360;\n    s.push([d, h]);\n  });\n  const r = vr(i),\n    c = [r, (r + 4) % 8,\n    // priority is given to diagonals\n    (r + 2) % 8, (r - 2 + 8) % 8, (r + 1) % 8, (r - 1 + 8) % 8, (r + 3) % 8, (r - 3 + 8) % 8].find(u => s.every(l => !fr[u](...l)));\n  return c === void 0 ? i : pr(c, i);\n}\nfunction Oe(e, t, n) {\n  e %= 360;\n  const o = (t - n + 360) % 360,\n    i = (t + n) % 360;\n  return o <= i ? o < e && e < i : o < e || e < i;\n}\nfunction vr(e) {\n  var t;\n  return (t = io[e]) != null ? t : 0;\n}\nfunction pr(e, t) {\n  var n, o;\n  return (o = (n = Object.entries(io)[e]) == null ? void 0 : n[0]) != null ? o : t;\n}\nconst gr = [\"transform\"],\n  Sn = /* @__PURE__ */W({\n    __name: \"VNodeLabel\",\n    props: {\n      id: null,\n      state: null,\n      pos: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        n = pt(),\n        {\n          edgeStates: o\n        } = Se(),\n        {\n          scale: i\n        } = me(),\n        {\n          handleNodePointerDownEvent: s,\n          handleNodePointerOverEvent: r,\n          handleNodePointerOutEvent: a,\n          handleNodeClickEvent: c,\n          handleNodeDoubleClickEvent: u,\n          handleNodeContextMenu: l\n        } = nt(),\n        h = C(() => {\n          var T;\n          return ((T = t.pos) == null ? void 0 : T.x) || 0;\n        }),\n        d = C(() => {\n          var T;\n          return ((T = t.pos) == null ? void 0 : T.y) || 0;\n        }),\n        v = C(() => t.state.label.direction === Z.CENTER ? 0 : t.state.label.margin * i.value),\n        x = _(0),\n        k = _(0),\n        E = _(0),\n        p = _(0),\n        y = C(() => {\n          var j;\n          const T = t.state.label.direction,\n            z = t.state.label.directionAutoAdjustment;\n          if (z === !1) return T;\n          const A = {\n            x: h.value,\n            y: d.value\n          };\n          return z === !0 ? hr(t.state.id, A, t.state.oppositeNodes, Y => {\n            var B, U;\n            return (U = (B = o[Y]) == null ? void 0 : B.loop) == null ? void 0 : U.center;\n          }, T) : (j = z({\n            nodeId: t.state.id,\n            pos: A,\n            oppositeNodes: t.state.oppositeNodes\n          })) != null ? j : T;\n        }),\n        w = C(() => {\n          switch (y.value) {\n            case Z.CENTER:\n            case Z.NORTH:\n            case Z.SOUTH:\n              return \"middle\";\n            case Z.EAST:\n            case Z.NORTH_EAST:\n            case Z.SOUTH_EAST:\n              return \"start\";\n            case Z.WEST:\n            case Z.NORTH_WEST:\n            case Z.SOUTH_WEST:\n            default:\n              return \"end\";\n          }\n        }),\n        m = C(() => {\n          switch (y.value) {\n            case Z.NORTH:\n            case Z.NORTH_EAST:\n            case Z.NORTH_WEST:\n              return \"text-top\";\n            case Z.SOUTH:\n            case Z.SOUTH_EAST:\n            case Z.SOUTH_WEST:\n              return \"hanging\";\n            case Z.CENTER:\n            case Z.EAST:\n            case Z.WEST:\n            default:\n              return \"central\";\n          }\n        }),\n        f = C(() => {\n          switch (y.value) {\n            case Z.CENTER:\n            case Z.NORTH:\n            case Z.SOUTH:\n              return 0;\n            case Z.EAST:\n              return k.value;\n            case Z.WEST:\n              return -k.value;\n            case Z.NORTH_EAST:\n            case Z.SOUTH_EAST:\n              return p.value;\n            case Z.NORTH_WEST:\n            case Z.SOUTH_WEST:\n            default:\n              return -p.value;\n          }\n        }),\n        g = C(() => {\n          switch (y.value) {\n            case Z.NORTH:\n              return -x.value;\n            case Z.SOUTH:\n              return x.value;\n            case Z.CENTER:\n            case Z.EAST:\n            case Z.WEST:\n              return 0;\n            case Z.NORTH_EAST:\n            case Z.NORTH_WEST:\n              return -E.value;\n            case Z.SOUTH_EAST:\n            case Z.SOUTH_WEST:\n            default:\n              return E.value;\n          }\n        });\n      ge(() => {\n        const T = i.value,\n          z = t.state.shape;\n        if (z.type == \"circle\") {\n          const A = z.radius * T,\n            j = A + v.value,\n            Y = Math.sqrt(ae(j, 2) / 2);\n          x.value = A + v.value, k.value = A + v.value, E.value = Y, p.value = Y;\n        } else {\n          const A = z.borderRadius * T,\n            j = z.width * T,\n            Y = z.height * T,\n            B = A + v.value,\n            U = Math.sqrt(ae(B, 2) / 2);\n          x.value = Y / 2 + v.value, k.value = j / 2 + v.value, E.value = Y / 2 - A + U, p.value = j / 2 - A + U;\n        }\n      });\n      const S = C(() => T => n.label.handleNodeEvents ? {\n          pointerdown: z => {\n            z.stopPropagation(), s(T, z);\n          },\n          pointerenter: z => r(T, z),\n          pointerleave: z => a(T, z),\n          click: z => {\n            z.stopPropagation(), c(T, z);\n          },\n          dblclick: z => {\n            z.stopPropagation(), u(T, z);\n          },\n          contextmenu: z => {\n            l(T, z);\n          }\n        } : {}),\n        O = C(() => {\n          const T = n.label.handleNodeEvents;\n          return {\n            \"v-ng-node-label\": !0,\n            hover: T && t.state.hovered,\n            selected: T && t.state.selected\n          };\n        }),\n        I = C(() => {\n          const T = n.label.handleNodeEvents;\n          return {\n            draggable: T && t.state.draggable,\n            selectable: T && t.state.selectable\n          };\n        });\n      return (T, z) => (M(), $(\"g\", Pe({\n        class: b(O),\n        transform: `translate(${b(h)} ${b(d)})`\n      }, Zo(b(S)(e.id), !0)), [K(T.$slots, \"override-node-label\", {\n        nodeId: e.id,\n        scale: b(i),\n        text: e.state.labelText,\n        x: b(f),\n        y: b(g),\n        config: e.state.label,\n        shape: e.state.shape,\n        textAnchor: b(w),\n        dominantBaseline: b(m),\n        class: ve(b(I))\n      }, () => [_e(wt, {\n        text: e.state.labelText,\n        x: 0,\n        y: 0,\n        config: e.state.label,\n        \"text-anchor\": b(w),\n        \"dominant-baseline\": b(m),\n        class: ve(b(I)),\n        transform: `translate(${b(f)} ${b(g)})`\n      }, null, 8, [\"text\", \"config\", \"text-anchor\", \"dominant-baseline\", \"class\", \"transform\"])])], 16, gr));\n    }\n  });\nconst mr = /* @__PURE__ */W({\n    __name: \"VNodeLabelsLayer\",\n    setup(e) {\n      const t = ft(),\n        n = C(() => \"override-node-label\" in t),\n        {\n          nodeZOrderedList: o\n        } = Se(),\n        i = pt(),\n        s = Yt(),\n        r = C(() => a(o.value));\n      function a(c) {\n        return c.filter(u => {\n          var l;\n          return u.label.visible && ((l = u.labelText) != null ? l : !1);\n        });\n      }\n      return (c, u) => b(n) ? (M(), R(Ye, {\n        key: 0,\n        name: b(i).transition,\n        css: !!b(i).transition,\n        tag: \"g\",\n        class: \"v-ng-layer-node-labels\"\n      }, {\n        default: te(() => [(M(!0), $(q, null, J(b(r), l => (M(), R(Sn, {\n          id: l.id,\n          key: l.id,\n          state: l,\n          pos: b(s).nodes[l.id]\n        }, {\n          \"override-node-label\": te(h => [K(c.$slots, \"override-node-label\", ue(de(h)))]),\n          _: 2\n        }, 1032, [\"id\", \"state\", \"pos\"]))), 128))]),\n        _: 3\n      }, 8, [\"name\", \"css\"])) : (M(), R(Ye, {\n        key: 1,\n        name: b(i).transition,\n        css: !!b(i).transition,\n        tag: \"g\",\n        class: \"v-ng-layer-node-labels\"\n      }, {\n        default: te(() => [(M(!0), $(q, null, J(b(r), l => (M(), R(Sn, {\n          id: l.id,\n          key: l.id,\n          state: l,\n          pos: b(s).nodes[l.id]\n        }, null, 8, [\"id\", \"state\", \"pos\"]))), 128))]),\n        _: 1\n      }, 8, [\"name\", \"css\"]));\n    }\n  }),\n  br = [\"d\", \"stroke\", \"stroke-width\", \"stroke-dasharray\", \"stroke-linecap\", \"stroke-linejoin\"],\n  yr = /* @__PURE__ */W({\n    __name: \"VPath\",\n    props: {\n      path: null\n    },\n    setup(e) {\n      const t = e,\n        {\n          nodeStates: n,\n          edgeStates: o,\n          layouts: i\n        } = Se(),\n        {\n          scale: s\n        } = me(),\n        r = $n();\n      function a(d) {\n        if (d.edges.length === 0) return [];\n        const v = L.value(r.margin, d.path) * s.value;\n        return ci(d, n, i.nodes, o, s.value, r.curveInNode, r.end, v);\n      }\n      function c(d) {\n        const v = a(d);\n        let x = !0;\n        return v.map(k => {\n          if (k === null) x = !0;else {\n            if (typeof k == \"string\") return k;\n            if (k instanceof Array) {\n              k = [...k];\n              const E = [];\n              if (k.length % 2 === 1) {\n                const p = k[0];\n                k = k.slice(1), E.push(`L ${p.x} ${p.y}`);\n              }\n              return _t(k, 2).map(([p, y]) => E.push(`Q ${p.x} ${p.y} ${y.x} ${y.y}`)), E.join(\" \");\n            } else {\n              const E = x;\n              return x = !1, `${E ? \"M \" : \"L \"}${k.x} ${k.y}`;\n            }\n          }\n        }).join(\" \");\n      }\n      const u = C(() => {\n          const d = t.path;\n          return d.selected ? L.values(r.selected, d.path) : d.hovered && r.hover ? L.values(r.hover, d.path) : L.values(r.normal, d.path);\n        }),\n        l = C(() => tt(u.value.dasharray, s.value)),\n        h = C(() => {\n          const d = u.value.animate ? ht(u.value.dasharray) * u.value.animationSpeed * s.value : !1;\n          return d ? {\n            \"--animation-speed\": d\n          } : void 0;\n        });\n      return (d, v) => (M(), $(\"path\", {\n        class: ve({\n          \"v-ng-path\": !0,\n          animate: b(u).animate,\n          clickable: e.path.clickable,\n          hoverable: e.path.hoverable\n        }),\n        d: c(e.path),\n        fill: \"none\",\n        stroke: b(u).color,\n        \"stroke-width\": b(u).width * b(s),\n        \"stroke-dasharray\": b(l),\n        \"stroke-linecap\": b(u).linecap,\n        \"stroke-linejoin\": b(u).linejoin,\n        style: et(b(h))\n      }, null, 14, br));\n    }\n  });\nconst wr = /* @__PURE__ */W({\n    __name: \"VPaths\",\n    setup(e) {\n      const {\n          pathZOrderedList: t\n        } = Se(),\n        n = $n(),\n        {\n          handlePathPointerDownEvent: o,\n          handlePathPointerOverEvent: i,\n          handlePathPointerOutEvent: s,\n          handlePathClickEvent: r,\n          handlePathDoubleClickEvent: a,\n          handlePathContextMenu: c\n        } = nt();\n      return (u, l) => (M(), R(Ye, {\n        name: b(n).transition,\n        css: !!b(n).transition,\n        tag: \"g\",\n        class: \"v-ng-paths\"\n      }, {\n        default: te(() => [(M(!0), $(q, null, J(b(t), h => (M(), R(yr, {\n          key: h.id,\n          path: h,\n          onPointerdown: d => b(o)(h.id, d),\n          onPointerenterPassive: d => b(i)(h.id, d),\n          onPointerleavePassive: d => b(s)(h.id, d),\n          onClick: xe(d => b(r)(h.id, d), [\"stop\"]),\n          onDblclick: xe(d => b(a)(h.id, d), [\"stop\"]),\n          onContextmenu: d => b(c)(h.id, d)\n        }, null, 8, [\"path\", \"onPointerdown\", \"onPointerenterPassive\", \"onPointerleavePassive\", \"onClick\", \"onDblclick\", \"onContextmenu\"]))), 128))]),\n        _: 1\n      }, 8, [\"name\", \"css\"]));\n    }\n  }),\n  Er = /* @__PURE__ */W({\n    __name: \"VPathsLayer\",\n    setup(e) {\n      return (t, n) => (M(), R(wr));\n    }\n  }),\n  xr = {\n    key: 0\n  },\n  kr = /* @__PURE__ */W({\n    __name: \"VNetworkGraph\",\n    props: {\n      nodes: {\n        default: () => ({})\n      },\n      edges: {\n        default: () => ({})\n      },\n      paths: {\n        default: () => ({})\n      },\n      layouts: {\n        default: () => ({})\n      },\n      zoomLevel: {\n        default: 1\n      },\n      selectedNodes: {\n        default: () => []\n      },\n      selectedEdges: {\n        default: () => []\n      },\n      selectedPaths: {\n        default: () => []\n      },\n      configs: {\n        default: () => ({})\n      },\n      layers: {\n        default: () => ({})\n      },\n      eventHandlers: {\n        default: () => ({})\n      }\n    },\n    emits: [\"update:zoomLevel\", \"update:selectedNodes\", \"update:selectedEdges\", \"update:selectedPaths\", \"update:layouts\"],\n    setup(e, {\n      expose: t,\n      emit: n\n    }) {\n      const o = e,\n        i = [\"override-node\", \"override-node-label\", \"edge-overlay\", \"edge-label\", \"edges-label\"],\n        s = ft(),\n        r = Me(o, \"nodes\"),\n        a = Me(o, \"edges\"),\n        {\n          objects: c,\n          isInCompatibilityModeForPath: u\n        } = fs(Me(o, \"paths\")),\n        l = Fi();\n      Object.entries(o.eventHandlers).forEach(([P, N]) => {\n        l.on(P, N);\n      });\n      const h = Wo(Me(o, \"configs\")),\n        d = C(() => {\n          const P = new Set(Object.keys(s));\n          i.forEach(D => P.delete(D));\n          const N = Object.fromEntries(jo.map(D => [D, []]));\n          return Object.assign(N, Object.entries(o.layers).reduce((D, [H, ie]) => (P.delete(H), ie in D ? D[ie].push(H) : D[ie] = [H], D), {})), N.root.push(...P), N;\n        }),\n        v = C(() => h.view.grid.visible),\n        x = C(() => {\n          const P = d.value;\n          return v.value || P.background.length > 0 || P.grid.length > 0;\n        }),\n        k = ys(h, s),\n        E = _(),\n        p = _(),\n        y = _(),\n        w = _(0\n        /* INITIAL */),\n        m = C(() => w.value !== 0\n        /* INITIAL */),\n        f = hs(o, \"zoomLevel\", n, P => (P = Math.max(P, h.view.minZoomLevel), P = Math.min(P, h.view.maxZoomLevel), P)),\n        {\n          svgPanZoom: g,\n          onSvgPanZoomMounted: S,\n          onSvgPanZoomUnmounted: O\n        } = ls(p, {\n          viewportSelector: \".v-ng-viewport\",\n          minZoom: h.view.minZoomLevel,\n          // temporary\n          maxZoom: h.view.maxZoomLevel,\n          // temporary\n          dblClickZoomEnabled: nn(h.view),\n          mouseWheelZoomEnabled: kt(h.view),\n          fit: h.view.autoPanAndZoomOnLoad === \"fit-content\",\n          center: h.view.autoPanAndZoomOnLoad !== !1,\n          zoomEnabled: h.view.zoomEnabled,\n          preventMouseEventsDefault: !1,\n          onZoom: P => {\n            var D, H;\n            if (w.value === 2) return;\n            const N = (H = (D = g.value) == null ? void 0 : D.getRealZoom()) != null ? H : 1;\n            Math.abs(f.value - N) >= 1e-6 && (f.value = N, l.emit(\"view:zoom\", N));\n          },\n          panEnabled: h.view.panEnabled,\n          onPan: P => {\n            w.value !== 2 && l.emit(\"view:pan\", P);\n          }\n        });\n      Vo({\n        container: E,\n        svg: p,\n        viewport: y,\n        svgPanZoom: g\n      });\n      const I = {\n          width: 0,\n          height: 0\n        },\n        T = globalThis.ResizeObserver ? new ResizeObserver(() => {\n          var N, D, H;\n          if ((N = g.value) == null || N.resize(), !h.view.autoPanOnResize) return;\n          const P = (D = E.value) == null ? void 0 : D.getBoundingClientRect();\n          if (P) {\n            const ie = -(I.width - P.width) / 2,\n              ot = -(I.height - P.height) / 2;\n            (H = g.value) == null || H.panBy({\n              x: ie,\n              y: ot\n            });\n            const {\n              width: je,\n              height: Pt\n            } = P;\n            (I.width !== je || I.height !== Pt) && (Object.assign(I, {\n              width: je,\n              height: Pt\n            }), l.emit(\"view:resize\", {\n              x: P.x,\n              y: P.y,\n              width: je,\n              height: Pt\n            }));\n          }\n        }) : void 0;\n      S(() => {\n        var ie, ot, je;\n        const P = G(E.value, \"svg-pan-zoom container\");\n        T == null || T.observe(P), (ot = (ie = h.view).onSvgPanZoomInitialized) == null || ot.call(ie, G(g.value, \"svg-pan-zoom instance\"));\n        const N = P.getBoundingClientRect(),\n          {\n            width: D,\n            height: H\n          } = N;\n        Object.assign(I, {\n          width: D,\n          height: H\n        }), (je = y.value) == null || je.addEventListener(\"touchstart\", on, {\n          passive: !1\n        });\n      }), O(() => {\n        var P;\n        T == null || T.disconnect(), (P = y.value) == null || P.removeEventListener(\"touchstart\", on);\n      });\n      const z = P => {\n        var N;\n        (N = g.value) == null || N.applyAbsoluteZoomLevel(P, h.view.minZoomLevel, h.view.maxZoomLevel);\n      };\n      F(() => h.view.panEnabled, P => {\n        var N;\n        (N = g.value) == null || N.setPanEnabled(P);\n      }), F(() => [h.view.zoomEnabled, nn(h.view), kt(h.view)], () => {\n        const P = g.value;\n        P && Mo(P, h.view.zoomEnabled, h.view.doubleClickZoomEnabled, h.view.mouseWheelZoomEnabled);\n      }), F(f, P => z(P)), F(() => [h.view.minZoomLevel, h.view.maxZoomLevel], P => {\n        z(f.value);\n      });\n      const {\n        scale: A\n      } = cs(f, h.view);\n      S(() => {\n        const P = o.zoomLevel;\n        z(P);\n      });\n      const j = () => Ee(this, null, function* () {\n          var P;\n          Object.keys(o.nodes).length > 0 && ((P = g.value) == null || P.updateBBox(), yield xn());\n        }),\n        Y = () => Ee(this, null, function* () {\n          yield j(), g.value && (g.value.fitToContents(), l.emit(\"view:fit\", void 0));\n        }),\n        B = () => Ee(this, null, function* () {\n          var P;\n          yield j(), (P = g.value) == null || P.center();\n        }),\n        U = () => {\n          var P, N;\n          return (N = (P = g.value) == null ? void 0 : P.getViewBox()) != null ? N : {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0\n          };\n        },\n        be = P => {\n          var N;\n          return (N = g.value) == null ? void 0 : N.setViewBox(P);\n        },\n        oe = Tt(o, \"selectedNodes\", r, n);\n      F(oe, P => l.emit(\"node:select\", Array.from(P)));\n      const ke = Tt(o, \"selectedEdges\", a, n);\n      F(ke, P => l.emit(\"edge:select\", Array.from(P)));\n      const De = Tt(o, \"selectedPaths\", c, n);\n      F(De, P => l.emit(\"path:select\", Array.from(P))), vs(oe, ke, De);\n      const Ue = ze( /* @__PURE__ */new Set()),\n        le = ze( /* @__PURE__ */new Set()),\n        Be = ze( /* @__PURE__ */new Set()),\n        ye = ze({\n          nodes: {}\n        });\n      gs(ye), F(() => o.layouts, () => Object.assign(ye, o.layouts), {\n        deep: !0,\n        immediate: !0\n      }), F(ye, () => n(\"update:layouts\", ye), {\n        deep: !0\n      });\n      const Et = pi(),\n        xt = _(!1);\n      l.on(\"node:dragstart\", P => xt.value = !0), l.on(\"node:dragend\", P => xt.value = !1), l.on(\"view:mode\", P => {\n        var N, D, H, ie;\n        h.view.panEnabled && (P === \"default\" ? (N = g.value) == null || N.enablePan() : (D = g.value) == null || D.disablePan()), h.view.zoomEnabled && (P === \"default\" ? (H = g.value) == null || H.enableZoom() : (ie = g.value) == null || ie.disableZoom());\n      });\n      const so = C(() => h.view.panEnabled || h.view.zoomEnabled || h.node.draggable),\n        {\n          nodeStates: ro,\n          edgeStates: ao,\n          pathStates: lo\n        } = wi(Ct(r, oe, Ue), Ct(a, ke, le), Ct(c, De, Be), Xe(h), ye, Et, A),\n        co = C(() => kt(h.view)),\n        {\n          isBoxSelectionMode: uo,\n          selectionBox: Qt,\n          startBoxSelection: fo,\n          stopBoxSelection: ho\n        } = Wi(p, Xe(ye), Xe(f), ro, ao, lo, oe, ke, De, Ue, le, Be, u, co, h, l),\n        Jt = () => ({\n          layouts: ze(ye.nodes),\n          // deprecated parameter.\n          nodePositions: Me(ye, \"nodes\"),\n          nodes: r,\n          edges: a,\n          configs: Xe(h),\n          scale: Xe(A),\n          emitter: l,\n          svgPanZoom: G(g.value)\n        });\n      F(() => h.view.layoutHandler, (P, N) => {\n        N.deactivate(), P.activate(Jt());\n      });\n      const {\n          transitionWhile: vo,\n          transitionOption: en\n        } = ds(),\n        po = C(() => {\n          const P = en.value;\n          return P.enabled ? {\n            \"--transition-duration\": P.duration + \"ms\",\n            \"--transition-function\": P.timingFunction\n          } : {};\n        });\n      S(() => Ee(this, null, function* () {\n        if (h.view.onBeforeInitialDisplay) {\n          const D = h.view.onBeforeInitialDisplay();\n          qo(D) && (yield D);\n        }\n        const P = G(g.value, \"svg-pan-zoom\");\n        h.view.layoutHandler.activate(Jt()), yield xn();\n        const N = h.view.autoPanAndZoomOnLoad;\n        if (h.view.fit || N !== !1) {\n          const D = Object.keys(o.nodes).length == 0,\n            H = P.getPan();\n          if (D || N === \"center-zero\") {\n            yield j();\n            const ie = P.getSizes();\n            P.pan({\n              x: ie.width / 2,\n              y: ie.height / 2\n            });\n          } else N === \"fit-content\" || h.view.fit ? yield Y() : N === \"center-content\" ? yield B() : yield j();\n          Dt(() => {\n            const ie = P.getPan();\n            H.x === ie.x && H.y === ie.y && l.emit(\"view:pan\", ie);\n          });\n        } else yield j();\n        l.emit(\"view:load\"), w.value = 1;\n      })), O(() => {\n        w.value = 2, l.emit(\"view:unload\"), h.view.layoutHandler.deactivate();\n      });\n      function go() {\n        var P;\n        (P = g.value) == null || P.zoomIn();\n      }\n      function mo() {\n        var P;\n        (P = g.value) == null || P.zoomOut();\n      }\n      function bo(P) {\n        var N;\n        (N = g.value) == null || N.pan(P);\n      }\n      function yo(P) {\n        var N;\n        (N = g.value) == null || N.panBy(P);\n      }\n      function wo() {\n        return G(g.value).getPan();\n      }\n      function Eo() {\n        const P = G(g.value).getSizes();\n        return {\n          width: P.width,\n          height: P.height,\n          viewBox: P.viewBox\n        };\n      }\n      function xo(P) {\n        return At(G(p.value, \"svg\"), G(y.value, \"viewport\"), P);\n      }\n      function ko(P) {\n        return Ni(G(p.value, \"svg\"), G(y.value, \"viewport\"), P);\n      }\n      function Po() {\n        return Xn(G(p.value, \"svg\"), G(y.value, \"viewport\"), A.value).outerHTML;\n      }\n      function So() {\n        return Ee(this, arguments, function* (P = {}) {\n          return (yield tn(P)).outerHTML;\n        });\n      }\n      function tn() {\n        return Ee(this, arguments, function* (P = {}) {\n          return Bi(G(p.value, \"svg\"), G(y.value, \"viewport\"), A.value, P);\n        });\n      }\n      t({\n        // methods\n        fitToContents: Y,\n        panToCenter: B,\n        getViewBox: U,\n        setViewBox: be,\n        transitionWhile: vo,\n        startBoxSelection: fo,\n        stopBoxSelection: ho,\n        zoomIn: go,\n        zoomOut: mo,\n        panTo: bo,\n        panBy: yo,\n        getPan: wo,\n        getSizes: Eo,\n        translateFromDomToSvgCoordinates: xo,\n        translateFromSvgToDomCoordinates: ko,\n        getAsSvg: Po,\n        exportAsSvgText: So,\n        exportAsSvgElement: tn\n      });\n      function Mo(P, N, D, H) {\n        P.setZoomEnabled(N), N && D ? P.enableDblClickZoom() : P.disableDblClickZoom(), N && H ? P.enableMouseWheelZoom() : P.disableMouseWheelZoom();\n      }\n      function nn(P) {\n        return P.zoomEnabled && P.doubleClickZoomEnabled;\n      }\n      function kt(P) {\n        return P.zoomEnabled && P.mouseWheelZoomEnabled;\n      }\n      function on(P) {\n        P.stopPropagation();\n      }\n      return (P, N) => (M(), $(\"div\", {\n        ref_key: \"container\",\n        ref: E,\n        class: \"v-network-graph v-ng-container\"\n      }, [(M(), $(\"svg\", {\n        ref_key: \"svg\",\n        ref: p,\n        class: ve([\"v-ng-canvas\", {\n          show: b(m),\n          dragging: xt.value,\n          touches: b(so),\n          \"box-selection-mode\": b(uo)\n        }]),\n        width: \"100%\",\n        height: \"100%\"\n      }, [(M(!0), $(q, null, J(b(d).root, D => K(P.$slots, D, {\n        key: D,\n        scale: b(A)\n      })), 128)), Object.keys(b(Et).markers).length > 0 ? (M(), $(\"defs\", xr, [(M(!0), $(q, null, J(b(Et).markers, (D, H) => (M(), R(Ts, {\n        id: H,\n        key: H,\n        marker: D,\n        scale: b(A)\n      }, null, 8, [\"id\", \"marker\", \"scale\"]))), 128))])) : ce(\"\", !0), b(x) ? (M(), R(Ds, {\n        key: 1\n      }, {\n        default: te(() => [(M(!0), $(q, null, J(b(d).background, D => (M(), $(\"g\", {\n          key: D,\n          class: \"v-ng-layer\"\n        }, [K(P.$slots, D, {\n          scale: b(A)\n        })]))), 128)), b(v) ? (M(), R(Zs, {\n          key: 0\n        })) : ce(\"\", !0), (M(!0), $(q, null, J(b(d).grid, D => (M(), $(\"g\", {\n          key: D,\n          class: \"v-ng-layer\"\n        }, [K(P.$slots, D, {\n          scale: b(A)\n        })]))), 128))]),\n        _: 3\n      })) : ce(\"\", !0), Cn(\"g\", {\n        ref_key: \"viewport\",\n        ref: y,\n        class: ve([\"v-ng-viewport\", {\n          \"v-ng-transition\": b(en).enabled\n        }]),\n        style: et(b(po))\n      }, [(M(!0), $(q, null, J(b(d).base, D => (M(), $(\"g\", {\n        key: D,\n        class: \"v-ng-layer\"\n      }, [K(P.$slots, D, {\n        scale: b(A)\n      })]))), 128)), (M(!0), $(q, null, J(b(k), D => (M(), $(q, {\n        key: D\n      }, [D === \"edges\" ? (M(), R(tr, {\n        key: 0\n      }, Nt({\n        _: 2\n      }, [\"edge-overlay\" in b(s) ? {\n        name: \"edge-overlay\",\n        fn: te(H => [K(P.$slots, \"edge-overlay\", ue(de(H)))]),\n        key: \"0\"\n      } : void 0]), 1024)) : D === \"edge-labels\" ? (M(), R(rr, {\n        key: 1,\n        \"enable-edge-label\": \"edge-label\" in b(s),\n        \"enable-edges-label\": \"edges-label\" in b(s)\n      }, {\n        \"edge-label\": te(H => [K(P.$slots, \"edge-label\", ue(de(H)))]),\n        \"edges-label\": te(H => [K(P.$slots, \"edges-label\", ue(de(H)))]),\n        _: 3\n      }, 8, [\"enable-edge-label\", \"enable-edges-label\"])) : D === \"focusring\" ? (M(), R(cr, {\n        key: 2\n      })) : D === \"nodes\" ? (M(), R(dr, {\n        key: 3\n      }, {\n        \"override-node\": te(H => [K(P.$slots, \"override-node\", ue(de(H)))]),\n        _: 3\n      })) : D === \"node-labels\" ? (M(), R(mr, {\n        key: 4\n      }, {\n        \"override-node-label\": te(H => [K(P.$slots, \"override-node-label\", ue(de(H)))]),\n        _: 3\n      })) : D === \"paths\" ? (M(), R(Er, {\n        key: 5\n      })) : ce(\"\", !0), (M(!0), $(q, null, J(b(d)[D], H => (M(), $(\"g\", {\n        key: H,\n        class: \"v-ng-layer\"\n      }, [K(P.$slots, H, {\n        scale: b(A)\n      })]))), 128))], 64))), 128))], 6), b(Qt) ? (M(), R(Es, {\n        key: 2,\n        box: b(Qt),\n        config: b(h).view.selection.box\n      }, null, 8, [\"box\", \"config\"])) : ce(\"\", !0)], 2))], 512));\n    }\n  });\nconst Pr = (e, t) => {\n    const n = e.__vccOpts || e;\n    for (const [o, i] of t) n[o] = i;\n    return n;\n  },\n  Sr = {};\nfunction Mr(e, t) {\n  return M(), $(\"defs\", null, [(M(), R(Mn(\"style\"), null, {\n    default: te(() => [K(e.$slots, \"default\")]),\n    _: 3\n  }))]);\n}\nconst Cr = /* @__PURE__ */Pr(Sr, [[\"render\", Mr]]),\n  Or = /* @__PURE__ */W({\n    __name: \"VEdgeLabel\",\n    props: {\n      area: null,\n      config: null,\n      text: {\n        default: \"\"\n      },\n      align: {\n        default: \"center\"\n      },\n      verticalAlign: {\n        default: \"center\"\n      },\n      edge: {\n        default: void 0\n      },\n      hovered: {\n        type: Boolean,\n        default: void 0\n      },\n      selected: {\n        type: Boolean,\n        default: void 0\n      },\n      scale: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        n = _(0),\n        o = _(0),\n        i = _(\"middle\"),\n        s = _(\"central\"),\n        r = _(0);\n      ge(() => {\n        const c = t.area.source,\n          u = t.area.target;\n        t.align === \"source\" ? (c.above.x == u.above.x ? i.value = c.above.y > u.above.y ? \"start\" : \"end\" : i.value = c.above.x < u.above.x ? \"start\" : \"end\", t.verticalAlign === \"above\" ? (n.value = c.above.x, o.value = c.above.y, s.value = \"text-top\") : t.verticalAlign === \"below\" ? (n.value = c.below.x, o.value = c.below.y, s.value = \"hanging\") : (n.value = (c.above.x + c.below.x) / 2, o.value = (c.above.y + c.below.y) / 2, s.value = \"central\")) : t.align === \"target\" ? (c.above.x == u.above.x ? i.value = c.above.y < u.above.y ? \"start\" : \"end\" : i.value = c.above.x > u.above.x ? \"start\" : \"end\", t.verticalAlign === \"above\" ? (n.value = u.above.x, o.value = u.above.y, s.value = \"text-top\") : t.verticalAlign === \"below\" ? (n.value = u.below.x, o.value = u.below.y, s.value = \"hanging\") : (n.value = (u.above.x + u.below.x) / 2, o.value = (u.above.y + u.below.y) / 2, s.value = \"central\")) : (i.value = \"middle\", t.verticalAlign === \"above\" ? (n.value = (c.above.x + u.above.x) / 2, o.value = (c.above.y + u.above.y) / 2, s.value = \"text-top\") : t.verticalAlign === \"below\" ? (n.value = (c.below.x + u.below.x) / 2, o.value = (c.below.y + u.below.y) / 2, s.value = \"hanging\") : (n.value = (c.above.x + u.below.x) / 2, o.value = (c.above.y + u.below.y) / 2, s.value = \"central\"));\n        let l = Q.fromPositions(c.above, u.above).v.angleDegree();\n        (l < -90 || l >= 90) && (l = l + 180, l > 180 && (l -= 360)), r.value = l;\n      });\n      const a = C(() => s.value === \"central\" && !t.config.background ? Fe(se({}, t.config), {\n        background: {\n          visible: !0,\n          color: \"#ffffff\",\n          padding: {\n            vertical: 1,\n            horizontal: 4\n          },\n          borderRadius: 2\n        }\n      }) : t.config);\n      return (c, u) => (M(), R(wt, {\n        class: \"v-ng-edge-label\",\n        text: e.text,\n        x: n.value,\n        y: o.value,\n        config: b(a),\n        \"text-anchor\": i.value,\n        \"dominant-baseline\": s.value,\n        transform: `rotate(${r.value} ${n.value} ${o.value})`\n      }, null, 8, [\"text\", \"x\", \"y\", \"config\", \"text-anchor\", \"dominant-baseline\", \"transform\"]));\n    }\n  }),\n  Tr = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    VEdgeLabel: Or,\n    VLabelText: wt,\n    VNetworkGraph: kr,\n    VShape: yt,\n    VStyle: Cr\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  zr = 10;\nclass Nr extends zn {\n  constructor(t = {}) {\n    super(), this.options = t;\n  }\n  setNodePosition(t, n) {\n    const o = this.options.grid || zr;\n    t.value.x = Math.floor(n.x / o) * o, t.value.y = Math.floor(n.y / o) * o;\n  }\n}\nconst _r = function (e) {\n  Object.entries(Tr).forEach(([t, n]) => {\n    e.component(t, n);\n  });\n};\nexport { L as Config, Nr as GridLayout, jo as LayerPositions, Z as NodeLabelDirection, zn as SimpleLayout, Or as VEdgeLabel, wt as VLabelText, kr as VNetworkGraph, yt as VShape, Cr as VStyle, V as Vector2D, Ar as configsWithType, _r as default, Zr as defineConfigs, Dr as getFullConfigs, Se as useStates, St as withSelf };","map":{"version":3,"names":["jo","ze","e","Lo","Ce","G","t","Error","Tn","Symbol","Vo","Ae","Bt","Ze","container","svg","viewport","svgPanZoom","L","value","n","Function","values","Object","filter","o","length","fromEntries","entries","map","i","Z","CENTER","NORTH","NORTH_EAST","EAST","SOUTH_EAST","SOUTH","SOUTH_WEST","WEST","NORTH_WEST","St","assign","Ar","Zr","cn","normal","type","width","radius","height","Ro","s","Math","abs","x","a","y","tt","split","parseInt","isNaN","join","ht","reduce","un","zn","activate","nodePositions","nodes","configs","emitter","scale","r","c","h","d","v","getOrCreateNodePosition","setNodePosition","u","k","getViewArea","E","p","node","se","center","m","f","g","S","O","box","right","w","keys","l","F","Ie","Set","on","onDeactivate","off","deactivate","ln","Me","In","view","scalingObjects","panEnabled","zoomEnabled","minZoomLevel","maxZoomLevel","doubleClickZoomEnabled","mouseWheelZoomEnabled","boxSelectionEnabled","autoPanAndZoomOnLoad","autoPanOnResize","layoutHandler","onSvgPanZoomInitialized","grid","visible","interval","thickIncrements","line","color","dasharray","thick","selection","strokeWidth","strokeColor","strokeDasharray","detector","test","navigator","userAgent","metaKey","ctrlKey","builtInLayerOrder","onBeforeInitialDisplay","borderRadius","hover","selected","draggable","selectable","label","fontFamily","fontSize","lineHeight","background","margin","direction","directionAutoAdjustment","text","handleNodeEvents","focusring","padding","zOrder","enabled","zIndex","bringToFrontOnHover","bringToFrontOnSelected","transition","edge","linecap","animate","animationSpeed","gap","marker","source","offset","units","target","summarize","summarized","shape","stroke","selfLoop","isClockwise","angle","keepOrder","path","clickable","hoverable","curveInNode","end","edges","charCodeAt","linejoin","Dr","On","Ln","Ho","No","Wo","Do","immediate","deep","vt","Uo","pt","gt","$n","Fo","Xo","he","at","forEach","delete","qo","Promise","then","Go","edgeLayoutPoints","edgeGroups","summarizedEdges","ge","Yo","groupWidth","dn","Ko","fn","pointInGroup","p1","p2","sort","console","warn","min","flatMap","hn","atan2","PI","sqrt","pow","An","jt","Zn","Dn","Vt","Nn","_n","Rt","Ht","Wt","Bn","jn","ct","cos","sin","Qo","Jo","Ut","Ft","V","fromArray","fromObject","constructor","add","subtract","multiply","multiplyScalar","divide","dot","cross","lengthSquared","distanceSquared","distance","normalize","angleDegree","rotate","isEqualTo","clone","toObject","toArray","ee","Vector2D","ei","Q","fromLinePosition","Re","fromPositions","fromVectors","ti","ni","ut","zt","oi","ii","qe","Xt","mt","ae","si","Ne","Qe","vn","tan","floor","Vn","above","below","ri","Le","It","Lt","He","push","ai","Ve","it","find","li","Number","EPSILON","ci","directions","di","edgeId","gn","ui","max","I","$t","T","z","st","A","j","Y","B","U","be","oe","curve","Array","ke","circle","theta","loop","bn","shift","unshift","pop","pn","Rn","includes","mn","isFinite","origin","position","Fe","reverse","Mt","has","fi","hovered","C","hi","states","zOrderedList","id","b","vi","btoa","Buffer","from","toString","replaceAll","pi","markers","referenceCount","gi","customId","mi","bi","makeMarker","clearMarker","isSource","Ct","objects","Hn","yi","wi","ki","_","Si","stopWatchHandle","call","Mi","Ti","wn","nodeStates","edgeStates","edgeGroupStates","summarizedEdgeStates","pathStates","layouts","nodeZOrderedList","edgeZOrderedList","pathZOrderedList","Ei","Se","xi","Wn","staticShape","labelText","oppositeNodeIds","oppositeNodes","nodeId","pos","Pi","yn","labelPosition","normalWidth","le","Be","ye","Oi","Ue","De","Ci","sourceMarkerId","targetMarkerId","key","group","flat","control","isLargeArc","Ke","valueOf","zi","Ii","Un","lt","qt","get","Fn","set","Date","now","lastTime","count","window","screenX","screenY","clientX","clientY","shiftKey","altKey","button","buttons","detail","PointerEvent","pointerId","pressure","tangentialPressure","tiltX","tiltY","twist","pointerType","isPrimary","MouseEvent","Gt","Li","pointers","Map","follow","followedPointerId","nodeBasePositions","hoveredNodesPre","clicks","pointermove","pointerup","pointercancel","Ot","dragBasePosition","latestPosition","nodeBasePosition","size","selectionMode","clear","pageX","pageY","isTrusted","emit","event","stopPropagation","moveCounter","document","removeEventListener","viewMode","eventTarget","dispatchEvent","addEventListener","currentTarget","handleNodePointerDownEvent","handleNodePointerOverEvent","handleNodePointerOutEvent","handleNodeClickEvent","handleNodeDoubleClickEvent","handleNodeContextMenu","$i","pointerPeekCount","we","every","some","handleEdgePointerDownEvent","handleEdgePointerOverEvent","handleEdgePointerOutEvent","handleEdgeClickEvent","handleEdgeDoubleClickEvent","handleEdgeContextMenu","handleEdgesPointerDownEvent","handleEdgesPointerOverEvent","handleEdgesPointerOutEvent","handleEdgesClickEvent","handleEdgesDoubleClickEvent","handleEdgesContextMenu","Ai","pointerCounter","clickState","passive","preventDefault","We","Je","Zi","handlePathPointerDownEvent","handlePathPointerOverEvent","handlePathPointerOutEvent","handlePathClickEvent","handlePathDoubleClickEvent","handlePathContextMenu","Di","Ee","fetch","blob","FileReader","onload","result","readAsDataURL","At","createSVGPoint","matrixTransform","getCTM","inverse","Ni","Xn","cloneNode","getBBox","ceil","setAttribute","querySelector","removeAttribute","createNodeIterator","NodeFilter","SHOW_COMMENT","nextNode","referenceNode","parentNode","removeChild","_i","getAttribute","startsWith","Bi","arguments","embedImages","querySelectorAll","all","ji","points","startPoint","selectedNodesAtSelectStarted","selectionType","options","stopTrigger","selectionTypeWithShiftKey","_o","Vi","maxWait","Ri","offsetX","offsetY","getBoundingClientRect","Hi","stop","withShiftKey","register","unregister","isBoxSelectionMode","selectionBox","startBoxSelection","stopBoxSelection","_container","_handlePointerDownEvent","_handlePointerUpEvent","_handlePointerMoveEvent","_handleClickEvent","_handleKeyDownEvent","_ignoreEvent","capture","_handleKeyUpEvent","_preventDefault","qn","Wi","selectedNodes","hoveredNodes","selectedEdges","hoveredEdges","selectedPaths","hoveredPaths","nt","Ui","splice","indexOf","slice","Gn","Fi","Xi","bt","getGlobalThis","globalThis","self","dt","extend","isObject","isElement","HTMLElement","SVGElement","SVGSVGElement","nodeType","nodeName","prototype","isNumber","parseFloat","getSvg","String","tagName","toLowerCase","contentDocument","documentElement","getSVGDocument","proxy","apply","getType","replace","mouseAndTouchNormalize","touches","left","top","originalEvent","touchNormalize","isDblClick","timeStamp","getTime","throttle","later","leading","clearTimeout","trailing","setTimeout","createRequestAnimationFrame","requestAnimationFrame","En","calculateDistance","Gi","Ki","createElement","onmousewheel","srcElement","deltaMode","deltaX","delatZ","returnValue","deltaY","wheelDelta","wheelDeltaX","element","rt","Kn","documentMode","Kt","svgNS","xmlNS","xmlnsNS","xlinkNS","evNS","getBoundingClientRectNormalized","clientWidth","clientHeight","getOrCreateViewport","childNodes","children","toISOString","createElementNS","appendChild","setupSvgAttributes","setAttributeNS","internetExplorerRedisplayInterval","refreshDefsGlobal","insertBefore","setCTM","style","transform","getEventPoint","getTouchPoint","getSvgCenterPoint","pe","Yi","enable","textContent","_createZoomIn","_createZoomReset","_createZoomOut","controlIcons","getPublicInstance","zoomIn","reset","zoomOut","disable","Qi","$e","ne","ShadowViewport","init","originalState","zoom","activeState","updateCTMCached","updateCTM","refreshRate","viewBox","cacheViewBox","processCTM","updateCTMOnNextFrame","simpleViewBoxCache","getViewBox","fit","contain","getOriginalState","getState","getZoom","getRelativeZoom","computeRelativeZoom","getPan","createSVGMatrix","isZoomDifferent","isPanDifferent","beforeZoom","updateCache","onZoom","beforePan","onPan","pendingUpdate","defs","onUpdatedCTM","Ji","shadowViewport","Yn","Zt","fe","re","es","X","SvgPanZoom","ts","viewportSelector","controlIconsEnabled","dblClickZoomEnabled","preventMouseEventsDefault","zoomScaleSensitivity","minZoom","maxZoom","customEventsHandler","eventsListenerElement","Qn","Jn","state","setBeforeZoom","setOnZoom","setBeforePan","setOnPan","setOnUpdatedCTM","lastMouseWheelEventTime","setupHandlers","eventListeners","pointerdown","handleMouseDown","touchstart","handleTouchStart","handleMouseUp","touchend","handleTouchEnd","handleMouseMove","touchmove","handleTouchMove","pointerleave","touchleave","touchcancel","svgElement","instance","haltEventListeners","hasOwnProperty","enableMouseWheelZoom","wheelListener","handleMouseWheel","disableMouseWheelZoom","log","getScreenCTM","zoomAtPoint","translate","publicZoom","computeFromRelativeZoom","publicZoomAtPoint","resetZoom","resetPan","pan","handleDblClick","firstEventCTM","stateOrigin","firstDistance","firstZoomLevel","updateBBox","panBy","resize","disableControlIcons","enableControlIcons","destroy","Te","publicInstance","enablePan","disablePan","isPanEnabled","enableZoom","disableZoom","isZoomEnabled","isControlIconsEnabled","enableDblClickZoom","disableDblClickZoom","isDblClickZoomEnabled","isMouseWheelZoomEnabled","setZoomScaleSensitivity","setMinZoom","setMaxZoom","zoomBy","zoomAtPointBy","getSizes","realZoom","ns","os","ss","fitToContents","bottom","setViewBox","getRealZoom","applyAbsoluteZoomLevel","_isPanEnabled","_internalEnablePan","_internalDisablePan","_isZoomEnabled","_internalEnableZoom","_internalDisableZoom","setPanEnabled","setZoomEnabled","rs","_internalIsPanEnabled","_internalIsZoomEnabled","as","is","ls","instanceMounted","instanceUnmounted","initialize","onSvgPanZoomMounted","onSvgPanZoomUnmounted","eo","cs","zoomLevel","me","us","ds","duration","timingFunction","Dt","transitionWhile","transitionOption","fs","isInCompatibilityModeForPath","hs","Tt","to","vs","ps","no","gs","Yt","ms","Ge","bs","ys","Bo","xn","asyncNextTick","ws","Es","W","arrow","ks","Ss","Cs","M","$","zs","updateAttributes","MutationObserver","attributeName","Boolean","observe","attributes","attributeFilter","disconnect","_t","config","baseX","baseY","$o","dominantBaseline","vertical","horizontal","updateObserver","isSummarized","getTotalLength","getPointAtLength","ft","summarizeState","individual","R","yt","io","fr","Oe","hr","vr","pr","pointerenter","click","dblclick","contextmenu","eventHandlers","P","N","D","layers","H","ie","root","nn","kt","ResizeObserver","ot","je","Pt","Mo","updateBorderBox","panToCenter","Et","xt","so","ro","ao","lo","Xe","co","uo","Qt","fo","ho","Jt","activateParams","vo","en","po","go","mo","bo","yo","wo","Eo","xo","ko","Po","outerHTML","So","tn","panTo","translateFromDomToSvgCoordinates","translateFromSvgToDomCoordinates","getAsSvg","exportAsSvgText","exportAsSvgElement","Mn","default","te","K","$slots","area","align","verticalAlign","zr","Nr","_r","install","Tr","component"],"sources":["../src/common/types.ts","../src/common/common.ts","../src/composables/container.ts","../src/common/configs.ts","../src/utils/visual.ts","../src/layouts/simple.ts","../src/common/config-defaults.ts","../src/composables/config.ts","../src/composables/id.ts","../src/utils/object.ts","../src/modules/edge/group.ts","../src/modules/vector2d/methods.ts","../src/modules/vector2d/vector2d.ts","../src/modules/vector2d/index.ts","../src/modules/calculation/line.ts","../src/modules/calculation/point.ts","../src/modules/calculation/2d.ts","../src/modules/node/node.ts","../src/utils/collection.ts","../src/modules/calculation/path.ts","../src/composables/objectState.ts","../src/utils/string.ts","../src/composables/marker.ts","../src/composables/state.ts","../src/utils/map.ts","../src/composables/mouse/core.ts","../src/composables/mouse/node.ts","../src/composables/mouse/edge.ts","../src/composables/mouse/container.ts","../src/composables/mouse/path.ts","../src/utils/download.ts","../src/utils/svg.ts","../src/composables/mouse/boxSelection.ts","../src/composables/mouse/index.ts","../node_modules/mitt/dist/mitt.mjs","../src/composables/event-emitter.ts","../node_modules/@dash14/svg-pan-zoom/src/utilities.js","../node_modules/@dash14/svg-pan-zoom/src/uniwheel.js","../node_modules/@dash14/svg-pan-zoom/src/svg-utilities.js","../node_modules/@dash14/svg-pan-zoom/src/control-icons.js","../node_modules/@dash14/svg-pan-zoom/src/shadow-viewport.js","../node_modules/@dash14/svg-pan-zoom/src/svg-pan-zoom.js","../src/modules/svg-pan-zoom-ex.ts","../src/composables/svg-pan-zoom.ts","../src/composables/zoom.ts","../src/composables/transition.ts","../src/composables/object.ts","../src/utils/props.ts","../src/composables/selection.ts","../src/composables/layout.ts","../src/modules/collection/iterate.ts","../src/modules/collection/array.ts","../src/composables/layer.ts","../src/modules/vue/nextTick.ts","../src/components/marker/VMarkerHeadArrow.vue","../src/components/marker/VMarkerHeadAngle.vue","../src/components/marker/VMarkerHead.vue","../src/components/background/VBackgroundGrid.vue","../src/components/background/VBackgroundViewport.vue","../src/components/edge/VEdgeBackground.vue","../src/components/edge/VEdgeBackgrounds.vue","../src/components/base/VLine.vue","../src/components/base/VArc.vue","../src/components/edge/VEdgeCurved.vue","../src/components/edge/VEdge.vue","../src/components/base/VShape.vue","../src/components/base/VLabelText.vue","../src/components/edge/VEdgeSummarized.vue","../src/components/edge/VEdgeOverlay.vue","../src/components/edge/VEdgeGroups.vue","../src/components/layers/VEdgesLayer.vue","../src/components/edge/VEdgeLabelPlace.vue","../src/components/edge/VEdgeLabelsPlace.vue","../src/components/edge/VEdgeLabels.vue","../src/components/node/VNodeFocusRing.vue","../src/components/layers/VFocusringLayer.vue","../src/components/node/VNode.vue","../src/components/layers/VNodesLayer.vue","../src/modules/node/label.ts","../src/components/node/VNodeLabel.vue","../src/components/layers/VNodeLabelsLayer.vue","../src/components/path/VPath.vue","../src/components/path/VPaths.vue","../src/components/VNetworkGraph.vue","../src/components/base/VStyle.vue","../src/components/edge/VEdgeLabel.vue","../src/layouts/grid.ts","../src/index.ts"],"sourcesContent":["import { RecursivePartial } from \"./common\"\n\n/* ------------------------------------------ *\n * Core types\n * ------------------------------------------ */\n\nexport interface Position {\n  x: number\n  y: number\n}\n\nexport interface LinePosition {\n  p1: Position\n  p2: Position\n}\n\nexport interface Size {\n  width: number\n  height: number\n}\n\nexport interface Rectangle {\n  pos: Position\n  size: Size\n}\n\n/** An object with a field named id */\nexport interface IdentifiedObject {\n  id: string\n}\n\n/* ------------------------------------------ *\n * Network graph elements\n * ------------------------------------------ */\n\nexport interface Node {\n  name?: string\n  // any properties\n  [x: string]: any\n}\n\nexport type Nodes = Record<string, Node>\nexport type NodeWithId = Node & IdentifiedObject\n\nexport interface Edge {\n  source: string\n  target: string\n  // any properties\n  [x: string]: any\n}\n\nexport type Edges = Record<string, Edge>\nexport type EdgeWithId = Edge & IdentifiedObject\n\nexport type LayerName = \"edges\" | \"edge-labels\" | \"focusring\" | \"nodes\" | \"node-labels\" | \"paths\"\n\nexport type LayerPosition = LayerName | \"base\" | \"grid\" | \"background\" | \"root\"\n\nexport type Layers = Record<string, LayerPosition>\n\nexport const LayerPositions: readonly LayerPosition[] = [\n  \"paths\",\n  \"node-labels\",\n  \"nodes\",\n  \"focusring\",\n  \"edge-labels\",\n  \"edges\",\n  \"base\",\n  \"grid\",\n  \"background\",\n  \"root\",\n]\n\n/* ------------------------------------------ *\n * View\n * ------------------------------------------ */\n\nexport type ViewMode = \"default\" | \"node\" | \"edge\" | \"path\" | \"box-selection\"\n\n/* ------------------------------------------ *\n * Layouts\n * ------------------------------------------ */\n\nexport interface FixablePosition extends Position {\n  fixed?: boolean\n}\n\nexport type NodePositions = Record<string, FixablePosition>\n\nexport interface Layouts {\n  nodes: NodePositions\n}\n/** for User Specified */\nexport type UserLayouts = RecursivePartial<Layouts>\n\n/* ------------------------------------------ *\n * Edge labels\n * ------------------------------------------ */\n\nexport interface EdgePosition {\n  source: Position\n  target: Position\n}\n\nexport interface EdgeLabelArea {\n  source: {\n    above: Position\n    below: Position\n  }\n  target: {\n    above: Position\n    below: Position\n  }\n}\n\n/* ------------------------------------------ *\n * Paths\n * ------------------------------------------ */\n\nexport interface Path {\n  id?: string\n  edges: string[]\n  // any properties\n  [x: string]: any\n}\n\nexport type Paths = Record<string, Path>\n\n// When specified in a list, the ID is not needed for a while to\n// keep compatibility.\n// TODO: After a while, remove `| Path[]`.\nexport type InputPaths = Record<string, Path> | Path[]\n\n// line: point | curve: [control-point, control-point, target-point] | \"arc\" | move to next point: null\nexport type PositionOrCurve = Position | Position[] | string | null\n\n/* ------------------------------------------ *\n * Events\n * ------------------------------------------ */\n\nexport type ViewEvent<T extends Event> = { event: T }\nexport type NodeEvent<T extends Event> = { node: string; event: T }\nexport type EdgeEvent<T extends Event> =\n  | { edge: string; edges: string[]; summarized: false; event: T }\n  | { edge?: undefined; edges: string[]; summarized: true; event: T }\nexport type PathEvent<T extends Event> = { path: string; event: T }\n\n// For compatibility with previous versions\nexport type NodePointerEvent = NodeEvent<PointerEvent>\nexport type EdgePointerEvent = EdgeEvent<PointerEvent>\n\nexport type Events = {\n  \"view:load\": undefined\n  \"view:unload\": undefined\n  \"view:mode\": ViewMode\n  \"view:zoom\": number\n  \"view:pan\": { x: number; y: number }\n  \"view:fit\": undefined\n  \"view:resize\": { x: number; y: number; width: number; height: number }\n  \"view:click\": ViewEvent<MouseEvent>\n  \"view:dblclick\": ViewEvent<MouseEvent>\n  \"view:contextmenu\": ViewEvent<MouseEvent>\n  \"node:click\": NodeEvent<MouseEvent>\n  \"node:dblclick\": NodeEvent<MouseEvent>\n  \"node:pointerover\": NodeEvent<PointerEvent>\n  \"node:pointerout\": NodeEvent<PointerEvent>\n  \"node:pointerup\": NodeEvent<PointerEvent>\n  \"node:pointerdown\": NodeEvent<PointerEvent>\n  \"node:contextmenu\": NodeEvent<MouseEvent>\n  \"node:dragstart\": { [name: string]: Position }\n  \"node:pointermove\": { [name: string]: Position }\n  \"node:dragend\": { [name: string]: Position }\n  \"node:select\": string[]\n  \"edge:pointerup\": EdgeEvent<PointerEvent>\n  \"edge:pointerdown\": EdgeEvent<PointerEvent>\n  \"edge:click\": EdgeEvent<MouseEvent>\n  \"edge:dblclick\": EdgeEvent<MouseEvent>\n  \"edge:pointerover\": EdgeEvent<PointerEvent>\n  \"edge:pointerout\": EdgeEvent<PointerEvent>\n  \"edge:contextmenu\": EdgeEvent<MouseEvent>\n  \"edge:select\": string[]\n  \"path:select\": string[]\n  \"path:pointerup\": PathEvent<PointerEvent>\n  \"path:pointerdown\": PathEvent<PointerEvent>\n  \"path:click\": PathEvent<MouseEvent>\n  \"path:dblclick\": PathEvent<MouseEvent>\n  \"path:pointerover\": PathEvent<PointerEvent>\n  \"path:pointerout\": PathEvent<PointerEvent>\n  \"path:contextmenu\": PathEvent<MouseEvent>\n}\n\nexport type EventHandlers = {\n  \"*\"?: <T extends keyof Events>(type: T, event: Events[T]) => void\n} & {\n  [K in keyof Events]?: (event: Events[K]) => void\n}\n\nexport type OnClickHandler = (param: NodeEvent<MouseEvent>) => void\nexport type OnDragHandler = (param: { [name: string]: Position }) => void\n\n/* ------------------------------------------ *\n * SVG area\n * ------------------------------------------ */\n\nexport interface Point {\n  x: number\n  y: number\n}\n\nexport interface Sizes {\n  width: number\n  height: number\n  viewBox: {\n    x: number\n    y: number\n    width: number\n    height: number\n  }\n}\n","import { isReactive, reactive } from \"vue\"\n\n/* ------------------------------------------ *\n * Utility\n * ------------------------------------------ */\n\nexport type RecursivePartial<T> = {\n  [P in keyof T]?: T[P] extends (infer U)[]\n    ? RecursivePartial<U>[]\n    : T[P] extends (infer U)[] | undefined\n    ? RecursivePartial<U>[]\n    : // eslint-disable-next-line @typescript-eslint/ban-types\n    T[P] extends object\n    ? RecursivePartial<T[P]>\n    : // eslint-disable-next-line @typescript-eslint/ban-types\n    T[P] extends object | undefined\n    ? RecursivePartial<T[P]>\n    : T[P]\n}\n\ndeclare class Id<T extends string> {\n  private IDENTITY: T\n}\n\nexport type Reactive<T> = Id<\"Reactive\"> & T\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function Reactive<T extends object>(value: T): Reactive<T> {\n  if (isReactive(value)) {\n    return value as Reactive<T>\n  } else {\n    return reactive(value) as Reactive<T>\n  }\n}\n\nexport interface ReadonlyRef<T> {\n  readonly value: T\n}\n\nexport function nonNull<T>(val?: T | null, name = \"Parameter\"): T {\n  if (val === undefined || val === null) {\n    throw new Error(`${name} is null`)\n  }\n  return val\n}\n","import { provide, inject, InjectionKey, Ref } from \"vue\"\nimport { SvgPanZoomInstance } from \"@/modules/svg-pan-zoom-ex\"\nimport { nonNull } from \"@/common/common\"\n\ninterface ProvideContainers {\n  container: Ref<HTMLDivElement>\n  svg: Ref<SVGElement>\n  viewport: Ref<SVGGElement>\n  svgPanZoom: Ref<SvgPanZoomInstance | undefined>\n}\n\ninterface Containers {\n  container: Ref<HTMLDivElement | undefined>\n  svg: Ref<SVGElement | undefined>\n  viewport: Ref<SVGGElement | undefined>\n  svgPanZoom: Ref<SvgPanZoomInstance | undefined>\n}\n\nconst containersKey = Symbol(\"containers\") as InjectionKey<Containers>\n\nexport function provideContainers(containers: Containers): void {\n  provide(containersKey, containers)\n}\n\nexport function useContainers(): ProvideContainers {\n  const containers = nonNull(inject(containersKey), \"containers\")\n  return {\n    container: containers.container as Ref<HTMLDivElement>,\n    svg: containers.svg as Ref<SVGElement>,\n    viewport: containers.viewport as Ref<SVGGElement>,\n    svgPanZoom: containers.svgPanZoom\n  }\n}\n","import { SvgPanZoomInstance } from \"@/modules/svg-pan-zoom-ex\"\nimport { LayoutHandler } from \"../layouts/handler\"\nimport { RecursivePartial } from \"./common\"\nimport { Edge, Edges, LayerName, Node, Path, Position } from \"./types\"\n\ntype CallableValue<V, T> = V | ((target: T) => V)\n\ntype CallableValues<V, T> = {\n  [K in keyof V]: CallableValue<V[K], T>\n}\n\nexport class Config {\n  static value<V, T>(value: CallableValue<V, T>, target: T): V {\n    return value instanceof Function ? value(target) : value\n  }\n\n  static values<V, T>(value: CallableValues<V, T>, target: T): V {\n    if (Object.values(value).filter(v => v instanceof Function).length === 0) {\n      return value as V // all config are literals\n    }\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, v instanceof Function ? v(target) : v])\n    ) as V\n  }\n}\n\n/* View configuration */\n\nexport interface GridLine {\n  color: string\n  width: number\n  dasharray?: string | number\n}\n\nexport interface GridConfig {\n  visible: boolean\n  interval: number\n  thickIncrements: number | false\n  line: GridLine\n  thick: GridLine\n}\n\nexport interface BasicShapeStyle {\n  strokeWidth: number\n  strokeColor?: string\n  strokeDasharray?: string | number\n  color: string\n}\n\nexport interface ViewConfig {\n  scalingObjects: boolean\n  panEnabled: boolean\n  zoomEnabled: boolean\n  minZoomLevel: number\n  maxZoomLevel: number\n  doubleClickZoomEnabled: boolean\n  mouseWheelZoomEnabled: boolean\n  boxSelectionEnabled: boolean\n  fit?: boolean // Deprecated\n  autoPanAndZoomOnLoad: false | \"center-zero\" | \"center-content\" | \"fit-content\"\n  autoPanOnResize: boolean\n  layoutHandler: LayoutHandler\n  onSvgPanZoomInitialized?: (instance: SvgPanZoomInstance) => void\n  grid: GridConfig\n  selection: {\n    box: BasicShapeStyle\n    detector: (event: KeyboardEvent) => boolean\n  }\n  builtInLayerOrder: Readonly<LayerName[]>\n  onBeforeInitialDisplay?: (() => Promise<any>) | (() => any)\n}\n\n/* Shape style */\n\nexport type ShapeStyleBase = BasicShapeStyle\n\nexport type ShapeType = \"circle\" | \"rect\"\n\ninterface CircleShape extends ShapeStyleBase {\n  radius: number\n}\n\ninterface RectangleShape extends ShapeStyleBase {\n  width: number\n  height: number\n  borderRadius: number\n}\n\n// `Shape` is an object whose fields can change depending on\n// the type value.\n// Normally, Union Types would be used, but in order to minimize\n// the use of type guards when users build and use the configuration,\n// we define it as an object that contains all fields.\n\ntype ShapeBase<T extends ShapeType = ShapeType> = {\n  type: T\n}\n\nexport type ShapeStyle = ShapeBase & CircleShape & RectangleShape\nexport type CircleShapeStyle = ShapeBase<\"circle\"> & CircleShape\nexport type RectangleShapeStyle = ShapeBase<\"rect\"> & RectangleShape\nexport type AnyShapeStyle = CircleShapeStyle | RectangleShapeStyle\n\n/* Label style */\n\ninterface Padding {\n  vertical: number\n  horizontal: number\n}\nexport interface LabelBackgroundStyle {\n  visible: boolean\n  color?: string\n  padding?: number | Padding\n  borderRadius?: number\n}\n\nexport interface LabelStyle {\n  fontFamily?: string\n  fontSize: number\n  color: string\n  background?: LabelBackgroundStyle\n  lineHeight: number\n}\n\n/* Z-Order config */\n\nexport interface ZOrderConfig<T> {\n  enabled: boolean\n  zIndex: CallableValue<number, T>\n  bringToFrontOnHover: boolean\n  bringToFrontOnSelected: boolean\n}\n\n/* Object common config */\n\nexport interface ObjectConfigs<O> {\n  selectable: CallableValue<boolean, O> | number\n  zOrder: ZOrderConfig<O>\n}\n\n/* Node style */\n\nexport enum NodeLabelDirection {\n  CENTER = \"center\",\n  NORTH = \"north\",\n  NORTH_EAST = \"north-east\",\n  EAST = \"east\",\n  SOUTH_EAST = \"south-east\",\n  SOUTH = \"south\",\n  SOUTH_WEST = \"south-west\",\n  WEST = \"west\",\n  NORTH_WEST = \"north-west\",\n}\n\nexport type NodeLabelDirectionType =\n  | \"center\"\n  | \"north\"\n  | \"north-east\"\n  | \"east\"\n  | \"south-east\"\n  | \"south\"\n  | \"south-west\"\n  | \"west\"\n  | \"north-west\"\n\nexport interface OppositeNode {\n  nodeId: string\n  pos: Position\n}\n\n// { edgeId: { nodeId, pos } }\nexport type OppositeNodes = Record<string, OppositeNode>\n\nexport interface NodeLabelDirectionHandlerParams {\n  nodeId: string\n  pos: Position\n  oppositeNodes: OppositeNodes\n}\n\nexport type NodeLabelDirectionAutoAdjustmentHandler = (\n  params: NodeLabelDirectionHandlerParams\n) => NodeLabelDirectionType | null\n\nexport interface NodeLabelStyle extends LabelStyle {\n  visible: boolean\n  margin: number\n  direction: NodeLabelDirectionType\n  directionAutoAdjustment: boolean | NodeLabelDirectionAutoAdjustmentHandler\n  text: string\n  handleNodeEvents: boolean\n}\n\nexport interface NodeFocusRingStyle {\n  visible: boolean\n  width: number\n  padding: number\n  color: string\n  dasharray?: string | number\n}\n\nexport interface NodeConfig<N extends Node = Node> {\n  normal: CallableValues<ShapeStyle, N>\n  hover?: CallableValues<ShapeStyle, N>\n  selected?: CallableValues<ShapeStyle, N>\n  draggable: CallableValue<boolean, N>\n  selectable: CallableValue<boolean, N> | number\n  label: CallableValues<NodeLabelStyle, N>\n  focusring: NodeFocusRingStyle\n  zOrder: ZOrderConfig<N>\n  transition?: string\n}\n\n/* Edge style */\n\nexport interface StrokeStyle {\n  width: number\n  color: string\n  dasharray?: string | number\n  linecap?: \"butt\" | \"round\" | \"square\"\n  animate: boolean\n  animationSpeed: number\n}\n\nexport interface EdgeLabelStyle extends LabelStyle {\n  margin: number\n  padding: number\n}\n\nexport type EdgeHeadType = \"none\" | \"arrow\" | \"angle\" | \"circle\" | \"custom\"\nexport type MarkerUnits = \"strokeWidth\" | \"userSpaceOnUse\"\n\nexport interface MarkerStyle {\n  type: EdgeHeadType\n  width: number\n  height: number\n  margin: number\n  offset: number\n  units: MarkerUnits\n  color: string | null\n  customId?: string\n}\n\nexport type EdgeType = \"straight\" | \"curve\"\n\n// Orientation to be considered when keeping multiple edge alignments.\n//   \"clock\": Keep the forward/backward when viewed as a clock.\n//   \"vertical\": Keep the vertical alignment.\n//   \"horizontal\": Keep the horizontal alignment.\nexport type EdgeKeepOrderType = \"clock\" | \"vertical\" | \"horizontal\"\n\nexport interface SelfLoopEdgeStyle {\n  radius: number\n  offset: number\n  angle: number\n  isClockwise: boolean\n}\n\nexport interface EdgeConfig<E extends Edge = Edge> {\n  normal: CallableValues<StrokeStyle, E>\n  hover?: CallableValues<StrokeStyle, E>\n  selected: CallableValues<StrokeStyle, E>\n  selectable: CallableValue<boolean, E> | number\n  gap: number | ((edges: Edges, configs: Configs) => number)\n  type: EdgeType\n  marker: {\n    source: CallableValues<MarkerStyle, [E, StrokeStyle]>\n    target: CallableValues<MarkerStyle, [E, StrokeStyle]>\n  }\n  margin: number | null\n  summarize: boolean | ((edges: Edges, configs: Configs) => boolean | null)\n  summarized: {\n    label: CallableValues<LabelStyle, Record<string, E>>\n    shape: CallableValues<ShapeStyle, Record<string, E>>\n    stroke: CallableValues<StrokeStyle, Record<string, E>>\n  }\n  selfLoop: CallableValues<SelfLoopEdgeStyle, E>\n  keepOrder: EdgeKeepOrderType\n  label: CallableValues<EdgeLabelStyle, E>\n  zOrder: ZOrderConfig<E>\n}\n\n/* Path config */\nexport interface PathStrokeStyle extends StrokeStyle {\n  linejoin: \"miter\" | \"round\" | \"bevel\"\n}\n\nexport type PathEndType = \"centerOfNode\" | \"edgeOfNode\"\n\nexport interface PathConfig<P extends Path = Path> {\n  visible: boolean\n  clickable: CallableValue<boolean, P>\n  hoverable: CallableValue<boolean, P>\n  curveInNode: boolean\n  end: PathEndType\n  margin: CallableValue<number, P>\n\n  // @Deprecated\n  path: CallableValues<PathStrokeStyle, P>\n\n  normal: CallableValues<PathStrokeStyle, P>\n  hover?: CallableValues<PathStrokeStyle, P>\n  selected: CallableValues<PathStrokeStyle, P>\n\n  selectable: CallableValue<boolean, P> | number\n  zOrder: ZOrderConfig<P>\n  transition?: string\n}\n\n/* Configuration */\n\nexport interface Configs<N extends Node = Node, E extends Edge = Edge, P extends Path = Path> {\n  view: ViewConfig\n  node: NodeConfig<N>\n  edge: EdgeConfig<E>\n  path: PathConfig<P>\n}\n\n/** For specification by the user */\nexport type UserConfigs<\n  N extends Node = Node,\n  E extends Edge = Edge,\n  P extends Path = Path\n> = RecursivePartial<Configs<N, E, P>>\n\n/** Make a config with self object */\nexport function withSelf<T extends { [name: string]: any }>(callback: (self: T) => T): T {\n  const self = {} as T\n  return Object.assign(self, callback(self))\n}\n\n/** @deprecated */\nexport function configsWithType<\n  N extends Node = Node,\n  E extends Edge = Edge,\n  P extends Path = Path,\n  U extends UserConfigs<N, E, P> = UserConfigs<N, E, P>\n>(configs: U): U & UserConfigs<N, E, P> {\n  return configs\n}\n\n/** Define configurations */\nexport function defineConfigs<\n  N extends Node = Node,\n  E extends Edge = Edge,\n  P extends Path = Path,\n  U extends UserConfigs<N, E, P> = UserConfigs<N, E, P>\n>(configs: U): U & UserConfigs<N, E, P> {\n  return configs\n}\n","import { Node, Position, Size } from \"@/common/types\"\nimport { Config, NodeConfig, StrokeStyle } from \"@/common/configs\"\n\nexport function getNodeSize(node: Node, style: NodeConfig, scale: number): Size {\n  const shape = Config.values(style.normal, node)\n  if (shape.type == \"circle\") {\n    return {\n      width: shape.radius * 2 * scale,\n      height: shape.radius * 2 * scale,\n    }\n  } else {\n    return {\n      width: shape.width * scale,\n      height: shape.height * scale,\n    }\n  }\n}\n\nexport function areNodesCollision(\n  nodePos: Position,\n  nodeSize: Size,\n  targetNodePos: Position,\n  targetNodeSize: Size\n): boolean {\n  // x\n  const distanceX = Math.abs(nodePos.x - targetNodePos.x)\n  const collisionX = distanceX < nodeSize.width / 2 + targetNodeSize.width / 2\n\n  // y\n  const distanceY = Math.abs(nodePos.y - targetNodePos.y)\n  const collisionY = distanceY < nodeSize.height / 2 + targetNodeSize.height / 2\n  return collisionX && collisionY\n}\n\nexport function applyScaleToDasharray(dasharray: number | string | undefined, scale: number) {\n  let result: number | string = 0\n  if (scale === 1 || dasharray === undefined || dasharray === \"none\") {\n    result = dasharray ?? 0\n  } else if (typeof dasharray === \"string\") {\n    result = dasharray\n      .split(/\\s+/)\n      .map(v => parseInt(v) * scale)\n      .filter(v => !isNaN(v))\n      .join(\" \")\n  } else {\n    result = dasharray * scale\n  }\n  return result && result !== \"0\" ? result : undefined\n}\n\nexport function getDasharrayUnit(dasharray: number | string | undefined) {\n  let result: number | string = 0\n  if (dasharray === undefined || dasharray === \"none\") {\n    result = 0\n  } else if (typeof dasharray === \"string\") {\n    const array = dasharray\n      .split(/\\s+/)\n      .map(v => parseInt(v))\n      .filter(v => !isNaN(v))\n    if (array.length % 2 === 0) {\n      // ex: 1 2 -> -  -  -  - ...\n      result = array.reduce((s, n) => s + n, 0)\n    } else {\n      // ex: 1 2 3 -> -  --- --   -  --- ...\n      result = array.reduce((s, n) => s + n, 0) * 2\n    }\n  } else {\n    result = dasharray * 2 // 2 <- border and space\n  }\n  return result\n}\n\nexport function getAnimationSpeed(key: string, config: StrokeStyle, scale: number): Record<string, number|undefined> {\n  const speed = config.animate\n    ? getDasharrayUnit(config.dasharray) * config.animationSpeed * scale\n    : undefined\n  return {[key]: speed}\n}\n","import { Ref, toRef, watch } from \"vue\"\nimport { isEqual, round } from \"lodash-es\"\nimport { NodePositions, OnDragHandler, Position } from \"@/common/types\"\nimport { getNodeSize, areNodesCollision } from \"@/utils/visual\"\nimport { LayoutActivateParameters, LayoutHandler } from \"./handler\"\n\nconst NEW_NODE_POSITION_MARGIN = 20\n\nexport class SimpleLayout implements LayoutHandler {\n  private onDeactivate?: () => void\n\n  activate(parameters: LayoutActivateParameters): void {\n    const { nodePositions, nodes, configs, emitter, scale, svgPanZoom } = parameters\n    const onDrag: OnDragHandler = positions => {\n      for (const [id, pos] of Object.entries(positions)) {\n        const layout = this.getOrCreateNodePosition(nodePositions, id)\n        this.setNodePosition(layout, pos)\n      }\n    }\n\n    const setNewNodePositions = (nodeIds: string[]) => {\n      // decide new node's position\n      const newNodes = nodeIds.filter(n => !(n in nodePositions.value))\n      const area = svgPanZoom.getViewArea()\n      const s = scale.value\n      for (const nodeId of newNodes) {\n        const node = nodes.value[nodeId]\n        const nodeSize = getNodeSize(node, configs.node, s)\n        const candidate = { ...area.center }\n        for (;;) {\n          let collision = false\n          for (const [id, pos] of Object.entries(nodePositions.value)) {\n            if (nodeId === id) continue\n            const targetNode = nodes.value[id]\n            if (!targetNode) continue\n            const targetNodeSize = getNodeSize(targetNode, configs.node, s)\n            collision = areNodesCollision(candidate, nodeSize, pos, targetNodeSize)\n            if (collision) {\n              break\n            }\n          }\n          if (collision) {\n            // Slide the width of one node + margin in the horizontal direction.\n            // If it reaches the edge of the display area, it moves downward.\n            candidate.x += nodeSize.width + NEW_NODE_POSITION_MARGIN * s\n            if (candidate.x + nodeSize.width / 2 > area.box.right) {\n              candidate.x = area.center.x\n              candidate.y += nodeSize.height + NEW_NODE_POSITION_MARGIN * s\n            }\n          } else {\n            break\n          }\n        }\n        const layout = this.getOrCreateNodePosition(nodePositions, nodeId)\n        this.setNodePosition(layout, candidate)\n      }\n    }\n\n    setNewNodePositions(Object.keys(nodes.value))\n    const stopNodeWatch = watch(\n      () => isEqual(new Set(Object.keys(nodes.value)), new Set(Object.keys(nodePositions.value))),\n      (equality: boolean) => {\n        if (!equality) setNewNodePositions(Object.keys(nodes.value))\n      }\n    )\n\n    emitter.on(\"node:dragstart\", onDrag)\n    emitter.on(\"node:pointermove\", onDrag)\n    emitter.on(\"node:dragend\", onDrag)\n\n    this.onDeactivate = () => {\n      stopNodeWatch()\n      emitter.off(\"node:dragstart\", onDrag)\n      emitter.off(\"node:pointermove\", onDrag)\n      emitter.off(\"node:dragend\", onDrag)\n    }\n  }\n\n  deactivate(): void {\n    if (this.onDeactivate) {\n      this.onDeactivate()\n    }\n  }\n\n  protected setNodePosition(nodeLayout: Ref<Position>, pos: Position) {\n    nodeLayout.value.x = round(pos.x, 3)\n    nodeLayout.value.y = round(pos.y, 3)\n  }\n\n  private getOrCreateNodePosition(nodePositions: Ref<NodePositions>, node: string) {\n    const layout = toRef(nodePositions.value, node)\n    if (!layout.value) {\n      layout.value = { x: 0, y: 0 }\n    }\n    return layout\n  }\n}\n","import { merge } from \"lodash-es\"\nimport { reactive } from \"vue\"\nimport { SimpleLayout } from \"../layouts/simple\"\nimport { Config, Configs, NodeLabelDirection, UserConfigs, withSelf } from \"./configs\"\nimport { Edge, Edges, Node, Path } from \"./types\"\n\n/**\n * Get all default configs.\n * @returns configs\n */\nexport function getConfigDefaults(): Configs {\n  return {\n    view: {\n      scalingObjects: false,\n      panEnabled: true,\n      zoomEnabled: true,\n      minZoomLevel: 0.1,\n      maxZoomLevel: 64,\n      doubleClickZoomEnabled: true,\n      mouseWheelZoomEnabled: true,\n      boxSelectionEnabled: false,\n      autoPanAndZoomOnLoad: \"center-content\",\n      autoPanOnResize: true,\n      layoutHandler: new SimpleLayout(),\n      onSvgPanZoomInitialized: undefined,\n      grid: {\n        visible: false,\n        interval: 10,\n        thickIncrements: 5,\n        line: {\n          color: \"#e0e0e0\",\n          width: 1,\n          dasharray: 1,\n        },\n        thick: {\n          color: \"#cccccc\",\n          width: 1,\n          dasharray: 0,\n        },\n      },\n      selection: {\n        box: {\n          color: \"#0000ff20\",\n          strokeWidth: 1,\n          strokeColor: \"#aaaaff\",\n          strokeDasharray: 0,\n        },\n        detector: (event: KeyboardEvent) => {\n          const detect = /Mac OS/.test(navigator.userAgent) ? event.metaKey : event.ctrlKey\n          return event.type === \"keydown\" ? detect : !detect\n        },\n      },\n      builtInLayerOrder: [],\n      onBeforeInitialDisplay: undefined,\n    },\n    node: withSelf(self => ({\n      normal: {\n        type: \"circle\",\n        radius: 16,\n        // for rect -->\n        width: 32,\n        height: 32,\n        borderRadius: 4,\n        // <-- for rect\n        color: \"#4466cc\",\n        strokeWidth: 0,\n        strokeColor: \"#000000\",\n        strokeDasharray: 0,\n      },\n      hover: {\n        type: node => Config.value(self.normal.type, node) as any,\n        radius: node => (Config.value(self.normal.radius, node) ?? 0) + 2,\n        width: node => (Config.value(self.normal.width, node) ?? 0) + 2,\n        height: node => (Config.value(self.normal.height, node) ?? 0) + 2,\n        borderRadius: node => Config.value(self.normal.borderRadius, node) ?? 0,\n        strokeWidth: node => Config.value(self.normal.strokeWidth, node),\n        strokeColor: node => Config.value(self.normal.strokeColor, node),\n        strokeDasharray: node => Config.value(self.normal.strokeDasharray, node),\n        color: \"#3355bb\",\n      },\n      selected: undefined,\n      draggable: true,\n      selectable: false,\n      label: {\n        visible: true,\n        fontFamily: undefined,\n        fontSize: 11,\n        lineHeight: 1.1,\n        color: \"#000000\",\n        background: undefined,\n        // background: {\n        //   visible: true,\n        //   color: \"#ffffff\",\n        //   padding: {\n        //     vertical: 1,\n        //     horizontal: 4,\n        //   },\n        //   borderRadius: 2\n        // },\n        margin: 4,\n        direction: NodeLabelDirection.SOUTH,\n        directionAutoAdjustment: false,\n        text: \"name\",\n        handleNodeEvents: true,\n      },\n      focusring: {\n        visible: true,\n        width: 4,\n        padding: 3,\n        color: \"#eebb00\",\n      },\n      zOrder: {\n        enabled: false,\n        zIndex: 0,\n        bringToFrontOnHover: true,\n        bringToFrontOnSelected: true,\n      },\n      transition: undefined,\n    })),\n    edge: withSelf(self => ({\n      normal: {\n        width: 2,\n        color: \"#4466cc\",\n        dasharray: 0,\n        linecap: \"butt\",\n        animate: false,\n        animationSpeed: 50,\n      },\n      hover: {\n        width: edge => Config.value(self.normal.width, edge) + 1,\n        color: \"#3355bb\",\n        dasharray: edge => Config.value(self.normal.dasharray, edge),\n        linecap: edge => Config.value(self.normal.linecap, edge),\n        animate: edge => Config.value(self.normal.animate, edge),\n        animationSpeed: edge => Config.value(self.normal.animationSpeed, edge),\n      },\n      selected: {\n        width: edge => Config.value(self.normal.width, edge) + 1,\n        color: \"#dd8800\",\n        dasharray: edge => {\n          const w = Config.value(self.normal.width, edge)\n          return `${w * 1.5} ${w * 2}`\n        },\n        linecap: edge => Config.value(self.normal.linecap, edge),\n        animate: edge => Config.value(self.normal.animate, edge),\n        animationSpeed: edge => Config.value(self.normal.animationSpeed, edge),\n      },\n      selectable: false,\n      gap: 3,\n      type: \"straight\",\n      marker: {\n        source: {\n          type: \"none\",\n          width: 5,\n          height: 5,\n          margin: -1,\n          offset: 0,\n          units: \"strokeWidth\",\n          color: null,\n        },\n        target: {\n          type: \"none\",\n          width: 5,\n          height: 5,\n          margin: -1,\n          offset: 0,\n          units: \"strokeWidth\",\n          color: null,\n        },\n      },\n      margin: null,\n      summarize: (_edges: Edges, configs: Configs) => {\n        return configs.edge.type == \"curve\" ? false : null\n      },\n      summarized: {\n        label: {\n          fontSize: 10,\n          lineHeight: 1,\n          color: \"#4466cc\",\n        },\n        shape: {\n          type: \"rect\",\n          // for circle -->\n          radius: 6,\n          // <-- for circle\n          width: 12,\n          height: 12,\n          borderRadius: 3,\n          color: \"#ffffff\",\n          strokeWidth: 1,\n          strokeColor: \"#4466cc\",\n          strokeDasharray: undefined,\n        },\n        stroke: {\n          width: 5,\n          color: \"#4466cc\",\n          dasharray: undefined,\n          linecap: undefined,\n          animate: false,\n          animationSpeed: 50,\n        },\n      },\n      selfLoop: {\n        radius: 12,\n        isClockwise: true,\n        offset: 10,\n        angle: 270,\n      },\n      keepOrder: \"clock\",\n      label: {\n        fontFamily: undefined,\n        fontSize: 11,\n        lineHeight: 1.1,\n        color: \"#000000\",\n        background: undefined,\n        // background: {\n        //   visible: true,\n        //   color: \"#ffffff\",\n        //   padding: {\n        //     vertical: 1,\n        //     horizontal: 4,\n        //   },\n        //   borderRadius: 2\n        // },\n        margin: 4,\n        padding: 4,\n      },\n      zOrder: {\n        enabled: false,\n        zIndex: 0,\n        bringToFrontOnHover: true,\n        bringToFrontOnSelected: true,\n      },\n    })),\n    path: withSelf(self => ({\n      visible: false,\n      clickable: false,\n      hoverable: false,\n      curveInNode: false,\n      end: \"centerOfNode\",\n      margin: 0,\n      // @Deprecated\n      path: reactive({\n        width: 6,\n        color: p => {\n          const list = [\n            \"#d5000088\",\n            \"#c5116288\",\n            \"#aa00ff88\",\n            \"#6200ea88\",\n            \"#304ffe88\",\n            \"#2962ff88\",\n            \"#0091ea88\",\n            \"#00b8d488\",\n            \"#00bfa588\",\n            \"#00c85388\",\n            \"#64dd1788\",\n            \"#aeea0088\",\n            \"#ffd60088\",\n            \"#ffab0088\",\n            \"#ff6d0088\",\n            \"#dd2c0088\",\n          ]\n          const hash = p.edges\n            .map(s =>\n              s.split(\"\").reduce((a, b) => {\n                a = (a << 5) - a + b.charCodeAt(0)\n                return a & a\n              }, 0)\n            )\n            .reduce((a, b) => a + b, 0)\n          return list[Math.abs(hash) % list.length]\n        },\n        dasharray: undefined,\n        linecap: \"round\",\n        linejoin: \"round\",\n        animate: false,\n        animationSpeed: 50,\n      }),\n      normal: {\n        width: path => Config.value(self.path.width, path),\n        color: path => Config.value(self.path.color, path),\n        dasharray: path => Config.value(self.path.dasharray, path),\n        linecap: path => Config.value(self.path.linecap, path),\n        linejoin: path => Config.value(self.path.linejoin, path),\n        animate: path => Config.value(self.path.animate, path),\n        animationSpeed: path => Config.value(self.path.animationSpeed, path),\n      },\n      hover: {\n        width: path => Config.value(self.normal.width, path) + 2,\n        color: path => Config.value(self.normal.color, path),\n        dasharray: path => Config.value(self.normal.dasharray, path),\n        linecap: path => Config.value(self.normal.linecap, path),\n        linejoin: path => Config.value(self.normal.linejoin, path),\n        animate: path => Config.value(self.normal.animate, path),\n        animationSpeed: path => Config.value(self.normal.animationSpeed, path),\n      },\n      selected: {\n        width: path => Config.value(self.normal.width, path) + 2,\n        color: path => Config.value(self.normal.color, path),\n        dasharray: \"6 12\",\n        linecap: path => Config.value(self.normal.linecap, path),\n        linejoin: path => Config.value(self.normal.linejoin, path),\n        animate: path => Config.value(self.normal.animate, path),\n        animationSpeed: path => Config.value(self.normal.animationSpeed, path),\n      },\n      selectable: false,\n      zOrder: {\n        enabled: false,\n        zIndex: 0,\n        bringToFrontOnHover: true,\n        bringToFrontOnSelected: true,\n      },\n      transition: undefined,\n    })),\n  }\n}\n\nexport function getFullConfigs<N extends Node = Node, E extends Edge = Edge, P extends Path = Path>(\n  config?: UserConfigs<N, E, P>\n): Configs {\n  const configs = getConfigDefaults()\n  if (config) {\n    merge(configs, config)\n  }\n  return configs\n}\n","import { inject, InjectionKey, provide, reactive, Ref, watch } from \"vue\"\nimport { isPlainObject, merge, mergeWith } from \"lodash-es\"\nimport { nonNull } from \"@/common/common\"\nimport { Configs, UserConfigs } from \"@/common/configs\"\nimport { getConfigDefaults } from \"@/common/config-defaults\"\n\nconst injectionKey = Symbol(\"style\") as InjectionKey<Configs>\n\nfunction merger(destination: any, source: any) {\n  if (isPlainObject(destination)) {\n    return merge(destination, source)\n  } else {\n    return source // overwrite\n  }\n}\n\nexport function provideConfigs(configs: Ref<UserConfigs>) {\n  const results: Configs = reactive(getConfigDefaults())\n  const styleKeys = Object.keys(results) as (keyof Configs)[]\n  for (const key of styleKeys) {\n    watch(() => configs.value[key], () => {\n      mergeWith(results[key], configs.value[key] || {}, merger)\n    }, { immediate: true, deep: true })\n  }\n\n  provide(injectionKey, results)\n  return results\n}\n\nfunction injectConfig<T extends keyof Configs>(key: T) {\n  return nonNull(inject(injectionKey), `Configs(${key})`)[key]\n}\n\nexport function useAllConfigs() {\n  return nonNull(inject(injectionKey))\n}\n\nexport function useViewConfig() {\n  return injectConfig(\"view\")\n}\n\nexport function useNodeConfig() {\n  return injectConfig(\"node\")\n}\n\nexport function useEdgeConfig() {\n  return injectConfig(\"edge\")\n}\n\nexport function usePathConfig() {\n  return injectConfig(\"path\")\n}\n","let nextId = 1\n\n/** Generate unique ID in v-network-graph instances */\nexport function useId(): number {\n  return nextId++\n}\n","import { isEqual } from \"lodash-es\"\n\nexport function keyOf<T extends object>(obj: T): (keyof T)[] {\n  return Object.keys(obj) as Array<keyof T>\n}\n\nexport function entriesOf<T extends object, K extends keyof T>(obj: T): [K, T[K]][] {\n  return Object.entries(obj) as [K, T[K]][]\n}\n\nexport function updateObjectDiff<T extends Record<string, any>>(target: T, from: T) {\n  const keys = new Set<keyof T>(Object.keys(target))\n  entriesOf(from).forEach(([key, value]) => {\n    if (!isEqual(target[key], value)) {\n      target[key] = value\n    }\n    keys.delete(key)\n  })\n  keys.forEach(k => delete target[k])\n}\n\nexport function isPromise(obj: any): boolean {\n  return obj instanceof Promise || (obj && typeof obj.then === 'function')\n}\n","import { Ref, watchEffect } from \"vue\"\nimport { Reactive } from \"@/common/common\"\nimport { Edge, Edges, LinePosition, Nodes, Position } from \"@/common/types\"\nimport { Config, Configs, EdgeKeepOrderType } from \"@/common/configs\"\nimport { EdgeGroup, EdgeGroupStates, EdgeLayoutPoint } from \"@/models/edge\"\nimport { updateObjectDiff } from \"@/utils/object\"\n\n// -----------------------------------------------------------------------\n// Type definition\n// -----------------------------------------------------------------------\n\n// -----------------------------------------------------------------------\n// Exported functions\n// -----------------------------------------------------------------------\n\n/**\n * Make the states for edge group.\n * @param nodes nodes\n * @param edges edges\n * @param configs configs\n * @returns the states object for edge group\n */\nexport function makeEdgeGroupStates(\n  nodes: Ref<Nodes>,\n  edges: Ref<Edges>,\n  configs: Readonly<Configs>\n): Reactive<EdgeGroupStates> {\n  // Calculate position map\n  const state = Reactive<EdgeGroupStates>({\n    edgeLayoutPoints: {},\n    edgeGroups: {},\n    summarizedEdges: {},\n  })\n\n  watchEffect(() => {\n    const { edgeLayoutPoints, edgeGroups } = calculateEdgeGroupAndPositions(\n      configs,\n      nodes.value,\n      edges.value\n    )\n    updateObjectDiff(state.edgeLayoutPoints, edgeLayoutPoints)\n    updateObjectDiff(state.edgeGroups, edgeGroups)\n  })\n\n  // calc layout and check summarize\n  watchEffect(() => {\n    const summarizedEdges: Record<string, true> = {}\n    for (const [id, { edges, groupWidth }] of Object.entries(state.edgeGroups)) {\n      let summarize = false\n      if (groupWidth == 0) {\n        summarize = false\n      } else if (configs.edge.summarize instanceof Function) {\n        const s = configs.edge.summarize(edges, configs)\n        if (s === null) {\n          summarize = defaultCheckSummarize(nodes.value, edges, configs, groupWidth)\n        } else {\n          summarize = s\n        }\n      } else if (configs.edge.summarize) {\n        summarize = defaultCheckSummarize(nodes.value, edges, configs, groupWidth)\n      } else {\n        summarize = false\n      }\n      state.edgeGroups[id].summarize = summarize\n      if (summarize) {\n        Object.keys(edges).forEach(id => (summarizedEdges[id] = true))\n      }\n    }\n    updateObjectDiff(state.summarizedEdges, summarizedEdges)\n  })\n\n  return state\n}\n\n/**\n * Calculate the edge position by applying a shift.\n * @param p relative layout information of edges\n * @param isSummarized summarize or not\n * @param source position of source node\n * @param target position of target node\n * @param scale scale factor\n * @param keepOrder edge positional type config\n * @returns the edge position by applying a shift\n */\nexport function calculateEdgeShiftedPosition(\n  p: EdgeLayoutPoint | undefined,\n  isSummarized: boolean,\n  source: Position,\n  target: Position,\n  scale: number,\n  keepOrder: EdgeKeepOrderType\n): LinePosition {\n  if (!p) {\n    return { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } } // sanitized\n  }\n  if (isSummarized) {\n    // summarize\n    return calculateEdgePositionInner(p.edge, source, target, scale, 0, 0, keepOrder)\n  } else {\n    return calculateEdgePositionInner(\n      p.edge,\n      source,\n      target,\n      scale,\n      p.groupWidth,\n      p.pointInGroup,\n      keepOrder\n    )\n  }\n}\n\n// -----------------------------------------------------------------------\n// Private functions\n// -----------------------------------------------------------------------\n\nfunction calculateEdgeGroupAndPositions(configs: Configs, nodes: Nodes, edges: Edges) {\n  const edgeLayoutPoints: Record<string, EdgeLayoutPoint> = {}\n  const edgeGroups: Record<string, EdgeGroup> = {}\n\n  // edges in nodes\n  // const edgesInNodes: Record<string, EdgesInNodes> = {}\n\n  // edge groups between same nodes\n  const map: Record<string, Edges> = {}\n\n  for (const [id, edge] of Object.entries(edges)) {\n    if (!(edge.source in nodes && edge.target in nodes)) {\n      // reject if no node ID is found on the nodes\n      continue\n    }\n    const key = [edge.source, edge.target].sort().join(\"<=>\")\n    const values = map[key] || {}\n    values[id] = edge\n    map[key] = values\n\n    // edgesInNodes[edge.source] ||= {}\n    // edgesInNodes[edge.target] ||= {}\n    // edgesInNodes[edge.source][id] = { opposite: edge.target }\n    // edgesInNodes[edge.target][id] = { opposite: edge.source }\n  }\n\n  // Calculate the following:\n  // - the starting point of each line\n  // - the width between the centers of the lines at both ends\n  // *Note*: the drawing position of the line is the center of the line.\n  const calcGap =\n    configs.edge.gap instanceof Function\n      ? configs.edge.gap\n      : (_e: Edges, _c: Configs) => configs.edge.gap as number\n  for (const [key, edges] of Object.entries(map)) {\n    const edgeLen = Object.keys(edges).length\n    if (edgeLen == 0) continue\n\n    const gap = calcGap(edges, configs)\n    const [edgeId, edge] = Object.entries(edges)[0]\n    if (edgeLen === 1) {\n      edgeLayoutPoints[edgeId] = { edge, pointInGroup: 0, groupWidth: 0 }\n      edgeGroups[key] = { edges, groupWidth: 0, summarize: false }\n    } else {\n      let pointInGroup = 0\n      const lineHalfWidths = Object.entries(edges).map(([id, edge]) => {\n        let width = Config.value(configs.edge.normal.width, edge)\n        if (isNaN(+width)) {\n          console.warn(\n            \"[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]\",\n            id,\n            width\n          )\n          width = 1\n        }\n        return width / 2\n      })\n      const points = Object.entries(edges).map(([edgeId, edge], i) => {\n        if (i > 0) {\n          pointInGroup += lineHalfWidths[i - 1] + gap + lineHalfWidths[i]\n        }\n        return [edgeId, edge, pointInGroup] as [string, Edge, number]\n      })\n      const groupWidth = pointInGroup\n      points.forEach(([edgeId, edge, pointInGroup]) => {\n        edgeLayoutPoints[edgeId] = { edge, pointInGroup, groupWidth }\n      })\n      edgeGroups[key] = { edges, groupWidth, summarize: false }\n    }\n  }\n\n  return { edgeLayoutPoints, edgeGroups }\n}\n\nfunction defaultCheckSummarize(nodes: Nodes, edges: Edges, configs: Configs, width: number) {\n  // aggregate if the edge width and gap width exceed the size of the node\n  const edgeCount = Object.entries(edges).length\n  if (edgeCount === 1) return false\n\n  // const width =\n  //   Object.values(edges)\n  //     .map(e => Config.value(configs.edge.normal.width, e))\n  //     .reduce((sum, v) => sum + v, 0) +\n  //   configs.edge.gap * (edgeCount - 1)\n\n  const minWidth = Math.min(\n    ...Object.values(edges)\n      .flatMap(e => [nodes[e.source], nodes[e.target]])\n      .filter(v => v)\n      .map(node => {\n        const shape = Config.values(configs.node.normal, node)\n        if (shape.type === \"circle\") {\n          return shape.radius * 2\n        } else {\n          return Math.min(shape.width, shape.height)\n        }\n      })\n  )\n  return width > minWidth\n}\n\nfunction calculateEdgePositionInner(\n  edge: Edge,\n  source: Position | undefined,\n  target: Position | undefined,\n  scale: number,\n  groupWidth: number,\n  pointInGroup: number,\n  keepOrder: EdgeKeepOrderType\n): LinePosition {\n  let x1, y1, x2, y2\n  if (edge.source < edge.target) {\n    ;[x1, y1, x2, y2] = calculateLinePosition(\n      source?.x ?? 0,\n      source?.y ?? 0,\n      target?.x ?? 0,\n      target?.y ?? 0,\n      scale,\n      groupWidth,\n      pointInGroup,\n      keepOrder\n    )\n  } else {\n    ;[x2, y2, x1, y1] = calculateLinePosition(\n      target?.x ?? 0,\n      target?.y ?? 0,\n      source?.x ?? 0,\n      source?.y ?? 0,\n      scale,\n      groupWidth,\n      pointInGroup,\n      keepOrder\n    )\n  }\n  return { p1: { x: x1, y: y1 }, p2: { x: x2, y: y2 } }\n}\n\nfunction calculateLinePosition(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  scale: number,\n  groupWidth: number,\n  pointInGroup: number,\n  keepOrder: EdgeKeepOrderType\n): [number, number, number, number] {\n  const dx = x2 - x1\n  const dy = y2 - y1\n\n  // Shifting width from center\n  let diff = (groupWidth / 2 - pointInGroup) * scale\n\n  // Adjust the relative position.\n  if (diff !== 0 && keepOrder !== \"clock\") {\n    const radian = Math.atan2(y2 - y1, x2 - x1)\n    if (keepOrder === \"vertical\") {\n      // Keep the vertical alignment of multiple edges.\n      const perpendicular = Math.PI / 2\n      if (radian < -perpendicular || radian >= perpendicular) {\n        diff *= -1\n      }\n    } else if (keepOrder === \"horizontal\") {\n      // Keep the horizontal alignment of multiple edges.\n      if (radian < 0) {\n        diff *= -1\n      }\n    }\n  }\n\n  if (dx === 0) {\n    const sign = dy < 0 ? -1 : 1\n    return [x1 + diff * sign, y1, x2 + diff * sign, y2]\n  } else if (dy === 0) {\n    const sign = dx < 0 ? 1 : -1\n    return [x1, y1 + diff * sign, x2, y2 + diff * sign]\n  } else {\n    const slope = dy / dx\n    const moveSlope = -1 / slope\n    if (dy < 0) {\n      diff = -diff\n    }\n    const diffX = diff / Math.sqrt(1 + Math.pow(moveSlope, 2))\n    return [x1 + diffX, y1 + diffX * moveSlope, x2 + diffX, y2 + diffX * moveSlope]\n  }\n}\n","import { Point2D } from \"./core\"\n\nexport function add(v1: Point2D, v2: Point2D): Point2D\nexport function add<T extends Point2D>(v1: Point2D, v2: Point2D, target: T): T\nexport function add(v1: Point2D, v2: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v1.x + v2.x\n  target.y = v1.y + v2.y\n  return target\n}\n\nexport function subtract(v1: Point2D, v2: Point2D): Point2D\nexport function subtract<T extends Point2D>(v1: Point2D, v2: Point2D, target: T): T\nexport function subtract(v1: Point2D, v2: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v1.x - v2.x\n  target.y = v1.y - v2.y\n  return target\n}\n\nexport function multiply(v1: Point2D, v2: Point2D): Point2D\nexport function multiply<T extends Point2D>(v1: Point2D, v2: Point2D, target: T): T\nexport function multiply(v1: Point2D, v2: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v1.x * v2.x\n  target.y = v1.y * v2.y\n  return target\n}\n\nexport function multiplyScalar(v: Point2D, scalar: number): Point2D\nexport function multiplyScalar<T extends Point2D>(v: Point2D, scalar: number, target: T): T\nexport function multiplyScalar(v: Point2D, scalar: number, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v.x * scalar\n  target.y = v.y * scalar\n  return target\n}\n\nexport function divide(v1: Point2D, v2: Point2D): Point2D\nexport function divide<T extends Point2D>(v1: Point2D, v2: Point2D, target: T): T\nexport function divide(v1: Point2D, v2: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v1.x / v2.x\n  target.y = v1.y / v2.y\n  return target\n}\n\nexport function dot(v1: Point2D, v2: Point2D): number {\n  return v1.x * v2.x + v1.y * v2.y\n}\n\nexport function cross(v1: Point2D, v2: Point2D): number {\n  return v1.x * v2.y - v1.y * v2.x\n}\n\nexport function lengthSquared(v: Point2D): number {\n  return v.x * v.x + v.y * v.y\n}\n\nexport function length(v: Point2D): number {\n  return Math.sqrt(lengthSquared(v))\n}\n\nexport function distanceSquared(v1: Point2D, v2: Point2D): number {\n  const dx = v1.x - v2.x\n  const dy = v1.y - v2.y\n  return dx * dx + dy * dy\n}\n\nexport function distance(v1: Point2D, v2: Point2D): number {\n  return Math.sqrt(distanceSquared(v1, v2))\n}\n\nexport function normalize(v: Point2D): Point2D\nexport function normalize<T extends Point2D>(v: Point2D, target: T): T\nexport function normalize(v: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  const len = length(v)\n  if (len === 0) {\n    target.x = 1\n    target.y = 0\n  } else {\n    divide(v, { x: len, y: len }, target)\n  }\n  return target\n}\n\nexport function rotate(v: Point2D, angle: number): Point2D\nexport function rotate<T extends Point2D>(v: Point2D, angle: number, target: T): T\nexport function rotate(v: Point2D, angle: number, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  // rotate in radians CCW from +X axis\n  const newX = v.x * Math.cos(angle) - v.y * Math.sin(angle)\n  const newY = v.x * Math.sin(angle) + v.y * Math.cos(angle)\n  target.x = newX\n  target.y = newY\n  return target\n}\n\nconst DEGREES = 180 / Math.PI\n\nfunction rad2deg(rad: number) {\n  return rad * DEGREES\n}\n\nexport function angle(v: Point2D) {\n  return Math.atan2(v.y, v.x)\n}\n\nexport function angleDegree(v: Point2D) {\n  return rad2deg(angle(v))\n}\n","import { Point2D } from \"./core\"\nimport { add, angle, angleDegree, cross, distance, distanceSquared, divide } from \"./methods\"\nimport { dot, length, lengthSquared, multiply, multiplyScalar, normalize } from \"./methods\"\nimport { rotate, subtract } from \"./methods\"\n\nexport class Vector2D implements Point2D {\n  public x: number\n  public y: number\n\n  static fromArray(array: number[]) {\n    return new Vector2D(array[0] || 0, array[1] || 0)\n  }\n\n  static fromObject(obj: Point2D) {\n    return new Vector2D(obj.x, obj.y)\n  }\n\n  constructor(x: number, y: number) {\n    this.x = x\n    this.y = y\n  }\n\n  // instance methods\n  add(v: Point2D): Vector2D {\n    return add(this, v, this)\n  }\n\n  subtract(v: Point2D): Vector2D {\n    return subtract(this, v, this)\n  }\n\n  multiply(v: Point2D): Vector2D {\n    return multiply(this, v, this)\n  }\n\n  multiplyScalar(scalar: number): Vector2D {\n    return multiplyScalar(this, scalar, this)\n  }\n\n  divide(v: Point2D): Vector2D {\n    return divide(this, v, this)\n  }\n\n  dot(v: Point2D): number {\n    return dot(this, v)\n  }\n\n  cross(v: Point2D): number {\n    return cross(this, v)\n  }\n\n  lengthSquared(): number {\n    return lengthSquared(this)\n  }\n\n  length(): number {\n    return length(this)\n  }\n\n  distanceSquared(v: Point2D): number {\n    return distanceSquared(this, v)\n  }\n\n  distance(v: Point2D): number {\n    return distance(this, v)\n  }\n\n  normalize(): Vector2D {\n    return normalize(this, this)\n  }\n\n  angle(): number {\n    return angle(this)\n  }\n\n  angleDegree(): number {\n    return angleDegree(this)\n  }\n\n  rotate(angle: number): Vector2D {\n    return rotate(this, angle, this)\n  }\n\n  isEqualTo(v: Point2D): boolean {\n    return this.x === v.x && this.y === v.y\n  }\n\n  clone(): Vector2D {\n    return new Vector2D(this.x, this.y)\n  }\n\n  toObject(): Point2D {\n    return { x: this.x, y: this.y }\n  }\n\n  toArray(): [number, number] {\n    return [this.x, this.y]\n  }\n}\n","export { Vector2D } from \"./vector2d\"\nexport * from \"./methods\"\n\nimport { Vector2D } from \"./vector2d\"\nimport * as V from \"./methods\"\n\nexport default {\n  Vector2D,\n  ...V\n}\n","import { LinePosition, Position } from \"@/common/types\"\nimport { Vector2D } from \"@/modules/vector2d\"\n\n// ---------------------------\n// Line information by vectors\n// ---------------------------\n\nexport class VectorLine {\n  public source: Vector2D\n  public target: Vector2D\n  public v: Vector2D\n\n  constructor(source: Vector2D, target: Vector2D, v: Vector2D) {\n    this.source = source\n    this.target = target\n    this.v = v\n  }\n\n  static fromLinePosition(line: LinePosition): VectorLine {\n    const source = Vector2D.fromObject(line.p1)\n    const target = Vector2D.fromObject(line.p2)\n    return new VectorLine(source, target, toLineVector(source, target))\n  }\n\n  static fromPositions(sourcePos: Position, targetPos: Position): VectorLine {\n    const source = Vector2D.fromObject(sourcePos)\n    const target = Vector2D.fromObject(targetPos)\n    return new VectorLine(source, target, toLineVector(source, target))\n  }\n\n  static fromVectors(source: Vector2D, target: Vector2D): VectorLine {\n    return new VectorLine(source, target, toLineVector(source, target))\n  }\n}\n\nexport function toLineVector(source: Vector2D, target: Vector2D): Vector2D {\n  return target.clone().subtract(source)\n}\n\nexport function toVectorsFromLinePosition(line: LinePosition): [Vector2D, Vector2D] {\n  return [Vector2D.fromObject(line.p1), Vector2D.fromObject(line.p2)]\n}\n\nexport function getCenterOfLinePosition(line: LinePosition): Vector2D {\n  return new Vector2D((line.p1.x + line.p2.x) / 2, (line.p1.y + line.p2.y) / 2)\n}\n\n// -------------------------------\n// Calculation functions for Lines\n// -------------------------------\n\n/**\n * Convert two `Position` to `LinePosition`\n * @param p1 source position of the line\n * @param p2 target position of the line\n * @returns `LinePosition` instance\n */\n export function toLinePosition(p1: Position, p2: Position): LinePosition {\n  return { p1, p2 }\n}\n\n/**\n * Calculates the line position to which the margin is applied.\n * @param linePos original position of the line\n * @param sourceMargin margin for source side\n * @param targetMargin margin for target side\n * @returns the line position\n */\n export function applyMargin(\n  linePos: LinePosition,\n  sourceMargin: number,\n  targetMargin: number\n): LinePosition {\n  const line = VectorLine.fromLinePosition(linePos)\n  return applyMarginInner(line, sourceMargin, targetMargin)\n}\n\nfunction applyMarginInner(\n  line: VectorLine,\n  sourceMargin: number,\n  targetMargin: number\n): LinePosition {\n  const normalized = line.v.clone().normalize()\n\n  const sv = line.source.clone().add(normalized.clone().multiplyScalar(sourceMargin))\n\n  const tv = line.target.clone().subtract(normalized.clone().multiplyScalar(targetMargin))\n\n  let p1 = sv.toObject()\n  let p2 = tv.toObject()\n\n  const check = toLineVector(sv, tv)\n  if (line.v.angle() * check.angle() < 0) {\n    // reversed\n    const c1 = new Vector2D((p1.x + p2.x) / 2, (p1.y + p2.y) / 2)\n    const c2 = c1.clone().add(normalized.multiplyScalar(0.5))\n    p1 = c1.toObject()\n    p2 = c2.toObject()\n  }\n\n  return { p1, p2 }\n}\n\nexport function inverseLine(line: LinePosition): LinePosition {\n  return { p1: line.p2, p2: line.p1 }\n}\n\nexport function calculatePerpendicularLine(line: VectorLine) {\n  const n1 = line.v\n    .clone()\n    .normalize()\n    .rotate(Math.PI / 2)\n  return VectorLine.fromVectors(line.target, line.target.clone().add(n1))\n}\n","import V, { Vector2D } from \"@/modules/vector2d\"\nimport { VectorLine } from \"./line\"\n\n/**\n * Calculate the nearest point from a point to a line.\n * @param p point\n * @param line line\n * @returns point on the line\n */\nexport function getNearestPoint(p: Vector2D, line: VectorLine): Vector2D {\n  const n = line.v.clone().normalize()\n\n  // Let `a` be a vector from any one point on a line to a point\n  const lp = line.source\n  const a = V.subtract(p, lp)\n\n  // Inner product of `n` and `a`\n  const dot = n.dot(a)\n\n  // The nearest point is the sum of a point on the line and a\n  // vector of n multiplied by dot.\n  const near = lp.clone().add(n.multiplyScalar(dot))\n\n  return near\n}\n\n// /**\n//  * Calculate the distance of nearest point from a point to a line.\n//  * @param p point\n//  * @param line line\n//  * @returns distance\n//  */\n// export function getDistanceToNearestPoint(p: Vector2D, line: VectorLine): number {\n//   const p2 = line.source\n//   const v2 = line.v\n\n//   const v2len = v2.lengthSquared()\n//   if (v2len === 0) {\n//     return 0\n//   }\n//   const t = V.dot(v2, V.subtract(p, p2)) / v2len\n//   const tv2 = V.multiplyScalar(v2, t)\n//   const h = p2.clone().add(tv2)\n//   return h.subtract(p).length()\n// }\n\nexport function getIntersectionOfLineTargetAndCircle(\n  source: Vector2D,\n  target: Vector2D,\n  center: Vector2D,\n  radius: number\n): Vector2D | null {\n  // Does the node contain a point?\n  const length = V.lengthSquared(V.subtract(target, center))\n  const contains = length - radius * radius <= Math.pow(1, -10)\n\n  if (!contains) return null // Not contained.\n\n  // If contained, calculate the intersection point.\n\n  // Find the nearest point `h` between `c` and the line\n  const line = VectorLine.fromVectors(source, target)\n  const h = getNearestPoint(center, line)\n\n  // Let `hp` be the vector from `c` to `h`.\n  const hpLen = V.length(V.subtract(h, center))\n\n  // If `hpLen` is larger than the radius of the circle,\n  // there is no intersection.\n  if (radius < hpLen) return null\n\n  // When a straight line and a circle are tangent, `hpLen` is `r`.\n  // Then the point of contact is the nearest point between the\n  // center and the line.\n  if (radius === hpLen) return h\n\n  // Let `t` be the distance from `h` to the contact point, and\n  // derive t from the Three Square Theorem.\n  const t = Math.sqrt(radius ** 2 - hpLen ** 2)\n\n  // Let `tv` be the vector of the normalized direction vector of\n  // the line multiplied by t\n  // - intersection point 1p + tv\n  // - intersection point 2p - tv\n  const tv = line.v.normalize().multiplyScalar(t)\n\n  // Calculate the addition or subtraction depending on which side\n  // of the line to focus on.\n  return h.subtract(tv)\n}\n\nexport function getIntersectionOfLineTargetAndCircle2(\n  source: Vector2D,\n  target: Vector2D,\n  center: Vector2D,\n  radius: number,\n  nearBy: Vector2D\n): Vector2D | null {\n  // Does the node contain a point?\n  const length = V.lengthSquared(V.subtract(target, center))\n  const contains = length - radius * radius <= Math.pow(1, -10)\n\n  if (!contains) return null // Not contained.\n\n  // If contained, calculate the intersection point.\n\n  // Find the nearest point `h` between `c` and the line\n  const line = VectorLine.fromVectors(source, target)\n  const h = getNearestPoint(center, line)\n\n  // Let `hp` be the vector from `c` to `h`.\n  const hpLen = V.length(V.subtract(h, center))\n\n  // If `hpLen` is larger than the radius of the circle,\n  // there is no intersection.\n  if (radius < hpLen) return null\n\n  // When a straight line and a circle are tangent, `hpLen` is `r`.\n  // Then the point of contact is the nearest point between the\n  // center and the line.\n  if (radius === hpLen) return h\n\n  // Let `t` be the distance from `h` to the contact point, and\n  // derive t from the Three Square Theorem.\n  const t = Math.sqrt(radius ** 2 - hpLen ** 2)\n\n  // Let `tv` be the vector of the normalized direction vector of\n  // the line multiplied by t\n  // - intersection point 1p + tv\n  // - intersection point 2p - tv\n  const tv = line.v.normalize().multiplyScalar(t)\n  const ip1 = h.clone().add(tv)\n  const ip2 = h.clone().subtract(tv)\n\n  const d1 = nearBy.distance(ip1)\n  const d2 = nearBy.distance(ip2)\n\n  if (Math.abs(d1 - d2) < 2) {\n    // Calculate the addition or subtraction depending on which side\n    // of the line to focus on.\n    return ip2\n  }\n\n  return d1 < d2 ? ip1 : ip2\n}\n\n/**\n * Calculate the intersection of two lines.\n * @param line1 line 1\n * @param line2 line 2\n * @returns intersection point\n */\nexport function getIntersectionPointOfLines(line1: VectorLine, line2: VectorLine): Vector2D {\n  const v = V.subtract(line2.source, line1.source)\n\n  const v1 = line1.v\n  const v2 = line2.v\n\n  const t2 = V.cross(v, v1) / V.cross(v1, v2)\n\n  return line2.source.clone().add(v2.clone().multiplyScalar(t2))\n}\n\nexport function getIntersectionOfCircles(\n  center1: Vector2D,\n  radius1: number,\n  center2: Vector2D,\n  radius2: number,\n  near: Vector2D\n): Vector2D | null\nexport function getIntersectionOfCircles(\n  center1: Vector2D,\n  radius1: number,\n  center2: Vector2D,\n  radius2: number\n): [Vector2D, Vector2D] | null\nexport function getIntersectionOfCircles(\n  center1: Vector2D,\n  radius1: number,\n  center2: Vector2D,\n  radius2: number,\n  near?: Vector2D\n): Vector2D | [Vector2D, Vector2D] | null {\n  const c1 = center1\n  const c2 = center2\n\n  // vector of C1-->C2\n  const vC1C2 = c2.clone().subtract(c1)\n\n  // length of C1--C2\n  const a = vC1C2.length()\n\n  const sumR = radius1 + radius2\n  if (sumR < a) return null // no overlap\n\n  // When a circle is contained, there is no contact point.\n  const subR = Math.abs(radius1 - radius2)\n  if (a < subR) return null\n\n  // When the circles are circumscribed, [a] and the sum of\n  // radius of two circles are equal. And there is only one\n  // contact point.\n  if (a === sumR) {\n    const n = vC1C2.clone().normalize()\n    const p = center1.clone().add(n.multiplyScalar(radius1))\n    return near ? p : [p , p]\n  }\n\n  // When the circles are inscribed, [a] and the difference\n  // between the radius of two circles are equal. And there\n  // is only one point of contact.\n  if (a === subR) {\n    const n = vC1C2.clone().normalize()\n    const isLarge = radius1 > radius2\n    // Let [P] be the contact point:\n    // * C1 is larger : P = C1 + r1 * n\n    // * C1 is smaller: P = C1 - r1 * n\n    const p = center1.clone().add(n.multiplyScalar(isLarge ? radius1 : -radius1))\n    return near ? p : [p , p]\n  }\n\n  // All three sides of triangle C1C2P are known.\n  // [b] := length of C1--P\n  // [c] := length of C2--P\n  const b = radius1\n  const c = radius2\n\n  // The cos  of angle C1 is given by the cosine theorem:\n  const cos = (a ** 2 + b ** 2 - c ** 2) / (2 * a * b)\n\n  // Let [H] be the point where the vertical line from [P] to\n  // C1--C2 is dropped, and let [rc] be the length of C1--H.\n  const rc = b * cos\n\n  // Let the length of the H--P be [rs]\n  const rs = Math.sqrt(b ** 2 - rc ** 2)\n\n  // normalized vector of vC1C2\n  const n1 = vC1C2.clone().normalize()\n\n  // vector with n1 rotated 90 degrees to the left\n  const n2 = new Vector2D(-n1.y, n1.x)\n\n  // The point of intersection [P]\n  // P  = C1 + tn1 + sn2\n  // P' = C1 + tn1 - sn2\n  const tn1 = n1.clone().multiplyScalar(rc)\n  const sn2 = n2.clone().multiplyScalar(rs)\n\n  const result1 = center1.clone().add(tn1).add(sn2)\n  const result2 = center1.clone().add(tn1).subtract(sn2)\n\n  if (near) {\n    const d1 = result1.distance(near)\n    const d2 = result2.distance(near)\n    return d1 < d2 ? result1 : result2\n  } else {\n    return [result1, result2]\n  }\n}\n","import { AnyShapeStyle, RectangleShapeStyle, StrokeStyle } from \"@/common/configs\"\nimport { EdgeLabelArea, LinePosition, Position } from \"@/common/types\"\nimport V, { Vector2D } from \"@/modules/vector2d\"\nimport * as PointUtils from \"./point\"\nimport * as LineUtils from \"./line\"\nimport { VectorLine } from \"./line\"\n\n// /**\n//  * Calculate whether a point is contained in a circle.\n//  * @param point point\n//  * @param center center of the circle\n//  * @param radius radius of the circle\n//  * @returns whether point is contained in a circle\n//  */\n// export function isPointContainedInCircle(\n//   point: Position,\n//   center: Position,\n//   radius: number\n// ): boolean {\n//   const p = Vector2D.fromObject(point)\n//   const c = Vector2D.fromObject(center)\n//   const v = p.subtract(c)\n//   return v.lengthSquared() < radius * radius\n// }\n\n// /**\n//  * Calculate the distance of the line.\n//  * @param line line\n//  * @returns distance\n//  */\n// export function calculateDistance(line: LinePosition): number {\n//   return V.distance(line.p1, line.p2)\n// }\n\n/**\n * Get the distance that a line should be away from the\n * edge to avoid contacting a rounded rectangle.\n * @param sourcePos source position of the line\n * @param targetPos target position of the line\n * @param rect rectangle style\n * @param scale scale factor\n * @returns distance from target position\n */\nfunction calculateDistanceToAvoidOverlapsWithRect(\n  sourcePos: Position,\n  targetPos: Position, // position of the target rounded rectangle\n  rect: RectangleShapeStyle,\n  scale: number\n) {\n  const centerLine = VectorLine.fromPositions(sourcePos, targetPos)\n  const halfWidth = ((rect.width + rect.strokeWidth) / 2) * scale\n  const halfHeight = ((rect.height + rect.strokeWidth) / 2) * scale\n\n  const borderRadius =\n    rect.borderRadius > 0 ? (rect.borderRadius + rect.strokeWidth / 2) * scale : 0\n\n  // check whether it crosses over the vertical or horizontal boundary\n  const angleVRad = (centerLine.v.angle() - Math.PI / 2) % Math.PI\n  const angleHRad = Math.PI / 2 - (angleVRad % Math.PI)\n  const w = halfHeight * Math.abs(Math.tan(angleVRad))\n  const h = halfWidth * Math.abs(Math.tan(angleHRad))\n  const isCrossedVLine = w <= halfWidth - borderRadius\n  const isCrossedHLine = h <= halfHeight - borderRadius\n  if (isCrossedVLine || isCrossedHLine || borderRadius === 0) {\n    if (isCrossedVLine) {\n      return Math.sqrt(halfHeight ** 2 + w ** 2)\n    } else {\n      return Math.sqrt(halfWidth ** 2 + h ** 2)\n    }\n  } else {\n    // on the border radius: calculate the center of circles\n    const left = targetPos.x - halfWidth + borderRadius\n    const top = targetPos.y - halfHeight + borderRadius\n    const right = targetPos.x + halfWidth - borderRadius\n    const bottom = targetPos.y + halfHeight - borderRadius\n    const vertexes = [\n      new Vector2D(left, top),\n      new Vector2D(right, top),\n      new Vector2D(right, bottom),\n      new Vector2D(left, bottom),\n    ]\n    const index = Math.floor(((centerLine.v.angleDegree() + 360) % 360) / 90)\n    const centerOfNearestCircle = vertexes[index]\n    const point = PointUtils.getIntersectionOfLineTargetAndCircle(\n      centerLine.source,\n      PointUtils.getNearestPoint(centerOfNearestCircle, centerLine),\n      centerOfNearestCircle,\n      borderRadius\n    )\n    return point\n      ? LineUtils.toLineVector(point, centerLine.target).length()\n      : LineUtils.toLineVector(centerOfNearestCircle, centerLine.target).length() + borderRadius\n  }\n}\n\n/**\n * Calculate the position to display the edge label from the\n * positions of the edge.\n * @param linePos line segment between the outermost of the nodes\n * @param edgeStyle stroke style of edges\n * @param margin margin from line\n * @param padding padding from outside\n * @param scale scale factor\n * @returns edge label display area\n */\nexport function calculateEdgeLabelArea(\n  linePos: LinePosition,\n  edgeStyle: StrokeStyle,\n  margin: number,\n  padding: number,\n  scale: number\n): EdgeLabelArea {\n  // the line segment between the outermost of the nodes\n  const line = VectorLine.fromLinePosition(linePos)\n  const normalized = line.v.clone().normalize()\n\n  // source side\n  const sv =\n    padding === 0\n      ? line.source\n      : line.source.clone().add(normalized.clone().multiplyScalar(padding * scale))\n\n  // target side\n  const tv =\n    padding === 0\n      ? line.target\n      : line.target.clone().subtract(normalized.clone().multiplyScalar(padding * scale))\n\n  // margin for edges\n  const labelMargin = (edgeStyle.width / 2 + margin) * scale\n  const vMargin = new Vector2D(-normalized.y, normalized.x).multiplyScalar(labelMargin)\n  let sourceAbove = V.subtract(sv, vMargin)\n  let sourceBelow = V.add(sv, vMargin)\n  let targetAbove = V.subtract(tv, vMargin)\n  let targetBelow = V.add(tv, vMargin)\n\n  const angle = line.v.angleDegree()\n  if (angle < -90 || angle >= 90) {\n    // upside down\n    ;[sourceAbove, sourceBelow] = [sourceBelow, sourceAbove]\n    ;[targetAbove, targetBelow] = [targetBelow, targetAbove]\n  }\n  return {\n    source: { above: sourceAbove, below: sourceBelow },\n    target: { above: targetAbove, below: targetBelow },\n  }\n}\n\n/**\n * Calculate the distances between center of node and edge of node.\n * @param sourceNodePos position of source node\n * @param targetNodePos position of target node\n * @param sourceNodeShape shape config of source node\n * @param targetNodeShape shape config of target node\n * @returns the distances\n */\nexport function calculateDistancesFromCenterOfNodeToEndOfNode(\n  sourceNodePos: Position,\n  targetNodePos: Position,\n  sourceNodeShape: AnyShapeStyle,\n  targetNodeShape: AnyShapeStyle\n): [number, number] {\n  // source side\n  let distance1: number\n  if (sourceNodeShape.type === \"circle\") {\n    distance1 = sourceNodeShape.radius + (sourceNodeShape.strokeWidth / 2)\n  } else {\n    distance1 = calculateDistanceToAvoidOverlapsWithRect(\n      targetNodePos,\n      sourceNodePos,\n      sourceNodeShape,\n      1 // scale\n    )\n  }\n\n  // target side\n  let distance2: number\n  if (targetNodeShape.type === \"circle\") {\n    distance2 = targetNodeShape.radius + (targetNodeShape.strokeWidth / 2)\n  } else {\n    distance2 = calculateDistanceToAvoidOverlapsWithRect(\n      sourceNodePos,\n      targetNodePos,\n      targetNodeShape,\n      1 // scale\n    )\n  }\n\n  return [distance1, distance2]\n}\n\n/**\n * Calculates the position of a given distance along the circumference.\n * @param pos original position\n * @param center center of the circle\n * @param radian radius of the circle\n * @returns the moved position\n */\nexport function moveOnCircumference(pos: Position, center: Position, radian: number) {\n  const { x, y } = pos\n  const dx = x - center.x\n  const dy = y - center.y\n\n  return {\n    x: dx * Math.cos(radian) - dy * Math.sin(radian) + center.x,\n    y: dx * Math.sin(radian) + dy * Math.cos(radian) + center.y,\n  }\n}\n\n/**\n * Reverse the direction of the angle.\n * @param theta angle\n * @returns reversed angle\n */\nexport function reverseAngleRadian(theta: number): number {\n  if (theta > 0) {\n    return -(Math.PI * 2 - theta)\n  } else {\n    return Math.PI * 2 + theta\n  }\n}\n\nexport function calculateBezierCurveControlPoint(\n  p1: Vector2D,\n  center: Vector2D,\n  p2: Vector2D,\n  theta0: number\n): Vector2D[] {\n  const control: Vector2D[] = []\n  const centerToSource = VectorLine.fromVectors(center, p1)\n  const centerToTarget = VectorLine.fromVectors(center, p2)\n\n  let theta = calculateRelativeAngleRadian(centerToSource, centerToTarget)\n  if (theta0 * theta < 0) {\n    theta = reverseAngleRadian(theta)\n  }\n  const middle = Vector2D.fromObject(moveOnCircumference(p1, center, -theta / 2))\n  const centerToMp = VectorLine.fromVectors(center, middle)\n  const mpTangent = LineUtils.calculatePerpendicularLine(centerToMp)\n\n  const theta1 = calculateRelativeAngleRadian(centerToSource, centerToMp)\n  let tangent = LineUtils.calculatePerpendicularLine(centerToSource)\n  if (Math.abs(theta1) < Math.PI / 2) {\n    const cp = PointUtils.getIntersectionPointOfLines(tangent, mpTangent)\n    control.push(cp)\n  } else {\n    // If greater than 90 degrees, go through the midpoint.\n    const mp = Vector2D.fromObject(moveOnCircumference(middle, center, theta1 / 2))\n    const tangent2 = LineUtils.calculatePerpendicularLine(\n      VectorLine.fromVectors(center, Vector2D.fromObject(mp))\n    )\n    const cp1 = PointUtils.getIntersectionPointOfLines(tangent, tangent2)\n    const cp2 = PointUtils.getIntersectionPointOfLines(tangent2, mpTangent)\n    control.push(cp1, mp, cp2)\n  }\n\n  control.push(middle)\n\n  const theta2 = calculateRelativeAngleRadian(centerToTarget, centerToMp)\n  tangent = LineUtils.calculatePerpendicularLine(centerToTarget)\n  if (Math.abs(theta2) < Math.PI / 2) {\n    const cp = PointUtils.getIntersectionPointOfLines(tangent, mpTangent)\n    control.push(cp)\n  } else {\n    // If greater than 90 degrees, go through the midpoint.\n    const mp = Vector2D.fromObject(moveOnCircumference(middle, center, theta2 / 2))\n    const tangent2 = LineUtils.calculatePerpendicularLine(\n      VectorLine.fromVectors(center, Vector2D.fromObject(mp))\n    )\n    const cp1 = PointUtils.getIntersectionPointOfLines(mpTangent, tangent2)\n    const cp2 = PointUtils.getIntersectionPointOfLines(tangent2, tangent)\n    control.push(cp1, mp, cp2)\n  }\n\n  return control\n}\n\nexport function calculateRelativeAngleRadian(line1: VectorLine, line2: VectorLine) {\n  return Math.atan2(\n    line1.v.y * line2.v.x - line1.v.x * line2.v.y,\n    line1.v.x * line2.v.x + line1.v.y * line2.v.y\n  )\n}\n\nexport function calculateCircleCenterAndRadiusBy3Points(\n  p1: Vector2D,\n  p2: Vector2D,\n  p3: Vector2D\n): [Vector2D, number] {\n  const x1 = p1.x\n  const y1 = p1.y\n  const x2 = p2.x\n  const y2 = p2.y\n  const x3 = p3.x\n  const y3 = p3.y\n  const x12 = x1 - x2\n  const y12 = y1 - y2\n  const x32 = x3 - x2\n  const y32 = y3 - y2\n\n  if ((x12 === 0 && y12 === 0) || (x32 === 0 && y32 === 0)) {\n    // Cannot determine the curve if two or more of the three points are in the same position.\n    return [p1, 0];\n  }\n\n  const x =\n    (y32 * (x12 * (x1 + x2) + y12 * (y1 + y2)) - y12 * (x32 * (x3 + x2) + y32 * (y3 + y2))) /\n    (2 * x12 * y32 - 2 * y12 * x32)\n  const y =\n    (-x32 * (x12 * (x1 + x2) + y12 * (y1 + y2)) + x12 * (x32 * (x3 + x2) + y32 * (y3 + y2))) /\n    (2 * x12 * y32 - 2 * y12 * x32)\n\n  const radius = Math.sqrt(Math.pow(x1 - x, 2) + Math.pow(y1 - y, 2))\n  const center = new Vector2D(x, y)\n  return [center, radius]\n}\n","import { AnyShapeStyle } from \"@/common/configs\"\n\nexport function getNodeRadius(shape: AnyShapeStyle) {\n  if (shape.type == \"circle\") {\n    return shape.radius\n  } else {\n    return Math.min(shape.width, shape.height) / 2\n  }\n}\n","\ntype Args<T> = [...(T | null)[], T]\n\nexport function findFirstNonNull<T>(...values: Args<T>): T {\n  return values.find(v => !!v) as T\n}\n","import { NodePositions, PositionOrCurve } from \"@/common/types\"\nimport { nonNull } from \"@/common/common\"\nimport { NodeStates } from \"@/models/node\"\nimport { EdgeStates, EdgeState } from \"@/models/edge\"\nimport { EdgeLine, EdgeObject, PathState } from \"@/models/path\"\nimport { PathEndType } from \"@/common/configs\"\nimport { findFirstNonNull } from \"@/utils/collection\"\nimport * as v2d from \"@/modules/calculation/2d\"\nimport * as PointUtils from \"@/modules/calculation/point\"\nimport { VectorLine } from \"@/modules/calculation/line\"\nimport * as LineUtils from \"@/modules/calculation/line\"\nimport * as NodeUtils from \"@/modules/node/node\"\nimport V, { Vector2D } from \"@/modules/vector2d\"\n\nconst EPSILON = Number.EPSILON * 100 // 2.2204... x 1014.\n\nexport function calculatePathPoints(\n  path: PathState,\n  nodeStates: NodeStates,\n  nodeLayouts: NodePositions,\n  edgeStates: EdgeStates,\n  scale: number,\n  curveInNode: boolean,\n  pathEndType: PathEndType,\n  margin: number\n): PositionOrCurve[] {\n  // The relationship between the source/target of a link and the connection\n  // by path can be different.\n  // Detect node at connection point and determine source/target for the path.\n  const edges = path.edges\n\n  // Edge ID list -> List of Edge locations\n  const directions = path.directions // true: forward, false: reverse\n  const edgePos = edges.map((edge, i) => _getEdgeLine(edge, directions[i], edgeStates[edge.edgeId]))\n\n  // the results\n  const points: (Vector2D[] | Vector2D)[] = []\n\n  let isMarginOverRunStart = false\n  let isMarginOverRunEnd = false\n\n  // ----------------------------------------------------\n  // Determine the starting point.\n  // ----------------------------------------------------\n  {\n    const firstEdge = edgePos[0]\n    let nodeRadius = NodeUtils.getNodeRadius(nodeStates[firstEdge.source].shape) * scale\n    const lineMargin = margin + (pathEndType === \"edgeOfNode\" ? nodeRadius : 0)\n    const nextPoint =\n      lineMargin <= 0\n        ? firstEdge.line.source\n        : _calculateEdgeOfNode(firstEdge, lineMargin, nodeLayouts, true)\n    points.push(nextPoint)\n    nodeRadius = NodeUtils.getNodeRadius(nodeStates[firstEdge.target].shape) * scale\n    if (margin > 0) {\n      const distance = V.distance(firstEdge.line.source, firstEdge.line.target)\n      if (distance <= lineMargin + nodeRadius) {\n        isMarginOverRunStart = true\n      }\n    }\n  }\n\n  // ----------------------------------------------------\n  // Determine transit points.\n  // ----------------------------------------------------\n  const length = edges.length\n  for (let i = 1; i < length; i++) {\n    const prev = edgePos[i - 1]\n    const next = edgePos[i]\n\n    const nodeId = next.source\n    const nodePos = Vector2D.fromObject(nodeLayouts[nodeId] ?? { x: 0, y: 0 })\n\n    // The intersection point of two lines: [X]\n    const crossPoint = _getIntersectionOfLines(prev, next, nodePos)\n\n    // Place another small circle inside the node's circle and\n    // calculate transit points so that the path line is smooth.\n    //   Inner circle: [] radius: `nodeCoreRadius`\n    //   Node circle : [] radius: `nodeRadius`\n    const nodeRadius = NodeUtils.getNodeRadius(nodeStates[nodeId].shape) * scale\n    const nodeCoreRadius = Math.max(nodeRadius * (2 / 3), nodeRadius - 4 * scale)\n    const isForwardPrev = _isForward(prev)\n    const isForwardNext = _isForward(next)\n    const prevCoreIp = _getIntersectionOfLineAndNode(prev, nodePos, nodeCoreRadius, isForwardPrev)\n    const nextCoreIp = _getIntersectionOfLineAndNode(next, nodePos, nodeCoreRadius, !isForwardNext)\n    const prevNodeIp = _getIntersectionOfLineAndNode(prev, nodePos, nodeRadius, isForwardPrev)\n    const nextNodeIp = _getIntersectionOfLineAndNode(next, nodePos, nodeRadius, !isForwardNext)\n\n    // ----------------------------------------------------\n    // Calculate transit points in the node.\n    // ----------------------------------------------------\n    let pos: Vector2D | Vector2D[]\n    if (crossPoint) {\n      const d = V.distance(crossPoint, nodePos)\n      if (d < nodeCoreRadius) {\n        // (1) [] includes [X]:\n        //  * [X]: control point in bezier\n        //  * intersection with []: transit point\n        pos = [\n          findFirstNonNull(prevCoreIp, prevNodeIp, prev.line.target),\n          crossPoint,\n          findFirstNonNull(nextCoreIp, nextNodeIp, next.line.source),\n        ]\n      } else if (d <= nodeRadius) {\n        // (2) [] includes [X]:\n        //  * [X]: control point in bezier\n        let p1: Vector2D, p2: Vector2D\n        if (prevNodeIp && prevCoreIp) {\n          // the prev line intersects [] and []:\n          // Of []x[line], []x[line], use the one closer to [X] as the transit point.\n          p1 =\n            V.distance(crossPoint, prevCoreIp) < V.distance(crossPoint, prevNodeIp)\n              ? prevCoreIp\n              : prevNodeIp\n        } else {\n          // the prev line intersects only with []:\n          // use []x[line] as the transit point.\n          p1 = prevNodeIp || prev.line.target\n        }\n        if (nextNodeIp && nextCoreIp) {\n          // the next line intersects with [] and []:\n          // Of []x[line], []x[line], use the one closer to [X] as the transit point.\n          p2 =\n            V.distance(crossPoint, nextCoreIp) < V.distance(crossPoint, nextNodeIp)\n              ? nextCoreIp\n              : nextNodeIp\n        } else {\n          // the next line intersects only with []:\n          // use []x[line] as the transit point.\n          p2 = nextNodeIp || next.line.source\n        }\n        pos = [p1, crossPoint, p2]\n      } else {\n        // (3) [X] is out of the node([])\n        if (prevCoreIp && nextCoreIp) {\n          // both lines intersect with []:\n          // use the []x[line] as transit point, and\n          // center of the node as control point in bezier.\n          pos = [prevCoreIp, nodePos, nextCoreIp]\n        } else if (prevNodeIp && nextNodeIp) {\n          // both lines intersect with []:\n          // use the []x[line] as transit point, and\n          // center of the node as control point in bezier.\n          pos = [prevNodeIp, nodePos, nextNodeIp]\n        } else {\n          // either or both lines do not intersect the node:\n          // [X] as transit point in bezier, and not place control points.\n          // []x[line] or []x[line] or end of [line] as the transit points, and\n          // center of the node as control point in bezier.\n          pos = [\n            findFirstNonNull(prevCoreIp, prevNodeIp, prev.line.target),\n            nodePos,\n            findFirstNonNull(nextCoreIp, nextNodeIp, next.line.source),\n          ]\n        }\n      }\n    } else {\n      // There is no intersection of two lines:\n      // center of the node as control point in bezier.\n      if (prevCoreIp && nextCoreIp) {\n        // both lines intersect with []:\n        // []x[line] as transit point.\n        pos = [prevCoreIp, nodePos, nextCoreIp]\n      } else if (prevNodeIp && nextNodeIp) {\n        // both lines intersect with []:\n        // []x[line] as transit point.\n        pos = [prevNodeIp, nodePos, nextNodeIp]\n      } else {\n        // either or both lines do not intersect the node:\n        // the end of the line as transit point.\n        pos = [prev.line.target, nodePos, next.line.source]\n      }\n    }\n\n    if (prev.curve) {\n      // ----------------------------------------------------\n      // Specify points on the curve.\n      // ----------------------------------------------------\n      // The starting point has already been added to `points`.\n      const lastPoints = points[points.length - 1]\n      if (lastPoints) {\n        const lastPoint =\n          lastPoints instanceof Array ? lastPoints[lastPoints.length - 1] : lastPoints\n        let nextPoint\n        if (pos instanceof Array) {\n          // Curved lines always end at the center of the node.\n          // To avoid smoothness, use only a transit point.\n          nextPoint = curveInNode ? pos[0] : pos[1]\n        } else {\n          nextPoint = pos\n        }\n        const control = v2d.calculateBezierCurveControlPoint(\n          lastPoint,\n          prev.curve.circle.center,\n          nextPoint,\n          prev.curve.theta\n        )\n        if (pos instanceof Array && curveInNode) {\n          points.push([...control, ...pos])\n        } else {\n          points.push([...control, nextPoint])\n        }\n      }\n    } else if (prev.loop) {\n      const [p1, p2, arc] = _makeArcString(nodePos, prev, nodeRadius)\n      points.push(p1)\n      points.push(arc)\n      if (pos instanceof Array && curveInNode) {\n        points.push([p2, pos[1], pos[2]])\n      } else {\n        points.push(pos[2])\n      }\n    } else {\n      if (curveInNode || !(pos instanceof Array)) {\n        points.push(pos)\n      } else {\n        if (next.curve) {\n          points.push(pos[1]) // use control point as transit point\n        } else if (next.loop) {\n          points.push(pos[0])\n        } else {\n          points.push(pos[0], pos[2]) // without control point to avoid smoothness\n        }\n      }\n    }\n  }\n\n  // ----------------------------------------------------\n  // Determine the terminate point.\n  // ----------------------------------------------------\n  {\n    const lastEdge = edgePos[edgePos.length - 1]\n    let nodeRadius = NodeUtils.getNodeRadius(nodeStates[lastEdge.target].shape) * scale\n    const lineMargin = margin + (pathEndType === \"edgeOfNode\" ? nodeRadius : 0)\n    const nextPoint =\n      lineMargin <= 0\n        ? lastEdge.line.target\n        : _calculateEdgeOfNode(lastEdge, lineMargin, nodeLayouts, false)\n    nodeRadius = NodeUtils.getNodeRadius(nodeStates[lastEdge.source].shape) * scale\n    if (lastEdge.loop) {\n      const nodePos = Vector2D.fromObject(nodeLayouts[lastEdge.target] ?? { x: 0, y: 0 })\n      const [p1, _, arc] = _makeArcString(nodePos, lastEdge, nodeRadius)\n      points.push(p1)\n      points.push(arc)\n    } else if (lastEdge.curve) {\n      // curve\n      const pos = points[points.length - 1]\n      const lastPoint = pos instanceof Array ? pos[pos.length - 1] : pos\n      const control = v2d.calculateBezierCurveControlPoint(\n        lastPoint,\n        lastEdge.curve.circle.center,\n        nextPoint,\n        lastEdge.curve.theta\n      )\n      points.push([...control, nextPoint])\n    } else {\n      // straight\n      points.push(nextPoint)\n    }\n    if (margin > 0) {\n      const distance = V.distance(lastEdge.line.source, lastEdge.line.target)\n      if (distance <= lineMargin + nodeRadius) {\n        isMarginOverRunEnd = true\n      }\n    }\n  }\n\n  if (isMarginOverRunStart) {\n    points.shift()\n    if (points[0] instanceof Array) {\n      points.unshift(points[0][0])\n    }\n  }\n  if (isMarginOverRunEnd) {\n    points.pop()\n  }\n\n  return points\n}\n\nexport function calculateDirectionsOfPathEdges(edges: EdgeObject[]): boolean[] {\n  const length = edges.length\n  if (length === 0) return []\n  if (length <= 1) return [true]\n\n  const directions: boolean[] = [] // true: forward, false: reverse\n  let lastNode: string | null = null\n  let isForward = true\n  for (let i = 0; i < length; i++) {\n    const source = edges[i].edge.source\n    const target = edges[i].edge.target\n    if (i === 0) {\n      if (length > 2) {\n        // If the next edge is an edge between the same nodes,\n        // check for more next edges.\n        const joint = _getJointNode(edges, 0)\n        if (joint === null) {\n          isForward = true\n        } else {\n          isForward = joint === target\n        }\n      } else {\n        isForward = [edges[1].edge.source, edges[1].edge.target].includes(target)\n      }\n    } else if (source === target) {\n      isForward = true // loop edge direction is always true\n    } else {\n      isForward = lastNode === source\n    }\n    directions.push(isForward)\n    lastNode = isForward ? target : source\n  }\n\n  return directions\n}\n\nfunction _getJointNode(edges: EdgeObject[], index: number): string | null {\n  const edgeObject0 = edges[index]\n  const edgeObject1 = edges[index + 1]\n  const currentEdge = [edgeObject0.edge.source, edgeObject0.edge.target].sort()\n  const nextEdge = [edgeObject1.edge.source, edgeObject1.edge.target].sort()\n\n  if (currentEdge[0] === currentEdge[1]) {\n    // current edge is looped\n    return currentEdge[0]\n  }\n\n  if (nextEdge[0] === nextEdge[1]) {\n    // next edge is looped\n    return nextEdge[0]\n  }\n\n  if (edgeObject0.edgeId === edgeObject1.edgeId || (currentEdge[0] === nextEdge[0] && currentEdge[1] === nextEdge[1])) {\n    // both edges are between same nodes\n    if (index >= edges.length - 2) {\n      // cannot be determined.\n      return null;\n    } else {\n      // check with next edge\n      const joint = _getJointNode(edges, index + 1)\n      if (joint === null) {\n        return null;\n      } else {\n        return joint === currentEdge[1] ? currentEdge[0] : currentEdge[1];\n      }\n    }\n  } else {\n    return nextEdge.includes(currentEdge[1]) ? currentEdge[1] : currentEdge[0]\n  }\n}\n\nfunction _calculateEdgeOfNode(\n  edge: EdgeLine,\n  nodeRadius: number,\n  nodeLayouts: NodePositions,\n  direction: boolean\n) {\n  const nodeId = direction ? edge.source : edge.target\n  const curve = edge.curve\n  if (curve) {\n    let moveRad = nodeRadius / curve.circle.radius\n    if (curve.theta > 0) {\n      moveRad *= -1\n    }\n    if (!direction) {\n      moveRad *= -1\n    }\n    return Vector2D.fromObject(\n      v2d.moveOnCircumference(\n        direction ? edge.line.source : edge.line.target,\n        curve.circle.center,\n        moveRad\n      )\n    )\n  } else {\n    let source: Vector2D, target: Vector2D\n    if (direction) {\n      source = edge.line.target\n      target = edge.line.source\n    } else {\n      source = edge.line.source\n      target = edge.line.target\n    }\n    // straight\n    if (nodeLayouts[nodeId]) {\n      const p = PointUtils.getIntersectionOfLineTargetAndCircle(\n        source,\n        target,\n        Vector2D.fromObject(nodeLayouts[nodeId]),\n        nodeRadius\n      )\n      return p === null ? source : p\n    } else {\n      return source\n    }\n  }\n}\n\nfunction _getIntersectionOfLines(\n  prev: EdgeLine,\n  next: EdgeLine,\n  nodePos: Vector2D\n): Vector2D | null {\n  let crossPoint: Vector2D | null = null\n  if (prev.loop || next.loop) {\n    crossPoint = null // not exist intersection point\n  } else if (prev.curve) {\n    if (next.curve) {\n      if (prev.line.target.isEqualTo(next.line.source)) {\n        return prev.line.target.clone()\n      }\n      // curve -- curve\n      crossPoint = PointUtils.getIntersectionOfCircles(\n        prev.curve.circle.center,\n        prev.curve.circle.radius,\n        next.curve.circle.center,\n        next.curve.circle.radius,\n        prev.curve.center\n      )\n    } else {\n      // curve -- straight\n      crossPoint = PointUtils.getIntersectionOfLineTargetAndCircle2(\n        next.line.target,\n        next.line.source,\n        prev.curve.circle.center,\n        prev.curve.circle.radius,\n        nodePos\n      )\n    }\n  } else {\n    if (next.curve) {\n      // straight -- curve\n      crossPoint = PointUtils.getIntersectionOfLineTargetAndCircle(\n        prev.line.source,\n        prev.line.target,\n        next.curve.circle.center,\n        next.curve.circle.radius\n      )\n    } else {\n      // straight -- straight\n      const prevSlope = _getSlope(prev.line)\n      const nextSlope = _getSlope(next.line)\n      const isParallel =\n        (!isFinite(prevSlope) && !isFinite(nextSlope)) || Math.abs(prevSlope - nextSlope) < EPSILON\n      if (isParallel) {\n        crossPoint = null // not exist intersection point\n      } else {\n        crossPoint = PointUtils.getIntersectionPointOfLines(prev.line, next.line)\n      }\n    }\n  }\n  return crossPoint\n}\n\nfunction _getIntersectionOfLineAndNode(\n  edge: EdgeLine,\n  nodeCenter: Vector2D,\n  nodeRadius: number,\n  targetSide: boolean\n): Vector2D | null {\n  if (edge.loop) {\n    const points = PointUtils.getIntersectionOfCircles(\n      nodeCenter,\n      nodeRadius,\n      edge.loop.center,\n      edge.loop.radius[0]\n    )\n    return points ? (targetSide ? points[0] : points[1]) : null\n  } else if (edge.curve) {\n    return PointUtils.getIntersectionOfCircles(\n      nodeCenter,\n      nodeRadius,\n      edge.curve.circle.center,\n      edge.curve.circle.radius,\n      Vector2D.fromObject(edge.curve.center)\n    )\n  } else {\n    return PointUtils.getIntersectionOfLineTargetAndCircle(\n      targetSide ? edge.line.source : edge.line.target,\n      targetSide ? edge.line.target : edge.line.source,\n      nodeCenter,\n      nodeRadius\n    )\n  }\n}\n\nfunction _getEdgeLine(edge: EdgeObject, direction: boolean, state: EdgeState): EdgeLine {\n  let position = state.origin\n  let source = edge.edge.source\n  let target = edge.edge.target\n  let curve = state.curve\n  const loop = state.loop\n  if (loop) {\n    position = state.position\n  } else if (!direction) {\n    position = LineUtils.inverseLine(position)\n    source = edge.edge.target\n    target = edge.edge.source\n    if (curve) {\n      curve = { ...curve, theta: -curve.theta }\n    }\n  }\n  const line = VectorLine.fromLinePosition(position)\n  const result: EdgeLine = {\n    edgeId: edge.edgeId,\n    source,\n    target,\n    line,\n    direction,\n    curve,\n    loop,\n  }\n  return result\n}\n\nfunction _getSlope(pos: VectorLine) {\n  return (pos.target.y - pos.source.y) / (pos.target.x - pos.source.x)\n}\n\nfunction _makeArcString(\n  nodePos: Vector2D,\n  edge: EdgeLine,\n  nodeRadius: number\n): [Vector2D, Vector2D, any] {\n  const { radius, center } = nonNull(edge.loop, \"Loop of edge parameter\")\n  const [rx, ry] = radius\n  const ends = PointUtils.getIntersectionOfCircles(nodePos, nodeRadius, center, radius[0])\n  let [end1, end2] = ends ? ends.reverse() : [edge.line.source, edge.line.target]\n  const isClockwise = _isForward(edge)\n  if (!isClockwise) {\n    [end1, end2] = [end2, end1]\n  }\n  const p1 = end1\n  const p2 = end2\n\n  const a1 = Vector2D.fromObject(p1).subtract(center).angleDegree()\n  const a2 = Vector2D.fromObject(p2).subtract(center).angleDegree()\n  const angle = (a2 + 360 - a1) % 360\n  let largeArc = angle >= 180 ? true : false\n  largeArc = isClockwise ? largeArc : !largeArc\n  const f1 = largeArc ? 1 : 0\n  const f2 = isClockwise ? 1 : 0\n\n  return [p1, p2, `A ${rx} ${ry} 0 ${f1} ${f2} ${p2.x} ${p2.y}`]\n}\n\nfunction _isForward(edge: EdgeLine) {\n  if (edge.loop) {\n    return edge.direction ? edge.loop.isClockwise : !edge.loop.isClockwise\n  } else {\n    return true\n  }\n}\n","// Management states of objects\n\nimport { computed, ComputedRef, reactive, Ref, unref, UnwrapRef, watch } from \"vue\"\nimport { Reactive } from \"@/common/common\"\nimport { Config, ObjectConfigs, ZOrderConfig } from \"@/common/configs\"\n\ntype Objects<T> = Record<string, T>\n\ninterface ObjectStateDatumBase {\n  id: string\n  selected: boolean\n  hovered: boolean\n  selectable: ComputedRef<boolean | number>\n  zIndex: ComputedRef<number>\n}\ntype ObjectState<S extends ObjectStateDatumBase> = UnwrapRef<S>\n\ntype PartiallyPartial<T, K extends keyof T> = Pick<T, K> & Partial<Omit<T, K>>\ntype NewStateDatum<T extends ObjectStateDatumBase> = PartiallyPartial<T, keyof ObjectStateDatumBase>\n\nexport function useObjectState<\n  T,\n  S extends ObjectStateDatumBase,\n  E extends { id: string; zIndex: number } = ObjectState<S>\n>(\n  objects: Ref<Record<string, T>>,\n  config: ObjectConfigs<T>,\n  selected: Reactive<Set<string>>,\n  hovered: Reactive<Set<string>>,\n  createState: (obj: Ref<Objects<T>>, id: string, state: NewStateDatum<S>) => void,\n  terminateState?: (id: string, state: ObjectState<S>) => void,\n  entriesForZOrder?: () => E[]\n): {\n  states: Record<string, ObjectState<S>>\n  zOrderedList: ComputedRef<E[]>\n} {\n  // Object states\n  const states: Record<string, ObjectState<S>> = reactive({})\n\n  // Handle object added/removed\n  watch(\n    () => new Set(Object.keys(objects.value)),\n    (idSet, prev) => {\n      if (!prev) prev = new Set([])\n      for (const id of idSet) {\n        if (prev.has(id)) continue\n        // object added\n        createNewState(objects, states, id, false, config, createState)\n        // adding to layouts is done by layout handler\n      }\n\n      for (const id of prev) {\n        if (idSet.has(id)) continue\n        // object removed\n        selected.delete(id)\n        hovered.delete(id)\n        terminateState?.(id, states[id] as ObjectState<S>)\n        delete states[id]\n      }\n    },\n    { immediate: true }\n  )\n\n  // Object selection\n  // - update `{obj}.selected` flag\n  watch(\n    () => [...selected],\n    (objects, prev) => {\n      const append = prev ? objects.filter(n => !prev.includes(n)) : objects\n      const removed = prev ? prev.filter(n => !objects.includes(n)) : []\n      append.forEach(id => {\n        const state = states[id]\n        if (state && !state.selected) state.selected = true\n      })\n      removed.forEach(id => {\n        const state = states[id]\n        if (state && state.selected) state.selected = false\n      })\n    },\n    { immediate: true } // for specified from the beginning\n  )\n\n  // - update `node.hovered` flag\n  watch(\n    () => [...hovered],\n    (nodes, prev) => {\n      const append = nodes.filter(n => !prev.includes(n))\n      const removed = prev.filter(n => !nodes.includes(n))\n      append.forEach(id => {\n        const state = states[id]\n        if (state && !state.hovered) state.hovered = true\n      })\n      removed.forEach(id => {\n        const state = states[id]\n        if (state && state.hovered) state.hovered = false\n      })\n    }\n  )\n\n  // z-order\n  // z-index applied Object List\n  const zOrderedList = computed(() => {\n    const list: E[] = entriesForZOrder ? entriesForZOrder() : (Object.values(states) as E[])\n    if (config.zOrder.enabled) {\n      return makeZOrderedList(list, config.zOrder, hovered, selected)\n    } else {\n      return list\n    }\n  })\n\n  return { states, zOrderedList }\n}\n\nfunction createNewState<T, S extends ObjectStateDatumBase>(\n  objects: Ref<Objects<T>>,\n  states: Record<string, ObjectState<S>>,\n  id: string,\n  selected: boolean,\n  config: ObjectConfigs<T>,\n  createState: (obj: Ref<Objects<T>>, id: string, state: NewStateDatum<S>) => void\n) {\n  const stateObject = <NewStateDatum<S>>{\n    id,\n    selected,\n    hovered: false,\n    selectable: computed(() => {\n      if (!objects.value[id]) return unref(stateObject.selectable) // Return the previous value\n      return Config.value(config.selectable, objects.value[id])\n    }),\n    zIndex: computed(() => {\n      if (!objects.value[id]) return unref(stateObject.zIndex) // Return the previous value\n      return Config.value(config.zOrder.zIndex, objects.value[id])\n    }),\n  }\n  states[id] = stateObject as ObjectState<S>\n  createState(objects, id, states[id] as NewStateDatum<S> /* get reactive object */)\n}\n\nfunction makeZOrderedList<S extends { id: string; zIndex: number }, T>(\n  states: S[],\n  zOrder: ZOrderConfig<T>,\n  hovered: Reactive<Set<string>>,\n  selected: Reactive<Set<string>>\n) {\n  if (zOrder.bringToFrontOnHover && zOrder.bringToFrontOnSelected) {\n    return states.sort((a, b) => {\n      const hover1 = hovered.has(a.id)\n      const hover2 = hovered.has(b.id)\n      if (hover1 != hover2) {\n        return hover1 ? 1 : -1\n      }\n      const selected1 = selected.has(a.id)\n      const selected2 = selected.has(b.id)\n      if (selected1 != selected2) {\n        return selected1 ? 1 : -1\n      }\n      return a.zIndex - b.zIndex\n    })\n  } else if (zOrder.bringToFrontOnHover) {\n    return states.sort((a, b) => {\n      const hover1 = hovered.has(a.id)\n      const hover2 = hovered.has(b.id)\n      if (hover1 != hover2) {\n        return hover1 ? 1 : -1\n      }\n      return a.zIndex - b.zIndex\n    })\n  } else if (zOrder.bringToFrontOnSelected) {\n    return states.sort((a, b) => {\n      const selected1 = selected.has(a.id)\n      const selected2 = selected.has(b.id)\n      if (selected1 != selected2) {\n        return selected1 ? 1 : -1\n      }\n      return a.zIndex - b.zIndex\n    })\n  } else {\n    return states.sort((a, b) => {\n      return a.zIndex - b.zIndex\n    })\n  }\n}\n","\nexport function convertToAscii(source: string): string {\n  if (typeof btoa === undefined) {\n    return Buffer.from(source).toString(\"base64\").replaceAll(\"=\", \"\")\n  } else {\n    return btoa(source).replaceAll(\"=\", \"\")\n  }\n}\n","import { reactive } from \"vue\"\nimport { MarkerStyle } from \"@/common/configs\"\nimport { convertToAscii } from \"@/utils/string\"\n\nexport type MarkerBuilder = (marker: MarkerStyle | null, isSource?: boolean) => string\n\nexport interface HeadMarker extends MarkerStyle {\n  color: string\n  isSource: boolean\n}\n\nexport interface MarkerState {\n  markers: Record<string, HeadMarker>\n  referenceCount: Record<string, number>\n}\n\nexport function makeMarkerState(): MarkerState {\n  const markers: Record<string, HeadMarker> = reactive({})\n  const referenceCount: Record<string, number> = {}\n  return { markers, referenceCount }\n}\n\nexport function useMarker(markerState: MarkerState) {\n  const { markers, referenceCount } = markerState\n\n  function addMarker(key: string, marker: HeadMarker) {\n    const m = referenceCount[key] ?? 0\n    referenceCount[key] = m + 1\n    if (!m) {\n      markers[key] = marker\n    }\n  }\n\n  function removeMarker(key: string) {\n    const m = referenceCount[key] ?? 0\n    if (m) {\n      if (m - 1 === 0) {\n        delete markers[key]\n        delete referenceCount[key]\n      } else {\n        referenceCount[key] = m - 1\n      }\n    }\n  }\n\n  function clearMarker(id: string | undefined) {\n    if (id) {\n      removeMarker(id)\n    }\n  }\n\n  function makeMarker(\n    marker: MarkerStyle,\n    isSource: boolean,\n    previousId: string | undefined,\n    strokeColor: string,\n    instanceId: number\n  ) {\n    if (marker.type === \"none\") {\n      clearMarker(previousId)\n      return undefined\n    }\n\n    if (marker.type === \"custom\") {\n      clearMarker(previousId)\n      return marker.customId\n    }\n\n    const headMarker = toHeadMarker(marker, isSource, strokeColor)\n    const id = buildKey(headMarker, instanceId)\n    if (id === previousId) {\n      return id\n    }\n    clearMarker(previousId)\n    addMarker(id, headMarker)\n    return id\n  }\n\n  return {\n    makeMarker,\n    clearMarker,\n  }\n}\n\nfunction toHeadMarker(marker: MarkerStyle, isSource: boolean, strokeColor: string) {\n  return {\n    ...marker,\n    color: marker.color ?? strokeColor,\n    isSource,\n  }\n}\n\nfunction buildKey(m: HeadMarker, instanceId: number) {\n  // If the same marker ID exists in the previous instance and is hidden by\n  // `display: none`, the marker in the other instance will disappear.\n  // For safety, marker IDs will be unique in the entire page.\n  const c = convertToAscii(m.color)\n  const d = m.isSource ? \"L\" : \"R\"\n  const u = m.units === \"strokeWidth\" ? \"rel\" : \"abs\"\n  return `marker_${instanceId}_${m.type}_${m.width}_${m.height}_${m.margin}_${m.offset}_${c}_${d}_${u}`\n}\n","// the states of nodes and edges\n\nimport { computed, ComputedRef, reactive, ref, Ref, toRef, unref } from \"vue\"\nimport { watch, watchEffect } from \"vue\"\nimport { inject, InjectionKey, provide } from \"vue\"\nimport { nonNull, Reactive } from \"@/common/common\"\nimport {\n  Config,\n  Configs,\n  EdgeConfig,\n  MarkerStyle,\n  NodeConfig,\n  OppositeNode,\n} from \"@/common/configs\"\nimport { StrokeStyle, ShapeStyle, SelfLoopEdgeStyle } from \"@/common/configs\"\nimport { Edge, Edges, Layouts, Node, Nodes, Path, Paths } from \"@/common/types\"\nimport { LinePosition, Position } from \"@/common/types\"\nimport { useId } from \"@/composables/id\"\nimport * as NodeModel from \"@/models/node\"\nimport * as EdgeModel from \"@/models/edge\"\nimport * as EdgeGroup from \"@/modules/edge/group\"\nimport * as PathModel from \"@/models/path\"\nimport * as v2d from \"@/modules/calculation/2d\"\nimport * as LineUtils from \"@/modules/calculation/line\"\nimport * as PointUtils from \"@/modules/calculation/point\"\nimport * as NodeUtils from \"@/modules/node/node\"\nimport { VectorLine } from \"@/modules/calculation/line\"\nimport { Vector2D } from \"@/modules/vector2d\"\nimport * as V2D from \"@/modules/vector2d\"\nimport { Point2D } from \"@/modules/vector2d/core\"\nimport { updateObjectDiff } from \"@/utils/object\"\nimport { calculateDirectionsOfPathEdges } from \"@/modules/calculation/path\"\nimport { useObjectState } from \"./objectState\"\nimport { MarkerState, useMarker } from \"./marker\"\n\n// -----------------------------------------------------------------------\n// Type definitions\n// -----------------------------------------------------------------------\n\nexport type { EdgeGroupStates } from \"@/models/edge\"\n\n// States of nodes\n\n// Provide states\n\ninterface States {\n  nodeStates: NodeModel.NodeStates\n  edgeStates: EdgeModel.EdgeStates\n  edgeGroupStates: EdgeModel.EdgeGroupStates\n  summarizedEdgeStates: EdgeModel.SummarizedEdgeStates\n  pathStates: PathModel.PathStates\n  nodeZOrderedList: ComputedRef<NodeModel.NodeState[]>\n  edgeZOrderedList: ComputedRef<EdgeModel.EdgeEntry[]>\n  pathZOrderedList: ComputedRef<PathModel.PathState[]>\n  layouts: Layouts\n}\n\nexport type ReadonlyStates = Readonly<States>\n\ninterface InputObjects<T> {\n  objects: Ref<T>\n  selected: Reactive<Set<string>>\n  hovered: Reactive<Set<string>>\n}\n\nexport function makeStateInput<T>(\n  objects: Ref<T>,\n  selected: Reactive<Set<string>>,\n  hovered: Reactive<Set<string>>\n) {\n  return {\n    objects,\n    selected,\n    hovered,\n  }\n}\n\n// -----------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------\n\nconst statesKey = Symbol(\"states\") as InjectionKey<States>\n\nconst NONE_MARKER: MarkerStyle = {\n  type: \"none\",\n  width: 0,\n  height: 0,\n  margin: 0,\n  offset: 0,\n  units: \"strokeWidth\",\n  color: null,\n}\n\n// -----------------------------------------------------------------------\n// Exported functions\n// -----------------------------------------------------------------------\n\nexport function provideStates(\n  nodes: InputObjects<Nodes>,\n  edges: InputObjects<Edges>,\n  paths: InputObjects<Paths>,\n  configs: Readonly<Configs>,\n  layouts: Reactive<Layouts>,\n  makerState: MarkerState,\n  scale: ComputedRef<number>\n) {\n  const summarizedEdgeStates: EdgeModel.SummarizedEdgeStates = reactive({})\n\n  // -----------------------------------------------------------------------\n  // States for nodes\n  // -----------------------------------------------------------------------\n\n  // { nodeId: { edgeId: opposingNodeId } }\n  const opposingNodes = Reactive<Record<string, Record<string, string>>>({})\n  watchEffect(() => {\n    const _nodes = Object.fromEntries(\n      Object.keys(nodes.objects.value).map(k => [k, {} as Record<string, string>])\n    )\n    Object.entries(edges.objects.value).forEach(([id, e]) => {\n      if (!_nodes?.[e.source]) _nodes[e.source] = {}\n      if (!_nodes?.[e.target]) _nodes[e.target] = {}\n      _nodes[e.source][id] = e.target\n      _nodes[e.target][id] = e.source\n    })\n    updateObjectDiff(opposingNodes, _nodes)\n  })\n\n  const {\n    states: nodeStates,\n    zOrderedList: nodeZOrderedList, //\n  } = useObjectState<Node, NodeModel.NodeStateDatum, NodeModel.NodeState>(\n    nodes.objects,\n    configs.node,\n    nodes.selected,\n    nodes.hovered,\n    (nodes, id, newState) => {\n      createNewNodeState(\n        nodes,\n        id,\n        newState as NodeModel.NodeStateDatum,\n        configs.node,\n        opposingNodes,\n        layouts\n      )\n    },\n    (nodeId, _state) => {\n      const positions = layouts.nodes\n      delete positions[nodeId]\n    }\n  )\n\n  // -----------------------------------------------------------------------\n  // States for edges\n  // -----------------------------------------------------------------------\n  // Instance ID number for using to make marker ID generation unique for the\n  // entire page.\n  // If the same marker ID exists in the previous instance and is hidden by\n  // `display: none`, the marker in the other instance will disappear.\n  // To be safe, markers should be unique in the entire page.\n  const instanceId = useId()\n\n  // grouping\n  const edgeGroupStates = EdgeGroup.makeEdgeGroupStates(nodes.objects, edges.objects, configs)\n\n  // edge entries for applying z-order\n  const edgeEntries = ref<EdgeModel.EdgeEntry[]>([])\n\n  const {\n    states: edgeStates,\n    zOrderedList: edgeZOrderedList, //\n  } = useObjectState<Edge, EdgeModel.EdgeStateDatum, EdgeModel.EdgeEntry>(\n    edges.objects,\n    configs.edge,\n    edges.selected,\n    edges.hovered,\n    (edges, id, newState) => {\n      createNewEdgeState(\n        edges,\n        id,\n        newState as EdgeModel.EdgeStateDatum,\n        configs.edge,\n        makerState,\n        nodeStates,\n        edgeGroupStates,\n        layouts,\n        scale,\n        instanceId\n      )\n    },\n    (_edgeId, state) => {\n      state.stopWatchHandle?.()\n    },\n    () => edgeEntries.value\n  )\n\n  // Edge item for display (an edge or summarized edges)\n  watchEffect(() => {\n    edgeEntries.value = createEdgeEntries(edgeGroupStates.edgeGroups, edgeStates)\n  })\n\n  watch(\n    edgeGroupStates.edgeGroups,\n    _ => createSummarizedEdgeStates(summarizedEdgeStates, edgeGroupStates, configs),\n    { immediate: true }\n  )\n\n  // -----------------------------------------------------------------------\n  // States for paths\n  // -----------------------------------------------------------------------\n\n  const {\n    states: pathStates,\n    zOrderedList: pathZOrderedList, //\n  } = useObjectState<Path, PathModel.PathStateDatum, PathModel.PathState>(\n    paths.objects,\n    configs.path,\n    paths.selected,\n    paths.hovered,\n    (paths, id, newState) => {\n      const state = newState as PathModel.PathStateDatum\n\n      state.clickable = computed(() => {\n        if (!paths.value[id]) return false\n        return Config.value(configs.path.clickable, paths.value[id])\n      })\n      state.hoverable = computed(() => {\n        if (!paths.value[id]) return false\n        return Config.value(configs.path.hoverable, paths.value[id])\n      })\n\n      state.path = paths.value[id]\n      state.edges = toEdgeObjects(state.path, edges)\n      state.directions = calculateDirectionsOfPathEdges(state.edges)\n\n      state.stopWatchHandle = watch(\n        () => paths.value[id].edges,\n        () => {\n          state.edges = toEdgeObjects(state.path, edges)\n          state.directions = calculateDirectionsOfPathEdges(state.edges)\n        }\n      )\n    },\n    (_, state) => {\n      state.stopWatchHandle?.()\n    }\n  )\n\n  const states = <States>{\n    nodeStates,\n    edgeStates,\n    edgeGroupStates,\n    summarizedEdgeStates,\n    pathStates,\n    layouts,\n    nodeZOrderedList,\n    edgeZOrderedList,\n    pathZOrderedList,\n  }\n  provide(statesKey, states)\n  return states\n}\n\nexport function isSummarizedEdges(item: EdgeModel.EdgeItem): item is EdgeModel.SummarizedEdgeItem {\n  return item.summarized\n}\n\nexport function useStates() {\n  return nonNull(inject(statesKey), \"states\") as ReadonlyStates\n}\n\n// -----------------------------------------------------------------------\n// Local functions\n// -----------------------------------------------------------------------\n\nfunction getNodeShape(node: Node, selected: boolean, hovered: boolean, config: NodeConfig) {\n  if (hovered && config.hover) {\n    return Config.values(config.hover, node)\n  } else {\n    return getNodeStaticShape(node, selected, config)\n  }\n}\n\nfunction getNodeStaticShape(node: Node, selected: boolean, config: NodeConfig) {\n  // get shape without hovered state\n  if (selected && config.selected) {\n    return Config.values(config.selected, node)\n  } else {\n    return Config.values(config.normal, node)\n  }\n}\n\nfunction createNewNodeState(\n  nodes: Ref<Nodes>,\n  id: string,\n  state: NodeModel.NodeStateDatum,\n  config: NodeConfig,\n  oppositeNodeIds: Reactive<Record<string, Record<string, string>>>,\n  layouts: Reactive<Layouts>\n) {\n  state.shape = computed(() => {\n    if (!nodes.value[id]) return unref(state.shape) // Return the previous value\n    return getNodeShape(nodes.value[id], state.selected, state.hovered, config)\n  })\n\n  state.staticShape = computed(() => {\n    if (!nodes.value[id]) return unref(state.staticShape) // Return the previous value\n    return getNodeStaticShape(nodes.value[id], state.selected, config)\n  })\n\n  state.label = computed(() => {\n    if (!nodes.value[id]) return unref(state.label) // Return the previous value\n    return Config.values(config.label, nodes.value[id])\n  })\n\n  state.labelText = computed(() => {\n    if (config.label.text instanceof Function) {\n      return unref(state.label).text\n    } else {\n      if (!nodes.value[id]) return unref(state.labelText) // Return the previous value\n      return nodes.value[id]?.[unref(state.label).text] ?? \"\"\n    }\n  })\n\n  state.draggable = computed(() => {\n    if (!nodes.value[id]) return unref(state.draggable) // Return the previous value\n    return Config.value(config.draggable, nodes.value[id])\n  })\n\n  state.oppositeNodeIds = toRef(oppositeNodeIds, id)\n\n  state.oppositeNodes = computed<Record<string, OppositeNode>>(() => {\n    return Object.entries(state.oppositeNodeIds).reduce(\n      (nodes, entry) => {\n        const [edgeId, nodeId] = entry as [string, string]\n        const pos = layouts.nodes[nodeId]\n        if (pos) nodes[edgeId] = { nodeId, pos: { ...pos } }\n        return nodes\n      },\n      {} as Record<string, OppositeNode>\n    )\n  })\n}\n\nfunction getEdgeStroke(edge: Edge, selected: boolean, hovered: boolean, config: EdgeConfig) {\n  if (selected) {\n    return Config.values(config.selected, edge)\n  } else if (hovered && config.hover) {\n    return Config.values(config.hover, edge)\n  } else {\n    return Config.values(config.normal, edge)\n  }\n}\n\nfunction toEdgeMarker(marker: MarkerStyle): MarkerStyle {\n  if (marker.type === \"none\") {\n    return NONE_MARKER\n  } else {\n    return marker\n  }\n}\n\nfunction createNewEdgeState(\n  edges: Ref<Edges>,\n  id: string,\n  state: EdgeModel.EdgeStateDatum,\n  config: EdgeConfig,\n  makerState: MarkerState,\n  nodeStates: NodeModel.NodeStates,\n  edgeGroupStates: Reactive<EdgeModel.EdgeGroupStates>,\n  layouts: Layouts,\n  scale: Ref<number>,\n  instanceId: number\n) {\n  const { makeMarker, clearMarker } = useMarker(makerState)\n\n  Object.assign(state, {\n    origin: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },\n    labelPosition: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },\n    position: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },\n  })\n\n  state.label = computed(() => {\n    if (!edges.value[id]) return unref(state.label) // Return the previous value\n    return Config.values(config.label, edges.value[id])\n  })\n\n  const line = computed<EdgeModel.Line>(() => {\n    const edge = edges.value[id]\n    const stroke = getEdgeStroke(edge, state.selected, state.hovered, config)\n    // Minimum error checking required for drawing\n    if (isNaN(+stroke.width)) {\n      console.warn(\n        \"[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]\",\n        id,\n        stroke.width\n      )\n      stroke.width = 1\n    }\n    if (stroke.color === undefined || stroke.color === null) {\n      console.warn(\n        \"[v-network-graph] Edge color is invalid value. id=[%s] value=[%s]\",\n        id,\n        stroke.color\n      )\n      stroke.color = \"#000000\"\n    }\n    let normalWidth = Config.value(config.normal.width, edge)\n    if (isNaN(+normalWidth)) {\n      normalWidth = 1\n    }\n    const source = toEdgeMarker(Config.values(config.marker.source, [edge, stroke]))\n    const target = toEdgeMarker(Config.values(config.marker.target, [edge, stroke]))\n    return { stroke, normalWidth, source, target }\n  })\n  state.line = line\n  const edgeLayoutPoint: Ref<EdgeModel.EdgeLayoutPoint | undefined> = toRef(\n    edgeGroupStates.edgeLayoutPoints,\n    id\n  )\n  const isEdgeSummarized: Ref<true | undefined> = toRef(edgeGroupStates.summarizedEdges, id)\n\n  const stopCalcHandle = watchEffect(() => {\n    const edge = edges.value[id]\n    if (!edge) return\n\n    const sourceShape = nodeStates[edge.source]?.staticShape\n    const targetShape = nodeStates[edge.target]?.staticShape\n    if (!sourceShape || !targetShape) {\n      return\n    }\n\n    const source = layouts.nodes[edge?.source] ?? { x: 0, y: 0 }\n    const target = layouts.nodes[edge?.target] ?? { x: 0, y: 0 }\n\n    // calculate the line segment between center of nodes\n    const shiftedPosition = EdgeGroup.calculateEdgeShiftedPosition(\n      edgeLayoutPoint.value,\n      isEdgeSummarized.value ?? false,\n      source,\n      target,\n      scale.value,\n      config.keepOrder\n    )\n\n    const [sourceShapeMargin, targetShapeMargin] =\n      v2d.calculateDistancesFromCenterOfNodeToEndOfNode(source, target, sourceShape, targetShape)\n\n    const s = scale.value\n\n    // calculate the line segment between the outermost of the nodes\n    state.labelPosition = LineUtils.applyMargin(\n      shiftedPosition,\n      sourceShapeMargin * s,\n      targetShapeMargin * s\n    )\n\n    // calculate margins\n    let sourceMargin = 0\n    let targetMargin = 0\n    const l = line.value\n    if (l.source.type !== \"none\") {\n      const marker = l.source\n      sourceMargin = marker.margin + marker.width\n      if (marker.units === \"strokeWidth\") {\n        sourceMargin *= l.normalWidth\n      }\n    }\n    if (l.target.type !== \"none\") {\n      const marker = l.target\n      targetMargin = marker.margin + marker.width\n      if (marker.units === \"strokeWidth\") {\n        targetMargin *= l.normalWidth\n      }\n    }\n\n    if (config.margin) {\n      sourceMargin += config.margin\n      targetMargin += config.margin\n    }\n\n    const isStartEdgeOfNode =\n      !!config.margin || l.source.type !== \"none\" || l.target.type !== \"none\"\n\n    // calculate self-loop edge\n    if (edge.source === edge.target) {\n      state.origin = LineUtils.toLinePosition(source, target)\n\n      const selfLoopStyle = Config.values(config.selfLoop, edge)\n      const [position, arc] = calculateArcPositionAndState(\n        source,\n        sourceShape,\n        selfLoopStyle,\n        isStartEdgeOfNode,\n        sourceMargin,\n        targetMargin,\n        edgeLayoutPoint.value?.pointInGroup ?? 0,\n        s\n      )\n      state.position = position\n      state.loop = arc\n      state.curve = undefined\n      return\n    } else {\n      state.loop = undefined\n    }\n\n    if (isStartEdgeOfNode) {\n      sourceMargin += sourceShapeMargin\n      targetMargin += targetShapeMargin\n    }\n\n    // calculate the line segments to be displayed with margins applied\n    const type = config.type\n    if (type === \"straight\" || isEdgeSummarized.value) {\n      state.origin = shiftedPosition\n      state.curve = undefined\n      if (sourceMargin === 0 && targetMargin === 0) {\n        state.position = state.origin\n      } else {\n        state.position = LineUtils.applyMargin(state.origin, sourceMargin * s, targetMargin * s)\n      }\n    } else {\n      // curve\n      state.origin = LineUtils.toLinePosition(source, target)\n\n      const shift = edgeLayoutPoint.value // undefined after node deletion\n        ? edgeLayoutPoint.value.groupWidth / 2 - edgeLayoutPoint.value.pointInGroup\n        : 0\n\n      const [position, curve] = calculateCurvePositionAndState(\n        state.origin,\n        shiftedPosition,\n        shift,\n        sourceMargin * s,\n        targetMargin * s\n      )\n      state.position = position\n      state.curve = curve\n    }\n  })\n\n  const stopUpdateMarkerHandle = watchEffect(() => {\n    if (!edges.value[id]) return\n    state.sourceMarkerId = makeMarker(\n      line.value.source,\n      true /* isSource */,\n      state.sourceMarkerId,\n      line.value.stroke.color,\n      instanceId\n    )\n    state.targetMarkerId = makeMarker(\n      line.value.target,\n      false /* isSource */,\n      state.targetMarkerId,\n      line.value.stroke.color,\n      instanceId\n    )\n  })\n\n  state.stopWatchHandle = () => {\n    stopCalcHandle()\n    stopUpdateMarkerHandle()\n    clearMarker(state.sourceMarkerId)\n    clearMarker(state.targetMarkerId)\n  }\n}\n\nfunction createEdgeEntries(\n  edgeGroups: Record<string, EdgeModel.EdgeGroup>,\n  edgeStates: EdgeModel.EdgeStates\n) {\n  return Object.entries(edgeGroups)\n    .map(([key, group]) => {\n      if (group.summarize) {\n        return <EdgeModel.SummarizedEdgeItem>{\n          id: Object.keys(group.edges)[0] ?? key,\n          summarized: true,\n          key,\n          group,\n          zIndex: Object.keys(group.edges)\n            .map(id => edgeStates[id]?.zIndex ?? 0)\n            .reduce((s, z) => Math.max(s, z)),\n        }\n      } else {\n        return Object.entries(group.edges).map(\n          ([id, edge]) =>\n            <EdgeModel.SingleEdgeItem>{\n              id,\n              summarized: false,\n              key: id,\n              edge,\n              zIndex: edgeStates[id]?.zIndex ?? 0,\n            }\n        )\n      }\n    })\n    .flat()\n}\n\nfunction calculateCurvePositionAndState(\n  originPosition: LinePosition,\n  shiftedPosition: LinePosition,\n  shift: number,\n  sourceMargin: number,\n  targetMargin: number\n): [LinePosition, EdgeModel.Curve | undefined] {\n  // The curve is assumed to be part of a perfect circle and is drawn\n  // as a Bezier curve.\n\n  const origin = VectorLine.fromLinePosition(originPosition)\n  const shifted = VectorLine.fromLinePosition(shiftedPosition)\n  const shiftedCenter = LineUtils.getCenterOfLinePosition(shiftedPosition)\n\n  // Calculate the center and radius of the circle of the curve.\n  const [center, radius] = v2d.calculateCircleCenterAndRadiusBy3Points(\n    origin.source,\n    origin.target,\n    shiftedCenter\n  )\n\n  let position: LinePosition\n  let curve: EdgeModel.Curve | undefined = undefined\n\n  if (radius === 0) {\n    return [originPosition, curve]\n  } else if (shift === 0) {\n    // The line connecting the centers of the nodes is regarded as a straight line.\n    if (sourceMargin === 0 && targetMargin === 0) {\n      position = originPosition\n    } else {\n      position = LineUtils.applyMargin(originPosition, sourceMargin, targetMargin)\n    }\n    return [position, curve]\n  }\n\n  // Apply margin to the line.\n  const centerToTop = VectorLine.fromVectors(center, shiftedCenter)\n\n  // Direction of rotation from source to center:\n  const theta0 = v2d.calculateRelativeAngleRadian(\n    VectorLine.fromVectors(center, origin.source),\n    centerToTop\n  )\n\n  if (sourceMargin === 0 && targetMargin === 0) {\n    position = originPosition\n  } else {\n    // The endpoints of the display line are the point on the circumference\n    // moved by the margin from the origin end points.\n    let sourceMoveRad = sourceMargin / radius\n    let targetMoveRad = targetMargin / radius\n\n    // Determine which direction to move.\n    if (theta0 > 0) {\n      sourceMoveRad *= -1\n      targetMoveRad *= -1\n    }\n    position = LineUtils.toLinePosition(\n      v2d.moveOnCircumference(origin.source, center, sourceMoveRad),\n      v2d.moveOnCircumference(origin.target, center, -targetMoveRad)\n    )\n\n    // If the endpoints are swapped by applying the margin,\n    // a short line is shown at the center.\n    let theta1 = v2d.calculateRelativeAngleRadian(\n      VectorLine.fromVectors(center, origin.source),\n      VectorLine.fromVectors(center, origin.target)\n    )\n    let theta2 = v2d.calculateRelativeAngleRadian(\n      VectorLine.fromPositions(center, position.p1),\n      VectorLine.fromPositions(center, position.p2)\n    )\n    if (theta0 * theta1 < 0) {\n      theta1 = v2d.reverseAngleRadian(theta1)\n      if (theta0 * theta2 < 0) {\n        theta2 = v2d.reverseAngleRadian(theta2)\n      }\n    }\n    if (theta1 * theta2 < 0) {\n      // reversed\n      const c = shiftedCenter.clone().add(shifted.v.normalize().multiplyScalar(0.5))\n      position = LineUtils.toLinePosition(shiftedCenter, c)\n      return [position, curve]\n    }\n  }\n\n  // Calculate the control/via points of a Bezier curve.\n  const [p1, p2] = LineUtils.toVectorsFromLinePosition(position)\n  const control = v2d\n    .calculateBezierCurveControlPoint(p1, center, p2, theta0)\n    .map(p => p.toObject())\n\n  curve = {\n    center: shiftedCenter,\n    theta: theta0,\n    circle: { center, radius },\n    control,\n  }\n  return [position, curve]\n}\n\nfunction calculateArcPositionAndState(\n  nodePos: Position,\n  nodeShape: ShapeStyle,\n  selfLoopStyle: SelfLoopEdgeStyle,\n  isStartEdgeOfNode: boolean,\n  sourceMargin: number,\n  targetMargin: number,\n  pointInGroup: number,\n  scale: number\n): [LinePosition, EdgeModel.Arc] {\n  const s = scale\n\n  // calculate the center position of the Arc\n  const radius = (selfLoopStyle.radius + pointInGroup / 2) * s\n  const d = selfLoopStyle.offset * s + radius\n  const rad = (selfLoopStyle.angle - 90) * (Math.PI / 180)\n  const center = Vector2D.fromObject({\n    x: nodePos.x + d * Math.cos(rad),\n    y: nodePos.y + d * Math.sin(rad),\n  })\n\n  const isClockwise = selfLoopStyle.isClockwise\n\n  let p1: Point2D | undefined, p2: Point2D | undefined\n  if (isStartEdgeOfNode) {\n    const intersects = PointUtils.getIntersectionOfCircles(\n      center,\n      radius,\n      Vector2D.fromObject(nodePos),\n      NodeUtils.getNodeRadius(nodeShape) * s\n    )\n    if (intersects) {\n      [p1, p2] = intersects\n      let direction = 1\n      if (!isClockwise) {\n        [p1, p2] = [p2, p1]\n        direction = -1\n      }\n      if (sourceMargin !== 0 || targetMargin !== 0) {\n        const sourceMoveRad = ((sourceMargin * s) / radius) * direction\n        const targetMoveRad = ((targetMargin * s) / radius) * direction\n        p1 = v2d.moveOnCircumference(p1, center, sourceMoveRad)\n        p2 = v2d.moveOnCircumference(p2, center, -targetMoveRad)\n      }\n    }\n  }\n  if (p1 === undefined || p2 === undefined) {\n    const radiusLine = Vector2D.fromObject(nodePos)\n      .subtract(center)\n      .normalize()\n      .multiplyScalar(radius)\n    let rad = 1 * (Math.PI / 180)\n    if (!isClockwise) rad *= -1\n    p1 = center.clone().add(V2D.rotate(radiusLine, rad))\n    p2 = center.clone().add(V2D.rotate(radiusLine, -rad))\n  }\n  const a1 = Vector2D.fromObject(p1).subtract(center).angleDegree()\n  const a2 = Vector2D.fromObject(p2).subtract(center).angleDegree()\n  const angle = (a2 + 360 - a1) % 360\n\n  const isLargeArc = angle >= 180 ? true : false\n  return [\n    { p1, p2 },\n    {\n      center,\n      radius: [radius, radius],\n      isLargeArc: isClockwise ? isLargeArc : !isLargeArc,\n      isClockwise,\n    },\n  ]\n}\n\nfunction createSummarizedEdgeStates(\n  summarizedEdgeStates: EdgeModel.SummarizedEdgeStates,\n  edgeGroupStates: Reactive<EdgeModel.EdgeGroupStates>,\n  configs: Configs\n) {\n  const groups = edgeGroupStates.edgeGroups\n  Object.entries(groups)\n    .filter(([id, group]) => group.summarize && !(id in summarizedEdgeStates))\n    .forEach(([id, group]) => {\n      const state = { stroke: undefined as any }\n      state.stroke = computed<StrokeStyle>(() =>\n        Config.values(configs.edge.summarized.stroke, group.edges)\n      )\n      summarizedEdgeStates[id] = state\n    })\n  Object.keys(summarizedEdgeStates).forEach(id => {\n    if (!edgeGroupStates.edgeGroups[id]?.summarize) {\n      delete summarizedEdgeStates[id]\n    }\n  })\n}\n\nfunction toEdgeObjects(path: Path, edges: InputObjects<Edges>) {\n  return path.edges\n    .map(edgeId => ({ edgeId, edge: edges.objects.value[edgeId] }))\n    .filter(e => e.edge)\n}\n","\nexport class MapUtil {\n  static valueOf<K, V>(map: Map<K, V>) {\n    return Array.from(map.values())\n  }\n}\n","import { Ref } from \"vue\"\nimport { Position, ViewMode } from \"@/common/types\"\n\nconst MOUSE_MOVE_DETECTION_THRESHOLD = 3 // Sensitivity to start dragging\nconst TOUCH_MOVE_DETECTION_THRESHOLD = 6 // Sensitivity to start dragging in touches\nexport const DOUBLE_CLICK_THRESHOLD = 500\n\nexport type SelectionMode = \"container\" | \"node\" | \"edge\" | \"path\"\n\n// state for each pointer of multi touch\nexport interface NodePointerState {\n  pointerId: number // pointer ID provided by the event\n  nodeId: string // pointer down node ID\n  moveCounter: number // count for pointermove event occurred\n  dragBasePosition: Position // drag started position\n  nodeBasePosition: Position // node position at drag started\n  latestPosition: Position // latest position\n  eventTarget: EventTarget | null // event target\n}\n\nexport interface EdgePointerState {\n  pointerId: number // pointer ID provided by the event\n  id: string | string[] // pointer down edge ID\n  eventTarget: EventTarget | null // event target\n}\n\nexport interface PathPointerState {\n  pointerId: number // pointer ID provided by the event\n  id: string // pointer down path ID\n  eventTarget: EventTarget | null // event target\n}\n\nexport interface ClickState {\n  lastTime: number\n  count: number\n  id: string // clicked object ID\n}\n\nexport interface InteractionModes {\n  selectionMode: Ref<SelectionMode>\n  viewMode: Ref<ViewMode>\n}\n\nexport function getPointerMoveDetectionThreshold(type: string): number {\n  return type === \"touch\" ? TOUCH_MOVE_DETECTION_THRESHOLD : MOUSE_MOVE_DETECTION_THRESHOLD\n}\n\nexport function detectClicks(\n  clickStates: Map<number, ClickState>,\n  pointerId: number,\n  id: string,\n  event: MouseEvent,\n): [MouseEvent, MouseEvent | undefined] {\n  // search click states\n  let clickState = clickStates.get(pointerId)\n  if (clickState) {\n    if (clickState.id !== id) {\n      // click an other object\n      clickState = undefined\n    }\n  } else {\n    const idAndState = Array.from(clickStates.entries()).find(([_, state]) => state.id === id)\n    if (idAndState) {\n      const [oldPointerId, state] = idAndState\n      clickStates.delete(oldPointerId)\n      clickState = state\n    }\n  }\n\n  let clickEvent: MouseEvent, doubleClickEvent: MouseEvent | undefined\n  [clickState, clickEvent, doubleClickEvent] = createClickEvents(clickState, event, id)\n\n  // update\n  clickStates.set(pointerId, clickState)\n\n  return [ clickEvent, doubleClickEvent ]\n}\n\nexport function createClickEvents(\n  clickState: ClickState | undefined,\n  event: MouseEvent,\n  id: string\n): [ClickState, MouseEvent, MouseEvent | undefined] {\n  const now = Date.now()\n  if (clickState && now - clickState.lastTime <= DOUBLE_CLICK_THRESHOLD) {\n    // continuous clicked\n    clickState.count++\n    clickState.lastTime = now\n  } else {\n    // single clicked\n    clickState = { count: 1, lastTime: now, id }\n  }\n\n  const initDict = {\n    view: window,\n    screenX: event.screenX,\n    screenY: event.screenY,\n    clientX: event.clientX,\n    clientY: event.clientY,\n    ctrlKey: event.ctrlKey,\n    shiftKey: event.shiftKey,\n    altKey: event.altKey,\n    metaKey: event.metaKey,\n    button: event.button,\n    buttons: event.buttons,\n    detail: clickState.count,\n  }\n\n  let clickEvent: MouseEvent\n  let doubleClickEvent: MouseEvent | undefined = undefined\n  if (event instanceof PointerEvent) {\n    Object.assign(initDict, {\n      pointerId: event.pointerId,\n      width: event.width,\n      height: event.height,\n      pressure: event.pressure,\n      tangentialPressure: event.tangentialPressure,\n      tiltX: event.tiltX,\n      tiltY: event.tiltY,\n      twist: event.twist,\n      pointerType: event.pointerType,\n      isPrimary: event.isPrimary,\n    })\n    clickEvent = new PointerEvent(\"click\", initDict)\n    if (clickState.count === 2) {\n      doubleClickEvent = new PointerEvent(\"dblclick\", initDict)\n    }\n  } else {\n    clickEvent = new MouseEvent(\"click\", initDict)\n    if (clickState.count === 2) {\n      doubleClickEvent = new MouseEvent(\"dblclick\", initDict)\n    }\n  }\n\n  return [clickState, clickEvent, doubleClickEvent]\n}\n\nexport function cleanClickState(states: Map<number, ClickState>) {\n  const now = Date.now()\n  Array.from(states.entries())\n    .filter(([_, state]) => now - state.lastTime > DOUBLE_CLICK_THRESHOLD)\n    .map(([pointerId, _]) => states.delete(pointerId))\n}\n","import { watch } from \"vue\"\nimport { Emitter } from \"mitt\"\nimport { Reactive, ReadonlyRef } from \"@/common/common\"\nimport { Events, Layouts, NodePositions, Position } from \"@/common/types\"\nimport { NodeStates } from \"@/models/node\"\nimport { entriesOf } from \"@/utils/object\"\nimport { MapUtil } from \"@/utils/map\"\nimport {\n  cleanClickState,\n  ClickState,\n  detectClicks,\n  getPointerMoveDetectionThreshold,\n  InteractionModes,\n  NodePointerState,\n} from \"./core\"\n\ntype PointerPosition = Pick<PointerEvent, \"pageX\" | \"pageY\" | \"pointerId\">\n\ninterface NodeInteractionState {\n  pointers: Map<number, NodePointerState> // <PointerId, ...>\n  follow: {\n    followedPointerId: number\n    nodeBasePositions: { [name: string]: Position }\n  }\n  hoveredNodesPre: Set<string> // to keep the hover state while dragging\n  clicks: Map<number, ClickState> // <PointerId, ...>\n}\n\nexport function makeNodeInteractionHandlers(\n  nodeStates: NodeStates,\n  layouts: Readonly<Layouts>,\n  modes: InteractionModes,\n  hoveredNodes: Reactive<Set<string>>,\n  selectedNodes: Reactive<Set<string>>,\n  zoomLevel: ReadonlyRef<number>,\n  emitter: Emitter<Events>\n) {\n  const state: NodeInteractionState = {\n    pointers: new Map(),\n    follow: {\n      followedPointerId: -1,\n      nodeBasePositions: {},\n    },\n    hoveredNodesPre: new Set(),\n    clicks: new Map(),\n  }\n\n  const nodePointerHandlers = {\n    pointermove: handleNodePointerMoveEvent,\n    pointerup: handleNodePointerUpEvent,\n    pointercancel: handleNodePointerCancelEvent,\n  }\n\n  function _updateFollowNodes(pointerState: NodePointerState) {\n    const isFollowed = state.follow.followedPointerId === pointerState.pointerId\n    const isSelectedNode = selectedNodes.has(pointerState.nodeId)\n\n    const removed = !(pointerState.pointerId in state.pointers)\n    if ((isFollowed && removed) || (isFollowed && !isSelectedNode)) {\n      // selected => unselected\n      const candidate = MapUtil.valueOf(state.pointers).find(p => selectedNodes.has(p.nodeId))\n      if (!candidate) {\n        state.follow = { followedPointerId: -1, nodeBasePositions: {} }\n        return\n      }\n      pointerState = candidate\n      state.follow.followedPointerId = pointerState.pointerId\n    } else {\n      const followed = state.pointers.get(state.follow.followedPointerId)\n      if (!followed) {\n        state.follow = { followedPointerId: -1, nodeBasePositions: {} }\n        return\n      }\n      pointerState = followed\n    }\n\n    if (isFollowed || isSelectedNode) {\n      // reset state for following:\n      // followed by selected nodes without user grabs\n      const userGrabs = MapUtil.valueOf(state.pointers).map(n => n.nodeId)\n      state.follow.nodeBasePositions = Object.fromEntries(\n        Array.from(selectedNodes)\n          .filter(n => !userGrabs.includes(n))\n          .filter(n => nodeStates[n]?.draggable)\n          .map(n => [n, _unwrapNodePosition(layouts.nodes, n)])\n      )\n      pointerState.dragBasePosition = { ...pointerState.latestPosition }\n      pointerState.nodeBasePosition = _unwrapNodePosition(layouts.nodes, pointerState.nodeId)\n    }\n  }\n\n  watch(selectedNodes, selected => {\n    const pointerState = state.pointers.get(state.follow.followedPointerId)\n    if (pointerState) {\n      _updateFollowNodes(pointerState)\n    }\n    if (selected.size > 0 && modes.selectionMode.value !== \"node\") {\n      modes.selectionMode.value = \"node\"\n    } else if (selected.size === 0 && modes.selectionMode.value === \"node\") {\n      modes.selectionMode.value = \"container\"\n    }\n  })\n\n  watch(modes.selectionMode, mode => {\n    if (mode !== \"node\") {\n      selectedNodes.clear()\n    }\n  })\n\n  function _calculateNodeNewPosition(pointerState: NodePointerState, event: PointerPosition) {\n    const dx = pointerState.dragBasePosition.x - event.pageX\n    const dy = pointerState.dragBasePosition.y - event.pageY\n    const positions =\n      state.follow.followedPointerId == pointerState.pointerId\n        ? {\n            [pointerState.nodeId]: pointerState.nodeBasePosition,\n            ...state.follow.nodeBasePositions,\n          }\n        : { [pointerState.nodeId]: pointerState.nodeBasePosition }\n    const z = zoomLevel.value\n\n    return Object.fromEntries(\n      Object.entries(positions).map(([node, pos]) => [\n        node,\n        {\n          x: pos.x - dx / z,\n          y: pos.y - dy / z,\n        },\n      ])\n    )\n  }\n\n  function handleNodeClickEvent(node: string, event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    // When a finger is placed on any object and another object is tapped,\n    // no click event is fired. Thus, click events are emulated by using\n    // pointerdown/up. The following is processing for emulated events only.\n\n    if (event.shiftKey && ![\"container\", \"node\"].includes(modes.selectionMode.value)) {\n      return\n    }\n    modes.selectionMode.value = \"node\"\n\n    const selectable = nodeStates[node]?.selectable ?? false\n    if (selectable) {\n      const isTouchAnySelectedNode =\n        MapUtil.valueOf(state.pointers).filter(p => selectedNodes.has(p.nodeId)).length > 0\n      if (event.shiftKey || isTouchAnySelectedNode) {\n        // select multiple nodes\n        if (selectedNodes.has(node)) {\n          selectedNodes.delete(node)\n        } else if (!(typeof selectable === \"number\" && selectedNodes.size >= selectable)) {\n          selectedNodes.add(node)\n        }\n      } else if (!selectedNodes.has(node)) {\n        // make the selectedNodes the clicked one\n        selectedNodes.clear()\n        selectedNodes.add(node)\n      }\n    }\n    emitter.emit(\"node:click\", { node, event })\n  }\n\n  function handleNodeDoubleClickEvent(node: string, event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    emitter.emit(\"node:dblclick\", { node, event })\n  }\n\n  function handleNodePointerMoveEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n    pointerState.latestPosition = { x: event.pageX, y: event.pageY }\n    pointerState.moveCounter++\n\n    const threshold = getPointerMoveDetectionThreshold(event.pointerType)\n    if (pointerState.moveCounter <= threshold) {\n      return // pending for click and drag distinguish\n    }\n\n    if (!nodeStates[pointerState.nodeId]?.draggable) {\n      return\n    }\n\n    if (pointerState.moveCounter === threshold + 1) {\n      const draggingNodes = _calculateNodeNewPosition(pointerState, {\n        pointerId: pointerState.pointerId,\n        pageX: pointerState.dragBasePosition.x,\n        pageY: pointerState.dragBasePosition.y,\n      })\n      emitter.emit(\"node:dragstart\", draggingNodes)\n    }\n    const draggingNodes = _calculateNodeNewPosition(pointerState, event)\n    emitter.emit(\"node:pointermove\", draggingNodes)\n  }\n\n  function handleNodePointerCancelEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    let pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    for (pointerState of state.pointers.values()) {\n      const node = pointerState.nodeId\n\n      const threshold = getPointerMoveDetectionThreshold(event.pointerType)\n      const isMoved = pointerState.moveCounter > threshold\n      if (isMoved) {\n        // pageX/Y in cancel event are zero => use latest position\n        const draggingNodes = _calculateNodeNewPosition(pointerState, {\n          pointerId: pointerState.pointerId,\n          pageX: pointerState.latestPosition.x,\n          pageY: pointerState.latestPosition.y,\n        })\n        emitter.emit(\"node:dragend\", draggingNodes)\n      }\n      emitter.emit(\"node:pointerup\", { node, event })\n    }\n\n    // reset state\n    state.pointers.clear()\n    state.follow = { followedPointerId: -1, nodeBasePositions: {} }\n    entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {\n      document.removeEventListener(ev, handler)\n    })\n    modes.viewMode.value = \"default\"\n  }\n\n  function handleNodePointerUpEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    state.pointers.delete(event.pointerId)\n\n    const node = pointerState.nodeId\n\n    const threshold = getPointerMoveDetectionThreshold(event.pointerType)\n    const isMoved = pointerState.moveCounter > threshold\n    if (isMoved) {\n      if (nodeStates[pointerState.nodeId]?.draggable) {\n        const draggingNodes = _calculateNodeNewPosition(pointerState, event)\n        emitter.emit(\"node:dragend\", draggingNodes)\n        emitter.emit(\"node:pointerup\", { node, event })\n      }\n    } else {\n      emitter.emit(\"node:pointerup\", { node, event })\n    }\n\n    if (!isMoved /* Don't fire the click event if the node is being dragged */) {\n      // click handling\n      const [clickEvent, doubleClickEvent] = detectClicks(\n        state.clicks,\n        pointerState.pointerId,\n        node,\n        event\n      )\n      pointerState.eventTarget?.dispatchEvent(clickEvent)\n      if (doubleClickEvent) {\n        pointerState.eventTarget?.dispatchEvent(doubleClickEvent)\n      }\n    }\n\n    if (state.pointers.size === 0) {\n      // re-initialize state\n      state.follow = { followedPointerId: -1, nodeBasePositions: {} }\n      entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler)\n      })\n      cleanClickState(state.clicks)\n      modes.viewMode.value = \"default\"\n    } else {\n      _updateFollowNodes(pointerState)\n    }\n\n    // reflect changes while dragging.\n    hoveredNodes.clear()\n    state.hoveredNodesPre.forEach(hoveredNodes.add, hoveredNodes)\n  }\n\n  function handleNodePointerDownEvent(node: string, event: PointerEvent) {\n    if (event.button == 2 /* right button */) {\n      return\n    }\n    event.stopPropagation()\n\n    if (![\"default\", \"node\"].includes(modes.viewMode.value)) {\n      return\n    }\n\n    if (state.pointers.size == 0) {\n      // Add event listeners\n      modes.viewMode.value = \"node\"\n      entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler)\n      })\n    }\n\n    // Create new pointer state\n    const pointerState: NodePointerState = {\n      pointerId: event.pointerId,\n      nodeId: node,\n      moveCounter: 0,\n      nodeBasePosition: _unwrapNodePosition(layouts.nodes, node),\n      dragBasePosition: { x: event.pageX, y: event.pageY },\n      latestPosition: { x: event.pageX, y: event.pageY },\n      eventTarget: event.currentTarget,\n    }\n    state.pointers.set(event.pointerId, pointerState)\n\n    if (selectedNodes.has(node)) {\n      if (state.follow.followedPointerId < 0) {\n        // pointer followed by selected nodes\n        state.follow.followedPointerId = event.pointerId\n        _updateFollowNodes(pointerState)\n      } else {\n        // current pointer is in charge of this node.\n        // do not follow another node anymore.\n        delete state.follow.nodeBasePositions[pointerState.nodeId]\n      }\n    }\n\n    emitter.emit(\"node:pointerdown\", { node, event })\n  }\n\n  function handleNodePointerOverEvent(node: string, event: PointerEvent) {\n    state.hoveredNodesPre.add(node)\n    if (state.pointers.size > 0) {\n      return // dragging\n    }\n    hoveredNodes.add(node)\n    emitter.emit(\"node:pointerover\", { node, event })\n  }\n\n  function handleNodePointerOutEvent(node: string, event: PointerEvent) {\n    state.hoveredNodesPre.delete(node)\n    if (state.pointers.size > 0) {\n      return // dragging\n    }\n    hoveredNodes.delete(node)\n    emitter.emit(\"node:pointerout\", { node, event })\n  }\n\n  function handleNodeContextMenu(node: string, event: MouseEvent) {\n    event.stopPropagation()\n    emitter.emit(\"node:contextmenu\", { node, event })\n  }\n\n  return {\n    handleNodePointerDownEvent,\n    handleNodePointerOverEvent,\n    handleNodePointerOutEvent,\n    handleNodeClickEvent,\n    handleNodeDoubleClickEvent,\n    handleNodeContextMenu,\n  }\n}\n\nfunction _unwrapNodePosition(nodes: Readonly<NodePositions>, node: string) {\n  const pos = nodes[node] ?? { x: 0, y: 0 }\n  return { ...pos } // unwrap reactivity\n}\n","import { watch } from \"vue\"\nimport { Emitter } from \"mitt\"\nimport { Reactive } from \"@/common/common\"\nimport { Events, EdgeEvent } from \"@/common/types\"\nimport { EdgeStates } from \"@/models/edge\"\nimport { entriesOf } from \"@/utils/object\"\nimport { MapUtil } from \"@/utils/map\"\nimport {\n  cleanClickState,\n  ClickState,\n  detectClicks,\n  EdgePointerState,\n  InteractionModes,\n} from \"./core\"\n\nexport function makeEdgeInteractionHandlers(\n  edgeStates: EdgeStates,\n  modes: InteractionModes,\n  hoveredEdges: Reactive<Set<string>>,\n  selectedEdges: Reactive<Set<string>>,\n  emitter: Emitter<Events>\n) {\n  const state = {\n    pointers: new Map<number, EdgePointerState>(), // <PointerId, ...>\n    pointerPeekCount: 0,\n    clicks: new Map<number, ClickState>(),\n  }\n\n  const edgePointerHandlers = {\n    pointerup: handleEdgePointerUpEvent,\n    pointercancel: handleEdgePointerCancelEvent,\n  }\n\n  watch(selectedEdges, selected => {\n    if (selected.size > 0 && modes.selectionMode.value !== \"edge\") {\n      modes.selectionMode.value = \"edge\"\n    } else if (selected.size === 0 && modes.selectionMode.value === \"edge\") {\n      modes.selectionMode.value = \"container\"\n    }\n  })\n\n  watch(modes.selectionMode, mode => {\n    if (mode !== \"edge\") {\n      selectedEdges.clear()\n    }\n  })\n\n  function handleEdgePointerDownEvent(edge: string, event: PointerEvent) {\n    if (event.button == 2 /* right button */) {\n      return\n    }\n    event.stopPropagation()\n\n    if (![\"default\", \"edge\"].includes(modes.viewMode.value)) {\n      return\n    }\n\n    if (state.pointers.size == 0) {\n      // Add event listeners\n      modes.viewMode.value = \"edge\"\n      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler)\n      })\n      state.pointerPeekCount = 0\n    }\n\n    state.pointerPeekCount++\n\n    // Create new pointer state\n    const pointerState: EdgePointerState = {\n      pointerId: event.pointerId,\n      id: edge,\n      eventTarget: event.currentTarget,\n    }\n    state.pointers.set(event.pointerId, pointerState)\n\n    emitter.emit(\"edge:pointerdown\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgePointerUpEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    state.pointers.delete(event.pointerId)\n\n    const edge = pointerState.id\n    emitter.emit(\"edge:pointerup\", _makeEdgeEventObject(edge, event))\n\n    // click handling\n    const [clickEvent, doubleClickEvent] = detectClicks(\n      state.clicks,\n      pointerState.pointerId,\n      edge instanceof Array ? edge.join(\",\") : edge,\n      event,\n    )\n    pointerState.eventTarget?.dispatchEvent(clickEvent)\n    if (doubleClickEvent) {\n      pointerState.eventTarget?.dispatchEvent(doubleClickEvent)\n    }\n\n    if (state.pointers.size === 0) {\n      // reset state\n      state.pointerPeekCount = 0\n      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler)\n      })\n      cleanClickState(state.clicks)\n      modes.viewMode.value = \"default\"\n    }\n  }\n\n  function handleEdgePointerCancelEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    for (const pointerState of state.pointers.values()) {\n      const edge = pointerState.id\n      emitter.emit(\"edge:pointerup\", _makeEdgeEventObject(edge, event))\n    }\n\n    // reset state\n    state.pointers.clear()\n    state.pointerPeekCount = 0\n    entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n      document.removeEventListener(ev, handler)\n    })\n    emitter.emit(\"view:mode\", \"default\")\n  }\n\n  function handleEdgeClickEvent(edge: string | string[], event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    // When a finger is placed on any object and another object is tapped,\n    // no click event is fired. Thus, click events are emulated by using\n    // pointerdown/up. The following is processing for emulated events only.\n\n    if (event.shiftKey && ![\"container\", \"edge\"].includes(modes.selectionMode.value)) {\n      return\n    }\n    modes.selectionMode.value = \"edge\"\n\n    const edges = edge instanceof Array ? edge : [edge]\n\n    const isTouchAnySelectedEdge =\n      MapUtil.valueOf(state.pointers).filter(p => {\n        const edges = p.id instanceof Array ? p.id : [p.id]\n        return edges.every(edge => selectedEdges.has(edge))\n      }).length > 0\n\n    if (edge instanceof Array) {\n      // select only selectable edge\n      const selectableEdges = edges.find(edge => edgeStates[edge]?.selectable)\n      if (selectableEdges) {\n        if (event.shiftKey || isTouchAnySelectedEdge) {\n          if (edges.some(edge => selectedEdges.has(edge))) {\n            edges.forEach(edge => selectedEdges.delete(edge))\n          } else {\n            edges.forEach(edge => {\n              const selectable = edgeStates[edge]?.selectable\n              if (!(typeof selectable === \"number\" && selectedEdges.size >= selectable)) {\n                selectedEdges.add(edge)\n              }\n            })\n          }\n        } else {\n          // make the selectedEdges the clicked summarized one\n          selectedEdges.clear()\n          edges.forEach(edge => selectedEdges.add(edge))\n        }\n      }\n    } else {\n      const selectable = edgeStates[edge]?.selectable\n      if (selectable) {\n        if (event.shiftKey || isTouchAnySelectedEdge) {\n          if (selectedEdges.has(edge)) {\n            selectedEdges.delete(edge)\n          } else if (!(typeof selectable === \"number\" && selectedEdges.size >= selectable)) {\n            selectedEdges.add(edge)\n          }\n        } else if (!selectedEdges.has(edge)) {\n          // make the selectedEdges the clicked one\n          selectedEdges.clear()\n          selectedEdges.add(edge)\n        }\n      }\n    }\n    emitter.emit(\"edge:click\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgeDoubleClickEvent(edge: string | string[], event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    emitter.emit(\"edge:dblclick\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgePointerOverEvent(edge: string, event: PointerEvent) {\n    hoveredEdges.add(edge)\n    emitter.emit(\"edge:pointerover\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgePointerOutEvent(edge: string, event: PointerEvent) {\n    hoveredEdges.delete(edge)\n    emitter.emit(\"edge:pointerout\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgeContextMenu(edge: string, event: MouseEvent) {\n    event.stopPropagation()\n    emitter.emit(\"edge:contextmenu\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgesPointerDownEvent(edges: string[], event: PointerEvent) {\n    if (event.button == 2 /* right button */) {\n      return\n    }\n    event.stopPropagation()\n\n    if (![\"default\", \"edge\"].includes(modes.viewMode.value)) {\n      return\n    }\n\n    if (state.pointers.size == 0) {\n      // Add event listeners\n      modes.viewMode.value = \"edge\"\n      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler)\n      })\n      state.pointerPeekCount = 0\n    }\n\n    state.pointerPeekCount++\n\n    // Create new pointer state\n    const pointerState: EdgePointerState = {\n      pointerId: event.pointerId,\n      id: edges,\n      eventTarget: event.currentTarget,\n    }\n    state.pointers.set(event.pointerId, pointerState)\n    emitter.emit(\"edge:pointerdown\", _makeEdgeEventObject(edges, event))\n  }\n\n  function handleEdgesPointerOverEvent(edges: string[], event: PointerEvent) {\n    edges.forEach(edge => hoveredEdges.add(edge))\n    emitter.emit(\"edge:pointerover\", _makeEdgeEventObject(edges, event))\n  }\n\n  function handleEdgesPointerOutEvent(edges: string[], event: PointerEvent) {\n    edges.forEach(edge => hoveredEdges.delete(edge))\n    emitter.emit(\"edge:pointerout\", _makeEdgeEventObject(edges, event))\n  }\n\n  function handleEdgesClickEvent(edges: string[], event: MouseEvent) {\n    handleEdgeClickEvent(edges, event)\n  }\n\n  function handleEdgesDoubleClickEvent(edges: string[], event: MouseEvent) {\n    handleEdgeDoubleClickEvent(edges, event)\n  }\n\n  function handleEdgesContextMenu(edges: string[], event: MouseEvent) {\n    event.stopPropagation()\n    emitter.emit(\"edge:contextmenu\", _makeEdgeEventObject(edges, event))\n  }\n\n  return {\n    handleEdgePointerDownEvent,\n    handleEdgePointerOverEvent,\n    handleEdgePointerOutEvent,\n    handleEdgeClickEvent,\n    handleEdgeDoubleClickEvent,\n    handleEdgeContextMenu,\n    handleEdgesPointerDownEvent,\n    handleEdgesPointerOverEvent,\n    handleEdgesPointerOutEvent,\n    handleEdgesClickEvent,\n    handleEdgesDoubleClickEvent,\n    handleEdgesContextMenu,\n  }\n}\n\nfunction _makeEdgeEventObject<T extends Event>(edge: string | string[], event: T): EdgeEvent<T> {\n  if (edge instanceof Array) {\n    return {\n      edges: edge,\n      event,\n      summarized: true,\n    }\n  } else {\n    return {\n      edge,\n      edges: [edge],\n      event,\n      summarized: false,\n    }\n  }\n}\n","import { onMounted, onUnmounted, Ref, watch } from \"vue\"\nimport { Emitter } from \"mitt\"\nimport { Events } from \"@/common/types\"\nimport { entriesOf } from \"@/utils/object\"\nimport {\n  ClickState,\n  createClickEvents,\n  getPointerMoveDetectionThreshold,\n  InteractionModes,\n} from \"./core\"\n\nexport function setupContainerInteractionHandlers(\n  container: Ref<SVGElement | undefined>,\n  modes: InteractionModes,\n  isSvgWheelZoomEnabled: Ref<boolean>,\n  emitter: Emitter<Events>\n) {\n  const state = {\n    moveCounter: 0,\n    pointerCounter: 0,\n    clickState: undefined as ClickState | undefined,\n  }\n\n  // measure the number of move events in the pointerdown state\n  // and use it to determine the click when pointerup.\n  const containerPointerHandlers = {\n    pointermove: handleContainerPointerMoveEvent,\n    pointerup: handleContainerPointerUpEvent,\n    pointercancel: handleContainerPointerUpEvent,\n  }\n\n  function handleContainerPointerDownEvent(_: PointerEvent) {\n    state.moveCounter = 0\n    if (state.pointerCounter === 0) {\n      // Add to event listener\n      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler, { passive: true })\n      })\n    }\n    state.pointerCounter++\n  }\n\n  function handleContainerPointerMoveEvent(_: PointerEvent) {\n    state.moveCounter++\n  }\n\n  function handleContainerPointerUpEvent(event: PointerEvent) {\n    state.pointerCounter--\n    if (state.pointerCounter <= 0) {\n      state.pointerCounter = 0\n      // Remove from event listener\n      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler)\n      })\n      const threshold = getPointerMoveDetectionThreshold(event.pointerType)\n      if (state.moveCounter <= threshold) {\n        // Click container (without mouse move)\n        if (event.shiftKey && modes.selectionMode.value !== \"container\") {\n          return\n        }\n        modes.selectionMode.value = \"container\"\n\n        // click handling\n        const [clickState, clickEvent, doubleClickEvent] = createClickEvents(\n          state.clickState,\n          event,\n          \"view\"\n        )\n        state.clickState = clickState\n        container.value!.dispatchEvent(clickEvent)\n        if (doubleClickEvent) {\n          container.value!.dispatchEvent(doubleClickEvent)\n        }\n      }\n    }\n  }\n\n  function handleContainerClickEvent(event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    // When a finger is placed on any object and another object is tapped,\n    // no click event is fired. Thus, click events are emulated by using\n    // pointerdown/up. The following is processing for emulated events only.\n    event.stopPropagation()\n    emitter.emit(\"view:click\", { event })\n  }\n\n  function handleContainerDoubleClickEvent(event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    event.stopPropagation()\n    emitter.emit(\"view:dblclick\", { event })\n  }\n\n  function handleContainerContextMenuEvent(event: MouseEvent) {\n    emitter.emit(\"view:contextmenu\", { event })\n\n    if (state.pointerCounter > 0) {\n      // reset pointer down state\n      state.pointerCounter = 0\n      // Remove from event listener\n      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {\n        container.value?.removeEventListener(ev, handler)\n      })\n    }\n  }\n\n  const preventDefault = (e: MouseEvent) => {\n    e.preventDefault()\n  }\n\n  onMounted(() => {\n    const c = container.value\n    if (!c) return\n    c.addEventListener(\"pointerdown\", handleContainerPointerDownEvent, { passive: true })\n    c.addEventListener(\"click\", handleContainerClickEvent, { passive: false })\n    c.addEventListener(\"dblclick\", handleContainerDoubleClickEvent, { passive: false })\n    c.addEventListener(\"contextmenu\", handleContainerContextMenuEvent, { passive: false })\n    if (isSvgWheelZoomEnabled.value) {\n      c.addEventListener(\"wheel\", preventDefault, { passive: false })\n    }\n  })\n\n  onUnmounted(() => {\n    const c = container.value\n    if (!c) return\n    c.removeEventListener(\"pointerdown\", handleContainerPointerDownEvent)\n    c.removeEventListener(\"click\", handleContainerClickEvent)\n    c.removeEventListener(\"dblclick\", handleContainerDoubleClickEvent)\n    c.removeEventListener(\"contextmenu\", handleContainerContextMenuEvent)\n    if (isSvgWheelZoomEnabled.value) {\n      c.removeEventListener(\"wheel\", preventDefault)\n    }\n  })\n\n  watch(isSvgWheelZoomEnabled, (enabled, old) => {\n    const c = container.value\n    if (!c || enabled === old) return\n\n    if (enabled) {\n      c.addEventListener(\"wheel\", preventDefault, { passive: false })\n    } else {\n      c.removeEventListener(\"wheel\", preventDefault)\n    }\n  })\n}\n","import { Ref, watch } from \"vue\"\nimport { Reactive } from \"@/common/common\"\nimport { Events, PathEvent } from \"@/common/types\"\nimport { PathStates } from \"@/models/path\"\nimport {\n  cleanClickState,\n  ClickState,\n  detectClicks,\n  InteractionModes,\n  PathPointerState,\n} from \"./core\"\nimport { entriesOf } from \"@/utils/object\"\nimport { MapUtil } from \"@/utils/map\"\nimport { Emitter } from \"mitt\"\n\nexport function makePathInteractionHandlers(\n  pathStates: PathStates,\n  modes: InteractionModes,\n  hoveredPaths: Reactive<Set<string>>,\n  selectedPaths: Reactive<Set<string>>,\n  isInCompatibilityModeForPath: Ref<boolean>,\n  emitter: Emitter<Events>\n) {\n  const state = {\n    pointers: new Map<number, PathPointerState>(), // <PointerId, ...>\n    pointerPeekCount: 0,\n    clicks: new Map<number, ClickState>(),\n  }\n\n  function _makePathEventObject<T extends Event>(path: string, event: T): PathEvent<T> {\n    if (isInCompatibilityModeForPath.value) {\n      return { path: (pathStates[path]?.path ?? path) as any, event }\n    } else {\n      return { path, event }\n    }\n  }\n\n  const pathPointerHandlers = {\n    pointerup: handlePathPointerUpEvent,\n    pointercancel: handlePathPointerCancelEvent,\n  }\n\n  watch(selectedPaths, selected => {\n    if (selected.size > 0 && modes.selectionMode.value !== \"path\") {\n      modes.selectionMode.value = \"path\"\n    } else if (selected.size === 0 && modes.selectionMode.value === \"path\") {\n      modes.selectionMode.value = \"container\"\n    }\n  })\n\n  watch(modes.selectionMode, mode => {\n    if (mode !== \"path\") {\n      selectedPaths.clear()\n    }\n  })\n\n  function handlePathPointerDownEvent(path: string, event: PointerEvent) {\n    if (!pathStates[path]?.clickable) {\n      return\n    }\n\n    if (event.button == 2 /* right button */) {\n      return\n    }\n    event.stopPropagation()\n\n    if (![\"default\", \"path\"].includes(modes.viewMode.value)) {\n      return\n    }\n\n    if (state.pointers.size == 0) {\n      // Add event listeners\n      modes.viewMode.value = \"path\"\n      entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler)\n      })\n      state.pointerPeekCount = 0\n    }\n\n    state.pointerPeekCount++\n\n    // Create new pointer state\n    const pointerState: PathPointerState = {\n      pointerId: event.pointerId,\n      id: path,\n      eventTarget: event.currentTarget,\n    }\n    state.pointers.set(event.pointerId, pointerState)\n\n    emitter.emit(\"path:pointerdown\", _makePathEventObject(path, event))\n  }\n\n  function handlePathPointerUpEvent(event: PointerEvent) {\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    event.stopPropagation()\n\n    state.pointers.delete(event.pointerId)\n\n    const path = pointerState.id\n    emitter.emit(\"path:pointerup\", _makePathEventObject(path, event))\n\n    // click handling\n    const [clickEvent, doubleClickEvent] = detectClicks(\n      state.clicks,\n      pointerState.pointerId,\n      path,\n      event\n    )\n    pointerState.eventTarget?.dispatchEvent(clickEvent)\n    if (doubleClickEvent) {\n      pointerState.eventTarget?.dispatchEvent(doubleClickEvent)\n    }\n\n    if (state.pointers.size === 0) {\n      // reset state\n      state.pointerPeekCount = 0\n      entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler)\n      })\n      cleanClickState(state.clicks)\n      modes.viewMode.value = \"default\"\n    }\n  }\n\n  function handlePathPointerCancelEvent(event: PointerEvent) {\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    event.stopPropagation()\n\n    for (const pointerState of state.pointers.values()) {\n      const path = pointerState.id\n      emitter.emit(\"path:pointerup\", _makePathEventObject(path, event))\n    }\n\n    // reset state\n    state.pointers.clear()\n    state.pointerPeekCount = 0\n    entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {\n      document.removeEventListener(ev, handler)\n    })\n    emitter.emit(\"view:mode\", \"default\")\n  }\n\n  function handlePathPointerOverEvent(path: string, event: PointerEvent) {\n    if (!pathStates[path]?.hoverable) {\n      return\n    }\n    hoveredPaths.add(path)\n    emitter.emit(\"path:pointerover\", _makePathEventObject(path, event))\n  }\n\n  function handlePathPointerOutEvent(path: string, event: PointerEvent) {\n    if (!pathStates[path]?.hoverable) {\n      return\n    }\n    hoveredPaths.delete(path)\n    emitter.emit(\"path:pointerout\", _makePathEventObject(path, event))\n  }\n\n  function handlePathClickEvent(path: string, event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    // When a finger is placed on any object and another object is tapped,\n    // no click event is fired. Thus, click events are emulated by using\n    // pointerdown/up. The following is processing for emulated events only.\n\n    if (!pathStates[path]?.clickable) {\n      return\n    }\n\n    if (event.shiftKey && ![\"container\", \"path\"].includes(modes.selectionMode.value)) {\n      return\n    }\n    modes.selectionMode.value = \"path\"\n\n    const selectable = pathStates[path]?.selectable ?? false\n    if (selectable) {\n      const isTouchAnySelectedPath =\n        MapUtil.valueOf(state.pointers).filter(p => selectedPaths.has(p.id)).length > 0\n      if (event.shiftKey || isTouchAnySelectedPath) {\n        // select multiple nodes\n        if (selectedPaths.has(path)) {\n          selectedPaths.delete(path)\n        } else if (!(typeof selectable === \"number\" && selectedPaths.size >= selectable)) {\n          selectedPaths.add(path)\n        }\n      } else if (!selectedPaths.has(path)) {\n        // make the selectedPaths the clicked one\n        selectedPaths.clear()\n        selectedPaths.add(path)\n      }\n    }\n    emitter.emit(\"path:click\", _makePathEventObject(path, event))\n  }\n\n  function handlePathDoubleClickEvent(path: string, event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    if (!pathStates[path]?.clickable) {\n      return\n    }\n    emitter.emit(\"path:dblclick\", _makePathEventObject(path, event))\n  }\n\n  function handlePathContextMenu(path: string, event: MouseEvent) {\n    if (!pathStates[path]?.clickable) {\n      return\n    }\n    event.stopPropagation()\n    emitter.emit(\"path:contextmenu\", _makePathEventObject(path, event))\n  }\n\n  return {\n    handlePathPointerDownEvent,\n    handlePathPointerOverEvent,\n    handlePathPointerOutEvent,\n    handlePathClickEvent,\n    handlePathDoubleClickEvent,\n    handlePathContextMenu,\n  }\n}\n","\nexport async function urlContentToDataUrl(url: string) {\n  const response = await fetch(url)\n  const blob = await response.blob()\n  return new Promise<string>((onSuccess, onError) => {\n    try {\n      const reader = new FileReader()\n      reader.onload = function() { onSuccess(this.result as string) } ;\n      reader.readAsDataURL(blob) ;\n    } catch (e) {\n      onError(e)\n    }\n  });\n}\n","import { Point } from \"@/common/types\"\nimport { urlContentToDataUrl } from \"./download\"\n\nexport interface ExportOptions {\n  embedImages: boolean\n}\n\nexport function translateFromDomToSvgCoordinates(\n  svg: SVGSVGElement,\n  viewport: SVGGElement,\n  coordinates: Point\n): Point {\n  const point = svg.createSVGPoint()\n  point.x = coordinates.x\n  point.y = coordinates.y\n  const svgPoint = point.matrixTransform(viewport.getCTM()?.inverse())\n  return { x: svgPoint.x, y: svgPoint.y }\n}\n\nexport function translateFromSvgToDomCoordinates(\n  svg: SVGSVGElement,\n  viewport: SVGGElement,\n  coordinates: Point\n): Point {\n  const point = svg.createSVGPoint()\n  point.x = coordinates.x\n  point.y = coordinates.y\n  const domPoint = point.matrixTransform(viewport.getCTM() as DOMMatrixInit)\n  return { x: domPoint.x, y: domPoint.y }\n}\n\nexport function exportSvgElement(\n  element: SVGElement,\n  svgViewport: SVGGElement,\n  scale: number\n): SVGElement {\n  const target = element.cloneNode(true) as SVGElement\n\n  const box = svgViewport.getBBox()\n  const z = 1 / scale\n  const svgRect = {\n    x: Math.floor((box.x - 10) * z),\n    y: Math.floor((box.y - 10) * z),\n    width: Math.ceil((box.width + 20) * z),\n    height: Math.ceil((box.height + 20) * z),\n  }\n  target.setAttribute(\"width\", svgRect.width.toString())\n  target.setAttribute(\"height\", svgRect.height.toString())\n\n  const v = target.querySelector(\".v-ng-viewport\") as SVGGElement\n  v.setAttribute(\"transform\", `translate(${-svgRect.x} ${-svgRect.y}), scale(${z})`)\n  v.removeAttribute(\"style\")\n\n  target.setAttribute(\"viewBox\", `0 0 ${svgRect.width} ${svgRect.height}`)\n  target.removeAttribute(\"style\")\n\n  // remove comments\n  const iter = document.createNodeIterator(target, NodeFilter.SHOW_COMMENT)\n  while (iter.nextNode()) {\n    const commentNode = iter.referenceNode\n    commentNode.parentNode?.removeChild(commentNode)\n  }\n  return target\n}\n\nasync function replaceImageSourceToDataUrl(image: SVGImageElement) {\n  let useNS = false\n  let href = image.getAttribute(\"href\")\n  if (!href) {\n    useNS = true\n    href = image.getAttribute(\"xlink:href\")\n  }\n  if (!href || href.startsWith(\"data:\")) return\n\n  try {\n    const dataUrl = await urlContentToDataUrl(href)\n    image.setAttribute(useNS ? \"xlink:href\" : \"href\", dataUrl)\n  } catch (e) {\n    // output log and ignore\n    console.warn(\"Image download failed.\", href)\n    return\n  }\n}\n\nexport async function exportSvgElementWithOptions(\n  element: SVGElement,\n  svgViewport: SVGGElement,\n  scale: number,\n  options: Partial<ExportOptions> = {}\n): Promise<SVGElement> {\n  const target = exportSvgElement(element, svgViewport, scale)\n\n  if (options.embedImages) {\n    // replace image to data-uri\n    const images = Array.from(target.querySelectorAll(\"image\"))\n    const promises = images.map(img => replaceImageSourceToDataUrl(img))\n    await Promise.all(promises)\n  }\n\n  return target\n}\n","import { computed, onMounted, onUnmounted, ref, Ref, watch } from \"vue\"\nimport { debounce } from \"lodash-es\"\nimport { nonNull, Reactive } from \"@/common/common\"\nimport { Configs } from \"@/common/configs\"\nimport { Layouts, NodePositions, Point, Rectangle } from \"@/common/types\"\nimport { Vector2D } from \"@/modules/vector2d\"\nimport { NodeStates } from \"@/models/node\"\nimport { translateFromDomToSvgCoordinates } from \"@/utils/svg\"\nimport { InteractionModes } from \"./core\"\n\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\n\nexport type StopTrigger = \"pointerup\" | \"click\" | \"manual\"\nexport type SelectionType = \"append\" | \"invert\"\n\nexport interface BoxSelectionOption {\n  stop: StopTrigger\n  type: SelectionType\n  withShiftKey: SelectionType | \"same\"\n}\n\n// ------------------------------------------------------------------\n// Export functions\n// ------------------------------------------------------------------\n\nexport function makeBoxSelectionMethods(\n  container: Ref<SVGElement | undefined>,\n  modes: InteractionModes,\n  layouts: Readonly<Layouts>,\n  nodeStates: NodeStates,\n  selectedNodes: Reactive<Set<string>>,\n  configs: Configs\n) {\n  const isBoxSelectionEnabled = computed(\n    () => !!configs.node.selectable && configs.view.boxSelectionEnabled\n  )\n  const isBoxSelectionMode = computed(() => modes.viewMode.value === \"box-selection\")\n\n  // ------------------------------------------------------------------\n  // States\n  // ------------------------------------------------------------------\n  const viewport = ref<SVGGElement>()\n  const selectionBox = ref<Rectangle>()\n  const states = {\n    pointers: new Set<number>(), // Set of pointers being pressed\n    points: new Map<number, Point>(), // Point indicated by each pointer\n    startPoint: null as Point | null, // Point where the drag started\n    selectedNodesAtSelectStarted: new Set<string>(), // Nodes selected at the start of the selection\n    selectionType: \"append\" as SelectionType, // Selection method for nodes included in the dragged range\n    options: {\n      // options specified by user at start of selection mode\n      stopTrigger: \"pointerup\" as StopTrigger,\n      selectionType: \"append\" as SelectionType,\n      selectionTypeWithShiftKey: \"same\" as SelectionType | \"same\",\n    },\n  }\n\n  // ------------------------------------------------------------------\n  // Private functions\n  // ------------------------------------------------------------------\n\n  const updateNodesSelection = debounce(\n    () => {\n      _updateNodesSelection(\n        nonNull(container.value, \"container\") as SVGSVGElement,\n        nonNull(viewport.value, \"viewport\"),\n        selectionBox,\n        layouts.nodes,\n        nodeStates,\n        selectedNodes,\n        states.selectedNodesAtSelectStarted,\n        states.selectionType\n      )\n    },\n    50,\n    { maxWait: 100 }\n  )\n\n  // ------------------------------------------------------------------\n  // Pointer event handlers\n  // ------------------------------------------------------------------\n  const pointerEventHandler = new PointerEventRegistrar(\n    container,\n    handlePointerDownEvent,\n    handlePointerUpEvent,\n    handlePointerMoveEvent,\n    handleClickEvent,\n    handleKeyDownEvent\n  )\n\n  function handleClickEvent(event: MouseEvent) {\n    if (states.options.stopTrigger !== \"click\") return\n    if (states.pointers.size > 0) return\n\n    const point = { x: event.offsetX, y: event.offsetY }\n    if (states.startPoint && Vector2D.fromObject(states.startPoint).distance(point) > 10) {\n      return // ignore in dragging\n    }\n    stopBoxSelection()\n  }\n\n  function handlePointerDownEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const point = { x: event.offsetX, y: event.offsetY }\n    if (states.pointers.size === 0) {\n      states.startPoint = point\n\n      pointerEventHandler.activate()\n\n      states.selectedNodesAtSelectStarted.clear()\n      selectedNodes.forEach(nodeId => states.selectedNodesAtSelectStarted.add(nodeId))\n      if (states.options.selectionTypeWithShiftKey === \"same\") {\n        states.selectionType = states.options.selectionType\n      } else {\n        states.selectionType = event.shiftKey\n          ? states.options.selectionTypeWithShiftKey\n          : states.options.selectionType\n      }\n    }\n    if (!states.pointers.has(event.pointerId)) {\n      states.pointers.add(event.pointerId)\n    }\n    states.points.set(event.pointerId, point)\n    updateRectangle()\n  }\n\n  function handlePointerUpEvent(event: PointerEvent) {\n    states.pointers.delete(event.pointerId)\n    if (states.pointers.size === 1) {\n      const rect = nonNull(container.value).getBoundingClientRect()\n      const point = { x: event.x - rect.x, y: event.y - rect.y }\n      states.startPoint = point\n    } else if (states.pointers.size === 0) {\n      pointerEventHandler.deactivate()\n      if (states.options.stopTrigger === \"pointerup\") {\n        stopBoxSelection()\n      }\n      states.selectedNodesAtSelectStarted.clear()\n    }\n    updateRectangle()\n  }\n\n  function handlePointerMoveEvent(event: PointerEvent) {\n    const rect = nonNull(container.value).getBoundingClientRect()\n    const point = { x: event.x - rect.x, y: event.y - rect.y }\n    states.points.set(event.pointerId, point)\n    updateRectangle()\n    updateNodesSelection()\n  }\n\n  function handleKeyDownEvent(event: KeyboardEvent) {\n    if (event.key === \"Escape\" && states.options.stopTrigger !== \"manual\") {\n      event.stopPropagation()\n      stopBoxSelection()\n    }\n  }\n\n  function updateRectangle() {\n    let pos1: Point | undefined\n    let pos2: Point | undefined\n    const pointerArray = Array.from(states.pointers)\n    if (pointerArray.length >= 2) {\n      const first = pointerArray[0]\n      const last = pointerArray[pointerArray.length - 1]\n      pos1 = states.points.get(first)\n      pos2 = states.points.get(last)\n    } else if (states.startPoint && pointerArray.length === 1) {\n      const first = pointerArray[0]\n      pos1 = states.startPoint\n      pos2 = states.points.get(first)\n    } else {\n      pos1 = undefined\n      pos2 = undefined\n    }\n    if (pos1 && pos2) {\n      // calculate left top position and size\n      selectionBox.value = {\n        pos: {\n          x: Math.min(pos1.x, pos2.x),\n          y: Math.min(pos1.y, pos2.y),\n        },\n        size: {\n          width: Math.abs(pos2.x - pos1.x),\n          height: Math.abs(pos2.y - pos1.y),\n        },\n      }\n      if (selectionBox.value.size.width === 0) {\n        selectionBox.value.size.width = 1\n      }\n      if (selectionBox.value.size.height === 0) {\n        selectionBox.value.size.height = 1\n      }\n    } else if (selectionBox.value) {\n      selectionBox.value = undefined\n    }\n  }\n\n  // ------------------------------------------------------------------\n  // Ctrl/Cmd key box selection\n  // ------------------------------------------------------------------\n  const keyEventRegistrar = new KeyEventRegistrar(\n    container,\n    // key down\n    (event: KeyboardEvent) => {\n      if (!isBoxSelectionEnabled.value) return\n      if (configs.view.selection.detector(event)) {\n        startBoxSelection({\n          stop: \"manual\",\n          type: \"append\",\n          withShiftKey: \"invert\",\n        })\n        keyEventRegistrar.activate()\n      }\n    },\n    // key up\n    (event: KeyboardEvent) => {\n      if (!isBoxSelectionEnabled.value) return\n      if (configs.view.selection.detector(event)) {\n        if (states.pointers.size === 0) {\n          stopBoxSelection()\n        } else {\n          states.options.stopTrigger = \"pointerup\"\n        }\n        keyEventRegistrar.deactivate()\n      }\n    }\n  )\n\n  watch(isBoxSelectionEnabled, value => {\n    if (value) {\n      keyEventRegistrar.register()\n    } else {\n      keyEventRegistrar.unregister()\n    }\n  })\n\n  // ------------------------------------------------------------------\n  // Lifecycle process\n  // ------------------------------------------------------------------\n\n  onMounted(() => {\n    viewport.value = container.value?.querySelector(\".v-ng-viewport\") as SVGGElement\n    if (isBoxSelectionEnabled.value) {\n      keyEventRegistrar.register()\n    }\n  })\n\n  onUnmounted(() => {\n    stopBoxSelection()\n    if (isBoxSelectionEnabled.value) {\n      keyEventRegistrar.unregister()\n    }\n  })\n\n  // ------------------------------------------------------------------\n  // Expose functions\n  // ------------------------------------------------------------------\n\n  function startBoxSelection(options: Partial<BoxSelectionOption> = {}) {\n    // Even if it's already in selection mode, behavior changes are acceptable.\n    states.options = {\n      stopTrigger: options.stop ?? \"pointerup\",\n      selectionType: options.type ?? \"append\",\n      selectionTypeWithShiftKey: options.withShiftKey ?? \"same\",\n    }\n\n    if (modes.viewMode.value === \"box-selection\") return\n    modes.viewMode.value = \"box-selection\"\n\n    states.pointers.clear()\n    pointerEventHandler.register()\n  }\n\n  function stopBoxSelection() {\n    if (modes.viewMode.value !== \"box-selection\") return\n    modes.viewMode.value = \"default\"\n    pointerEventHandler.unregister()\n  }\n\n  return { isBoxSelectionMode, selectionBox, startBoxSelection, stopBoxSelection }\n}\n\n// ------------------------------------------------------------------\n// Package local functions\n// ------------------------------------------------------------------\n\nfunction _updateNodesSelection(\n  svg: SVGSVGElement,\n  viewport: SVGGElement,\n  selectionBox: Ref<Rectangle | undefined>,\n  nodePositions: Readonly<NodePositions>,\n  nodeStates: Readonly<NodeStates>,\n  selectedNodes: Reactive<Set<string>>,\n  selectedNodesAtSelectStarted: Set<string>,\n  selectionType: SelectionType\n) {\n  if (!selectionBox.value) return\n  const box = selectionBox.value\n  const pos1 = translateFromDomToSvgCoordinates(svg, viewport, box.pos)\n  const pos2 = translateFromDomToSvgCoordinates(svg, viewport, {\n    x: box.pos.x + box.size.width,\n    y: box.pos.y + box.size.height,\n  })\n\n  // find enclosed nodes\n  const enclosedNodes = new Set(\n    Object.entries(nodePositions)\n      .filter(([_, pos]) => {\n        return pos1.x <= pos.x && pos.x <= pos2.x && pos1.y <= pos.y && pos.y <= pos2.y\n      })\n      .map(([nodeId, _]) => nodeId)\n  )\n\n  if (selectionType === \"append\") {\n    selectedNodes.forEach(nodeId => {\n      if (!enclosedNodes.has(nodeId)) {\n        selectedNodes.delete(nodeId)\n      }\n    })\n    enclosedNodes.forEach(nodeId => {\n      const selectable = nodeStates[nodeId]?.selectable ?? false\n      if (\n        selectable === true ||\n        (typeof selectable === \"number\" && selectedNodes.size < selectable)\n      ) {\n        selectedNodes.add(nodeId)\n      }\n    })\n  } else {\n    // selectionType === \"invert\"\n    const temporary = new Set<string>(selectedNodesAtSelectStarted)\n    temporary.forEach(nodeId => {\n      if (enclosedNodes.has(nodeId)) {\n        temporary.delete(nodeId)\n      }\n    })\n    enclosedNodes.forEach(nodeId => {\n      if (!selectedNodesAtSelectStarted.has(nodeId)) {\n        const selectable = nodeStates[nodeId]?.selectable ?? false\n        if (\n          selectable === true ||\n          (typeof selectable === \"number\" && temporary.size < selectable)\n        ) {\n          temporary.add(nodeId)\n        }\n      }\n    })\n    // replace\n    selectedNodes.clear()\n    temporary.forEach(nodeId => selectedNodes.add(nodeId))\n  }\n}\n\n// ------------------------------------------------------------------\n// Event register/unregister\n// ------------------------------------------------------------------\n\ntype KeyboardEventHandler = (event: KeyboardEvent) => void\ntype PointerEventHandler = (event: PointerEvent) => void\ntype MouseEventHandler = (event: MouseEvent) => void\n\nclass PointerEventRegistrar {\n  _container: Ref<SVGElement | undefined>\n  _handlePointerDownEvent: PointerEventHandler\n  _handlePointerUpEvent: PointerEventHandler\n  _handlePointerMoveEvent: PointerEventHandler\n  _handleClickEvent: MouseEventHandler\n  _handleKeyDownEvent: KeyboardEventHandler\n  _ignoreEvent: PointerEventHandler\n\n  constructor(\n    container: Ref<SVGElement | undefined>,\n    handlePointerDownEvent: PointerEventHandler,\n    handlePointerUpEvent: PointerEventHandler,\n    handlePointerMoveEvent: PointerEventHandler,\n    handleClickEvent: MouseEventHandler,\n    handleKeyDownEvent: KeyboardEventHandler\n  ) {\n    this._container = container\n    this._handlePointerDownEvent = handlePointerDownEvent\n    this._handlePointerUpEvent = handlePointerUpEvent\n    this._handlePointerMoveEvent = handlePointerMoveEvent\n    this._handleClickEvent = handleClickEvent\n    this._handleKeyDownEvent = handleKeyDownEvent\n    this._ignoreEvent = (event: PointerEvent) => event.stopPropagation()\n  }\n\n  register() {\n    const options = { capture: true, passive: false }\n    const container = nonNull(this._container.value, \"container\")\n    container.addEventListener(\"pointerdown\", this._handlePointerDownEvent, options)\n    container.addEventListener(\"click\", this._handleClickEvent, options)\n    container.addEventListener(\"pointerenter\", this._ignoreEvent, options)\n    container.addEventListener(\"pointerleave\", this._ignoreEvent, options)\n    document.addEventListener(\"keydown\", this._handleKeyDownEvent, options)\n  }\n\n  activate() {\n    const options = { capture: true, passive: false }\n    document.addEventListener(\"pointermove\", this._handlePointerMoveEvent, options)\n    document.addEventListener(\"pointerup\", this._handlePointerUpEvent, options)\n  }\n\n  deactivate() {\n    const options = { capture: true }\n    document.removeEventListener(\"pointermove\", this._handlePointerMoveEvent, options)\n    document.removeEventListener(\"pointerup\", this._handlePointerUpEvent, options)\n  }\n\n  unregister() {\n    this.deactivate()\n    const options = { capture: true }\n    if (this._container.value) {\n      const container = this._container.value\n      container.removeEventListener(\"pointerdown\", this._handlePointerDownEvent, options)\n      container.removeEventListener(\"click\", this._handleClickEvent, options)\n      container.removeEventListener(\"pointerenter\", this._ignoreEvent, options)\n      container.removeEventListener(\"pointerleave\", this._ignoreEvent, options)\n      document.removeEventListener(\"keydown\", this._handleKeyDownEvent, options)\n    }\n  }\n}\n\nclass KeyEventRegistrar {\n  _container: Ref<SVGElement | undefined>\n  _handleKeyDownEvent: KeyboardEventHandler\n  _handleKeyUpEvent: KeyboardEventHandler\n  _preventDefault: MouseEventHandler\n\n  constructor(\n    container: Ref<SVGElement | undefined>,\n    handleKeyDownEvent: KeyboardEventHandler,\n    handleKeyUpEvent: KeyboardEventHandler\n  ) {\n    this._container = container\n    this._handleKeyDownEvent = handleKeyDownEvent\n    this._handleKeyUpEvent = handleKeyUpEvent\n    this._preventDefault = (event: MouseEvent) => {\n      event.stopPropagation()\n      event.preventDefault()\n    }\n  }\n\n  register() {\n    document.addEventListener(\"keydown\", this._handleKeyDownEvent, { capture: true, passive: true })\n  }\n\n  activate() {\n    document.addEventListener(\"keyup\", this._handleKeyUpEvent, { capture: true, passive: true })\n    const container = nonNull(this._container.value, \"container\")\n    container.addEventListener(\"contextmenu\", this._preventDefault, { passive: false })\n  }\n\n  deactivate() {\n    document.removeEventListener(\"keyup\", this._handleKeyUpEvent, { capture: true })\n    if (this._container.value) {\n      const container = this._container.value\n      container.removeEventListener(\"contextmenu\", this._preventDefault)\n    }\n  }\n\n  unregister() {\n    this.deactivate()\n    document.removeEventListener(\"keydown\", this._handleKeyDownEvent, { capture: true })\n  }\n}\n","// Module responsible for selection state and mouse/touch operations\n\nimport { inject, InjectionKey, provide, ref, Ref, watch } from \"vue\"\nimport { Emitter } from \"mitt\"\nimport { nonNull, Reactive, ReadonlyRef } from \"@/common/common\"\nimport { Events, Layouts, Rectangle } from \"@/common/types\"\nimport { NodeStates } from \"@/models/node\"\nimport { EdgeStates } from \"@/models/edge\"\nimport { PathStates } from \"@/models/path\"\nimport { Configs } from \"@/common/configs\"\nimport { InteractionModes } from \"./core\"\nimport { makeNodeInteractionHandlers } from \"./node\"\nimport { makeEdgeInteractionHandlers } from \"./edge\"\nimport { setupContainerInteractionHandlers } from \"./container\"\nimport { makePathInteractionHandlers } from \"./path\"\nimport { BoxSelectionOption, makeBoxSelectionMethods } from \"./boxSelection\"\n\ntype NodeEventHandler<T extends Event = PointerEvent> = (node: string, event: T) => void\ntype EdgeEventHandler<T extends Event = PointerEvent> = (edge: string, event: T) => void\ntype EdgesEventHandler<T extends Event = PointerEvent> = (edges: string[], event: T) => void\ntype PathEventHandler<T extends Event = PointerEvent> = (path: string, event: T) => void\n\ninterface MouseEventHandlers {\n  selectedNodes: Reactive<Set<string>>\n  hoveredNodes: Reactive<Set<string>>\n  selectedEdges: Reactive<Set<string>>\n  hoveredEdges: Reactive<Set<string>>\n  selectedPaths: Reactive<Set<string>>\n  hoveredPaths: Reactive<Set<string>>\n\n  // for Nodes\n  handleNodePointerDownEvent: NodeEventHandler\n  handleNodePointerOverEvent: NodeEventHandler\n  handleNodePointerOutEvent: NodeEventHandler\n  handleNodeClickEvent: NodeEventHandler<MouseEvent>\n  handleNodeDoubleClickEvent: NodeEventHandler<MouseEvent>\n  handleNodeContextMenu: NodeEventHandler<MouseEvent>\n\n  // for Edges\n  handleEdgePointerDownEvent: EdgeEventHandler\n  handleEdgePointerOverEvent: EdgeEventHandler\n  handleEdgePointerOutEvent: EdgeEventHandler\n  handleEdgeClickEvent: EdgeEventHandler<MouseEvent>\n  handleEdgeDoubleClickEvent: EdgeEventHandler<MouseEvent>\n  handleEdgeContextMenu: EdgeEventHandler<MouseEvent>\n  handleEdgesPointerDownEvent: EdgesEventHandler\n  handleEdgesPointerOverEvent: EdgesEventHandler\n  handleEdgesPointerOutEvent: EdgesEventHandler\n  handleEdgesClickEvent: EdgesEventHandler<MouseEvent>\n  handleEdgesDoubleClickEvent: EdgesEventHandler<MouseEvent>\n  handleEdgesContextMenu: EdgesEventHandler<MouseEvent>\n\n  // for Paths\n  handlePathPointerDownEvent: PathEventHandler\n  handlePathPointerOverEvent: PathEventHandler\n  handlePathPointerOutEvent: PathEventHandler\n  handlePathClickEvent: PathEventHandler<MouseEvent>\n  handlePathDoubleClickEvent: PathEventHandler<MouseEvent>\n  handlePathContextMenu: PathEventHandler<MouseEvent>\n\n  // for Box Selection\n  isBoxSelectionMode: Ref<boolean>\n  selectionBox: Ref<Rectangle>\n  startBoxSelection: (options?: Partial<BoxSelectionOption>) => void\n  stopBoxSelection: () => void\n}\nconst mouseEventHandlersKey = Symbol(\"mouseEventHandlers\") as InjectionKey<MouseEventHandlers>\n\nexport function provideMouseOperation(\n  container: Ref<SVGElement | undefined>,\n  layouts: Readonly<Layouts>,\n  zoomLevel: ReadonlyRef<number>,\n  nodeStates: NodeStates,\n  edgeStates: EdgeStates,\n  pathStates: PathStates,\n  selectedNodes: Reactive<Set<string>>,\n  selectedEdges: Reactive<Set<string>>,\n  selectedPaths: Reactive<Set<string>>,\n  hoveredNodes: Reactive<Set<string>>,\n  hoveredEdges: Reactive<Set<string>>,\n  hoveredPaths: Reactive<Set<string>>,\n  isInCompatibilityModeForPath: Ref<boolean>,\n  isSvgWheelZoomEnabled: Ref<boolean>,\n  configs: Configs,\n  emitter: Emitter<Events>\n): MouseEventHandlers {\n  const modes: InteractionModes = {\n    selectionMode: ref(\"container\"),\n    viewMode: ref(\"default\"),\n  }\n\n  if (selectedNodes.size > 0) {\n    modes.selectionMode.value = \"node\"\n  } else if (selectedEdges.size > 0) {\n    modes.selectionMode.value = \"edge\"\n  } else if (selectedPaths.size > 0) {\n    modes.selectionMode.value = \"path\"\n  }\n\n  watch(modes.viewMode, mode => {\n    emitter.emit(\"view:mode\", mode)\n  })\n\n  setupContainerInteractionHandlers(container, modes, isSvgWheelZoomEnabled, emitter)\n\n  const provides = <MouseEventHandlers>{\n    selectedNodes,\n    hoveredNodes,\n    selectedEdges,\n    hoveredEdges,\n    selectedPaths,\n    hoveredPaths,\n    ...makeNodeInteractionHandlers(\n      nodeStates,\n      layouts,\n      modes,\n      hoveredNodes,\n      selectedNodes,\n      zoomLevel,\n      emitter\n    ),\n    ...makeEdgeInteractionHandlers(edgeStates, modes, hoveredEdges, selectedEdges, emitter),\n    ...makePathInteractionHandlers(\n      pathStates,\n      modes,\n      hoveredPaths,\n      selectedPaths,\n      isInCompatibilityModeForPath,\n      emitter\n    ),\n    ...makeBoxSelectionMethods(\n      container,\n      modes,\n      layouts,\n      nodeStates,\n      selectedNodes,\n      configs\n    ),\n  }\n  provide(mouseEventHandlersKey, provides)\n  return provides\n}\n\nexport function useMouseOperation(): MouseEventHandlers {\n  return nonNull(inject(mouseEventHandlersKey), \"mouseEventHandlers\")\n}\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n","import { provide, inject, InjectionKey } from \"vue\"\nimport mitt, { Emitter } from \"mitt\"\nimport { nonNull } from \"@/common/common\"\nimport { Events } from \"@/common/types\"\n\nconst eventEmitterKey = Symbol(\"emitter\") as InjectionKey<Emitter<Events>>\n\nexport function provideEventEmitter(): Emitter<Events> {\n  // event bus\n  const emitter = mitt<Events>()\n  provide(eventEmitterKey, emitter)\n  return emitter\n}\n\nexport function useEventEmitter(): Emitter<Events> {\n  return nonNull(inject(eventEmitterKey), \"event emitter\")\n}\n","module.exports = {\n  /**\n   * Get global this object\n   *\n   * @return {Object}        global this object\n   */\n  getGlobalThis: function () {\n    if (typeof globalThis !== \"undefined\") return globalThis;\n    if (typeof self !== \"undefined\") return self;\n    if (typeof window !== \"undefined\") return window;\n    if (typeof global !== \"undefined\") return global;\n    // Note: this might still return the wrong result!\n    if (typeof this !== \"undefined\") return this;\n    throw new Error(\"Unable to locate global `this`\");\n  },\n\n  /**\n   * Extends an object\n   *\n   * @param  {Object} target object to extend\n   * @param  {Object} source object to take properties from\n   * @return {Object}        extended object\n   */\n  extend: function (target, source) {\n    target = target || {};\n    for (var prop in source) {\n      // Go recursively\n      if (this.isObject(source[prop])) {\n        target[prop] = this.extend(target[prop], source[prop]);\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n    return target;\n  },\n\n  /**\n   * Checks if an object is a DOM element\n   *\n   * @param  {Object}  o HTML element or String\n   * @return {Boolean}   returns true if object is a DOM element\n   */\n  isElement: function (o) {\n    return (\n      o instanceof HTMLElement ||\n      o instanceof SVGElement ||\n      o instanceof SVGSVGElement || //DOM2\n      (o &&\n        typeof o === \"object\" &&\n        o !== null &&\n        o.nodeType === 1 &&\n        typeof o.nodeName === \"string\")\n    );\n  },\n\n  /**\n   * Checks if an object is an Object\n   *\n   * @param  {Object}  o Object\n   * @return {Boolean}   returns true if object is an Object\n   */\n  isObject: function (o) {\n    return Object.prototype.toString.call(o) === \"[object Object]\";\n  },\n\n  /**\n   * Checks if variable is Number\n   *\n   * @param  {Integer|Float}  n\n   * @return {Boolean}   returns true if variable is Number\n   */\n  isNumber: function (n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  },\n\n  /**\n   * Search for an SVG element\n   *\n   * @param  {Object|String} elementOrSelector DOM Element or selector String\n   * @return {Object|Null}                   SVG or null\n   */\n  getSvg: function (elementOrSelector) {\n    var element, svg;\n\n    if (!this.isElement(elementOrSelector)) {\n      // If selector provided\n      if (\n        typeof elementOrSelector === \"string\" ||\n        elementOrSelector instanceof String\n      ) {\n        // Try to find the element\n        element = document.querySelector(elementOrSelector);\n\n        if (!element) {\n          throw new Error(\n            \"Provided selector did not find any elements. Selector: \" +\n              elementOrSelector\n          );\n          return null;\n        }\n      } else {\n        throw new Error(\"Provided selector is not an HTML object nor String\");\n        return null;\n      }\n    } else {\n      element = elementOrSelector;\n    }\n\n    if (element.tagName.toLowerCase() === \"svg\") {\n      svg = element;\n    } else {\n      if (element.tagName.toLowerCase() === \"object\") {\n        svg = element.contentDocument.documentElement;\n      } else {\n        if (element.tagName.toLowerCase() === \"embed\") {\n          svg = element.getSVGDocument().documentElement;\n        } else {\n          if (element.tagName.toLowerCase() === \"img\") {\n            throw new Error(\n              'Cannot script an SVG in an \"img\" element. Please use an \"object\" element or an in-line SVG.'\n            );\n          } else {\n            throw new Error(\"Cannot get SVG.\");\n          }\n          return null;\n        }\n      }\n    }\n\n    return svg;\n  },\n\n  /**\n   * Attach a given context to a function\n   * @param  {Function} fn      Function\n   * @param  {Object}   context Context\n   * @return {Function}           Function with certain context\n   */\n  proxy: function (fn, context) {\n    return function () {\n      return fn.apply(context, arguments);\n    };\n  },\n\n  /**\n   * Returns object type\n   * Uses toString that returns [object SVGPoint]\n   * And than parses object type from string\n   *\n   * @param  {Object} o Any object\n   * @return {String}   Object type\n   */\n  getType: function (o) {\n    return Object.prototype.toString\n      .apply(o)\n      .replace(/^\\[object\\s/, \"\")\n      .replace(/\\]$/, \"\");\n  },\n\n  /**\n   * If it is a touch event than add clientX and clientY to event object\n   *\n   * @param  {Event} evt\n   * @param  {SVGSVGElement} svg\n   */\n  mouseAndTouchNormalize: function (evt, svg) {\n    // If no clientX then fallback\n    if (evt.clientX === void 0 || evt.clientX === null) {\n      // Fallback\n      evt.clientX = 0;\n      evt.clientY = 0;\n\n      // If it is a touch event\n      if (evt.touches !== void 0 && evt.touches.length) {\n        if (evt.touches[0].clientX !== void 0) {\n          evt.clientX = evt.touches[0].clientX;\n          evt.clientY = evt.touches[0].clientY;\n        } else if (evt.touches[0].pageX !== void 0) {\n          var rect = svg.getBoundingClientRect();\n\n          evt.clientX = evt.touches[0].pageX - rect.left;\n          evt.clientY = evt.touches[0].pageY - rect.top;\n        }\n        // If it is a custom event\n      } else if (evt.originalEvent !== void 0) {\n        if (evt.originalEvent.clientX !== void 0) {\n          evt.clientX = evt.originalEvent.clientX;\n          evt.clientY = evt.originalEvent.clientY;\n        }\n      }\n    }\n  },\n\n  /**\n   * If it is a touch event than add clientX and clientY to event object\n   *\n   * @param  {Event} evt\n   * @param  {SVGSVGElement} svg\n   * @param  {Number} touch\n   */\n  touchNormalize: function (evt, svg, touch) {\n    // If it is a touch event\n    if (evt.touches !== void 0 && evt.touches.length) {\n      if (evt.touches[touch].clientX !== void 0) {\n        evt.clientX = evt.touches[touch].clientX;\n        evt.clientY = evt.touches[touch].clientY;\n      } else if (evt.touches[touch].pageX !== void 0) {\n        var rect = svg.getBoundingClientRect();\n\n        evt.clientX = evt.touches[touch].pageX - rect.left;\n        evt.clientY = evt.touches[touch].pageY - rect.top;\n      }\n      // If it is a custom event\n    } else {\n      // If no clientX then fallback\n      if (evt.clientX === void 0 || evt.clientX === null) {\n        // Fallback\n        evt.clientX = 0;\n        evt.clientY = 0;\n        if (evt.originalEvent !== void 0) {\n          if (evt.originalEvent.clientX !== void 0) {\n            evt.clientX = evt.originalEvent.clientX;\n            evt.clientY = evt.originalEvent.clientY;\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * Check if an event is a double click/tap\n   * TODO: For touch gestures use a library (hammer.js) that takes in account other events\n   * (touchmove and touchend). It should take in account tap duration and traveled distance\n   *\n   * @param  {Event}  evt\n   * @param  {Event}  prevEvt Previous Event\n   * @return {Boolean}\n   */\n  isDblClick: function (evt, prevEvt) {\n    // Double click detected by browser\n    if (evt.detail === 2) {\n      return true;\n    }\n    // Try to compare events\n    else if (prevEvt !== void 0 && prevEvt !== null) {\n      var timeStampDiff = evt.timeStamp - prevEvt.timeStamp, // should be lower than 250 ms\n        touchesDistance = Math.sqrt(\n          Math.pow(evt.clientX - prevEvt.clientX, 2) +\n            Math.pow(evt.clientY - prevEvt.clientY, 2)\n        );\n\n      return timeStampDiff < 250 && touchesDistance < 10;\n    }\n\n    // Nothing found\n    return false;\n  },\n\n  /**\n   * Returns current timestamp as an integer\n   *\n   * @return {Number}\n   */\n  now:\n    Date.now ||\n    function () {\n      return new Date().getTime();\n    },\n\n  // From underscore.\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  throttle: function (func, wait, options) {\n    var that = this;\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) {\n      options = {};\n    }\n    var later = function () {\n      previous = options.leading === false ? 0 : that.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = args = null;\n      }\n    };\n    return function () {\n      var now = that.now();\n      if (!previous && options.leading === false) {\n        previous = now;\n      }\n      var remaining = wait - (now - previous);\n      context = this; // eslint-disable-line consistent-this\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) {\n          context = args = null;\n        }\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  },\n\n  /**\n   * Create a requestAnimationFrame simulation\n   *\n   * @param  {Number|String} refreshRate\n   * @return {Function}\n   */\n  createRequestAnimationFrame: function (refreshRate) {\n    var timeout = null;\n\n    // Convert refreshRate to timeout\n    if (refreshRate !== \"auto\" && refreshRate < 60 && refreshRate > 1) {\n      timeout = Math.floor(1000 / refreshRate);\n    }\n\n    if (timeout === null) {\n      return window.requestAnimationFrame || requestTimeout(33);\n    } else {\n      return requestTimeout(timeout);\n    }\n  },\n\n  /**\n   * Calculate distance of points\n   *\n   * @param  {SVGPoint} point1\n   * @param  {SVGPoint} point2\n   * @return {Number}\n   */\n  calculateDistance: function (point1, point2) {\n    var dx = point1.x - point2.x;\n    var dy = point1.y - point2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  },\n};\n\n/**\n * Create a callback that will execute after a given timeout\n *\n * @param  {Function} timeout\n * @return {Function}\n */\nfunction requestTimeout(timeout) {\n  return function (callback) {\n    window.setTimeout(callback, timeout);\n  };\n}\n","// uniwheel 0.1.2 (customized)\n// A unified cross browser mouse wheel event handler\n// https://github.com/teemualap/uniwheel\n\nvar Utils = require(\"./utilities\");\n\nmodule.exports = (function() {\n  //Full details: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel\n\n  var prefix = \"\",\n    _addEventListener,\n    _removeEventListener,\n    support,\n    fns = [];\n  var passiveTrueOption = { passive: true };\n  var passiveFalseOption = { passive: false };\n\n  // detect event model\n  if (Utils.getGlobalThis().addEventListener) {\n    _addEventListener = \"addEventListener\";\n    _removeEventListener = \"removeEventListener\";\n  } else {\n    _addEventListener = \"attachEvent\";\n    _removeEventListener = \"detachEvent\";\n    prefix = \"on\";\n  }\n\n  function getSupport() {\n    if (!support) {\n      support =\n        \"onwheel\" in document.createElement(\"div\")\n          ? \"wheel\" // Modern browsers support \"wheel\"\n          : document.onmousewheel !== undefined\n          ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\n          : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n    }\n    return support;\n  }\n\n  function createCallback(element, callback) {\n    // detect available wheel event\n\n    var fn = function(originalEvent) {\n      !originalEvent && (originalEvent = window.event);\n\n      // create a normalized event object\n      var event = {\n        // keep a ref to the original event object\n        originalEvent: originalEvent,\n        target: originalEvent.target || originalEvent.srcElement,\n        type: \"wheel\",\n        deltaMode: originalEvent.type == \"MozMousePixelScroll\" ? 0 : 1,\n        deltaX: 0,\n        delatZ: 0,\n        preventDefault: function() {\n          originalEvent.preventDefault\n            ? originalEvent.preventDefault()\n            : (originalEvent.returnValue = false);\n        }\n      };\n\n      // calculate deltaY (and deltaX) according to the event\n      if (getSupport() == \"mousewheel\") {\n        event.deltaY = (-1 / 40) * originalEvent.wheelDelta;\n        // Webkit also support wheelDeltaX\n        originalEvent.wheelDeltaX &&\n          (event.deltaX = (-1 / 40) * originalEvent.wheelDeltaX);\n      } else {\n        event.deltaY = originalEvent.detail;\n      }\n\n      // it's time to fire the callback\n      return callback(event);\n    };\n\n    fns.push({\n      element: element,\n      fn: fn\n    });\n\n    return fn;\n  }\n\n  function getCallback(element) {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].element === element) {\n        return fns[i].fn;\n      }\n    }\n    return function() {};\n  }\n\n  function removeCallback(element) {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].element === element) {\n        return fns.splice(i, 1);\n      }\n    }\n  }\n\n  function _addWheelListener(elem, eventName, callback, isPassiveListener) {\n    var cb;\n\n    if (getSupport() === \"wheel\") {\n      cb = callback;\n    } else {\n      cb = createCallback(elem, callback);\n    }\n\n    elem[_addEventListener](\n      prefix + eventName,\n      cb,\n      isPassiveListener ? passiveTrueOption : passiveFalseOption\n    );\n  }\n\n  function _removeWheelListener(elem, eventName, callback, isPassiveListener) {\n    var cb;\n\n    if (getSupport() === \"wheel\") {\n      cb = callback;\n    } else {\n      cb = getCallback(elem);\n    }\n\n    elem[_removeEventListener](\n      prefix + eventName,\n      cb,\n      isPassiveListener ? passiveTrueOption : passiveFalseOption\n    );\n\n    removeCallback(elem);\n  }\n\n  function addWheelListener(elem, callback, isPassiveListener) {\n    _addWheelListener(elem, getSupport(), callback, isPassiveListener);\n\n    // handle MozMousePixelScroll in older Firefox\n    if (getSupport() == \"DOMMouseScroll\") {\n      _addWheelListener(\n        elem,\n        \"MozMousePixelScroll\",\n        callback,\n        isPassiveListener\n      );\n    }\n  }\n\n  function removeWheelListener(elem, callback, isPassiveListener) {\n    _removeWheelListener(elem, getSupport(), callback, isPassiveListener);\n\n    // handle MozMousePixelScroll in older Firefox\n    if (getSupport() == \"DOMMouseScroll\") {\n      _removeWheelListener(\n        elem,\n        \"MozMousePixelScroll\",\n        callback,\n        isPassiveListener\n      );\n    }\n  }\n\n  return {\n    on: addWheelListener,\n    off: removeWheelListener\n  };\n})();\n","var Utils = require(\"./utilities\"),\n  _browser = \"unknown\";\n\n// http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\nif (\n  /*@cc_on!@*/ false ||\n  (typeof document != \"undefined\" && !!document.documentMode)\n) {\n  // internet explorer\n  _browser = \"ie\";\n}\n\nmodule.exports = {\n  svgNS: \"http://www.w3.org/2000/svg\",\n  xmlNS: \"http://www.w3.org/XML/1998/namespace\",\n  xmlnsNS: \"http://www.w3.org/2000/xmlns/\",\n  xlinkNS: \"http://www.w3.org/1999/xlink\",\n  evNS: \"http://www.w3.org/2001/xml-events\",\n\n  /**\n   * Get svg dimensions: width and height\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {Object}     {width: 0, height: 0}\n   */\n  getBoundingClientRectNormalized: function (svg) {\n    if (svg.clientWidth && svg.clientHeight) {\n      return { width: svg.clientWidth, height: svg.clientHeight };\n    } else if (!!svg.getBoundingClientRect()) {\n      return svg.getBoundingClientRect();\n    } else {\n      throw new Error(\"Cannot get BoundingClientRect for SVG.\");\n    }\n  },\n\n  /**\n   * Gets g element with class of \"viewport\" or creates it if it doesn't exist\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {SVGElement}     g (group) element\n   */\n  getOrCreateViewport: function (svg, selector) {\n    var viewport = null;\n\n    if (Utils.isElement(selector)) {\n      viewport = selector;\n    } else {\n      viewport = svg.querySelector(selector);\n    }\n\n    // Check if there is just one main group in SVG\n    if (!viewport) {\n      var childNodes = Array.prototype.slice\n        .call(svg.childNodes || svg.children)\n        .filter(function (el) {\n          return el.nodeName !== \"defs\" && el.nodeName !== \"#text\";\n        });\n\n      // Node name should be SVGGElement and should have no transform attribute\n      // Groups with transform are not used as viewport because it involves parsing of all transform possibilities\n      if (\n        childNodes.length === 1 &&\n        childNodes[0].nodeName === \"g\" &&\n        childNodes[0].getAttribute(\"transform\") === null\n      ) {\n        viewport = childNodes[0];\n      }\n    }\n\n    // If no favorable group element exists then create one\n    if (!viewport) {\n      var viewportId =\n        \"viewport-\" + new Date().toISOString().replace(/\\D/g, \"\");\n      viewport = document.createElementNS(this.svgNS, \"g\");\n      viewport.setAttribute(\"id\", viewportId);\n\n      // Internet Explorer (all versions?) can't use childNodes, but other browsers prefer (require?) using childNodes\n      var svgChildren = svg.childNodes || svg.children;\n      if (!!svgChildren && svgChildren.length > 0) {\n        for (var i = svgChildren.length; i > 0; i--) {\n          // Move everything into viewport except defs\n          if (svgChildren[svgChildren.length - i].nodeName !== \"defs\") {\n            viewport.appendChild(svgChildren[svgChildren.length - i]);\n          }\n        }\n      }\n      svg.appendChild(viewport);\n    }\n\n    // Parse class names\n    var classNames = [];\n    if (viewport.getAttribute(\"class\")) {\n      classNames = viewport.getAttribute(\"class\").split(\" \");\n    }\n\n    // Set class (if not set already)\n    if (!~classNames.indexOf(\"svg-pan-zoom_viewport\")) {\n      classNames.push(\"svg-pan-zoom_viewport\");\n      viewport.setAttribute(\"class\", classNames.join(\" \"));\n    }\n\n    return viewport;\n  },\n\n  /**\n   * Set SVG attributes\n   *\n   * @param  {SVGSVGElement} svg\n   */\n  setupSvgAttributes: function (svg) {\n    // Setting default attributes\n    svg.setAttribute(\"xmlns\", this.svgNS);\n    svg.setAttributeNS(this.xmlnsNS, \"xmlns:xlink\", this.xlinkNS);\n    svg.setAttributeNS(this.xmlnsNS, \"xmlns:ev\", this.evNS);\n\n    // Needed for Internet Explorer, otherwise the viewport overflows\n    if (svg.parentNode !== null) {\n      var style = svg.getAttribute(\"style\") || \"\";\n      if (style.toLowerCase().indexOf(\"overflow\") === -1) {\n        svg.setAttribute(\"style\", \"overflow: hidden; \" + style);\n      }\n    }\n  },\n\n  /**\n   * How long Internet Explorer takes to finish updating its display (ms).\n   */\n  internetExplorerRedisplayInterval: 300,\n\n  /**\n   * Forces the browser to redisplay all SVG elements that rely on an\n   * element defined in a 'defs' section. It works globally, for every\n   * available defs element on the page.\n   * The throttling is intentionally global.\n   *\n   * This is only needed for IE. It is as a hack to make markers (and 'use' elements?)\n   * visible after pan/zoom when there are multiple SVGs on the page.\n   * See bug report: https://connect.microsoft.com/IE/feedback/details/781964/\n   * also see svg-pan-zoom issue: https://github.com/ariutta/svg-pan-zoom/issues/62\n   */\n  refreshDefsGlobal: Utils.throttle(\n    function () {\n      var allDefs = document.querySelectorAll(\"defs\");\n      var allDefsCount = allDefs.length;\n      for (var i = 0; i < allDefsCount; i++) {\n        var thisDefs = allDefs[i];\n        thisDefs.parentNode.insertBefore(thisDefs, thisDefs);\n      }\n    },\n    this ? this.internetExplorerRedisplayInterval : null\n  ),\n\n  /**\n   * Sets the current transform matrix of an element\n   *\n   * @param {SVGElement} element\n   * @param {SVGMatrix} matrix  CTM\n   * @param {SVGElement} defs\n   */\n  setCTM: function (element, matrix, defs) {\n    var that = this,\n      s =\n        \"matrix(\" +\n        matrix.a +\n        \",\" +\n        matrix.b +\n        \",\" +\n        matrix.c +\n        \",\" +\n        matrix.d +\n        \",\" +\n        matrix.e +\n        \",\" +\n        matrix.f +\n        \")\";\n\n    element.setAttributeNS(null, \"transform\", s);\n    if (\"transform\" in element.style) {\n      element.style.transform = s;\n    } else if (\"-ms-transform\" in element.style) {\n      element.style[\"-ms-transform\"] = s;\n    } else if (\"-webkit-transform\" in element.style) {\n      element.style[\"-webkit-transform\"] = s;\n    }\n\n    // IE has a bug that makes markers disappear on zoom (when the matrix \"a\" and/or \"d\" elements change)\n    // see http://stackoverflow.com/questions/17654578/svg-marker-does-not-work-in-ie9-10\n    // and http://srndolha.wordpress.com/2013/11/25/svg-line-markers-may-disappear-in-internet-explorer-11/\n    if (_browser === \"ie\" && !!defs) {\n      // this refresh is intended for redisplaying the SVG during zooming\n      defs.parentNode.insertBefore(defs, defs);\n      // this refresh is intended for redisplaying the other SVGs on a page when panning a given SVG\n      // it is also needed for the given SVG itself, on zoomEnd, if the SVG contains any markers that\n      // are located under any other element(s).\n      window.setTimeout(function () {\n        that.refreshDefsGlobal();\n      }, that.internetExplorerRedisplayInterval);\n    }\n  },\n\n  /**\n   * Instantiate an SVGPoint object with given event coordinates\n   *\n   * @param {Event} evt\n   * @param  {SVGSVGElement} svg\n   * @return {SVGPoint}     point\n   */\n  getEventPoint: function (evt, svg) {\n    var point = svg.createSVGPoint();\n\n    Utils.mouseAndTouchNormalize(evt, svg);\n\n    point.x = evt.clientX;\n    point.y = evt.clientY;\n\n    return point;\n  },\n\n  /**\n   * Instantiate an SVGPoint object with given touch event coordinates\n   *\n   * @param {Event} evt\n   * @param  {SVGSVGElement} svg\n   * @param  {Number} touch\n   * @return {SVGPoint}     point\n   */\n  getTouchPoint: function (evt, svg, touch) {\n    var point = svg.createSVGPoint();\n\n    Utils.touchNormalize(evt, svg, touch);\n\n    point.x = evt.clientX;\n    point.y = evt.clientY;\n\n    return point;\n  },\n\n  /**\n   * Get SVG center point\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {SVGPoint}\n   */\n  getSvgCenterPoint: function (svg, width, height) {\n    return this.createSVGPoint(svg, width / 2, height / 2);\n  },\n\n  /**\n   * Create a SVGPoint with given x and y\n   *\n   * @param  {SVGSVGElement} svg\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {SVGPoint}\n   */\n  createSVGPoint: function (svg, x, y) {\n    var point = svg.createSVGPoint();\n    point.x = x;\n    point.y = y;\n\n    return point;\n  },\n};\n","var SvgUtils = require(\"./svg-utilities\");\n\nmodule.exports = {\n  enable: function (instance) {\n    // Select (and create if necessary) defs\n    var defs = instance.svg.querySelector(\"defs\");\n    if (!defs) {\n      defs = document.createElementNS(SvgUtils.svgNS, \"defs\");\n      instance.svg.appendChild(defs);\n    }\n\n    // Check for style element, and create it if it doesn't exist\n    var styleEl = defs.querySelector(\"style#svg-pan-zoom-controls-styles\");\n    if (!styleEl) {\n      var style = document.createElementNS(SvgUtils.svgNS, \"style\");\n      style.setAttribute(\"id\", \"svg-pan-zoom-controls-styles\");\n      style.setAttribute(\"type\", \"text/css\");\n      style.textContent =\n        \".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }\";\n      defs.appendChild(style);\n    }\n\n    // Zoom Group\n    var zoomGroup = document.createElementNS(SvgUtils.svgNS, \"g\");\n    zoomGroup.setAttribute(\"id\", \"svg-pan-zoom-controls\");\n    zoomGroup.setAttribute(\n      \"transform\",\n      \"translate(\" +\n        (instance.width - 70) +\n        \" \" +\n        (instance.height - 76) +\n        \") scale(0.75)\"\n    );\n    zoomGroup.setAttribute(\"class\", \"svg-pan-zoom-control\");\n\n    // Control elements\n    zoomGroup.appendChild(this._createZoomIn(instance));\n    zoomGroup.appendChild(this._createZoomReset(instance));\n    zoomGroup.appendChild(this._createZoomOut(instance));\n\n    // Finally append created element\n    instance.svg.appendChild(zoomGroup);\n\n    // Cache control instance\n    instance.controlIcons = zoomGroup;\n  },\n\n  _createZoomIn: function (instance) {\n    var zoomIn = document.createElementNS(SvgUtils.svgNS, \"g\");\n    zoomIn.setAttribute(\"id\", \"svg-pan-zoom-zoom-in\");\n    zoomIn.setAttribute(\"transform\", \"translate(30.5 5) scale(0.015)\");\n    zoomIn.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    zoomIn.addEventListener(\n      \"click\",\n      function () {\n        instance.getPublicInstance().zoomIn();\n      },\n      false\n    );\n    zoomIn.addEventListener(\n      \"touchstart\",\n      function () {\n        instance.getPublicInstance().zoomIn();\n      },\n      false\n    );\n\n    var zoomInBackground = document.createElementNS(SvgUtils.svgNS, \"rect\"); // TODO change these background space fillers to rounded rectangles so they look prettier\n    zoomInBackground.setAttribute(\"x\", \"0\");\n    zoomInBackground.setAttribute(\"y\", \"0\");\n    zoomInBackground.setAttribute(\"width\", \"1500\"); // larger than expected because the whole group is transformed to scale down\n    zoomInBackground.setAttribute(\"height\", \"1400\");\n    zoomInBackground.setAttribute(\"class\", \"svg-pan-zoom-control-background\");\n    zoomIn.appendChild(zoomInBackground);\n\n    var zoomInShape = document.createElementNS(SvgUtils.svgNS, \"path\");\n    zoomInShape.setAttribute(\n      \"d\",\n      \"M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z\"\n    );\n    zoomInShape.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    zoomIn.appendChild(zoomInShape);\n\n    return zoomIn;\n  },\n\n  _createZoomReset: function (instance) {\n    // reset\n    var resetPanZoomControl = document.createElementNS(SvgUtils.svgNS, \"g\");\n    resetPanZoomControl.setAttribute(\"id\", \"svg-pan-zoom-reset-pan-zoom\");\n    resetPanZoomControl.setAttribute(\"transform\", \"translate(5 35) scale(0.4)\");\n    resetPanZoomControl.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    resetPanZoomControl.addEventListener(\n      \"click\",\n      function () {\n        instance.getPublicInstance().reset();\n      },\n      false\n    );\n    resetPanZoomControl.addEventListener(\n      \"touchstart\",\n      function () {\n        instance.getPublicInstance().reset();\n      },\n      false\n    );\n\n    var resetPanZoomControlBackground = document.createElementNS(\n      SvgUtils.svgNS,\n      \"rect\"\n    ); // TODO change these background space fillers to rounded rectangles so they look prettier\n    resetPanZoomControlBackground.setAttribute(\"x\", \"2\");\n    resetPanZoomControlBackground.setAttribute(\"y\", \"2\");\n    resetPanZoomControlBackground.setAttribute(\"width\", \"182\"); // larger than expected because the whole group is transformed to scale down\n    resetPanZoomControlBackground.setAttribute(\"height\", \"58\");\n    resetPanZoomControlBackground.setAttribute(\n      \"class\",\n      \"svg-pan-zoom-control-background\"\n    );\n    resetPanZoomControl.appendChild(resetPanZoomControlBackground);\n\n    var resetPanZoomControlShape1 = document.createElementNS(\n      SvgUtils.svgNS,\n      \"path\"\n    );\n    resetPanZoomControlShape1.setAttribute(\n      \"d\",\n      \"M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z\"\n    );\n    resetPanZoomControlShape1.setAttribute(\n      \"class\",\n      \"svg-pan-zoom-control-element\"\n    );\n    resetPanZoomControl.appendChild(resetPanZoomControlShape1);\n\n    var resetPanZoomControlShape2 = document.createElementNS(\n      SvgUtils.svgNS,\n      \"path\"\n    );\n    resetPanZoomControlShape2.setAttribute(\n      \"d\",\n      \"M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z\"\n    );\n    resetPanZoomControlShape2.setAttribute(\n      \"class\",\n      \"svg-pan-zoom-control-element\"\n    );\n    resetPanZoomControl.appendChild(resetPanZoomControlShape2);\n\n    return resetPanZoomControl;\n  },\n\n  _createZoomOut: function (instance) {\n    // zoom out\n    var zoomOut = document.createElementNS(SvgUtils.svgNS, \"g\");\n    zoomOut.setAttribute(\"id\", \"svg-pan-zoom-zoom-out\");\n    zoomOut.setAttribute(\"transform\", \"translate(30.5 70) scale(0.015)\");\n    zoomOut.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    zoomOut.addEventListener(\n      \"click\",\n      function () {\n        instance.getPublicInstance().zoomOut();\n      },\n      false\n    );\n    zoomOut.addEventListener(\n      \"touchstart\",\n      function () {\n        instance.getPublicInstance().zoomOut();\n      },\n      false\n    );\n\n    var zoomOutBackground = document.createElementNS(SvgUtils.svgNS, \"rect\"); // TODO change these background space fillers to rounded rectangles so they look prettier\n    zoomOutBackground.setAttribute(\"x\", \"0\");\n    zoomOutBackground.setAttribute(\"y\", \"0\");\n    zoomOutBackground.setAttribute(\"width\", \"1500\"); // larger than expected because the whole group is transformed to scale down\n    zoomOutBackground.setAttribute(\"height\", \"1400\");\n    zoomOutBackground.setAttribute(\"class\", \"svg-pan-zoom-control-background\");\n    zoomOut.appendChild(zoomOutBackground);\n\n    var zoomOutShape = document.createElementNS(SvgUtils.svgNS, \"path\");\n    zoomOutShape.setAttribute(\n      \"d\",\n      \"M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z\"\n    );\n    zoomOutShape.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    zoomOut.appendChild(zoomOutShape);\n\n    return zoomOut;\n  },\n\n  disable: function (instance) {\n    if (instance.controlIcons) {\n      instance.controlIcons.parentNode.removeChild(instance.controlIcons);\n      instance.controlIcons = null;\n    }\n  },\n};\n","var SvgUtils = require(\"./svg-utilities\"),\n  Utils = require(\"./utilities\");\n\nvar ShadowViewport = function (viewport, options) {\n  this.init(viewport, options);\n};\n\n/**\n * Initialization\n *\n * @param  {SVGElement} viewport\n * @param  {Object} options\n */\nShadowViewport.prototype.init = function (viewport, options) {\n  // DOM Elements\n  this.viewport = viewport;\n  this.options = options;\n\n  // State cache\n  this.originalState = { zoom: 1, x: 0, y: 0 };\n  this.activeState = { zoom: 1, x: 0, y: 0 };\n\n  this.updateCTMCached = Utils.proxy(this.updateCTM, this);\n\n  // Create a custom requestAnimationFrame taking in account refreshRate\n  this.requestAnimationFrame = Utils.createRequestAnimationFrame(\n    this.options.refreshRate\n  );\n\n  // ViewBox\n  this.viewBox = { x: 0, y: 0, width: 0, height: 0 };\n  this.cacheViewBox();\n\n  // Process CTM\n  var newCTM = this.processCTM();\n\n  // Update viewport CTM and cache zoom and pan\n  this.setCTM(newCTM);\n\n  // Update CTM in this frame\n  this.updateCTM();\n};\n\n/**\n * Cache initial viewBox value\n * If no viewBox is defined, then use viewport size/position instead for viewBox values\n */\nShadowViewport.prototype.cacheViewBox = function () {\n  var svgViewBox = this.options.svg.getAttribute(\"viewBox\");\n\n  if (svgViewBox) {\n    var viewBoxValues = svgViewBox\n      .split(/[\\s\\,]/)\n      .filter(function (v) {\n        return v;\n      })\n      .map(parseFloat);\n\n    // Cache viewbox x and y offset\n    this.viewBox.x = viewBoxValues[0];\n    this.viewBox.y = viewBoxValues[1];\n    this.viewBox.width = viewBoxValues[2];\n    this.viewBox.height = viewBoxValues[3];\n\n    var zoom = Math.min(\n      this.options.width / this.viewBox.width,\n      this.options.height / this.viewBox.height\n    );\n\n    // Update active state\n    this.activeState.zoom = isFinite(zoom) ? zoom : 1;\n    this.activeState.x = (this.options.width - this.viewBox.width * zoom) / 2;\n    this.activeState.y = (this.options.height - this.viewBox.height * zoom) / 2;\n\n    // Force updating CTM\n    this.updateCTMOnNextFrame();\n\n    this.options.svg.removeAttribute(\"viewBox\");\n  } else {\n    this.simpleViewBoxCache();\n  }\n};\n\n/**\n * Recalculate viewport sizes and update viewBox cache\n */\nShadowViewport.prototype.simpleViewBoxCache = function () {\n  var bBox = this.viewport.getBBox();\n\n  this.viewBox.x = bBox.x;\n  this.viewBox.y = bBox.y;\n  this.viewBox.width = bBox.width;\n  this.viewBox.height = bBox.height;\n};\n\n/**\n * Returns a viewbox object. Safe to alter\n *\n * @return {Object} viewbox object\n */\nShadowViewport.prototype.getViewBox = function () {\n  return Utils.extend({}, this.viewBox);\n};\n\n/**\n * Get initial zoom and pan values. Save them into originalState\n * Parses viewBox attribute to alter initial sizes\n *\n * @return {CTM} CTM object based on options\n */\nShadowViewport.prototype.processCTM = function () {\n  var newCTM = this.getCTM();\n\n  if (this.options.fit || this.options.contain) {\n    var newScale;\n    if (this.options.fit) {\n      newScale = Math.min(\n        this.options.width / this.viewBox.width,\n        this.options.height / this.viewBox.height\n      );\n    } else {\n      newScale = Math.max(\n        this.options.width / this.viewBox.width,\n        this.options.height / this.viewBox.height\n      );\n    }\n\n    newScale = isFinite(newScale) ? newScale : 1;\n\n    newCTM.a = newScale; //x-scale\n    newCTM.d = newScale; //y-scale\n    newCTM.e = -this.viewBox.x * newScale; //x-transform\n    newCTM.f = -this.viewBox.y * newScale; //y-transform\n  }\n\n  if (this.options.center) {\n    var offsetX =\n        (this.options.width -\n          (this.viewBox.width + this.viewBox.x * 2) * newCTM.a) *\n        0.5,\n      offsetY =\n        (this.options.height -\n          (this.viewBox.height + this.viewBox.y * 2) * newCTM.a) *\n        0.5;\n\n    newCTM.e = offsetX;\n    newCTM.f = offsetY;\n  }\n\n  // Cache initial values. Based on activeState and fix+center opitons\n  this.originalState.zoom = newCTM.a;\n  this.originalState.x = newCTM.e;\n  this.originalState.y = newCTM.f;\n\n  return newCTM;\n};\n\n/**\n * Return originalState object. Safe to alter\n *\n * @return {Object}\n */\nShadowViewport.prototype.getOriginalState = function () {\n  return Utils.extend({}, this.originalState);\n};\n\n/**\n * Return actualState object. Safe to alter\n *\n * @return {Object}\n */\nShadowViewport.prototype.getState = function () {\n  return Utils.extend({}, this.activeState);\n};\n\n/**\n * Get zoom scale\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.getZoom = function () {\n  return this.activeState.zoom;\n};\n\n/**\n * Get zoom scale for pubilc usage\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.getRelativeZoom = function () {\n  return this.activeState.zoom / this.originalState.zoom;\n};\n\n/**\n * Compute zoom scale for pubilc usage\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.computeRelativeZoom = function (scale) {\n  return scale / this.originalState.zoom;\n};\n\n/**\n * Get pan\n *\n * @return {Object}\n */\nShadowViewport.prototype.getPan = function () {\n  return { x: this.activeState.x, y: this.activeState.y };\n};\n\n/**\n * Return cached viewport CTM value that can be safely modified\n *\n * @return {SVGMatrix}\n */\nShadowViewport.prototype.getCTM = function () {\n  var safeCTM = this.options.svg.createSVGMatrix();\n\n  // Copy values manually as in FF they are not itterable\n  safeCTM.a = this.activeState.zoom;\n  safeCTM.b = 0;\n  safeCTM.c = 0;\n  safeCTM.d = this.activeState.zoom;\n  safeCTM.e = this.activeState.x;\n  safeCTM.f = this.activeState.y;\n\n  return safeCTM;\n};\n\n/**\n * Set a new CTM\n *\n * @param {SVGMatrix} newCTM\n */\nShadowViewport.prototype.setCTM = function (newCTM) {\n  var willZoom = this.isZoomDifferent(newCTM),\n    willPan = this.isPanDifferent(newCTM);\n\n  if (willZoom || willPan) {\n    // Before zoom\n    if (willZoom) {\n      // If returns false then cancel zooming\n      if (\n        this.options.beforeZoom(\n          this.getRelativeZoom(),\n          this.computeRelativeZoom(newCTM.a)\n        ) === false\n      ) {\n        newCTM.a = newCTM.d = this.activeState.zoom;\n        willZoom = false;\n      } else {\n        this.updateCache(newCTM);\n        this.options.onZoom(this.getRelativeZoom());\n      }\n    }\n\n    // Before pan\n    if (willPan) {\n      var preventPan = this.options.beforePan(this.getPan(), {\n          x: newCTM.e,\n          y: newCTM.f,\n        }),\n        // If prevent pan is an object\n        preventPanX = false,\n        preventPanY = false;\n\n      // If prevent pan is Boolean false\n      if (preventPan === false) {\n        // Set x and y same as before\n        newCTM.e = this.getPan().x;\n        newCTM.f = this.getPan().y;\n\n        preventPanX = preventPanY = true;\n      } else if (Utils.isObject(preventPan)) {\n        // Check for X axes attribute\n        if (preventPan.x === false) {\n          // Prevent panning on x axes\n          newCTM.e = this.getPan().x;\n          preventPanX = true;\n        } else if (Utils.isNumber(preventPan.x)) {\n          // Set a custom pan value\n          newCTM.e = preventPan.x;\n        }\n\n        // Check for Y axes attribute\n        if (preventPan.y === false) {\n          // Prevent panning on x axes\n          newCTM.f = this.getPan().y;\n          preventPanY = true;\n        } else if (Utils.isNumber(preventPan.y)) {\n          // Set a custom pan value\n          newCTM.f = preventPan.y;\n        }\n      }\n\n      // Update willPan flag\n      // Check if newCTM is still different\n      if ((preventPanX && preventPanY) || !this.isPanDifferent(newCTM)) {\n        willPan = false;\n      } else {\n        this.updateCache(newCTM);\n        this.options.onPan(this.getPan());\n      }\n    }\n\n    // Check again if should zoom or pan\n    if (willZoom || willPan) {\n      this.updateCTMOnNextFrame();\n    }\n  }\n};\n\nShadowViewport.prototype.isZoomDifferent = function (newCTM) {\n  return this.activeState.zoom !== newCTM.a;\n};\n\nShadowViewport.prototype.isPanDifferent = function (newCTM) {\n  return this.activeState.x !== newCTM.e || this.activeState.y !== newCTM.f;\n};\n\n/**\n * Update cached CTM and active state\n *\n * @param {SVGMatrix} newCTM\n */\nShadowViewport.prototype.updateCache = function (newCTM) {\n  this.activeState.zoom = newCTM.a;\n  this.activeState.x = newCTM.e;\n  this.activeState.y = newCTM.f;\n};\n\nShadowViewport.prototype.pendingUpdate = false;\n\n/**\n * Place a request to update CTM on next Frame\n */\nShadowViewport.prototype.updateCTMOnNextFrame = function () {\n  if (!this.pendingUpdate) {\n    // Lock\n    this.pendingUpdate = true;\n\n    // Throttle next update\n    this.requestAnimationFrame.call(window, this.updateCTMCached);\n  }\n};\n\n/**\n * Update viewport CTM with cached CTM\n */\nShadowViewport.prototype.updateCTM = function () {\n  var ctm = this.getCTM();\n\n  // Updates SVG element\n  SvgUtils.setCTM(this.viewport, ctm, this.defs);\n\n  // Free the lock\n  this.pendingUpdate = false;\n\n  // Notify about the update\n  if (this.options.onUpdatedCTM) {\n    this.options.onUpdatedCTM(ctm);\n  }\n};\n\nmodule.exports = function (viewport, options) {\n  return new ShadowViewport(viewport, options);\n};\n","var Wheel = require(\"./uniwheel\"),\n  ControlIcons = require(\"./control-icons\"),\n  Utils = require(\"./utilities\"),\n  SvgUtils = require(\"./svg-utilities\"),\n  ShadowViewport = require(\"./shadow-viewport\");\n\nvar SvgPanZoom = function (svg, options) {\n  this.init(svg, options);\n};\n\nvar optionsDefaults = {\n  viewportSelector: \".svg-pan-zoom_viewport\", // Viewport selector. Can be querySelector string or SVGElement\n  panEnabled: true, // enable or disable panning (default enabled)\n  controlIconsEnabled: false, // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)\n  zoomEnabled: true, // enable or disable zooming (default enabled)\n  dblClickZoomEnabled: true, // enable or disable zooming by double clicking (default enabled)\n  mouseWheelZoomEnabled: true, // enable or disable zooming by mouse wheel (default enabled)\n  preventMouseEventsDefault: true, // enable or disable preventDefault for mouse events\n  zoomScaleSensitivity: 0.1, // Zoom sensitivity\n  minZoom: 0.5, // Minimum Zoom level\n  maxZoom: 10, // Maximum Zoom level\n  fit: true, // enable or disable viewport fit in SVG (default true)\n  contain: false, // enable or disable viewport contain the svg (default false)\n  center: true, // enable or disable viewport centering in SVG (default true)\n  refreshRate: \"auto\", // Maximum number of frames per second (altering SVG's viewport)\n  beforeZoom: null,\n  onZoom: null,\n  beforePan: null,\n  onPan: null,\n  customEventsHandler: null,\n  eventsListenerElement: null,\n  onUpdatedCTM: null,\n};\n\nvar passiveListenerTrueOption = { passive: true };\nvar passiveListenerFalseOption = { passive: false };\n\nSvgPanZoom.prototype.init = function (svg, options) {\n  var that = this;\n\n  this.svg = svg;\n  this.defs = svg.querySelector(\"defs\");\n\n  // Add default attributes to SVG\n  SvgUtils.setupSvgAttributes(this.svg);\n\n  // Set options\n  this.options = Utils.extend(Utils.extend({}, optionsDefaults), options);\n\n  // Set default state\n  this.state = \"none\";\n\n  // Get dimensions\n  var boundingClientRectNormalized =\n    SvgUtils.getBoundingClientRectNormalized(svg);\n  this.width = boundingClientRectNormalized.width;\n  this.height = boundingClientRectNormalized.height;\n\n  // Init shadow viewport\n  this.viewport = ShadowViewport(\n    SvgUtils.getOrCreateViewport(this.svg, this.options.viewportSelector),\n    {\n      svg: this.svg,\n      width: this.width,\n      height: this.height,\n      fit: this.options.fit,\n      contain: this.options.contain,\n      center: this.options.center,\n      refreshRate: this.options.refreshRate,\n      // Put callbacks into functions as they can change through time\n      beforeZoom: function (oldScale, newScale) {\n        if (that.viewport && that.options.beforeZoom) {\n          return that.options.beforeZoom(oldScale, newScale);\n        }\n      },\n      onZoom: function (scale) {\n        if (that.viewport && that.options.onZoom) {\n          return that.options.onZoom(scale);\n        }\n      },\n      beforePan: function (oldPoint, newPoint) {\n        if (that.viewport && that.options.beforePan) {\n          return that.options.beforePan(oldPoint, newPoint);\n        }\n      },\n      onPan: function (point) {\n        if (that.viewport && that.options.onPan) {\n          return that.options.onPan(point);\n        }\n      },\n      onUpdatedCTM: function (ctm) {\n        if (that.viewport && that.options.onUpdatedCTM) {\n          return that.options.onUpdatedCTM(ctm);\n        }\n      },\n    }\n  );\n\n  // Wrap callbacks into public API context\n  var publicInstance = this.getPublicInstance();\n  publicInstance.setBeforeZoom(this.options.beforeZoom);\n  publicInstance.setOnZoom(this.options.onZoom);\n  publicInstance.setBeforePan(this.options.beforePan);\n  publicInstance.setOnPan(this.options.onPan);\n  publicInstance.setOnUpdatedCTM(this.options.onUpdatedCTM);\n\n  if (this.options.controlIconsEnabled) {\n    ControlIcons.enable(this);\n  }\n\n  // Init events handlers\n  this.lastMouseWheelEventTime = Date.now();\n  this.setupHandlers();\n};\n\n/**\n * Register event handlers\n */\nSvgPanZoom.prototype.setupHandlers = function () {\n  var that = this,\n    prevEvt = null; // use for touchstart event to detect double tap\n\n  this.eventListeners = {\n    // Mouse down group\n    pointerdown: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      var result = that.handleMouseDown(evt, prevEvt);\n      prevEvt = evt;\n      return result;\n    },\n    touchstart: function (evt) {\n      var result = that.handleTouchStart(evt, prevEvt);\n      prevEvt = evt;\n      return result;\n    },\n\n    // Mouse up group\n    pointerup: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseUp(evt);\n    },\n    touchend: function (evt) {\n      return that.handleTouchEnd(evt);\n    },\n\n    // Mouse move group\n    pointermove: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseMove(evt);\n    },\n    touchmove: function (evt) {\n      return that.handleTouchMove(evt);\n    },\n\n    // Mouse leave group\n    pointerleave: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseUp(evt);\n    },\n    pointercancel: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseUp(evt);\n    },\n    touchleave: function (evt) {\n      return that.handleTouchEnd(evt);\n    },\n    touchcancel: function (evt) {\n      return that.handleTouchEnd(evt);\n    },\n  };\n\n  // Init custom events handler if available\n  // eslint-disable-next-line eqeqeq\n  if (this.options.customEventsHandler != null) {\n    this.options.customEventsHandler.init({\n      svgElement: this.svg,\n      eventsListenerElement: this.options.eventsListenerElement,\n      instance: this.getPublicInstance(),\n    });\n\n    // Custom event handler may halt builtin listeners\n    var haltEventListeners =\n      this.options.customEventsHandler.haltEventListeners;\n    if (haltEventListeners && haltEventListeners.length) {\n      for (var i = haltEventListeners.length - 1; i >= 0; i--) {\n        if (this.eventListeners.hasOwnProperty(haltEventListeners[i])) {\n          delete this.eventListeners[haltEventListeners[i]];\n        }\n      }\n    }\n  }\n\n  // Bind eventListeners\n  for (var event in this.eventListeners) {\n    // Attach event to eventsListenerElement or SVG if not available\n    (this.options.eventsListenerElement || this.svg).addEventListener(\n      event,\n      this.eventListeners[event],\n      !this.options.preventMouseEventsDefault\n        ? passiveListenerTrueOption\n        : passiveListenerFalseOption\n    );\n  }\n\n  // Zoom using mouse wheel\n  if (this.options.mouseWheelZoomEnabled) {\n    this.options.mouseWheelZoomEnabled = false; // set to false as enable will set it back to true\n    this.enableMouseWheelZoom();\n  }\n};\n\n/**\n * Enable ability to zoom using mouse wheel\n */\nSvgPanZoom.prototype.enableMouseWheelZoom = function () {\n  if (!this.options.mouseWheelZoomEnabled) {\n    var that = this;\n\n    // Mouse wheel listener\n    this.wheelListener = function (evt) {\n      return that.handleMouseWheel(evt);\n    };\n\n    // Bind wheelListener\n    var isPassiveListener = !this.options.preventMouseEventsDefault;\n    Wheel.on(\n      this.options.eventsListenerElement || this.svg,\n      this.wheelListener,\n      isPassiveListener\n    );\n\n    this.options.mouseWheelZoomEnabled = true;\n  }\n};\n\n/**\n * Disable ability to zoom using mouse wheel\n */\nSvgPanZoom.prototype.disableMouseWheelZoom = function () {\n  if (this.options.mouseWheelZoomEnabled) {\n    var isPassiveListener = !this.options.preventMouseEventsDefault;\n    Wheel.off(\n      this.options.eventsListenerElement || this.svg,\n      this.wheelListener,\n      isPassiveListener\n    );\n    this.options.mouseWheelZoomEnabled = false;\n  }\n};\n\n/**\n * Handle mouse wheel event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleMouseWheel = function (evt) {\n  if (!this.options.zoomEnabled || this.state !== \"none\") {\n    return;\n  }\n\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  // Default delta in case that deltaY is not available\n  var delta = evt.deltaY || 1,\n    timeDelta = Date.now() - this.lastMouseWheelEventTime,\n    divider = 3 + Math.max(0, 30 - timeDelta);\n\n  // Update cache\n  this.lastMouseWheelEventTime = Date.now();\n\n  // Make empirical adjustments for browsers that give deltaY in pixels (deltaMode=0)\n  if (\"deltaMode\" in evt && evt.deltaMode === 0 && evt.wheelDelta) {\n    delta = evt.deltaY === 0 ? 0 : Math.abs(evt.wheelDelta) / evt.deltaY;\n  }\n\n  delta =\n    -0.3 < delta && delta < 0.3\n      ? delta\n      : ((delta > 0 ? 1 : -1) * Math.log(Math.abs(delta) + 10)) / divider;\n\n  var inversedScreenCTM = this.svg.getScreenCTM().inverse(),\n    relativeMousePoint = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n      inversedScreenCTM\n    ),\n    zoom = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * delta); // multiplying by neg. 1 so as to make zoom in/out behavior match Google maps behavior\n\n  this.zoomAtPoint(zoom, relativeMousePoint);\n};\n\n/**\n * Zoom in at a SVG point\n *\n * @param  {SVGPoint} point\n * @param  {Float} zoomScale    Number representing how much to zoom\n * @param  {Boolean} zoomAbsolute Default false. If true, zoomScale is treated as an absolute value.\n *                                Otherwise, zoomScale is treated as a multiplied (e.g. 1.10 would zoom in 10%)\n */\nSvgPanZoom.prototype.zoomAtPoint = function (zoomScale, point, zoomAbsolute) {\n  var originalState = this.viewport.getOriginalState();\n\n  if (!zoomAbsolute) {\n    // Fit zoomScale in set bounds\n    if (\n      this.getZoom() * zoomScale <\n      this.options.minZoom * originalState.zoom\n    ) {\n      zoomScale = (this.options.minZoom * originalState.zoom) / this.getZoom();\n    } else if (\n      this.getZoom() * zoomScale >\n      this.options.maxZoom * originalState.zoom\n    ) {\n      zoomScale = (this.options.maxZoom * originalState.zoom) / this.getZoom();\n    }\n  } else {\n    // Fit zoomScale in set bounds\n    zoomScale = Math.max(\n      this.options.minZoom * originalState.zoom,\n      Math.min(this.options.maxZoom * originalState.zoom, zoomScale)\n    );\n    // Find relative scale to achieve desired scale\n    zoomScale = zoomScale / this.getZoom();\n  }\n\n  var oldCTM = this.viewport.getCTM(),\n    relativePoint = point.matrixTransform(oldCTM.inverse()),\n    modifier = this.svg\n      .createSVGMatrix()\n      .translate(relativePoint.x, relativePoint.y)\n      .scale(zoomScale)\n      .translate(-relativePoint.x, -relativePoint.y),\n    newCTM = oldCTM.multiply(modifier);\n\n  if (newCTM.a !== oldCTM.a) {\n    this.viewport.setCTM(newCTM);\n  }\n};\n\n/**\n * Zoom at center point\n *\n * @param  {Float} scale\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.zoom = function (scale, absolute) {\n  this.zoomAtPoint(\n    scale,\n    SvgUtils.getSvgCenterPoint(this.svg, this.width, this.height),\n    absolute\n  );\n};\n\n/**\n * Zoom used by public instance\n *\n * @param  {Float} scale\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.publicZoom = function (scale, absolute) {\n  if (absolute) {\n    scale = this.computeFromRelativeZoom(scale);\n  }\n\n  this.zoom(scale, absolute);\n};\n\n/**\n * Zoom at point used by public instance\n *\n * @param  {Float} scale\n * @param  {SVGPoint|Object} point    An object that has x and y attributes\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.publicZoomAtPoint = function (scale, point, absolute) {\n  if (absolute) {\n    // Transform zoom into a relative value\n    scale = this.computeFromRelativeZoom(scale);\n  }\n\n  // If not a SVGPoint but has x and y then create a SVGPoint\n  if (Utils.getType(point) !== \"SVGPoint\") {\n    if (\"x\" in point && \"y\" in point) {\n      point = SvgUtils.createSVGPoint(this.svg, point.x, point.y);\n    } else {\n      throw new Error(\"Given point is invalid\");\n    }\n  }\n\n  this.zoomAtPoint(scale, point, absolute);\n};\n\n/**\n * Get zoom scale\n *\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.getZoom = function () {\n  return this.viewport.getZoom();\n};\n\n/**\n * Get zoom scale for public usage\n *\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.getRelativeZoom = function () {\n  return this.viewport.getRelativeZoom();\n};\n\n/**\n * Compute actual zoom from public zoom\n *\n * @param  {Float} zoom\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.computeFromRelativeZoom = function (zoom) {\n  return zoom * this.viewport.getOriginalState().zoom;\n};\n\n/**\n * Set zoom to initial state\n */\nSvgPanZoom.prototype.resetZoom = function () {\n  var originalState = this.viewport.getOriginalState();\n\n  this.zoom(originalState.zoom, true);\n};\n\n/**\n * Set pan to initial state\n */\nSvgPanZoom.prototype.resetPan = function () {\n  this.pan(this.viewport.getOriginalState());\n};\n\n/**\n * Set pan and zoom to initial state\n */\nSvgPanZoom.prototype.reset = function () {\n  this.resetZoom();\n  this.resetPan();\n};\n\n/**\n * Handle double click event\n * See handleMouseDown() for alternate detection method\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleDblClick = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  // Check if target was a control button\n  if (this.options.controlIconsEnabled) {\n    var targetClass = evt.target.getAttribute(\"class\") || \"\";\n    if (targetClass.indexOf(\"svg-pan-zoom-control\") > -1) {\n      return false;\n    }\n  }\n\n  var zoomFactor;\n\n  if (evt.shiftKey) {\n    zoomFactor = 1 / ((1 + this.options.zoomScaleSensitivity) * 2); // zoom out when shift key pressed\n  } else {\n    zoomFactor = (1 + this.options.zoomScaleSensitivity) * 2;\n  }\n\n  var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n    this.svg.getScreenCTM().inverse()\n  );\n  this.zoomAtPoint(zoomFactor, point);\n};\n\n/**\n * Handle click event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleMouseDown = function (evt, prevEvt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  Utils.mouseAndTouchNormalize(evt, this.svg);\n\n  // Double click detection; more consistent than ondblclick\n  if (this.options.dblClickZoomEnabled && Utils.isDblClick(evt, prevEvt)) {\n    this.handleDblClick(evt);\n  } else {\n    // Pan mode\n    this.state = \"pan\";\n    this.firstEventCTM = this.viewport.getCTM();\n    this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n      this.firstEventCTM.inverse()\n    );\n  }\n};\n\n/**\n * Handle mouse move event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleMouseMove = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  if (this.state === \"pan\" && this.options.panEnabled) {\n    // Pan mode\n    var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n        this.firstEventCTM.inverse()\n      ),\n      viewportCTM = this.firstEventCTM.translate(\n        point.x - this.stateOrigin.x,\n        point.y - this.stateOrigin.y\n      );\n\n    this.viewport.setCTM(viewportCTM);\n  }\n};\n\n/**\n * Handle mouse button release event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleMouseUp = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  if (this.state === \"pan\") {\n    // Quit pan mode\n    this.state = \"none\";\n  }\n};\n\n/**\n * Handle click event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleTouchStart = function (evt, prevEvt) {\n  if (evt.touches.length == 1) {\n    this.handleMouseDown(evt, prevEvt);\n  } else {\n    if (this.options.preventMouseEventsDefault) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else {\n        evt.returnValue = false;\n      }\n    }\n\n    this.firstEventCTM = this.viewport.getCTM();\n    var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);\n    var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);\n    this.firstDistance = Utils.calculateDistance(touch1, touch2);\n    touch1.x = (touch1.x + touch2.x) / 2;\n    touch1.y = (touch1.y + touch2.y) / 2;\n    this.stateOrigin = touch1.matrixTransform(this.firstEventCTM.inverse());\n    this.firstZoomLevel = this.getZoom();\n  }\n};\n\n/**\n * Handle mouse move event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleTouchMove = function (evt) {\n  if (evt.touches.length == 1) {\n    this.handleMouseMove(evt);\n  } else {\n    // pan and zoom\n    if (this.options.preventMouseEventsDefault) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else {\n        evt.returnValue = false;\n      }\n    }\n    if (!this.options.panEnabled && !this.options.zoomEnabled) {\n      return;\n    }\n\n    var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);\n    var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);\n    var center = this.svg.createSVGPoint();\n    center.x = (touch1.x + touch2.x) / 2;\n    center.y = (touch1.y + touch2.y) / 2;\n\n    if (this.state === \"pan\" && this.options.panEnabled) {\n      // Pan mode\n      var point = center.matrixTransform(this.firstEventCTM.inverse());\n      var viewportCTM = this.firstEventCTM.translate(\n        point.x - this.stateOrigin.x,\n        point.y - this.stateOrigin.y\n      );\n      this.viewport.setCTM(viewportCTM);\n    }\n\n    if (this.options.zoomEnabled) {\n      // zoom\n      var distance = Utils.calculateDistance(touch1, touch2);\n      var scale = distance / this.firstDistance;\n      var inversedScreenCTM = this.svg.getScreenCTM().inverse();\n      var relativeTouchPoint = center.matrixTransform(inversedScreenCTM);\n      this.zoomAtPoint(this.firstZoomLevel * scale, relativeTouchPoint, true);\n    }\n  }\n};\n\n/**\n * Handle mouse button release event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleTouchEnd = function (evt) {\n  if (evt.touches.length == 0) {\n    this.handleMouseUp(evt);\n  } else {\n    if (this.options.preventMouseEventsDefault) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else {\n        evt.returnValue = false;\n      }\n    }\n\n    this.firstEventCTM = this.viewport.getCTM();\n    if (evt.touches.length == 1) {\n      this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n        this.firstEventCTM.inverse()\n      );\n    } else {\n      var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);\n      var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);\n      this.firstDistance = Utils.calculateDistance(touch1, touch2);\n      touch1.x = (touch1.x + touch2.x) / 2;\n      touch1.y = (touch1.y + touch2.y) / 2;\n      this.stateOrigin = touch1.matrixTransform(this.firstEventCTM.inverse());\n    }\n  }\n};\n\n/**\n * Adjust viewport size (only) so it will fit in SVG\n * Does not center image\n */\nSvgPanZoom.prototype.fit = function () {\n  var viewBox = this.viewport.getViewBox(),\n    newScale = Math.min(\n      this.width / viewBox.width,\n      this.height / viewBox.height\n    );\n\n  this.zoom(newScale, true);\n};\n\n/**\n * Adjust viewport size (only) so it will contain the SVG\n * Does not center image\n */\nSvgPanZoom.prototype.contain = function () {\n  var viewBox = this.viewport.getViewBox(),\n    newScale = Math.max(\n      this.width / viewBox.width,\n      this.height / viewBox.height\n    );\n\n  this.zoom(newScale, true);\n};\n\n/**\n * Adjust viewport pan (only) so it will be centered in SVG\n * Does not zoom/fit/contain image\n */\nSvgPanZoom.prototype.center = function () {\n  var viewBox = this.viewport.getViewBox(),\n    offsetX =\n      (this.width - (viewBox.width + viewBox.x * 2) * this.getZoom()) * 0.5,\n    offsetY =\n      (this.height - (viewBox.height + viewBox.y * 2) * this.getZoom()) * 0.5;\n\n  this.getPublicInstance().pan({ x: offsetX, y: offsetY });\n};\n\n/**\n * Update content cached BorderBox\n * Use when viewport contents change\n */\nSvgPanZoom.prototype.updateBBox = function () {\n  this.viewport.simpleViewBoxCache();\n};\n\n/**\n * Pan to a rendered position\n *\n * @param  {Object} point {x: 0, y: 0}\n */\nSvgPanZoom.prototype.pan = function (point) {\n  var viewportCTM = this.viewport.getCTM();\n  viewportCTM.e = point.x;\n  viewportCTM.f = point.y;\n  this.viewport.setCTM(viewportCTM);\n};\n\n/**\n * Relatively pan the graph by a specified rendered position vector\n *\n * @param  {Object} point {x: 0, y: 0}\n */\nSvgPanZoom.prototype.panBy = function (point) {\n  var viewportCTM = this.viewport.getCTM();\n  viewportCTM.e += point.x;\n  viewportCTM.f += point.y;\n  this.viewport.setCTM(viewportCTM);\n};\n\n/**\n * Get pan vector\n *\n * @return {Object} {x: 0, y: 0}\n */\nSvgPanZoom.prototype.getPan = function () {\n  var state = this.viewport.getState();\n\n  return { x: state.x, y: state.y };\n};\n\n/**\n * Recalculates cached svg dimensions and controls position\n */\nSvgPanZoom.prototype.resize = function () {\n  // Get dimensions\n  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(\n    this.svg\n  );\n  this.width = boundingClientRectNormalized.width;\n  this.height = boundingClientRectNormalized.height;\n\n  // Recalculate original state\n  var viewport = this.viewport;\n  viewport.options.width = this.width;\n  viewport.options.height = this.height;\n  viewport.processCTM();\n\n  // Reposition control icons by re-enabling them\n  if (this.options.controlIconsEnabled) {\n    this.getPublicInstance().disableControlIcons();\n    this.getPublicInstance().enableControlIcons();\n  }\n};\n\n/**\n * Unbind mouse events, free callbacks and destroy public instance\n */\nSvgPanZoom.prototype.destroy = function () {\n  var that = this;\n\n  // Free callbacks\n  this.beforeZoom = null;\n  this.onZoom = null;\n  this.beforePan = null;\n  this.onPan = null;\n  this.onUpdatedCTM = null;\n\n  // Destroy custom event handlers\n  // eslint-disable-next-line eqeqeq\n  if (this.options.customEventsHandler != null) {\n    this.options.customEventsHandler.destroy({\n      svgElement: this.svg,\n      eventsListenerElement: this.options.eventsListenerElement,\n      instance: this.getPublicInstance(),\n    });\n  }\n\n  // Unbind eventListeners\n  for (var event in this.eventListeners) {\n    (this.options.eventsListenerElement || this.svg).removeEventListener(\n      event,\n      this.eventListeners[event],\n      !this.options.preventMouseEventsDefault\n        ? passiveListenerTrueOption\n        : passiveListenerFalseOption\n    );\n  }\n\n  // Unbind wheelListener\n  this.disableMouseWheelZoom();\n\n  // Remove control icons\n  this.getPublicInstance().disableControlIcons();\n\n  // Remove instance from instancesStore\n  instancesStore = instancesStore.filter(function (instance) {\n    return instance.svg !== that.svg;\n  });\n\n  // Delete options and its contents\n  delete this.options;\n\n  // Delete viewport to make public shadow viewport functions uncallable\n  delete this.viewport;\n\n  // Destroy public instance and rewrite getPublicInstance\n  delete this.publicInstance;\n  delete this.pi;\n  this.getPublicInstance = function () {\n    return null;\n  };\n};\n\n/**\n * Returns a public instance object\n *\n * @return {Object} Public instance object\n */\nSvgPanZoom.prototype.getPublicInstance = function () {\n  var that = this;\n\n  // Create cache\n  if (!this.publicInstance) {\n    this.publicInstance = this.pi = {\n      // Pan\n      enablePan: function () {\n        that.options.panEnabled = true;\n        return that.pi;\n      },\n      disablePan: function () {\n        that.options.panEnabled = false;\n        return that.pi;\n      },\n      isPanEnabled: function () {\n        return !!that.options.panEnabled;\n      },\n      pan: function (point) {\n        that.pan(point);\n        return that.pi;\n      },\n      panBy: function (point) {\n        that.panBy(point);\n        return that.pi;\n      },\n      getPan: function () {\n        return that.getPan();\n      },\n      // Pan event\n      setBeforePan: function (fn) {\n        that.options.beforePan =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      setOnPan: function (fn) {\n        that.options.onPan =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      // Zoom and Control Icons\n      enableZoom: function () {\n        that.options.zoomEnabled = true;\n        return that.pi;\n      },\n      disableZoom: function () {\n        that.options.zoomEnabled = false;\n        return that.pi;\n      },\n      isZoomEnabled: function () {\n        return !!that.options.zoomEnabled;\n      },\n      enableControlIcons: function () {\n        if (!that.options.controlIconsEnabled) {\n          that.options.controlIconsEnabled = true;\n          ControlIcons.enable(that);\n        }\n        return that.pi;\n      },\n      disableControlIcons: function () {\n        if (that.options.controlIconsEnabled) {\n          that.options.controlIconsEnabled = false;\n          ControlIcons.disable(that);\n        }\n        return that.pi;\n      },\n      isControlIconsEnabled: function () {\n        return !!that.options.controlIconsEnabled;\n      },\n      // Double click zoom\n      enableDblClickZoom: function () {\n        that.options.dblClickZoomEnabled = true;\n        return that.pi;\n      },\n      disableDblClickZoom: function () {\n        that.options.dblClickZoomEnabled = false;\n        return that.pi;\n      },\n      isDblClickZoomEnabled: function () {\n        return !!that.options.dblClickZoomEnabled;\n      },\n      // Mouse wheel zoom\n      enableMouseWheelZoom: function () {\n        that.enableMouseWheelZoom();\n        return that.pi;\n      },\n      disableMouseWheelZoom: function () {\n        that.disableMouseWheelZoom();\n        return that.pi;\n      },\n      isMouseWheelZoomEnabled: function () {\n        return !!that.options.mouseWheelZoomEnabled;\n      },\n      // Zoom scale and bounds\n      setZoomScaleSensitivity: function (scale) {\n        that.options.zoomScaleSensitivity = scale;\n        return that.pi;\n      },\n      setMinZoom: function (zoom) {\n        that.options.minZoom = zoom;\n        return that.pi;\n      },\n      setMaxZoom: function (zoom) {\n        that.options.maxZoom = zoom;\n        return that.pi;\n      },\n      // Zoom event\n      setBeforeZoom: function (fn) {\n        that.options.beforeZoom =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      setOnZoom: function (fn) {\n        that.options.onZoom =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      // Zooming\n      zoom: function (scale) {\n        that.publicZoom(scale, true);\n        return that.pi;\n      },\n      zoomBy: function (scale) {\n        that.publicZoom(scale, false);\n        return that.pi;\n      },\n      zoomAtPoint: function (scale, point) {\n        that.publicZoomAtPoint(scale, point, true);\n        return that.pi;\n      },\n      zoomAtPointBy: function (scale, point) {\n        that.publicZoomAtPoint(scale, point, false);\n        return that.pi;\n      },\n      zoomIn: function () {\n        this.zoomBy(1 + that.options.zoomScaleSensitivity);\n        return that.pi;\n      },\n      zoomOut: function () {\n        this.zoomBy(1 / (1 + that.options.zoomScaleSensitivity));\n        return that.pi;\n      },\n      getZoom: function () {\n        return that.getRelativeZoom();\n      },\n      // CTM update\n      setOnUpdatedCTM: function (fn) {\n        that.options.onUpdatedCTM =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      // Reset\n      resetZoom: function () {\n        that.resetZoom();\n        return that.pi;\n      },\n      resetPan: function () {\n        that.resetPan();\n        return that.pi;\n      },\n      reset: function () {\n        that.reset();\n        return that.pi;\n      },\n      // Fit, Contain and Center\n      fit: function () {\n        that.fit();\n        return that.pi;\n      },\n      contain: function () {\n        that.contain();\n        return that.pi;\n      },\n      center: function () {\n        that.center();\n        return that.pi;\n      },\n      // Size and Resize\n      updateBBox: function () {\n        that.updateBBox();\n        return that.pi;\n      },\n      resize: function () {\n        that.resize();\n        return that.pi;\n      },\n      getSizes: function () {\n        return {\n          width: that.width,\n          height: that.height,\n          realZoom: that.getZoom(),\n          viewBox: that.viewport.getViewBox(),\n        };\n      },\n      // Destroy\n      destroy: function () {\n        that.destroy();\n        return that.pi;\n      },\n    };\n  }\n\n  return this.publicInstance;\n};\n\n/**\n * Stores pairs of instances of SvgPanZoom and SVG\n * Each pair is represented by an object {svg: SVGSVGElement, instance: SvgPanZoom}\n *\n * @type {Array}\n */\nvar instancesStore = [];\n\nvar svgPanZoom = function (elementOrSelector, options) {\n  var svg = Utils.getSvg(elementOrSelector);\n\n  if (svg === null) {\n    return null;\n  } else {\n    // Look for existent instance\n    for (var i = instancesStore.length - 1; i >= 0; i--) {\n      if (instancesStore[i].svg === svg) {\n        return instancesStore[i].instance.getPublicInstance();\n      }\n    }\n\n    // If instance not found - create one\n    instancesStore.push({\n      svg: svg,\n      instance: new SvgPanZoom(svg, options),\n    });\n\n    // Return just pushed instance\n    return instancesStore[\n      instancesStore.length - 1\n    ].instance.getPublicInstance();\n  }\n};\n\nmodule.exports = svgPanZoom;\n","import svgPanZoom, * as SvgPanZoom from \"@dash14/svg-pan-zoom\"\n\nexport interface Box {\n  top: number\n  bottom: number\n  left: number\n  right: number\n}\n\ninterface ViewArea {\n  box: Box\n  center: SvgPanZoom.Point\n}\n\nexport interface SvgPanZoomInstance extends SvgPanZoom.Instance {\n  fitToContents(): SvgPanZoomInstance\n  getViewArea(): ViewArea\n  getViewBox(): Box\n  setViewBox(box: Box): void\n  getRealZoom(): number\n  applyAbsoluteZoomLevel(zoomLevel: number, minZoomLevel: number, maxZoomLevel: number): void\n  setPanEnabled(enabled: boolean): SvgPanZoomInstance\n  setZoomEnabled(enabled: boolean): SvgPanZoomInstance\n}\n\nexport interface CustomEventOptions {\n  svgElement: SVGSVGElement;\n  instance: SvgPanZoomInstance;\n}\n\nexport interface CustomEventHandler {\n  init: (options: CustomEventOptions) => void;\n  haltEventListeners: string[];\n  destroy: (options: CustomEventOptions) => void;\n}\n\nexport interface SvgPanZoomOptions extends Omit<SvgPanZoom.Options, \"customEventsHandler\"> {\n  customEventsHandler?: CustomEventHandler; // (default null)\n}\n\nexport interface SvgPanZoomInternal extends SvgPanZoomInstance {\n  _isPanEnabled: boolean\n  _isZoomEnabled: boolean\n  _internalIsPanEnabled(): boolean\n  _internalEnablePan(): void\n  _internalDisablePan(): void\n  _internalIsZoomEnabled(): boolean\n  _internalEnableZoom(): void\n  _internalDisableZoom(): void\n}\n\nconst methods: Partial<SvgPanZoomInternal> = {\n  fitToContents(this: SvgPanZoomInternal) {\n    this.fit()\n      .center()\n      .zoomOut() // Zoom out two steps.\n      .zoomOut()\n    return this\n  },\n  getViewArea(this: SvgPanZoomInternal) {\n    const sizes = this.getSizes()\n    const pan = this.getPan()\n    const scale = sizes.realZoom\n    pan.x /= scale\n    pan.y /= scale\n    const viewport = {\n      width: sizes.width / scale,\n      height: sizes.height / scale,\n    }\n    return {\n      box: {\n        top: -pan.y,\n        bottom: viewport.height - pan.y,\n        left: -pan.x,\n        right: viewport.width - pan.x,\n      },\n      center: {\n        x: viewport.width / 2 - pan.x,\n        y: viewport.height / 2 - pan.y,\n      },\n    }\n  },\n  getViewBox(this: SvgPanZoomInternal): Box {\n    return this.getViewArea().box\n  },\n  setViewBox(this: SvgPanZoomInternal, box: Box) {\n    // Adjust zoom and pan to include the box.\n    // If the aspect ratio is different from the box, pan to\n    // include the box with keeping the center.\n    const width = box.right - box.left\n    const height = box.bottom - box.top\n    const { width: sizeWidth, height: sizeHeight } = this.getSizes()\n    const ratio = width / height\n    const currentRatio = sizeWidth / sizeHeight\n    const newWidth = ratio < currentRatio ? height * currentRatio : width\n    const newHeight = ratio > currentRatio ? width / currentRatio : height\n    const absoluteZoom = Math.min(\n      sizeWidth / newWidth,\n      sizeHeight / newHeight\n    )\n    const realZoom = this.getRealZoom()\n    const relativeZoom = this.getZoom()\n    const originalZoom = realZoom / relativeZoom\n    this.zoom(absoluteZoom / originalZoom)\n\n    const center = {\n      x: (box.left + width / 2) * absoluteZoom,\n      y: (box.top + height / 2) * absoluteZoom\n    }\n    this.pan({\n      x: -(center.x) + newWidth / 2 * absoluteZoom,\n      y: -(center.y) + newHeight / 2 * absoluteZoom\n    })\n  },\n  getRealZoom(this: SvgPanZoomInternal) {\n    return this.getSizes().realZoom\n  },\n  applyAbsoluteZoomLevel(this: SvgPanZoomInternal, zoomLevel: number, minZoomLevel: number, maxZoomLevel: number) {\n    // normalize\n    const min = Math.max(0.0001, minZoomLevel)\n    const max = Math.max(min, maxZoomLevel)\n    const zoom = Math.max(Math.min(max, zoomLevel), min)\n\n    const realZoom = this.getRealZoom()\n    const relativeZoom = this.getZoom()\n    const originalZoom = realZoom / relativeZoom\n\n    this.setMinZoom(min / originalZoom)\n      .setMaxZoom(max / originalZoom)\n      .zoom(zoom / originalZoom)\n  },\n  isPanEnabled(this: SvgPanZoomInternal) {\n    return this._isPanEnabled\n  },\n  enablePan(this: SvgPanZoomInternal) {\n    this._isPanEnabled = true\n    this._internalEnablePan()\n    return this\n  },\n  disablePan(this: SvgPanZoomInternal) {\n    this._isPanEnabled = false\n    this._internalDisablePan()\n    return this\n  },\n  isZoomEnabled(this: SvgPanZoomInternal) {\n    return this._isZoomEnabled\n  },\n  enableZoom(this: SvgPanZoomInternal) {\n    this._isZoomEnabled = true\n    this._internalEnableZoom()\n    return this\n  },\n  disableZoom(this: SvgPanZoomInternal) {\n    this._isZoomEnabled = false\n    this._internalDisableZoom()\n    return this\n  },\n  setPanEnabled(this: SvgPanZoomInternal, enabled: boolean) {\n    if (enabled) {\n      this.enablePan()\n    } else {\n      this.disablePan()\n    }\n    return this\n  },\n  setZoomEnabled(this: SvgPanZoomInternal, enabled: boolean) {\n    if (enabled) {\n      this.enableZoom()\n      this.enableDblClickZoom()\n    } else {\n      this.disableZoom()\n      this.disableDblClickZoom()\n    }\n    return this\n  },\n}\n\nfunction constructor(\n  svgPanZoom: SvgPanZoom.Instance,\n  options: SvgPanZoomOptions,\n): SvgPanZoomInternal {\n  const instance = svgPanZoom as SvgPanZoomInternal\n  instance._isPanEnabled = options.panEnabled ?? true\n  instance._isZoomEnabled = options?.zoomEnabled ?? true\n  instance._internalIsPanEnabled = instance.isPanEnabled\n  instance._internalEnablePan = instance.enablePan\n  instance._internalDisablePan = instance.disablePan\n  instance._internalIsZoomEnabled = instance.isZoomEnabled\n  instance._internalEnableZoom = instance.enableZoom\n  instance._internalDisableZoom = instance.disableZoom\n  Object.assign(svgPanZoom, methods)\n  return instance\n}\n\nexport function createSvgPanZoomEx(\n  svg: SVGElement,\n  options: SvgPanZoomOptions\n): SvgPanZoomInstance {\n\n  const userInit = options.customEventsHandler?.init ?? ((_: any) => {})\n  const userDestroy = options.customEventsHandler?.destroy ?? ((_: any) => {})\n  const haltEventListeners = options.customEventsHandler?.haltEventListeners ?? []\n\n  if (options.mouseWheelZoomEnabled === undefined) {\n    options.mouseWheelZoomEnabled = options.zoomEnabled\n  }\n\n  options.customEventsHandler = {\n    init: o => {\n      constructor(o.instance, options)\n      userInit(o)\n    },\n    destroy: o => userDestroy(o),\n    haltEventListeners\n  }\n\n  return svgPanZoom(svg, options as SvgPanZoom.Options) as SvgPanZoomInternal\n}\n","import { ref, Ref, onMounted, onUnmounted } from \"vue\"\nimport { nonNull } from \"@/common/common\"\nimport { createSvgPanZoomEx, SvgPanZoomInstance, SvgPanZoomOptions } from \"@/modules/svg-pan-zoom-ex\"\n\ntype Callback = () => void\n\nenum State {\n  INITIAL = 0,\n  MOUNTED = 1,\n  UNMOUNTED = 2\n}\n\nexport function useSvgPanZoom(svg: Ref<SVGSVGElement | undefined>, options: SvgPanZoomOptions) {\n  const instance = ref<SvgPanZoomInstance>()\n  let state = State.INITIAL\n  const mountedCallbacks: Callback[] = []\n  const unmountedCallbacks: Callback[] = []\n\n  const instanceMounted = () => {\n    state = State.MOUNTED\n    mountedCallbacks.forEach(c => c())\n    mountedCallbacks.length = 0 // clear\n  }\n\n  const instanceUnmounted = () => {\n    state = State.UNMOUNTED\n    unmountedCallbacks.forEach(c => c())\n    unmountedCallbacks.length = 0 // clear\n  }\n\n  onMounted(() => {\n    const element = nonNull(svg.value, \"<svg>\")\n    // hook init/destroy custom events\n    const userInit = options.customEventsHandler?.init ?? ((_: any) => {})\n    const userDestroy = options.customEventsHandler?.destroy ?? ((_: any) => {})\n    const haltEventListeners = options.customEventsHandler?.haltEventListeners ?? []\n\n    options.customEventsHandler = {\n      init: o => {\n        instance.value = o.instance\n        userInit(o)\n        instanceMounted()\n      },\n      destroy: o => {\n        instanceUnmounted()\n        userDestroy(o)\n      },\n      haltEventListeners\n    }\n\n    const initialize = () => {\n      const rect = element.getBoundingClientRect()\n      // In svg-pan-zoom, the shadow viewport is generated based with\n      // size on initialization. At this time, if the width and height\n      // are zero, an exception will occur during the calculation.\n      // Therefore, initialization is performed after allocating the area.\n      // Note that even after onMounted, the area is not allocated at\n      // the time of page switching with Nuxt.\n      if (rect.width !== 0 && rect.height !== 0) {\n        createSvgPanZoomEx(element, options)\n      } else {\n        setTimeout(initialize, 200)\n      }\n    }\n    initialize()\n  })\n\n  onUnmounted(() => {\n    instance.value?.destroy()\n    instance.value = undefined\n  })\n\n  const onSvgPanZoomMounted = (callback: Callback) => {\n    if (state === State.INITIAL) {\n      mountedCallbacks.push(callback)\n    } else if (state === State.MOUNTED) {\n      callback()\n    }\n  }\n\n  const onSvgPanZoomUnmounted = (callback: Callback) => {\n    if (state === State.INITIAL || state === State.MOUNTED) {\n      unmountedCallbacks.push(callback)\n    } else {\n      callback()\n    }\n  }\n\n  return { svgPanZoom: instance, onSvgPanZoomMounted, onSvgPanZoomUnmounted }\n}\n","import { provide, inject, InjectionKey, Ref, computed } from \"vue\"\nimport { nonNull } from \"@/common/common\"\nimport { ViewConfig } from \"@/common/configs\"\n\ninterface ZoomProvides {\n  zoomLevel: Ref<number>,\n  scale: Ref<number>\n}\n\nconst zoomLevelKey = Symbol(\"zoomLevel\") as InjectionKey<ZoomProvides>\n\nexport function provideZoomLevel(zoomLevel: Ref<number>, viewStyle: ViewConfig) {\n  const scale = computed(() => {\n    return viewStyle.scalingObjects ? 1 : (1 / zoomLevel.value)\n  })\n  provide(zoomLevelKey, {\n    zoomLevel,\n    scale\n  })\n  return { scale }\n}\n\nexport function useZoomLevel(): ZoomProvides {\n  return nonNull(inject(zoomLevelKey), \"zoomLevel\")\n}\n","import { nextTick, ref } from \"vue\"\n\ntype TimingFunction = \"ease\" | \"linear\" | \"ease-in\" | \"ease-out\" | \"ease-in-out\" | string\n\n/** Parameters of transition */\ninterface TransitionParameters {\n  enabled: boolean\n  duration: number\n  timingFunction: TimingFunction\n}\n\ntype CallbackFunction = () => void | Promise<void>\n\nfunction isPromise(obj: any): boolean {\n  return obj instanceof Promise || (obj && typeof obj.then === \"function\")\n}\n\nexport function useTransitionWhile() {\n  let timerId: number | null = null\n  const transitionOption = ref<TransitionParameters>({\n    enabled: false,\n    duration: 300,\n    timingFunction: \"linear\"\n  })\n\n  function transitionWhile(\n    func: CallbackFunction,\n    duration = 300,\n    timingFunction: TimingFunction = \"linear\"\n  ) {\n    if (timerId) {\n      clearTimeout(timerId)\n      timerId = null\n    }\n    transitionOption.value = {\n      enabled: true,\n      duration,\n      timingFunction\n    }\n\n    nextTick(async () => {\n      const promise = func()\n      if (isPromise(promise)) {\n        await promise\n      }\n\n      if (timerId) {\n        clearTimeout(timerId)\n      }\n      timerId = window?.setTimeout(() => {\n        transitionOption.value.enabled = false\n        timerId = null\n      }, duration)\n    })\n  }\n\n  return { transitionWhile, transitionOption }\n}\n\n","import { ref, Ref, watchEffect } from \"vue\"\nimport { InputPaths, Path } from \"@/common/types\"\n\nexport function useTranslatePathsToObject(input: Ref<InputPaths>) {\n  const objects = ref<Record<string, Path>>({})\n\n  const isInCompatibilityModeForPath = ref(false)\n  let nextId = 1\n  const idStore = new Map<Path, string>()\n\n  // translate for compatibility\n  watchEffect(() => {\n    if (input.value instanceof Array) {\n      const containKeys = new Set<string>([])\n      objects.value = Object.fromEntries(\n        input.value.map(path => {\n          let id = path.id\n          if (!id) {\n            if (!isInCompatibilityModeForPath.value) {\n              isInCompatibilityModeForPath.value = true\n              console.warn(\n                \"[v-network-graph] Please specify the `id` field for the `Path` object.\" +\n                  \" Currently, this works for compatibility,\" +\n                  \" but in the future, the id field will be required.\"\n              )\n            }\n            id = idStore.get(path)\n            if (!id) {\n              id = \"path-\" + nextId++\n              idStore.set(path, id)\n            }\n          }\n          containKeys.add(id)\n          return [id, path]\n        })\n      )\n      if (isInCompatibilityModeForPath.value) {\n        for (const [path, id] of Array.from(idStore.entries())) {\n          if (!containKeys.has(id)) {\n            idStore.delete(path)\n          }\n        }\n      }\n    } else {\n      objects.value = input.value\n    }\n  })\n\n  return { objects, isInCompatibilityModeForPath }\n}\n","import { watch, reactive, ref, Ref } from \"vue\"\nimport { isEqual } from \"lodash-es\"\nimport { Reactive } from \"../common/common\"\n\nexport function bindProp<T extends object, K extends keyof T>(\n  props: T,\n  name: K,\n  emit: (event: `update:${K & string}`, ...args: any[]) => void,\n  filter?: (arg: T[K]) => T[K]\n): Ref<T[K]> {\n  // Build two-way binding ties.\n\n  // Since it is not always passed in props (emit does not\n  // rewrite it), always keep a ref for self management.\n\n  if (filter) {\n    const prop = ref<T[K]>(filter(props[name])) as Ref<T[K]>\n    const update = (filtered: T[K]) => {\n      if (!isEqual(filtered, prop.value)) {\n        prop.value = filtered\n      }\n      if (!isEqual(filtered, props[name])) {\n        emit(`update:${name as string & K}`, filtered)\n      }\n    }\n    watch(() => filter(prop.value), update)\n    watch(() => props[name],v => update(filter(v)))\n    if (prop.value !== props[name]) {\n      emit(`update:${name as string & K}`, prop.value)\n    }\n    return prop\n  }\n\n  const prop = ref<T[K]>(props[name]) as Ref<T[K]>\n  watch(\n    () => props[name],\n    v => {\n      if (!isEqual(v, prop.value)) {\n        prop.value = v\n      }\n    }\n  )\n  watch(prop, v => {\n    if (!isEqual(v, props[name])) {\n      emit(`update:${name as string & K}`, v)\n    }\n  })\n  return prop\n}\n\ntype KeysOfType<Obj, Val> = {\n  [K in keyof Obj]-?: Obj[K] extends Val ? K : never\n}[keyof Obj]\n\nexport function bindPropKeySet<T extends object, K extends string & KeysOfType<T, string[]>>(\n  props: T,\n  name: K,\n  sourceObject: Ref<{ [name: string]: any }>,\n  emit: (event: `update:${K & string}`, ...args: any[]) => void\n): Reactive<Set<string>> {\n  // Generate two-way bindings for a given prop.\n  // Assumes that the specified prop indicates the key of the object.\n  const bound = reactive<Set<string>>(new Set())\n  watch(\n    () => props[name],\n    () => {\n      // Since it is not recognized as a string[] by type checking,\n      // use any for now.\n      const prop: string[] = props[name] as any\n      const filtered = prop.filter(n => n in sourceObject.value)\n      if (!isEqual(filtered, Array.from(bound))) {\n        bound.clear()\n        filtered.forEach(bound.add, bound)\n      }\n    },\n    { deep: true, immediate: true }\n  )\n  watch(bound, () => {\n    const array = Array.from(bound)\n    if (!isEqual(props[name], array)) {\n      emit(`update:${name}` as const, array)\n    }\n  })\n  return Reactive(bound)\n}\n","import { inject, InjectionKey, provide } from \"vue\"\nimport { nonNull, Reactive } from \"@/common/common\"\n\ninterface Selections {\n  selectedNodes: Reactive<Set<string>>\n  selectedEdges: Reactive<Set<string>>\n  selectedPaths: Reactive<Set<string>>\n}\n\nconst injectionKey = Symbol(\"selection\") as InjectionKey<Selections>\n\nexport function provideSelections(\n  selectedNodes: Reactive<Set<string>>,\n  selectedEdges: Reactive<Set<string>>,\n  selectedPaths: Reactive<Set<string>>\n) {\n  provide(injectionKey, {\n    selectedNodes,\n    selectedEdges,\n    selectedPaths,\n  })\n}\n\nexport function useSelections(): Selections {\n  return nonNull(inject(injectionKey), \"Selections\")\n}\n","import { inject, InjectionKey, provide } from \"vue\"\nimport { nonNull, Reactive } from \"@/common/common\"\nimport { Layouts } from \"@/common/types\"\n\nconst injectionKey = Symbol(\"layouts\") as InjectionKey<Reactive<Layouts>>\n\nexport function provideLayouts(layouts: Reactive<Layouts>) {\n  provide(injectionKey, layouts)\n}\n\nexport function useLayouts(): Layouts {\n  return nonNull(inject(injectionKey), \"Layouts\")\n}\n","\nexport function pairwise<T>(arr: T[], func: (p1: T, p2: T) => void) {\n  for (let i = 0; i < arr.length - 1; i++) {\n    func(arr[i], arr[i + 1])\n  }\n}\n","\nexport function removeItem<T extends number | string>(arr: T[], value: T): void {\n  const i = arr.indexOf(value)\n  if (i >= 0) arr.splice(i, 1)\n}\n\nexport function insertAfter<T extends number | string>(arr: T[], base: T, value: T): void {\n  const i = arr.indexOf(base)\n  if (i < 0) return\n  arr.splice(i + 1, 0, value)\n}\n","import { computed, ComputedRef, Slots } from \"vue\"\nimport { uniq } from \"lodash-es\"\nimport { Configs } from \"@/common/configs\"\nimport { LayerName } from \"@/common/types\"\nimport { pairwise } from \"@/modules/collection/iterate\"\nimport { insertAfter, removeItem } from \"@/modules/collection/array\"\n\nexport function useBuiltInLayerOrder<T extends Configs>(\n  configs: T,\n  slots: Readonly<Slots>\n): ComputedRef<LayerName[]> {\n  const builtInLayers: Readonly<LayerName[]> = [\n    \"edges\",\n    \"edge-labels\",\n    \"focusring\",\n    \"nodes\",\n    \"node-labels\",\n    \"paths\",\n  ] as const\n\n  return computed<LayerName[]>(() => {\n    const request = uniq(configs.view.builtInLayerOrder)\n      .filter(layer => {\n        const defined = builtInLayers.includes(layer)\n        if (!defined) {\n          console.warn(`Layer ${layer} is not a built-in layer.`)\n        }\n        return defined\n      })\n      .reverse()\n    const order = [...builtInLayers]\n    pairwise(request, (lower, higher) => {\n      removeItem(order, higher)\n      insertAfter(order, lower, higher)\n    })\n\n    // Remove unused layers\n    if (!(\"edge-label\" in slots || \"edges-label\" in slots)) {\n      removeItem(order, \"edge-labels\")\n    }\n    if (!configs.node.focusring.visible) {\n      removeItem(order, \"focusring\")\n    }\n    if (configs.node.label.visible === false) {\n      removeItem(order, \"node-labels\")\n    }\n    if (!configs.path.visible) {\n      removeItem(order, \"paths\")\n    }\n\n    return order\n  })\n}\n","import { nextTick } from \"vue\"\n\nexport const asyncNextTick = () => {\n  return new Promise((resolve) => nextTick(resolve as () => void))\n}\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { MarkerUnits } from \"@/common/configs\"\n\nconst props = defineProps<{\n  width: number\n  height: number\n  refX: number\n  color: string\n  isSource: boolean\n  units: MarkerUnits\n}>()\n\nconst arrowPoints = computed(() => {\n  const w = props.width\n  const h = props.height\n  if (props.isSource) {\n    return `${w} ${h}, 0 ${h / 2}, ${w} 0`\n  } else {\n    return `0 0, ${w} ${h / 2}, 0 ${h}`\n  }\n})\n</script>\n\n<template>\n  <polygon :points=\"arrowPoints\" :fill=\"color\" />\n</template>\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { MarkerUnits } from \"@/common/configs\"\n\nconst props = defineProps<{\n  width: number\n  height: number\n  refX: number\n  color: string\n  isSource: boolean\n  units: MarkerUnits\n}>()\n\nconst angleStroke = computed(() => {\n  return props.units === \"strokeWidth\" ? 1 : Math.min(props.width, props.height) / 5\n})\n\nconst anglePoints = computed(() => {\n  const m = angleStroke.value / 2\n  const w = props.width\n  const h = props.height\n  if (props.isSource) {\n    return `${w - m} ${h - m}, ${m} ${h / 2}, ${w - m} ${m}`\n  } else {\n    return `${m} ${m}, ${w - m} ${h / 2}, ${m} ${h - m}`\n  }\n})\n</script>\n\n<template>\n  <polyline\n    :points=\"anglePoints\"\n    fill=\"none\"\n    :stroke-width=\"angleStroke\"\n    :stroke=\"color\"\n    stroke-linecap=\"round\"\n    stroke-linejoin=\"round\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { EdgeHeadType } from \"@/common/configs\"\nimport { HeadMarker } from \"@/composables/marker\"\nimport VMarkerHeadArrow from \"./VMarkerHeadArrow.vue\"\nimport VMarkerHeadAngle from \"./VMarkerHeadAngle.vue\"\nimport VMarkerHeadCircle from \"./VMarkerHeadCircle.vue\"\n\ntype MarkerType = Exclude<EdgeHeadType, \"none\" | \"custom\">\n\nconst types: Record<MarkerType, any> = {\n  arrow: VMarkerHeadArrow,\n  angle: VMarkerHeadAngle,\n  circle: VMarkerHeadCircle,\n}\n\nconst props = defineProps<{\n  id: string\n  marker: HeadMarker\n  scale: number\n}>()\n\nconst width = computed(\n  () => props.marker.width * (props.marker.units === \"strokeWidth\" ? 1 : props.scale)\n)\n\nconst height = computed(\n  () => props.marker.height * (props.marker.units === \"strokeWidth\" ? 1 : props.scale)\n)\n\nconst refX = computed(() => {\n  const margin = props.marker.margin * (props.marker.units === \"strokeWidth\" ? 1 : props.scale)\n  return props.marker.isSource ? width.value + margin : -margin\n})\n\nconst refYOffset = computed(() => {\n  const offset = props.marker.offset * (props.marker.units === \"strokeWidth\" ? 1 : props.scale)\n  return props.marker.isSource ? offset : -offset\n})\n</script>\n\n<template>\n  <marker\n    v-if=\"marker.type !== 'none' && marker.type !== 'custom'\"\n    :id=\"id\"\n    :markerWidth=\"width\"\n    :markerHeight=\"height\"\n    :refX=\"refX\"\n    :refY=\"height / 2 + refYOffset\"\n    orient=\"auto\"\n    :markerUnits=\"marker.units\"\n    class=\"v-ng-marker\"\n  >\n    <component\n      :is=\"types[marker.type]\"\n      :width=\"width\"\n      :height=\"height\"\n      :refX=\"refX\"\n      :color=\"marker.color\"\n      :is-source=\"marker.isSource\"\n      :units=\"marker.units\"\n    />\n  </marker>\n</template>\n","<script setup lang=\"ts\">\nimport { onMounted, ref, watchEffect } from \"vue\"\nimport { Point, Size } from \"@/common/types\"\nimport { useViewConfig } from \"@/composables/config\"\nimport { useContainers } from \"@/composables/container\"\nimport { useEventEmitter } from \"@/composables/event-emitter\"\nimport { useZoomLevel } from \"@/composables/zoom\"\n\n// [index, pos, start, end, attrs][]\ntype LineDefinitions = [number, number, number, number, Record<string, any>][]\n\nconst { container, svgPanZoom } = useContainers()\nconst { zoomLevel } = useZoomLevel()\nconst emitter = useEventEmitter()\nconst config = useViewConfig()\n\n// left-top point in SVG coordinates\nconst basePoint = ref<Point>({ x: 0, y: 0 })\n\n// container size in pixel\nconst viewport = ref<Size>({ width: 500, height: 500 })\n\nonMounted(() => {\n  const pan = svgPanZoom.value?.getPan()\n  if (pan) {\n    basePoint.value = {\n      x: -pan.x,\n      y: -pan.y,\n    }\n  }\n  const rect = container.value.getBoundingClientRect()\n  viewport.value = {\n    width: rect.width,\n    height: rect.height,\n  }\n})\n\nemitter.on(\"view:resize\", rect => {\n  viewport.value = { width: rect.width, height: rect.height }\n})\n\nemitter.on(\"view:pan\", pan => {\n  basePoint.value = { x: -pan.x, y: -pan.y }\n})\n\nemitter.on(\"view:zoom\", () => {\n  const pan = svgPanZoom.value?.getPan()\n  if (pan) {\n    basePoint.value = { x: -pan.x, y: -pan.y }\n  }\n})\n\nconst thickVerticals = ref<LineDefinitions>([])\nconst thickHorizontals = ref<LineDefinitions>([])\nconst normalVerticals = ref<LineDefinitions>([])\nconst normalHorizontals = ref<LineDefinitions>([])\n\n// make grid lines\nwatchEffect(() => {\n  const thickH: LineDefinitions = []\n  const thickV: LineDefinitions = []\n  const normalH: LineDefinitions = []\n  const normalV: LineDefinitions = []\n\n  const s = 1 / zoomLevel.value\n  const gi = config.grid.interval\n  const x = basePoint.value.x * s\n  const y = basePoint.value.y * s\n  const width = Math.floor(viewport.value.width / gi + 1) * gi\n  const height = Math.floor(viewport.value.height / gi + 1) * gi\n  const maxWidth = (basePoint.value.x + width) * s\n  const maxHeight = (basePoint.value.y + height) * s\n  const inc = config.grid.thickIncrements // interval to make the line thicker\n  const normalDasharray = config.grid.line.dasharray\n  const thickDasharray = config.grid.thick.dasharray\n\n  let thickAttrs = {\n    stroke: config.grid.thick.color,\n    \"stroke-width\": config.grid.thick.width,\n    \"stroke-dasharray\": thickDasharray,\n    \"stroke-dashoffset\": thickDasharray ? x / s : undefined,\n  }\n\n  let normalAttrs = {\n    stroke: config.grid.line.color,\n    \"stroke-width\": config.grid.line.width,\n    \"stroke-dasharray\": normalDasharray,\n    \"stroke-dashoffset\": normalDasharray ? x / s : undefined,\n  }\n\n  // horizontal lines\n  const w = (basePoint.value.x + width) * s\n  for (let i = y; i <= maxHeight; i += gi) {\n    const index = Math.floor(i / gi)\n    if (inc && index % inc === 0) {\n      thickH.push([index, index * gi, x, w, thickAttrs])\n    } else {\n      normalH.push([index, index * gi, x, w, normalAttrs])\n    }\n  }\n\n  thickAttrs = { ...thickAttrs }\n  thickAttrs[\"stroke-dashoffset\"] = thickDasharray ? y / s : undefined\n\n  normalAttrs = { ...normalAttrs }\n  normalAttrs[\"stroke-dashoffset\"] = normalDasharray ? y / s : undefined\n\n  // vertical lines\n  const h = (basePoint.value.y + height) * s\n  for (let i = x; i <= maxWidth; i += gi) {\n    const index = Math.floor(i / gi)\n    if (inc && index % inc === 0) {\n      thickV.push([index, index * gi, y, h, thickAttrs])\n    } else {\n      normalV.push([index, index * gi, y, h, normalAttrs])\n    }\n  }\n\n  thickHorizontals.value = thickH\n  thickVerticals.value = thickV\n  normalHorizontals.value = normalH\n  normalVerticals.value = normalV\n})\n</script>\n\n<template>\n  <g class=\"v-ng-background-grid\" shape-rendering=\"crispEdges\">\n    <!-- normal -->\n    <path\n      v-for=\"[i, v, x, w, attrs] in normalHorizontals\"\n      :key=\"`nv${i}`\"\n      :d=\"`M ${x} ${v} L ${w} ${v}`\"\n      v-bind=\"attrs\"\n      style=\"vector-effect: non-scaling-stroke\"\n    />\n    <path\n      v-for=\"[i, v, y, h, attrs] in normalVerticals\"\n      :key=\"`nh${i}`\"\n      :d=\"`M ${v} ${y} L ${v} ${h}`\"\n      v-bind=\"attrs\"\n      style=\"vector-effect: non-scaling-stroke\"\n    />\n    <!-- thick -->\n    <path\n      v-for=\"[i, v, x, w, attrs] in thickHorizontals\"\n      :key=\"`tv${i}`\"\n      :d=\"`M ${x} ${v} L ${w} ${v}`\"\n      v-bind=\"attrs\"\n      style=\"vector-effect: non-scaling-stroke\"\n    />\n    <path\n      v-for=\"[i, v, y, h, attrs] in thickVerticals\"\n      :key=\"`th${i}`\"\n      :d=\"`M ${v} ${y} L ${v} ${h}`\"\n      v-bind=\"attrs\"\n      style=\"vector-effect: non-scaling-stroke\"\n    />\n  </g>\n</template>\n\n<style lang=\"scss\">\n.v-ng-background-grid {\n  pointer-events: none;\n}\n</style>\n","<script setup lang=\"ts\">\nimport { onMounted, onUnmounted, ref } from \"vue\"\nimport { useContainers } from \"@/composables/container\"\n\n// By detecting and copying changes in the `transform` and `style`\n// attributes reflected by svg-pan-zoom, it follows changes in the\n// display area caused by panning and zooming.\n\nconst { viewport } = useContainers()\n\n// ref=\"background\"\nconst background = ref<SVGGElement>()\n\nconst updateAttributes = (attrs: string[], bgLayer: SVGGElement, vpLayer: SVGGElement) => {\n  attrs.forEach(attr => bgLayer.setAttribute(attr, vpLayer.getAttribute(attr) ?? \"\"))\n}\n\nconst observer = new MutationObserver(records => {\n  if (!background.value) return\n  const attrs = records.map(r => r.attributeName ?? \"\").filter(Boolean)\n  updateAttributes(attrs, background.value, viewport.value)\n})\n\nonMounted(() => {\n  const attrs = [\"transform\", \"style\"]\n  observer.observe(viewport.value, {\n    attributes: true,\n    attributeFilter: attrs,\n  })\n  if (!background.value) return\n  updateAttributes(attrs, background.value, viewport.value)\n})\n\nonUnmounted(() => {\n  observer.disconnect()\n})\n</script>\n\n<template>\n  <g ref=\"background\" class=\"v-ng-background-viewport\">\n    <slot />\n  </g>\n</template>\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { chunk } from \"lodash-es\"\nimport { Position } from \"@/common/types\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useEdgeConfig } from \"@/composables/config\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport { useZoomLevel } from \"@/composables/zoom\"\n\ninterface Props {\n  id: string\n  state: EdgeState\n  sourcePos?: Position\n  targetPos?: Position\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  sourcePos: undefined,\n  targetPos: undefined,\n})\n\nconst { scale } = useZoomLevel()\n\nconst config = useEdgeConfig()\nconst {\n  handleEdgePointerDownEvent,\n  handleEdgePointerOverEvent,\n  handleEdgePointerOutEvent,\n  handleEdgeClickEvent,\n  handleEdgeDoubleClickEvent,\n  handleEdgeContextMenu,\n} = useMouseOperation()\n\nconst pathD = computed(() => {\n  const p = props.state.position\n  if (props.state.loop) {\n    const { radius, isLargeArc, isClockwise } = props.state.loop\n    const [rx, ry] = radius\n    const f1 = isLargeArc ? 1 : 0\n    const f2 = isClockwise ? 1 : 0\n    return `M ${p.p1.x} ${p.p1.y} A ${rx} ${ry} 0 ${f1} ${f2} ${p.p2.x} ${p.p2.y}`\n  } else if (config.type === \"straight\" || !props.state.curve) {\n    return `M ${p.p1.x} ${p.p1.y} L ${p.p2.x} ${p.p2.y}`\n  } else {\n    const points = [...props.state.curve.control, { x: p.p2.x, y: p.p2.y }]\n    const d: string[] = []\n    d.push(`M ${p.p1.x} ${p.p1.y}`)\n    chunk(points, 2).forEach(([p1, p2]) => d.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`))\n    return d.join(\" \")\n  }\n})\n\nconst strokeWidth = computed(() => (props.state.line.stroke.width + 10) * scale.value)\n</script>\n\n<template>\n  <path\n    :class=\"{ 'v-ng-line-background': true, selectable: state.selectable }\"\n    :d=\"pathD\"\n    stroke=\"transparent\"\n    :stroke-width=\"strokeWidth\"\n    fill=\"none\"\n    @pointerdown.stop=\"handleEdgePointerDownEvent(id, $event)\"\n    @pointerenter.passive=\"handleEdgePointerOverEvent(id, $event)\"\n    @pointerleave.passive=\"handleEdgePointerOutEvent(id, $event)\"\n    @click.stop=\"handleEdgeClickEvent(id, $event)\"\n    @dblclick.stop=\"handleEdgeDoubleClickEvent(id, $event)\"\n    @contextmenu=\"handleEdgeContextMenu(id, $event)\"\n  />\n</template>\n\n<style lang=\"scss\">\n.v-ng-line-background {\n  &.selectable {\n    cursor: pointer;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { useStates } from \"@/composables/state\"\nimport VEdgeBackground from \"./VEdgeBackground.vue\"\n\nconst { edgeStates, edgeGroupStates, layouts } = useStates()\n</script>\n\n<template>\n  <template v-for=\"{ summarize, edges } in edgeGroupStates.edgeGroups\">\n    <template v-if=\"!summarize\">\n      <template v-for=\"(edge, id) in edges\" :key=\"id\">\n        <v-edge-background\n          :id=\"id\"\n          :state=\"edgeStates[id]\"\n          :source-pos=\"layouts.nodes[edge.source]\"\n          :target-pos=\"layouts.nodes[edge.target]\"\n        />\n      </template>\n    </template>\n  </template>\n</template>\n","<script setup lang=\"ts\">\nimport { CSSProperties, computed } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { StrokeStyle } from \"@/common/configs\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray, getDasharrayUnit } from \"@/utils/visual\"\n\nconst props = defineProps<{\n  p1: Position\n  p2: Position\n  config: StrokeStyle\n}>()\n\nconst { scale } = useZoomLevel()\n\nconst strokeWidth = computed(() => {\n  return props.config.width * scale.value\n})\n\nconst strokeDasharray = computed(() => {\n  return applyScaleToDasharray(props.config.dasharray, scale.value)\n})\n\nconst animationSpeed = computed(() => {\n  const speed = props.config.animate\n    ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value\n    : false\n  return speed ? ({ \"--animation-speed\": speed } as CSSProperties) : undefined\n})\n</script>\n\n<template>\n  <path\n    :class=\"{ 'v-ng-line': true, animate: config.animate }\"\n    :d=\"`M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`\"\n    :stroke=\"config.color\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n    :stroke-linecap=\"config.linecap\"\n    :style=\"animationSpeed\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { CSSProperties, computed } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { StrokeStyle } from \"@/common/configs\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray, getDasharrayUnit } from \"@/utils/visual\"\n\nconst props = defineProps<{\n  p1: Position\n  p2: Position\n  radius: number[]\n  isLargeArc: boolean\n  isClockwise: boolean\n  config: StrokeStyle\n}>()\n\nconst { scale } = useZoomLevel()\n\nconst strokeWidth = computed(() => {\n  return props.config.width * scale.value\n})\n\nconst strokeDasharray = computed(() => {\n  return applyScaleToDasharray(props.config.dasharray, scale.value)\n})\n\nconst animationSpeed = computed(() => {\n  const speed = props.config.animate\n    ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value\n    : false\n  return speed ? ({ \"--animation-speed\": speed } as CSSProperties) : undefined\n})\n\nconst pathD = computed(() => {\n  const { p1, p2, radius, isLargeArc, isClockwise } = props\n  const [rx, ry] = radius\n  const f1 = isLargeArc ? 1 : 0\n  const f2 = isClockwise ? 1 : 0\n  return `M ${p1.x} ${p1.y} A ${rx} ${ry} 0 ${f1} ${f2} ${p2.x} ${p2.y}`\n})\n</script>\n\n<template>\n  <path\n    :class=\"{ 'v-ng-line': true, animate: config.animate }\"\n    :d=\"pathD\"\n    :stroke=\"config.color\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n    :stroke-linecap=\"config.linecap\"\n    :style=\"animationSpeed\"\n    fill=\"none\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { CSSProperties, computed } from \"vue\"\nimport { chunk } from \"lodash-es\"\nimport { StrokeStyle } from \"@/common/configs\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray, getDasharrayUnit } from \"@/utils/visual\"\n\ninterface Props {\n  state: EdgeState\n  config: StrokeStyle\n  markerStart?: string\n  markerEnd?: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  markerStart: undefined,\n  markerEnd: undefined,\n})\n\nconst { scale } = useZoomLevel()\n\nconst pathD = computed(() => {\n  const p = props.state.position\n  const points = [...(props.state.curve?.control ?? []), { x: p.p2.x, y: p.p2.y }]\n  const d: string[] = []\n  d.push(`M ${p.p1.x} ${p.p1.y}`)\n  chunk(points, 2).forEach(([p1, p2]) => d.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`))\n  return d.join(\" \")\n})\n\nconst strokeWidth = computed(() => {\n  return props.config.width * scale.value\n})\n\nconst strokeDasharray = computed(() => {\n  return applyScaleToDasharray(props.config.dasharray, scale.value)\n})\n\nconst animationSpeed = computed(() => {\n  const speed = props.config.animate\n    ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value\n    : false\n  return speed ? ({ \"--animation-speed\": speed } as CSSProperties) : undefined\n})\n</script>\n\n<template>\n  <!-- <circle\n    v-if=\"state.curve\"\n    :cx=\"state.curve.circle.center.x\"\n    :cy=\"state.curve.circle.center.y\"\n    :r=\"state.curve.circle.radius\"\n    fill=\"#ff000080\"\n  />\n  <circle\n    v-for=\"cp in state.curve?.control\"\n    :key=\"JSON.stringify(cp)\"\n    :cx=\"cp.x\"\n    :cy=\"cp.y\"\n    :r=\"2\"\n    fill=\"#0000ff\"\n  /> -->\n  <path\n    :class=\"{ 'v-ng-line': true, animate: config.animate }\"\n    :d=\"pathD\"\n    fill=\"none\"\n    :stroke=\"config.color\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n    :stroke-linecap=\"config.linecap\"\n    :style=\"animationSpeed\"\n    :marker-start=\"markerStart\"\n    :marker-end=\"markerEnd\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { Position } from \"@/common/types\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useEdgeConfig } from \"@/composables/config\"\nimport VLine from \"@/components/base/VLine.vue\"\nimport VArc from \"@/components/base/VArc.vue\"\nimport VEdgeCurved from \"./VEdgeCurved.vue\"\n\ninterface Props {\n  id: string\n  state: EdgeState\n  sourcePos?: Position\n  targetPos?: Position\n}\n\nwithDefaults(defineProps<Props>(), {\n  sourcePos: undefined,\n  targetPos: undefined,\n})\n\nconst config = useEdgeConfig()\n</script>\n\n<template>\n  <v-arc\n    v-if=\"state.loop\"\n    v-bind=\"state.position\"\n    :radius=\"state.loop.radius\"\n    :is-large-arc=\"state.loop.isLargeArc\"\n    :is-clockwise=\"state.loop.isClockwise\"\n    :class=\"{ selectable: state.selectable, hover: state.hovered, selected: state.selected }\"\n    :config=\"state.line.stroke\"\n    :marker-start=\"state.sourceMarkerId ? `url('#${state.sourceMarkerId}')` : undefined\"\n    :marker-end=\"state.targetMarkerId ? `url('#${state.targetMarkerId}')` : undefined\"\n    class=\"v-ng-edge\"\n  />\n  <v-line\n    v-else-if=\"config.type == 'straight' || !state.curve\"\n    :data-edge-id=\"id\"\n    v-bind=\"state.position\"\n    :class=\"{ selectable: state.selectable, hover: state.hovered, selected: state.selected }\"\n    :config=\"state.line.stroke\"\n    :marker-start=\"state.sourceMarkerId ? `url('#${state.sourceMarkerId}')` : undefined\"\n    :marker-end=\"state.targetMarkerId ? `url('#${state.targetMarkerId}')` : undefined\"\n    class=\"v-ng-edge\"\n  />\n  <v-edge-curved\n    v-else\n    :data-edge-id=\"id\"\n    :class=\"{ selectable: state.selectable, hover: state.hovered, selected: state.selected }\"\n    :state=\"state\"\n    :config=\"state.line.stroke\"\n    :marker-start=\"state.sourceMarkerId ? `url('#${state.sourceMarkerId}')` : undefined\"\n    :marker-end=\"state.targetMarkerId ? `url('#${state.targetMarkerId}')` : undefined\"\n    class=\"v-ng-edge\"\n  />\n</template>\n\n<style lang=\"scss\">\n$transition: 0.1s linear;\n\n.v-ng-edge {\n  transition:\n    stroke $transition,\n    stroke-width $transition;\n  pointer-events: none;\n}\n</style>\n","<script setup lang=\"ts\">\nimport { ref, watchEffect } from \"vue\"\nimport { AnyShapeStyle } from \"@/common/configs\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray } from \"@/utils/visual\"\n\ninterface Props {\n  baseX?: number\n  baseY?: number\n  config: AnyShapeStyle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  baseX: 0,\n  baseY: 0,\n})\n\nconst { scale } = useZoomLevel()\n\nconst x = ref(props.baseX)\nconst y = ref(props.baseY)\nconst strokeWidth = ref(0)\nconst strokeColor = ref(\"#000000\")\nconst strokeDasharray = ref<string | number | undefined>(undefined)\nconst radius = ref(0)\nconst width = ref(0)\nconst height = ref(0)\nconst borderRadius = ref(0)\n\nwatchEffect(() => {\n  const s = scale.value\n  strokeWidth.value = props.config.strokeWidth * s\n  strokeColor.value = props.config.strokeColor ?? \"none\"\n  strokeDasharray.value = applyScaleToDasharray(props.config.strokeDasharray, s)\n\n  if (props.config.type === \"circle\") {\n    x.value = props.baseX\n    y.value = props.baseY\n    radius.value = props.config.radius * s\n  } else {\n    width.value = props.config.width * s\n    height.value = props.config.height * s\n    borderRadius.value = props.config.borderRadius * s\n    x.value = props.baseX - width.value / 2\n    y.value = props.baseY - height.value / 2\n  }\n})\n</script>\n\n<template>\n  <circle\n    v-if=\"config.type === 'circle'\"\n    class=\"v-ng-shape-circle\"\n    :cx=\"x\"\n    :cy=\"y\"\n    :r=\"radius\"\n    :fill=\"config.color\"\n    :stroke=\"strokeColor\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n  />\n  <rect\n    v-else\n    class=\"v-ng-shape-rect\"\n    :x=\"x\"\n    :y=\"y\"\n    :width=\"width\"\n    :height=\"height\"\n    :rx=\"borderRadius\"\n    :ry=\"borderRadius\"\n    :fill=\"config.color\"\n    :stroke=\"strokeColor\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { computed, reactive, Ref, ref, useAttrs, watch, onMounted, onUnmounted } from \"vue\"\nimport { LabelStyle } from \"@/common/configs\"\nimport { useZoomLevel } from \"@/composables/zoom\"\n\ntype Rect = { x: number; y: number; width: number; height: number }\n\ninterface Props {\n  text: string\n  x?: number\n  y?: number\n  dominantBaseline?: string\n  config: LabelStyle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  x: 0,\n  y: 0,\n  dominantBaseline: \"central\",\n})\n\nconst attrs = useAttrs()\n\nconst { scale } = useZoomLevel()\n\nconst texts = computed(() => props.text?.toString().split(/\\r?\\n/) ?? \"\")\n\nconst fontSize = computed(() => {\n  return (attrs[\"font-size\"] as number) ?? props.config.fontSize * scale.value\n})\n\nconst lineHeight = computed(() => fontSize.value * props.config.lineHeight)\n\nconst topDeltaY = computed(() => {\n  const dominantBaseline = props.dominantBaseline\n  if (dominantBaseline === \"hanging\") {\n    return 0\n  } else if (dominantBaseline === \"central\") {\n    return -(lineHeight.value * (texts.value.length - 1)) / 2\n  } else {\n    // \"auto\", \"text-top\"\n    return -lineHeight.value * (texts.value.length - 1)\n  }\n})\n\nconst element = ref<SVGTextElement>()\nconst transform = ref(\"\") // copy from <text>\nconst pos = reactive<Rect>({ x: 0, y: 0, width: 0, height: 0 })\nconst backgroundRectPos = computed(() => {\n  const config = props.config.background\n  if (!config) return pos\n  let paddingVertical, paddingHorizontal\n  if (config.padding instanceof Object) {\n    paddingVertical = config.padding.vertical\n    paddingHorizontal = config.padding.horizontal\n  } else {\n    paddingVertical = config.padding ?? 0\n    paddingHorizontal = config.padding ?? 0\n  }\n  const lineMargin = lineHeight.value - fontSize.value\n  return {\n    x: pos.x - paddingHorizontal * scale.value,\n    y: pos.y - paddingVertical * scale.value - lineMargin / 2,\n    width: pos.width + paddingHorizontal * 2 * scale.value,\n    height: pos.height + paddingVertical * 2 * scale.value + lineMargin,\n  }\n})\n\nlet observer: MutationObserver | undefined\nconst updateObserver = () => {\n  if (props.config.background && props.config.background.visible) {\n    if (!observer && element.value) {\n      observer = enableMutationObserver(element.value, pos, transform)\n    }\n  } else {\n    observer?.disconnect()\n    observer = undefined\n  }\n}\n\nonMounted(() => updateObserver())\nwatch(\n  () => props.config.background && props.config.background.visible,\n  (v, prev) => {\n    if (v == prev) return\n    updateObserver()\n  }\n)\nonUnmounted(() => {\n  observer?.disconnect()\n  observer = undefined\n})\n\nfunction updateBackgroundPosition(\n  element: SVGTextElement,\n  pos: Rect,\n  transform: Ref<string | undefined>\n) {\n  const bbox = element.getBBox()\n  pos.x = bbox.x\n  pos.y = bbox.y\n  pos.width = bbox.width\n  pos.height = bbox.height\n  transform.value = element.getAttribute(\"transform\") ?? undefined\n}\n\nfunction enableMutationObserver(\n  element: SVGTextElement,\n  pos: Rect,\n  transform: Ref<string | undefined>\n) {\n  const observer = new MutationObserver(() => {\n    updateBackgroundPosition(element, pos, transform)\n  })\n  observer.observe(element, {\n    attributes: true,\n    attributeFilter: [\"x\", \"y\", \"transform\", \"font-size\"],\n  })\n  updateBackgroundPosition(element, pos, transform)\n  return observer\n}\n</script>\n\n<template>\n  <rect\n    v-if=\"config.background && config.background.visible\"\n    class=\"v-ng-text-background\"\n    v-bind=\"backgroundRectPos\"\n    :rx=\"(config.background?.borderRadius ?? 0) * scale\"\n    :ry=\"(config.background?.borderRadius ?? 0) * scale\"\n    :fill=\"config.background?.color ?? '#ffffff'\"\n    :transform=\"transform\"\n  />\n  <text\n    ref=\"element\"\n    class=\"v-ng-text\"\n    v-bind=\"$attrs\"\n    :x=\"x\"\n    :y=\"y\"\n    :dominant-baseline=\"dominantBaseline\"\n    :font-family=\"$attrs['font-family'] ? `${$attrs['font-family']}` : config.fontFamily\"\n    :font-size=\"fontSize\"\n    :fill=\"$attrs.fill ? `${$attrs.fill}` : config.color\"\n  >\n    <template v-if=\"texts.length <= 1\">\n      {{ text }}\n    </template>\n    <template v-else>\n      <!--\n        In Safari, it seems that `<tspan>` does not inherit the\n        `dominant-baseline` attribute from its parent `<text>` element.\n        Therefore, set the dominant-baseline directly on `<tspan>`.\n        Chrome and Firefox do not have this issue.\n        refs. https://stackoverflow.com/questions/41985077/centering-an-svg-element-chrome-vs-safari/42023579#42023579\n      -->\n      <tspan\n        v-for=\"(t, i) in texts\"\n        :key=\"i\"\n        :x=\"x\"\n        :dy=\"i == 0 ? topDeltaY : lineHeight\"\n        :dominant-baseline=\"dominantBaseline\"\n      >{{ t }}</tspan>\n    </template>\n  </text>\n</template>\n","<script setup lang=\"ts\">\nimport { computed, ref, watchEffect } from \"vue\"\nimport { Edges, NodePositions, LinePosition, Position } from \"@/common/types\"\nimport { Config } from \"@/common/configs\"\nimport { useEdgeConfig } from \"@/composables/config\"\nimport { useStates } from \"@/composables/state\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport VLine from \"@/components/base/VLine.vue\"\nimport VShape from \"@/components/base/VShape.vue\"\nimport VText from \"@/components/base/VLabelText.vue\"\n\nconst props = defineProps<{\n  edges: Edges\n  layouts: NodePositions\n}>()\n\nconst config = useEdgeConfig()\nconst {\n  handleEdgesPointerDownEvent,\n  handleEdgesPointerOverEvent,\n  handleEdgesPointerOutEvent,\n  handleEdgesClickEvent,\n  handleEdgesDoubleClickEvent,\n  handleEdgesContextMenu,\n} = useMouseOperation()\n\nconst { edgeStates } = useStates()\n\n// Since the specified edges are in the same pair,\n// get the first one and draw it.\nconst pos = ref<LinePosition>({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } })\nconst centerPos = ref<Position>({ x: 0, y: 0 })\n\nwatchEffect(() => {\n  const edgeId = Object.keys(props.edges).find(edgeId => edgeId in edgeStates)\n  if (edgeId) {\n    pos.value = edgeStates[edgeId].position\n    centerPos.value = {\n      x: (pos.value.p1.x + pos.value.p2.x) / 2,\n      y: (pos.value.p1.y + pos.value.p2.y) / 2,\n    }\n  }\n})\n\nconst edgeIds = computed(() => Object.keys(props.edges))\nconst labelConfig = computed(() => Config.values(config.summarized.label, props.edges))\nconst shapeConfig = computed(() => Config.values(config.summarized.shape, props.edges))\nconst strokeConfig = computed(() => Config.values(config.summarized.stroke, props.edges))\n\nconst hovered = computed(() => edgeIds.value.some(edge => edgeStates[edge].hovered))\nconst selectable = computed(() => edgeIds.value.some(edge => edgeStates[edge].selectable))\nconst selected = computed(() => edgeIds.value.some(edge => edgeStates[edge].selected))\n</script>\n\n<template>\n  <g\n    :class=\"{ 'v-ng-line-summarized': true, hovered, selectable, selected }\"\n    @pointerdown.stop=\"handleEdgesPointerDownEvent(edgeIds, $event)\"\n    @pointerenter.passive=\"handleEdgesPointerOverEvent(edgeIds, $event)\"\n    @pointerleave.passive=\"handleEdgesPointerOutEvent(edgeIds, $event)\"\n    @click.stop=\"handleEdgesClickEvent(edgeIds, $event)\"\n    @dblclick.stop=\"handleEdgesDoubleClickEvent(edgeIds, $event)\"\n    @contextmenu=\"handleEdgesContextMenu(edgeIds, $event)\"\n  >\n    <v-line v-bind=\"pos\" :config=\"strokeConfig\" :data-edge-id=\"edgeIds[0]\" />\n    <v-shape :base-x=\"centerPos.x\" :base-y=\"centerPos.y\" :config=\"shapeConfig\" />\n    <v-text\n      :text=\"Object.keys(edges).length.toString()\"\n      :x=\"centerPos.x\"\n      :y=\"centerPos.y\"\n      :config=\"labelConfig\"\n      text-anchor=\"middle\"\n      dominant-baseline=\"central\"\n    />\n  </g>\n</template>\n\n<style lang=\"scss\">\n.v-ng-line-summarized {\n  &.selectable {\n    cursor: pointer;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { Edge, EdgePosition, Edges, LinePosition, Point } from \"@/common/types\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { useContainers } from \"@/composables/container\"\nimport { Config } from \"@/common/configs\"\nimport { useEdgeConfig } from \"@/composables/config\"\n\ninterface Props {\n  edgeId?: string\n  edge?: Edge\n  edges?: Edges\n  state: EdgeState\n  isSummarized: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  edgeId: undefined,\n  edge: undefined,\n  edges: () => ({}),\n})\n\nconst { svg } = useContainers()\nconst { scale } = useZoomLevel()\nconst edgeConfig = useEdgeConfig()\n\nfunction getStrokeConfig() {\n  if (props.isSummarized) {\n    return Config.values(edgeConfig.summarized.stroke, props.edges)\n  } else {\n    return props.state.line.stroke\n  }\n}\n\nfunction toEdgePosition(line: LinePosition): EdgePosition {\n  return { source: line.p1, target: line.p2 }\n}\n\nfunction calculateCenterPoint(state: EdgeState): Point {\n  if (state.curve) {\n    return state.curve.center\n  } else {\n    const p1 = state.origin.p1\n    const p2 = state.origin.p2\n    return {\n      x: (p1.x + p2.x) / 2,\n      y: (p1.y + p2.y) / 2,\n    }\n  }\n}\n\nfunction getPathTotalLength() {\n  if (!svg.value) return 0\n  const edgeId = props.edgeId ?? Object.keys(props.edges)[0]\n  const path = svg.value.querySelector<SVGPathElement>(`path[data-edge-id=\"${edgeId}\"]`)\n  if (!path) return 0\n  return path.getTotalLength()\n}\n\nfunction calculatePointAtLength(distance: number): Point {\n  if (!svg.value || !isFinite(distance)) return props.state.position.p1\n\n  // for detecting changes and re-calculation\n  props.state\n\n  const edgeId = props.edgeId ?? Object.keys(props.edges)[0]\n\n  const path = svg.value.querySelector<SVGPathElement>(`path[data-edge-id=\"${edgeId}\"]`)\n  if (!path) return props.state.position.p1\n\n  const p = path.getPointAtLength(distance)\n  return { x: p.x, y: p.y }\n}\n</script>\n\n<template>\n  <g class=\"v-ng-edge-overlay\">\n    <slot\n      v-if=\"isSummarized\"\n      :edges=\"edges\"\n      :is-summarized=\"isSummarized\"\n      :stroke=\"getStrokeConfig()\"\n      :position=\"toEdgePosition(state.origin)\"\n      :center=\"calculateCenterPoint(state)\"\n      :hovered=\"state.hovered\"\n      :selected=\"state.selected\"\n      :scale=\"scale\"\n      :length=\"getPathTotalLength()\"\n      :point-at-length=\"calculatePointAtLength\"\n    />\n    <slot\n      v-else\n      :edge-id=\"edgeId\"\n      :edge=\"edge\"\n      :edges=\"{ [edgeId!]: edge }\"\n      :is-summarized=\"isSummarized\"\n      :stroke=\"getStrokeConfig()\"\n      :position=\"toEdgePosition(state.origin)\"\n      :center=\"calculateCenterPoint(state)\"\n      :hovered=\"state.hovered\"\n      :selected=\"state.selected\"\n      :scale=\"scale\"\n      :length=\"getPathTotalLength()\"\n      :point-at-length=\"calculatePointAtLength\"\n    />\n  </g>\n</template>\n","<script setup lang=\"ts\">\nimport { useStates, isSummarizedEdges } from \"@/composables/state\"\nimport VEdge from \"./VEdge.vue\"\nimport VEdgeSummarized from \"./VEdgeSummarized.vue\"\nimport VEdgeOverlay from \"./VEdgeOverlay.vue\"\n\ndefineProps<{\n  hasEdgeOverlaySlot: boolean\n}>()\n\nconst { edgeStates, edgeZOrderedList, layouts } = useStates()\n\n// type FlattenEdge = {\n//     key: string\n//     summarize: true\n//     edges: Edges\n//     id?: undefined\n//     edge?: undefined\n// } | {\n//     key: string\n//     summarize: false\n//     edges?: undefined\n//     id: string\n//     edge: Edge\n// }\n\n// const flattenEdges = computed(() => {\n//   const results: FlattenEdge[] = []\n//   for (const [key, {summarize, edges}] of Object.entries(edgeGroupStates.edgeGroups)) {\n//     if (summarize) {\n//       results.push({ key, summarize, edges })\n//     } else {\n//       results.push(...Object.entries(edges).map(([id, edge]) => ({ key, summarize, id, edge })))\n//     }\n//   }\n//   return results\n// })\n</script>\n\n<template>\n  <template v-for=\"entry in edgeZOrderedList\">\n    <template v-if=\"isSummarizedEdges(entry)\">\n      <v-edge-summarized\n        :key=\"entry.key\"\n        :edges=\"entry.group.edges\"\n        :layouts=\"layouts.nodes\"\n      />\n      <v-edge-overlay\n        v-if=\"hasEdgeOverlaySlot\"\n        :key=\"entry.key\"\n        :edges=\"entry.group.edges\"\n        :state=\"edgeStates[Object.keys(entry.group.edges)[0]]\"\n        :is-summarized=\"true\"\n      >\n        <template #default=\"slotProps\">\n          <slot v-bind=\"slotProps\" />\n        </template>\n      </v-edge-overlay>\n    </template>\n    <template v-else>\n      <v-edge\n        :id=\"entry.key\"\n        :key=\"entry.key\"\n        :state=\"edgeStates[entry.key]\"\n        :source-pos=\"layouts.nodes[entry.edge.source]\"\n        :target-pos=\"layouts.nodes[entry.edge.target]\"\n      />\n      <v-edge-overlay\n        v-if=\"hasEdgeOverlaySlot\"\n        :key=\"entry.key\"\n        :edge-id=\"entry.key\"\n        :edge=\"entry.edge\"\n        :state=\"edgeStates[entry.key]\"\n        :is-summarized=\"false\"\n      >\n        <template #default=\"slotProps\">\n          <slot v-bind=\"slotProps\" />\n        </template>\n      </v-edge-overlay>\n    </template>\n  </template>\n</template>\n","<script setup lang=\"ts\">\nimport { computed, useSlots } from \"vue\"\n\nimport VEdgeBackgrounds from \"../edge/VEdgeBackgrounds.vue\"\nimport VEdgeGroups from \"../edge/VEdgeGroups.vue\"\n\nconst slots = useSlots()\n\nconst hasEdgeOverlaySlot = computed(() => \"edge-overlay\" in slots)\n</script>\n\n<template>\n  <!-- edges -->\n  <g class=\"v-ng-layer-edges\">\n    <v-edge-backgrounds />\n    <v-edge-groups :has-edge-overlay-slot=\"hasEdgeOverlaySlot\">\n      <template v-if=\"hasEdgeOverlaySlot\" #default=\"slotProps\">\n        <slot name=\"edge-overlay\" v-bind=\"slotProps\" />\n      </template>\n    </v-edge-groups>\n  </g>\n</template>\n","<!--\n  When using slots in v-for, unnecessary update hooks are called,\n  resulting in performance degradation.\n  This can be avoided by placing a component inside the v-for and\n  placing a fixed number of slots inside that component.\n  ref: https://github.com/vuejs/core/issues/6833\n-->\n<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { Edge } from \"@/common/types\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport * as v2d from \"@/modules/calculation/2d\"\n\ninterface Props {\n  edgeId: string\n  edge: Edge\n  state: EdgeState\n}\n\nconst props = defineProps<Props>()\nconst { scale } = useZoomLevel()\n\nconst area = computed(() => {\n  return v2d.calculateEdgeLabelArea(\n    props.state.labelPosition,\n    props.state.line.stroke,\n    props.state.label.margin,\n    props.state.label.padding,\n    scale.value\n  )\n})\n</script>\n<template>\n  <slot\n    v-if=\"!state.loop\"\n    :edge-id=\"edgeId\"\n    :edge=\"edge\"\n    :config=\"state.label\"\n    :area=\"area\"\n    :hovered=\"state.hovered\"\n    :selected=\"state.selected\"\n    :scale=\"scale\"\n  />\n</template>\n","<!--\n  When using slots in v-for, unnecessary update hooks are called,\n  resulting in performance degradation.\n  This can be avoided by placing a component inside the v-for and\n  placing a fixed number of slots inside that component.\n  ref: https://github.com/vuejs/core/issues/6833\n-->\n<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { Edges } from \"@/common/types\"\nimport { EdgeState, SummarizedEdgeState } from \"@/models/edge\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport * as v2d from \"@/modules/calculation/2d\"\n\ninterface Props {\n  edges: Edges\n  state: EdgeState\n  summarizeState?: SummarizedEdgeState\n}\n\nconst props = defineProps<Props>()\nconst { scale } = useZoomLevel()\n\nconst area = computed(() => {\n  return v2d.calculateEdgeLabelArea(\n    props.state.labelPosition,\n    props.summarizeState?.stroke ?? props.state.line.stroke,\n    props.state.label.margin,\n    props.state.label.padding,\n    scale.value\n  )\n})\n</script>\n<template>\n  <slot\n    v-if=\"!state.loop\"\n    :edges=\"edges\"\n    :config=\"state.label\"\n    :area=\"area\"\n    :hovered=\"state.hovered\"\n    :selected=\"state.selected\"\n    :scale=\"scale\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { EdgeGroup } from \"@/models/edge\"\nimport { useStates } from \"@/composables/state\"\nimport VEdgeLabelPlace from \"./VEdgeLabelPlace.vue\"\nimport VEdgeLabelsPlace from \"./VEdgeLabelsPlace.vue\"\n\ninterface Props {\n  enableEdgeLabel: boolean\n  enableEdgesLabel: boolean\n}\n\nwithDefaults(defineProps<Props>(), {\n  enableEdgeLabel: false,\n  enableEdgesLabel: false,\n})\n\nconst { edgeStates, edgeGroupStates, summarizedEdgeStates } = useStates()\n\nconst edgeGroups = computed(() => {\n  const individual: Record<string, EdgeGroup> = {}\n  const summarized: Record<string, EdgeGroup> = {}\n  Object.entries(edgeGroupStates.edgeGroups).forEach(([id, group]) => {\n    if (Object.keys(group.edges).length > 0) {\n      if (group.summarize) {\n        summarized[id] = group\n      } else {\n        individual[id] = group\n      }\n    }\n  })\n  return { individual, summarized }\n})\n\nfunction getRepresentativeEdgeKey(group: EdgeGroup) {\n  return Object.keys(group.edges)[0]\n}\n</script>\n\n<template>\n  <g class=\"v-ng-edge-labels\">\n    <template v-if=\"enableEdgeLabel\">\n      <template v-for=\"(group, id) in edgeGroups.individual\" :key=\"id\">\n        <template v-for=\"(edge, edgeId) in group.edges\" :key=\"edgeId\">\n          <v-edge-label-place\n            :edge-id=\"edgeId\"\n            :edge=\"edge\"\n            :state=\"edgeStates[edgeId]\"\n          >\n            <template #default=\"slotProps\">\n              <slot name=\"edge-label\" v-bind=\"slotProps\" />\n            </template>\n          </v-edge-label-place>\n        </template>\n      </template>\n    </template>\n    <template v-if=\"enableEdgesLabel\">\n      <template v-for=\"(group, id) in edgeGroups.summarized\" :key=\"id\">\n        <v-edge-labels-place\n          :edges=\"group.edges\"\n          :state=\"edgeStates[getRepresentativeEdgeKey(group)]\"\n          :summarize-state=\"summarizedEdgeStates[getRepresentativeEdgeKey(group)]\"\n        >\n          <template #default=\"slotProps\">\n            <slot name=\"edges-label\" v-bind=\"slotProps\" />\n          </template>\n        </v-edge-labels-place>\n      </template>\n    </template>\n  </g>\n</template>\n\n<style lang=\"scss\">\n.v-ng-edge-labels {\n  .v-ng-text,\n  .v-ng-text-background {\n    pointer-events: none;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, reactive, watchEffect } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { CircleShapeStyle, RectangleShapeStyle, ShapeStyle } from \"@/common/configs\"\nimport { NodeState } from \"@/models/node\"\nimport { useNodeConfig } from \"@/composables/config\"\nimport VShape from \"@/components/base/VShape.vue\"\n\ninterface Props {\n  id: string\n  state: NodeState\n  pos: Position\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  pos: undefined,\n})\n\nconst x = computed(() => props.pos?.x || 0)\nconst y = computed(() => props.pos?.y || 0)\n\nconst config = useNodeConfig()\nconst shapeConfig = reactive<ShapeStyle>({} as any)\n\nwatchEffect(() => {\n  const shapeStyle = props.state.shape\n  if (shapeStyle.type === \"circle\") {\n    const shape: CircleShapeStyle = {\n      type: \"circle\",\n      radius:\n        shapeStyle.radius +\n        (shapeStyle.strokeWidth ?? 0) / 2 +\n        config.focusring.padding +\n        config.focusring.width / 2,\n      color: \"none\",\n      strokeWidth: config.focusring.width,\n      strokeColor: config.focusring.color,\n      strokeDasharray: config.focusring.dasharray,\n    }\n    Object.assign(shapeConfig, shape)\n  } else {\n    const shape: RectangleShapeStyle = {\n      type: \"rect\",\n      width:\n        shapeStyle.width +\n        (shapeStyle.strokeWidth ?? 0) +\n        config.focusring.padding * 2 +\n        config.focusring.width,\n      height:\n        shapeStyle.height +\n        (shapeStyle.strokeWidth ?? 0) +\n        config.focusring.padding * 2 +\n        config.focusring.width,\n      borderRadius:\n        shapeStyle.borderRadius > 0 ? shapeStyle.borderRadius + config.focusring.padding : 0,\n      color: \"none\",\n      strokeWidth: config.focusring.width,\n      strokeColor: config.focusring.color,\n      strokeDasharray: config.focusring.dasharray,\n    }\n    Object.assign(shapeConfig, shape)\n  }\n})\n</script>\n\n<template>\n  <v-shape\n    class=\"v-ng-node-focusring\"\n    :base-x=\"x\"\n    :base-y=\"y\"\n    :config=\"shapeConfig\"\n  />\n</template>\n\n<style lang=\"scss\">\n$transition: 0.1s linear;\n\n.v-ng-node-focusring {\n  pointer-events: none;\n}\n\n:where(.v-ng-shape-circle) {\n  transition: r $transition;\n}\n:where(.v-ng-shape-rect) {\n  transition:\n    x $transition,\n    y $transition,\n    width $transition,\n    height $transition;\n}\n:where(.dragging .v-ng-shape-circle),\n:where(.dragging .v-ng-shape-rect) {\n  transition: none;\n}\n</style>\n","<script setup lang=\"ts\">\nimport VNodeFocusRing from \"@/components/node/VNodeFocusRing.vue\"\nimport { useStates } from \"@/composables/state\"\nimport { useSelections } from \"@/composables/selection\"\nimport { useLayouts } from \"@/composables/layout\"\n\nconst { nodeStates } = useStates()\nconst { selectedNodes } = useSelections()\nconst layouts = useLayouts()\n</script>\n\n<template>\n  <!-- node selections (focus ring) -->\n  <g class=\"v-ng-layer-nodes-selections\">\n    <v-node-focus-ring\n      v-for=\"nodeId in selectedNodes\"\n      :id=\"nodeId\"\n      :key=\"nodeId\"\n      :state=\"nodeStates[nodeId]\"\n      :pos=\"layouts.nodes[nodeId]\"\n    />\n  </g>\n</template>\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { NodeState } from \"@/models/node\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport VShape from \"@/components/base/VShape.vue\"\n\ninterface Props {\n  id: string\n  state: NodeState\n  pos?: Position\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  pos: undefined,\n})\n\nconst x = computed(() => props.pos?.x || 0)\nconst y = computed(() => props.pos?.y || 0)\n\nconst { scale } = useZoomLevel()\n\nconst {\n  handleNodePointerDownEvent,\n  handleNodePointerOverEvent,\n  handleNodePointerOutEvent,\n  handleNodeClickEvent,\n  handleNodeDoubleClickEvent,\n  handleNodeContextMenu,\n} = useMouseOperation()\n</script>\n\n<template>\n  <g\n    :class=\"{ 'v-ng-node': true, hover: state.hovered, selected: state.selected }\"\n    :transform=\"`translate(${x} ${y})`\"\n    @pointerdown.stop=\"handleNodePointerDownEvent(id, $event)\"\n    @pointerenter.passive=\"handleNodePointerOverEvent(id, $event)\"\n    @pointerleave.passive=\"handleNodePointerOutEvent(id, $event)\"\n    @click.stop=\"handleNodeClickEvent(id, $event)\"\n    @dblclick.stop=\"handleNodeDoubleClickEvent(id, $event)\"\n    @contextmenu=\"handleNodeContextMenu(id, $event)\"\n  >\n    <slot\n      name=\"override-node\"\n      :node-id=\"id\"\n      :scale=\"scale\"\n      :config=\"state.shape\"\n      :class=\"{ draggable: state.draggable, selectable: state.selectable }\"\n    >\n      <v-shape\n        :config=\"state.shape\"\n        :class=\"{\n          'v-ng-node-default': true,\n          draggable: state.draggable,\n          selectable: state.selectable,\n        }\"\n      />\n    </slot>\n  </g>\n</template>\n\n<style lang=\"scss\">\n$transition: 0.1s linear;\n\n.v-ng-node {\n  :where(.v-ng-shape-circle) {\n    transition:\n      fill $transition,\n      stroke $transition,\n      stroke-width $transition,\n      r $transition;\n  }\n  :where(.v-ng-shape-rect) {\n    transition:\n      fill $transition,\n      stroke $transition,\n      stroke-width $transition,\n      x $transition,\n      y $transition,\n      width $transition,\n      height $transition;\n  }\n\n  :where(.v-ng-node-default.v-ng-shape-circle) {\n    pointer-events: none;\n  }\n  :where(.v-ng-node-default.v-ng-shape-rect) {\n    pointer-events: none;\n  }\n\n  .draggable,\n  .selectable {\n    pointer-events: all;\n    cursor: pointer;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, useSlots } from \"vue\"\nimport { useNodeConfig } from \"@/composables/config\"\nimport { useLayouts } from \"@/composables/layout\"\nimport { useStates } from \"@/composables/state\"\nimport VNode from \"@/components/node/VNode.vue\"\n\nconst slots = useSlots()\nconst hasOverrideNodeSlot = computed(() => \"override-node\" in slots)\nconst { nodeZOrderedList } = useStates()\n\nconst configs = useNodeConfig()\nconst layouts = useLayouts()\n</script>\n\n<template>\n  <template v-if=\"hasOverrideNodeSlot\">\n    <transition-group\n      :name=\"configs.transition\"\n      :css=\"!!configs.transition\"\n      tag=\"g\"\n      class=\"v-ng-layer-nodes\"\n    >\n      <v-node\n        v-for=\"nodeState in nodeZOrderedList\"\n        :id=\"nodeState.id\"\n        :key=\"nodeState.id\"\n        :state=\"nodeState\"\n        :pos=\"layouts.nodes[nodeState.id]\"\n      >\n        <!-- override the node -->\n        <template #override-node=\"slotProps\">\n          <slot name=\"override-node\" v-bind=\"slotProps\" />\n        </template>\n      </v-node>\n    </transition-group>\n  </template>\n  <template v-else>\n    <!--\n      If a `v-node` contains a slot and no external slot is specified,\n      `v-ng-layer-nodes` element will be needlessly redrawn and all\n      `v-node` components get update notifications. Therefore, if there is\n      no external slot, do not specify a slot in the `v-node` component. -->\n    <transition-group\n      :name=\"configs.transition\"\n      :css=\"!!configs.transition\"\n      tag=\"g\"\n      class=\"v-ng-layer-nodes\"\n    >\n      <v-node\n        v-for=\"nodeState in nodeZOrderedList\"\n        :id=\"nodeState.id\"\n        :key=\"nodeState.id\"\n        :state=\"nodeState\"\n        :pos=\"layouts.nodes[nodeState.id]\"\n      />\n    </transition-group>\n  </template>\n</template>\n","import { NodeLabelDirection, NodeLabelDirectionType, OppositeNodes } from \"@/common/configs\"\nimport { Position } from \"@/common/types\"\nimport { subtract, angleDegree } from \"@/modules/vector2d\"\n\nconst labelDirections: Record<NodeLabelDirectionType, number> = {\n  [NodeLabelDirection.NORTH]: 0,\n  [NodeLabelDirection.NORTH_EAST]: 1,\n  [NodeLabelDirection.EAST]: 2,\n  [NodeLabelDirection.SOUTH_EAST]: 3,\n  [NodeLabelDirection.SOUTH]: 4,\n  [NodeLabelDirection.SOUTH_WEST]: 5,\n  [NodeLabelDirection.WEST]: 6,\n  [NodeLabelDirection.NORTH_WEST]: 7,\n  [NodeLabelDirection.CENTER]: -1,\n}\n\nconst denyAngles: ((a: number, loop: boolean) => boolean)[] = [\n  /* N */ (a, loop) => inRange(a, 0, loop ? 90 : 60),\n  /* NE */ (a, loop) => inRange(a, 45, loop ? 90 : 45),\n  /* E */ (a, loop) => inRange(a, 90, loop ? 60 : 30),\n  /* SE */ (a, loop) => inRange(a, 135, loop ? 90 : 45),\n  /* S */ (a, loop) => inRange(a, 180, loop ? 90 : 60),\n  /* SW */ (a, loop) => inRange(a, 225, loop ? 90 : 45),\n  /* W */ (a, loop) => inRange(a, 270, loop ? 60 : 30),\n  /* NW */ (a, loop) => inRange(a, 315, loop ? 90 : 45),\n]\n\nexport function handleNodeLabelAutoAdjustment(\n  nodeId: string,\n  currentPos: Position,\n  oppositeNodes: OppositeNodes,\n  getLoopCenter: (edgeId: string) => Position | undefined,\n  defaultDirection: NodeLabelDirectionType\n): NodeLabelDirectionType {\n  if (defaultDirection === NodeLabelDirection.CENTER) {\n    return NodeLabelDirection.CENTER\n  }\n\n  // Avoid overlapping edges from the node.\n  const angles: [number, boolean][] = []\n  Object.entries(oppositeNodes).forEach(([edgeId, oppositeNode]) => {\n    let isSelfLoop = false\n    if (oppositeNode.nodeId === nodeId) {\n      // self looped edge\n      const center = getLoopCenter(edgeId)\n      if (center) {\n        isSelfLoop = true\n        oppositeNode = {\n          ...oppositeNode,\n          pos: { x: center.x, y: center.y },\n        }\n      }\n    }\n    // angleDegree(): east=0, north=90, west=180, south=-90\n    // -> Divide into 10 azimuths except horizontal, and assign indexes including\n    //    horizontal in clockwise direction\n    const angle = (angleDegree(subtract(oppositeNode.pos, currentPos)) + 360 + 90) % 360\n    angles.push([angle, isSelfLoop])\n  })\n\n  const directionIndex = directionToIndex(defaultDirection)\n\n  // order of priority.\n  const candidates = [\n    directionIndex,\n    (directionIndex + 4) % 8, // priority is given to diagonals\n    (directionIndex + 2) % 8,\n    (directionIndex - 2 + 8) % 8,\n    (directionIndex + 1) % 8,\n    (directionIndex - 1 + 8) % 8,\n    (directionIndex + 3) % 8,\n    (directionIndex - 3 + 8) % 8,\n  ]\n\n  const azimuth = candidates.find(c => {\n    return angles.every(a => !denyAngles[c](...a))\n  })\n  if (azimuth === undefined) {\n    return defaultDirection\n  } else {\n    return indexToDirection(azimuth, defaultDirection)\n  }\n}\n\nfunction inRange(target: number, center: number, amount: number): boolean {\n  target %= 360\n  const min = (center - amount + 360) % 360\n  const max = (center + amount) % 360\n  if (min <= max) {\n    return min < target && target < max\n  } else {\n    return min < target || target < max\n  }\n}\n\nfunction directionToIndex(direction: NodeLabelDirectionType) {\n  return labelDirections[direction] ?? 0\n}\n\nfunction indexToDirection(index: number, defaultValue: NodeLabelDirectionType) {\n  return (Object.entries(labelDirections)[index]?.[0] ?? defaultValue) as NodeLabelDirectionType\n}\n","<script setup lang=\"ts\">\nimport { computed, ref, watchEffect } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { NodeLabelDirection } from \"@/common/configs\"\nimport { NodeState } from \"@/models/node\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { useNodeConfig } from \"@/composables/config\"\nimport { useStates } from \"@/composables/state\"\nimport { handleNodeLabelAutoAdjustment } from \"@/modules/node/label\"\nimport VLabelText from \"@/components/base/VLabelText.vue\"\n\ninterface Props {\n  id: string\n  state: NodeState\n  pos?: Position\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  pos: undefined,\n})\n\nconst configs = useNodeConfig()\nconst { edgeStates } = useStates()\nconst { scale } = useZoomLevel()\n\nconst {\n  handleNodePointerDownEvent,\n  handleNodePointerOverEvent,\n  handleNodePointerOutEvent,\n  handleNodeClickEvent,\n  handleNodeDoubleClickEvent,\n  handleNodeContextMenu,\n} = useMouseOperation()\n\nconst x = computed(() => props.pos?.x || 0)\nconst y = computed(() => props.pos?.y || 0)\n\nconst labelMargin = computed(() => {\n  if (props.state.label.direction === NodeLabelDirection.CENTER) {\n    return 0\n  } else {\n    return props.state.label.margin * scale.value\n  }\n})\n\nconst labelShiftV = ref(0) // Amount of label shift (vertical)\nconst labelShiftH = ref(0) // Amount of label shift (horizontal)\nconst labelDiagonalShiftV = ref(0) // Amount of shift in diagonal direction (vertical)\nconst labelDiagonalShiftH = ref(0) // Amount of shift in diagonal direction (horizontal)\n\nconst labelDirection = computed(() => {\n  const direction = props.state.label.direction\n  const autoAdjustment = props.state.label.directionAutoAdjustment\n  if (autoAdjustment === false) {\n    return direction\n  }\n\n  const pos = { x: x.value, y: y.value }\n  if (autoAdjustment === true) {\n    return handleNodeLabelAutoAdjustment(\n      props.state.id,\n      pos,\n      props.state.oppositeNodes,\n      (edgeId: string) => edgeStates[edgeId]?.loop?.center,\n      direction\n    )\n  } else {\n    return (\n      autoAdjustment({\n        nodeId: props.state.id,\n        pos,\n        oppositeNodes: props.state.oppositeNodes,\n      }) ?? direction\n    )\n  }\n})\n\nconst textAnchor = computed(() => {\n  switch (labelDirection.value) {\n    case NodeLabelDirection.CENTER:\n    case NodeLabelDirection.NORTH:\n    case NodeLabelDirection.SOUTH:\n      return \"middle\"\n    case NodeLabelDirection.EAST:\n    case NodeLabelDirection.NORTH_EAST:\n    case NodeLabelDirection.SOUTH_EAST:\n      return \"start\"\n    case NodeLabelDirection.WEST:\n    case NodeLabelDirection.NORTH_WEST:\n    case NodeLabelDirection.SOUTH_WEST:\n    default:\n      return \"end\"\n  }\n})\n\nconst dominantBaseline = computed(() => {\n  switch (labelDirection.value) {\n    case NodeLabelDirection.NORTH:\n    case NodeLabelDirection.NORTH_EAST:\n    case NodeLabelDirection.NORTH_WEST:\n      return \"text-top\"\n    case NodeLabelDirection.SOUTH:\n    case NodeLabelDirection.SOUTH_EAST:\n    case NodeLabelDirection.SOUTH_WEST:\n      return \"hanging\"\n    case NodeLabelDirection.CENTER:\n    case NodeLabelDirection.EAST:\n    case NodeLabelDirection.WEST:\n    default:\n      return \"central\"\n  }\n})\n\nconst labelX = computed(() => {\n  switch (labelDirection.value) {\n    case NodeLabelDirection.CENTER:\n    case NodeLabelDirection.NORTH:\n    case NodeLabelDirection.SOUTH:\n      return 0\n    case NodeLabelDirection.EAST:\n      return labelShiftH.value\n    case NodeLabelDirection.WEST:\n      return -labelShiftH.value\n    case NodeLabelDirection.NORTH_EAST:\n    case NodeLabelDirection.SOUTH_EAST:\n      return labelDiagonalShiftH.value\n    case NodeLabelDirection.NORTH_WEST:\n    case NodeLabelDirection.SOUTH_WEST:\n    default:\n      return -labelDiagonalShiftH.value\n  }\n})\n\nconst labelY = computed(() => {\n  switch (labelDirection.value) {\n    case NodeLabelDirection.NORTH:\n      return -labelShiftV.value\n    case NodeLabelDirection.SOUTH:\n      return labelShiftV.value\n    case NodeLabelDirection.CENTER:\n    case NodeLabelDirection.EAST:\n    case NodeLabelDirection.WEST:\n      return 0\n    case NodeLabelDirection.NORTH_EAST:\n    case NodeLabelDirection.NORTH_WEST:\n      return -labelDiagonalShiftV.value\n    case NodeLabelDirection.SOUTH_EAST:\n    case NodeLabelDirection.SOUTH_WEST:\n    default:\n      return labelDiagonalShiftV.value\n  }\n})\n\nwatchEffect(() => {\n  const s = scale.value\n  const shape = props.state.shape\n  if (shape.type == \"circle\") {\n    const radius = shape.radius * s\n    const m = radius + labelMargin.value\n    const diagonalMargin = Math.sqrt(m ** 2 / 2)\n    labelShiftV.value = radius + labelMargin.value\n    labelShiftH.value = radius + labelMargin.value\n    labelDiagonalShiftV.value = diagonalMargin\n    labelDiagonalShiftH.value = diagonalMargin\n  } else {\n    const borderRadius = shape.borderRadius * s\n    const width = shape.width * s\n    const height = shape.height * s\n    const m = borderRadius + labelMargin.value\n    const diagonalMargin = Math.sqrt(m ** 2 / 2)\n    labelShiftV.value = height / 2 + labelMargin.value\n    labelShiftH.value = width / 2 + labelMargin.value\n    labelDiagonalShiftV.value = height / 2 - borderRadius + diagonalMargin\n    labelDiagonalShiftH.value = width / 2 - borderRadius + diagonalMargin\n  }\n})\n\nconst eventHandlers = computed(() => (id: string) => {\n  if (configs.label.handleNodeEvents) {\n    return {\n      pointerdown: (e: PointerEvent) => {\n        e.stopPropagation()\n        handleNodePointerDownEvent(id, e)\n      },\n      pointerenter: (e: PointerEvent) => handleNodePointerOverEvent(id, e),\n      pointerleave: (e: PointerEvent) => handleNodePointerOutEvent(id, e),\n      click: (e: MouseEvent) => {\n        e.stopPropagation()\n        handleNodeClickEvent(id, e)\n      },\n      dblclick: (e: MouseEvent) => {\n        e.stopPropagation()\n        handleNodeDoubleClickEvent(id, e)\n      },\n      contextmenu: (e: MouseEvent) => {\n        handleNodeContextMenu(id, e)\n      },\n    }\n  } else {\n    return {}\n  }\n})\n\nconst groupClasses = computed(() => {\n  const handleEvents = configs.label.handleNodeEvents\n  return {\n    \"v-ng-node-label\": true,\n    hover: handleEvents && props.state.hovered,\n    selected: handleEvents && props.state.selected,\n  }\n})\n\nconst labelClasses = computed(() => {\n  const handleEvents = configs.label.handleNodeEvents\n  return {\n    draggable: handleEvents && props.state.draggable,\n    selectable: handleEvents && props.state.selectable,\n  }\n})\n</script>\n\n<template>\n  <g\n    :class=\"groupClasses\"\n    :transform=\"`translate(${x} ${y})`\"\n    v-on=\"eventHandlers(id)\"\n  >\n    <slot\n      name=\"override-node-label\"\n      :node-id=\"id\"\n      :scale=\"scale\"\n      :text=\"state.labelText\"\n      :x=\"labelX\"\n      :y=\"labelY\"\n      :config=\"state.label\"\n      :shape=\"state.shape\"\n      :text-anchor=\"textAnchor\"\n      :dominant-baseline=\"dominantBaseline\"\n      :class=\"labelClasses\"\n    >\n      <v-label-text\n        :text=\"state.labelText\"\n        :x=\"0\"\n        :y=\"0\"\n        :config=\"state.label\"\n        :text-anchor=\"textAnchor\"\n        :dominant-baseline=\"dominantBaseline\"\n        :class=\"labelClasses\"\n        :transform=\"`translate(${labelX} ${labelY})`\"\n      />\n    </slot>\n  </g>\n</template>\n\n<style lang=\"scss\">\n$transition: 0.1s linear;\n\n:where(.v-ng-node-label) {\n  > :where(*) {\n    cursor: default;\n    user-select: none;\n    transition: transform $transition;\n  }\n\n  .draggable,\n  .selectable {\n    pointer-events: all;\n    cursor: pointer;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, useSlots } from \"vue\"\nimport { useNodeConfig } from \"@/composables/config\"\nimport { useLayouts } from \"@/composables/layout\"\nimport { useStates } from \"@/composables/state\"\nimport { NodeState } from \"@/models/node\"\nimport VNodeLabel from \"@/components/node/VNodeLabel.vue\"\n\nconst slots = useSlots()\nconst hasOverrideNodeLabelSlot = computed(() => \"override-node-label\" in slots)\nconst { nodeZOrderedList } = useStates()\n\nconst configs = useNodeConfig()\nconst layouts = useLayouts()\n\nconst nodeStates = computed(() => onlyHasDisplayLabel(nodeZOrderedList.value))\n\nfunction onlyHasDisplayLabel(nodeZOrderedList: NodeState[]): NodeState[] {\n  return nodeZOrderedList.filter(state => {\n    return state.label.visible && (state.labelText ?? false)\n  })\n}\n</script>\n\n<template>\n  <template v-if=\"hasOverrideNodeLabelSlot\">\n    <transition-group\n      :name=\"configs.transition\"\n      :css=\"!!configs.transition\"\n      tag=\"g\"\n      class=\"v-ng-layer-node-labels\"\n    >\n      <v-node-label\n        v-for=\"nodeState in nodeStates\"\n        :id=\"nodeState.id\"\n        :key=\"nodeState.id\"\n        :state=\"nodeState\"\n        :pos=\"layouts.nodes[nodeState.id]\"\n      >\n        <!-- override the node label -->\n        <template #override-node-label=\"slotProps\">\n          <slot name=\"override-node-label\" v-bind=\"slotProps\" />\n        </template>\n      </v-node-label>\n    </transition-group>\n  </template>\n  <template v-else>\n    <transition-group\n      :name=\"configs.transition\"\n      :css=\"!!configs.transition\"\n      tag=\"g\"\n      class=\"v-ng-layer-node-labels\"\n    >\n      <v-node-label\n        v-for=\"nodeState in nodeStates\"\n        :id=\"nodeState.id\"\n        :key=\"nodeState.id\"\n        :state=\"nodeState\"\n        :pos=\"layouts.nodes[nodeState.id]\"\n      />\n    </transition-group>\n  </template>\n</template>\n","<script setup lang=\"ts\">\nimport { chunk } from \"lodash-es\"\nimport { CSSProperties, computed } from \"vue\"\nimport { PositionOrCurve } from \"@/common/types\"\nimport { Config } from \"@/common/configs\"\nimport { PathState } from \"@/models/path\"\nimport { usePathConfig } from \"@/composables/config\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray, getDasharrayUnit } from \"@/utils/visual\"\nimport { useStates } from \"@/composables/state\"\nimport { calculatePathPoints } from \"@/modules/calculation/path\"\n\nconst props = defineProps<{\n  path: PathState\n}>()\n\nconst { nodeStates, edgeStates, layouts } = useStates()\nconst { scale } = useZoomLevel()\nconst pathConfig = usePathConfig()\n\nfunction calcPathPoints(path: PathState): PositionOrCurve[] {\n  if (path.edges.length === 0) return []\n  const margin = Config.value(pathConfig.margin, path.path) * scale.value\n  return calculatePathPoints(\n    path,\n    nodeStates,\n    layouts.nodes,\n    edgeStates,\n    scale.value,\n    pathConfig.curveInNode,\n    pathConfig.end,\n    margin\n  )\n}\n\nfunction calcPathD(path: PathState) {\n  const points = calcPathPoints(path)\n  let move = true\n  return points\n    .map(p => {\n      if (p === null) {\n        move = true\n      } else if (typeof p === \"string\") {\n        return p\n      } else if (p instanceof Array) {\n        p = [...p]\n        const list = []\n        if (p.length % 2 === 1) {\n          const x = p[0]\n          p = p.slice(1)\n          list.push(`L ${x.x} ${x.y}`)\n        }\n        chunk(p, 2).map(([p1, p2]) => list.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`))\n        return list.join(\" \")\n      } else {\n        const m = move\n        move = false\n        return `${m ? \"M \" : \"L \"}${p.x} ${p.y}`\n      }\n    })\n    .join(\" \")\n}\n\nconst config = computed(() => {\n  const state = props.path\n  if (state.selected) {\n    return Config.values(pathConfig.selected, state.path)\n  } else if (state.hovered && pathConfig.hover) {\n    return Config.values(pathConfig.hover, state.path)\n  } else {\n    return Config.values(pathConfig.normal, state.path)\n  }\n})\n\nconst strokeDasharray = computed(() => {\n  return applyScaleToDasharray(config.value.dasharray, scale.value)\n})\n\nconst animationSpeed = computed(() => {\n  const speed = config.value.animate\n    ? getDasharrayUnit(config.value.dasharray) * config.value.animationSpeed * scale.value\n    : false\n  return speed ? ({ \"--animation-speed\": speed } as CSSProperties) : undefined\n})\n</script>\n\n<template>\n  <path\n    :class=\"{\n      'v-ng-path': true,\n      animate: config.animate,\n      clickable: path.clickable,\n      hoverable: path.hoverable,\n    }\"\n    :d=\"calcPathD(path)\"\n    fill=\"none\"\n    :stroke=\"config.color\"\n    :stroke-width=\"config.width * scale\"\n    :stroke-dasharray=\"strokeDasharray\"\n    :stroke-linecap=\"config.linecap\"\n    :stroke-linejoin=\"config.linejoin\"\n    :style=\"animationSpeed\"\n  />\n</template>\n\n<style lang=\"scss\">\n$transition: 0.1s linear;\n\n.v-path {\n  pointer-events: none;\n  transition:\n    stroke $transition,\n    stroke-width $transition;\n\n  &.clickable {\n    pointer-events: stroke;\n    cursor: pointer;\n  }\n  &.hoverable {\n    pointer-events: stroke;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { useStates } from \"@/composables/state\"\nimport { usePathConfig } from \"@/composables/config\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport VPath from \"./VPath.vue\"\n\nconst { pathZOrderedList } = useStates()\nconst pathConfig = usePathConfig()\n\nconst {\n  handlePathPointerDownEvent,\n  handlePathPointerOverEvent,\n  handlePathPointerOutEvent,\n  handlePathClickEvent,\n  handlePathDoubleClickEvent,\n  handlePathContextMenu,\n} = useMouseOperation()\n</script>\n\n<template>\n  <transition-group\n    :name=\"pathConfig.transition\"\n    :css=\"!!pathConfig.transition\"\n    tag=\"g\"\n    class=\"v-ng-paths\"\n  >\n    <template v-for=\"path in pathZOrderedList\" :key=\"path.id\">\n      <v-path\n        :path=\"path\"\n        @pointerdown=\"handlePathPointerDownEvent(path.id, $event)\"\n        @pointerenter.passive=\"handlePathPointerOverEvent(path.id, $event)\"\n        @pointerleave.passive=\"handlePathPointerOutEvent(path.id, $event)\"\n        @click.stop=\"handlePathClickEvent(path.id, $event)\"\n        @dblclick.stop=\"handlePathDoubleClickEvent(path.id, $event)\"\n        @contextmenu=\"handlePathContextMenu(path.id, $event)\"\n      />\n    </template>\n  </transition-group>\n</template>\n","<script setup lang=\"ts\">\nimport { readonly, ref, toRef, useSlots, computed, nextTick, watch, CSSProperties } from \"vue\"\nimport { EventHandlers, Nodes, Edges, InputPaths, Layouts, UserLayouts } from \"@/common/types\"\nimport { Layers, LayerPosition, LayerPositions, Point, Sizes } from \"@/common/types\"\nimport { Reactive, nonNull } from \"@/common/common\"\nimport { UserConfigs, ViewConfig } from \"@/common/configs\"\nimport { provideContainers } from \"@/composables/container\"\nimport { provideConfigs } from \"@/composables/config\"\nimport { provideStates, makeStateInput } from \"@/composables/state\"\nimport { provideMouseOperation } from \"@/composables/mouse\"\nimport { provideEventEmitter } from \"@/composables/event-emitter\"\nimport { makeMarkerState } from \"@/composables/marker\"\nimport { useSvgPanZoom } from \"@/composables/svg-pan-zoom\"\nimport { provideZoomLevel } from \"@/composables/zoom\"\nimport { useTransitionWhile } from \"@/composables/transition\"\nimport { useTranslatePathsToObject } from \"@/composables/object\"\nimport { bindProp, bindPropKeySet } from \"@/utils/props\"\nimport * as svgUtils from \"@/utils/svg\"\nimport { SvgPanZoomInstance, Box } from \"@/modules/svg-pan-zoom-ex\"\nimport { exportSvgElement, exportSvgElementWithOptions, ExportOptions } from \"@/utils/svg\"\nimport { provideSelections } from \"@/composables/selection\"\nimport { provideLayouts } from \"@/composables/layout\"\nimport { useBuiltInLayerOrder } from \"@/composables/layer\"\nimport { asyncNextTick } from \"@/modules/vue/nextTick\"\nimport { isPromise } from \"@/utils/object\"\nimport VSelectionBox from \"./base/VSelectionBox.vue\"\nimport VMarkerHead from \"./marker/VMarkerHead.vue\"\nimport VBackgroundGrid from \"./background/VBackgroundGrid.vue\"\nimport VBackgroundViewport from \"./background/VBackgroundViewport.vue\"\nimport VEdgesLayer from \"./layers/VEdgesLayer.vue\"\nimport VEdgeLabelsLayer from \"./layers/VEdgeLabelsLayer.vue\"\nimport VFocusringLayer from \"./layers/VFocusringLayer.vue\"\nimport VNodesLayer from \"./layers/VNodesLayer.vue\"\nimport VNodeLabelsLayer from \"./layers/VNodeLabelsLayer.vue\"\nimport VPathsLayer from \"./layers/VPathsLayer.vue\"\n\nconst SYSTEM_SLOTS = [\n  \"override-node\",\n  \"override-node-label\",\n  \"edge-overlay\",\n  \"edge-label\",\n  \"edges-label\",\n]\n\nenum State {\n  INITIAL = 0,\n  LOADED = 1,\n  UNLOADED = 2,\n}\n\ninterface Props {\n  nodes?: Nodes\n  edges?: Edges\n  paths?: InputPaths\n  layouts?: UserLayouts\n  zoomLevel?: number\n  selectedNodes?: string[]\n  selectedEdges?: string[]\n  selectedPaths?: string[]\n  configs?: UserConfigs\n  layers?: Layers\n  eventHandlers?: EventHandlers\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  nodes: () => ({}),\n  edges: () => ({}),\n  paths: () => ({}),\n  layouts: () => ({}),\n  zoomLevel: 1,\n  selectedNodes: () => [],\n  selectedEdges: () => [],\n  selectedPaths: () => [],\n  configs: () => ({}),\n  layers: () => ({}),\n  eventHandlers: () => ({}),\n})\n\nconst emit = defineEmits<{\n  (e: \"update:zoomLevel\", v: number): void\n  (e: \"update:selectedNodes\", v: string[]): void\n  (e: \"update:selectedEdges\", v: string[]): void\n  (e: \"update:selectedPaths\", v: string[]): void\n  (e: \"update:layouts\", v: Layouts): void\n}>()\n\nconst slots = useSlots()\n\nconst nodesRef = toRef(props, \"nodes\")\nconst edgesRef = toRef(props, \"edges\")\nconst { objects: pathsRef, isInCompatibilityModeForPath } = useTranslatePathsToObject(\n  toRef(props, \"paths\")\n)\n\n// Event Bus\nconst emitter = provideEventEmitter()\nObject.entries(props.eventHandlers).forEach(([type, event]) => {\n  emitter.on(type as any, event as any)\n})\n\n// Style settings\nconst configs = provideConfigs(toRef(props, \"configs\"))\n\n// Additional layers\nconst layerDefs = computed(() => {\n  const definedSlots = new Set(Object.keys(slots))\n  SYSTEM_SLOTS.forEach(s => definedSlots.delete(s))\n\n  const layers = Object.fromEntries(LayerPositions.map(n => [n, [] as string[]]))\n  Object.assign(\n    layers,\n    Object.entries(props.layers).reduce(\n      (accum, [name, type]) => {\n        definedSlots.delete(name)\n        if (type in accum) {\n          accum[type].push(name)\n        } else {\n          accum[type] = [name]\n        }\n        return accum\n      },\n      {} as Record<LayerPosition, string[]>\n    )\n  )\n  // The default slot and any slots not defined in the layers into root.\n  layers[\"root\"].push(...definedSlots)\n  return layers as Record<LayerPosition, string[]>\n})\n\n// Grid layer\nconst isShowGrid = computed(() => configs.view.grid.visible)\nconst isShowBackgroundViewport = computed(() => {\n  const layers = layerDefs.value\n  return isShowGrid.value || layers[\"background\"].length > 0 || layers[\"grid\"].length > 0\n})\n\nconst builtInLayerOrder = useBuiltInLayerOrder(configs, slots)\n\n// -----------------------------------------------------------------------\n// SVG\n// -----------------------------------------------------------------------\nconst container = ref<HTMLDivElement>()\nconst svg = ref<SVGElement & SVGSVGElement>()\nconst viewport = ref<SVGGElement>()\nconst state = ref<State>(State.INITIAL)\nconst show = computed(() => state.value !== State.INITIAL)\n\nconst zoomLevel = bindProp(props, \"zoomLevel\", emit, v => {\n  v = Math.max(v, configs.view.minZoomLevel)\n  v = Math.min(v, configs.view.maxZoomLevel)\n  return v\n})\n\n// SVG pan / zoom\nconst { svgPanZoom, onSvgPanZoomMounted, onSvgPanZoomUnmounted } = useSvgPanZoom(svg, {\n  viewportSelector: \".v-ng-viewport\",\n  minZoom: configs.view.minZoomLevel, // temporary\n  maxZoom: configs.view.maxZoomLevel, // temporary\n  dblClickZoomEnabled: isDoubleClickZoomEnabled(configs.view),\n  mouseWheelZoomEnabled: isMouseWheelZoomEnabled(configs.view),\n  fit: configs.view.autoPanAndZoomOnLoad === \"fit-content\",\n  center: configs.view.autoPanAndZoomOnLoad !== false,\n  zoomEnabled: configs.view.zoomEnabled,\n  preventMouseEventsDefault: false,\n  onZoom: _ => {\n    if (state.value === State.UNLOADED) return\n    const z = svgPanZoom.value?.getRealZoom() ?? 1\n    if (Math.abs(zoomLevel.value - z) >= 1.0e-6) {\n      zoomLevel.value = z\n      emitter.emit(\"view:zoom\", z)\n    }\n  },\n  panEnabled: configs.view.panEnabled,\n  onPan: p => {\n    if (state.value === State.UNLOADED) return\n    emitter.emit(\"view:pan\", p)\n  },\n})\n\nprovideContainers({ container, svg, viewport, svgPanZoom })\n\n// Observe container resizing\nconst rectSize = { width: 0, height: 0 }\nconst resizeObserver = globalThis.ResizeObserver\n  ? new ResizeObserver(() => {\n      svgPanZoom.value?.resize()\n      if (!configs.view.autoPanOnResize) return\n      // Pan to keep the view area centered\n      const r = container.value?.getBoundingClientRect()\n      if (r) {\n        const x = -(rectSize.width - r.width) / 2\n        const y = -(rectSize.height - r.height) / 2\n        svgPanZoom.value?.panBy({ x, y })\n        const { width, height } = r\n        if (rectSize.width !== width || rectSize.height !== height) {\n          Object.assign(rectSize, { width, height })\n          emitter.emit(\"view:resize\", { x: r.x, y: r.y, width, height })\n        }\n      }\n    })\n  : undefined\nonSvgPanZoomMounted(() => {\n  const c = nonNull(container.value, \"svg-pan-zoom container\")\n  resizeObserver?.observe(c)\n  configs.view.onSvgPanZoomInitialized?.(nonNull(svgPanZoom.value, \"svg-pan-zoom instance\"))\n  const r = c.getBoundingClientRect()\n  const { width, height } = r\n  Object.assign(rectSize, { width, height })\n  viewport.value?.addEventListener(\"touchstart\", stopEventPropagation, { passive: false })\n})\nonSvgPanZoomUnmounted(() => {\n  resizeObserver?.disconnect()\n  viewport.value?.removeEventListener(\"touchstart\", stopEventPropagation)\n})\n\nconst applyAbsoluteZoomLevel = (absoluteZoomLevel: number) => {\n  svgPanZoom.value?.applyAbsoluteZoomLevel(\n    absoluteZoomLevel,\n    configs.view.minZoomLevel,\n    configs.view.maxZoomLevel\n  )\n}\n\nwatch(\n  () => configs.view.panEnabled,\n  v => {\n    svgPanZoom.value?.setPanEnabled(v)\n  }\n)\nwatch(\n  () => [\n    configs.view.zoomEnabled,\n    isDoubleClickZoomEnabled(configs.view),\n    isMouseWheelZoomEnabled(configs.view),\n  ],\n  () => {\n    const svgPanZoomInstance = svgPanZoom.value\n    if (!svgPanZoomInstance) return\n    applyZoomEnabled(\n      svgPanZoomInstance,\n      configs.view.zoomEnabled,\n      configs.view.doubleClickZoomEnabled,\n      configs.view.mouseWheelZoomEnabled\n    )\n  }\n)\n\nwatch(zoomLevel, v => applyAbsoluteZoomLevel(v))\nwatch(\n  () => [configs.view.minZoomLevel, configs.view.maxZoomLevel],\n  _ => {\n    applyAbsoluteZoomLevel(zoomLevel.value)\n  }\n)\n\n// Provide zoom level / scaling parameter\nconst { scale } = provideZoomLevel(zoomLevel, configs.view)\n\nonSvgPanZoomMounted(() => {\n  // apply initial zoom level\n  const initialZoomLevel = props.zoomLevel\n  applyAbsoluteZoomLevel(initialZoomLevel)\n})\n\n// To resolve the problem that the center position and\n// magnification rate may not be recognized.\nconst updateBorderBox = async () => {\n  if (Object.keys(props.nodes).length > 0) {\n    svgPanZoom.value?.updateBBox()\n    await asyncNextTick()\n  }\n}\n\n// Scales the content to fit in the SVG area.\nconst fitToContents = async () => {\n  await updateBorderBox()\n  if (svgPanZoom.value) {\n    svgPanZoom.value.fitToContents()\n    emitter.emit(\"view:fit\", undefined)\n  }\n}\n\n// Place content in the center of the SVG area.\nconst panToCenter = async () => {\n  await updateBorderBox()\n  svgPanZoom.value?.center()\n}\n\n// Get viewport box\nconst getViewBox = () =>\n  svgPanZoom.value?.getViewBox() ?? {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n  }\n\n// Get viewport box\nconst setViewBox = (box: Box) => svgPanZoom.value?.setViewBox(box)\n\n// -----------------------------------------------------------------------\n// States of selected nodes/edges\n// -----------------------------------------------------------------------\nconst currentSelectedNodes = bindPropKeySet(props, \"selectedNodes\", nodesRef, emit)\nwatch(currentSelectedNodes, nodes => emitter.emit(\"node:select\", Array.from(nodes)))\n\nconst currentSelectedEdges = bindPropKeySet(props, \"selectedEdges\", edgesRef, emit)\nwatch(currentSelectedEdges, edges => emitter.emit(\"edge:select\", Array.from(edges)))\n\nconst currentSelectedPaths = bindPropKeySet(props, \"selectedPaths\", pathsRef, emit)\nwatch(currentSelectedPaths, paths => emitter.emit(\"path:select\", Array.from(paths)))\n\nprovideSelections(currentSelectedNodes, currentSelectedEdges, currentSelectedPaths)\n\nconst hoveredNodes = Reactive(new Set<string>())\nconst hoveredEdges = Reactive(new Set<string>())\nconst hoveredPaths = Reactive(new Set<string>())\nconst currentLayouts = Reactive<Layouts>({ nodes: {} })\n\nprovideLayouts(currentLayouts)\n\n// two-way binding\nwatch(\n  () => props.layouts,\n  () => Object.assign(currentLayouts, props.layouts),\n  { deep: true, immediate: true }\n)\nwatch(currentLayouts, () => emit(\"update:layouts\", currentLayouts), { deep: true })\n\n// -----------------------------------------------------------------------\n// SVG Markers\n// -----------------------------------------------------------------------\nconst markerState = makeMarkerState()\n\n// -----------------------------------------------------------------------\n// Mouse processing\n// -----------------------------------------------------------------------\n\n// mouse pointer change on dragging\nconst dragging = ref<boolean>(false)\nemitter.on(\"node:dragstart\", _ => (dragging.value = true))\nemitter.on(\"node:dragend\", _ => (dragging.value = false))\nemitter.on(\"view:mode\", mode => {\n  // avoid pan/zoom when using nodes and edges with multi-touch\n  if (configs.view.panEnabled) {\n    if (mode === \"default\") {\n      svgPanZoom.value?.enablePan()\n    } else {\n      svgPanZoom.value?.disablePan()\n    }\n  }\n  if (configs.view.zoomEnabled) {\n    if (mode === \"default\") {\n      svgPanZoom.value?.enableZoom()\n    } else {\n      svgPanZoom.value?.disableZoom()\n    }\n  }\n})\n\nconst touches = computed(() => {\n  return configs.view.panEnabled || configs.view.zoomEnabled || configs.node.draggable\n})\n\nconst { nodeStates, edgeStates, pathStates } = provideStates(\n  makeStateInput(nodesRef, currentSelectedNodes, hoveredNodes),\n  makeStateInput(edgesRef, currentSelectedEdges, hoveredEdges),\n  makeStateInput(pathsRef, currentSelectedPaths, hoveredPaths),\n  readonly(configs),\n  currentLayouts,\n  markerState,\n  scale\n)\n\nconst isSvgWheelZoomEnabled = computed(() => isMouseWheelZoomEnabled(configs.view))\n\n// mouse and touch support\nconst { isBoxSelectionMode, selectionBox, startBoxSelection, stopBoxSelection } =\n  provideMouseOperation(\n    svg,\n    readonly(currentLayouts),\n    readonly(zoomLevel),\n    nodeStates,\n    edgeStates,\n    pathStates,\n    currentSelectedNodes,\n    currentSelectedEdges,\n    currentSelectedPaths,\n    hoveredNodes,\n    hoveredEdges,\n    hoveredPaths,\n    isInCompatibilityModeForPath,\n    isSvgWheelZoomEnabled,\n    configs,\n    emitter\n  )\n\n// -----------------------------------------------------------------------\n// Node layout handler\n// -----------------------------------------------------------------------\n\nconst activateParams = () => ({\n  layouts: Reactive(currentLayouts.nodes), // deprecated parameter.\n  nodePositions: toRef(currentLayouts, \"nodes\"),\n  nodes: nodesRef,\n  edges: edgesRef,\n  configs: readonly(configs),\n  scale: readonly(scale),\n  emitter,\n  svgPanZoom: nonNull(svgPanZoom.value),\n})\nwatch(\n  () => configs.view.layoutHandler,\n  (newHandler, oldHandler) => {\n    oldHandler.deactivate()\n    newHandler.activate(activateParams())\n  }\n)\n\n// -----------------------------------------------------------------------\n// Transition of element positions\n// -----------------------------------------------------------------------\n\n// #transitionWhile() method\nconst { transitionWhile, transitionOption } = useTransitionWhile()\nconst transitionStyles = computed(() => {\n  const o = transitionOption.value\n  return (\n    o.enabled\n      ? {\n          \"--transition-duration\": o.duration + \"ms\",\n          \"--transition-function\": o.timingFunction,\n        }\n      : {}\n  ) as CSSProperties\n})\n\n// -----------------------------------------------------------------------\n// Events\n// -----------------------------------------------------------------------\n\nonSvgPanZoomMounted(async () => {\n  // Wait promise for network loading\n  if (configs.view.onBeforeInitialDisplay) {\n    const promise = configs.view.onBeforeInitialDisplay()\n    if (isPromise(promise)) {\n      await promise\n    }\n  }\n\n  // pan to center\n  const svg = nonNull(svgPanZoom.value, \"svg-pan-zoom\")\n\n  // activate layout handler.\n  // (calc the positions of nodes whose positions are not specified)\n  configs.view.layoutHandler.activate(activateParams())\n\n  // Wait for applying network/layout changes such as nodes, layouts, etc.\n  // by onBeforeInitialDisplay/LayoutHandler\n  await asyncNextTick()\n\n  const autoPanAndZoom = configs.view.autoPanAndZoomOnLoad\n  if (configs.view.fit || autoPanAndZoom !== false) {\n    const nodesEmpty = Object.keys(props.nodes).length == 0\n    const pan1 = svg.getPan()\n    if (nodesEmpty || autoPanAndZoom === \"center-zero\") {\n      await updateBorderBox()\n      // Pan (0, 0) to the center.\n      const sizes = svg.getSizes()\n      svg.pan({\n        x: sizes.width / 2,\n        y: sizes.height / 2,\n      })\n    } else if (autoPanAndZoom === \"fit-content\" || configs.view.fit) {\n      await fitToContents()\n    } else if (autoPanAndZoom === \"center-content\") {\n      await panToCenter()\n    } else {\n      await updateBorderBox()\n    }\n\n    // If the pan position does not change, the onPan event of svg-pan-zoom\n    // is not fired, but v-network-graph always fires the `view:pan` event\n    // when initialized.\n    nextTick(() => {\n      const pan2 = svg.getPan()\n      if (pan1.x === pan2.x && pan1.y === pan2.y) {\n        emitter.emit(\"view:pan\", pan2)\n      }\n    })\n  } else {\n    await updateBorderBox()\n  }\n\n  emitter.emit(\"view:load\")\n\n  // start displaying the svg\n  state.value = State.LOADED\n})\n\nonSvgPanZoomUnmounted(() => {\n  state.value = State.UNLOADED\n  emitter.emit(\"view:unload\")\n  configs.view.layoutHandler.deactivate()\n})\n\n/**\n * Zoom in\n */\nfunction zoomIn() {\n  svgPanZoom.value?.zoomIn()\n}\n\n/**\n * Zoom out\n */\nfunction zoomOut() {\n  svgPanZoom.value?.zoomOut()\n}\n\n/**\n * Pan to a rendered position\n * @return {Point} point to pan\n */\nfunction panTo(point: Point) {\n  svgPanZoom.value?.pan(point)\n}\n\n/**\n * Relatively pan the graph by a specified rendered position vector\n * @return {Point} relative point to pan\n */\nfunction panBy(point: Point) {\n  svgPanZoom.value?.panBy(point)\n}\n\n/**\n * Get pan vector\n * @return {Point} pan vector\n */\nfunction getPan(): Point {\n  return nonNull(svgPanZoom.value).getPan()\n}\n\n/**\n * Get all calculate svg dimensions\n */\nfunction getSizes(): Sizes {\n  const sizes = nonNull(svgPanZoom.value).getSizes()\n  return {\n    width: sizes.width,\n    height: sizes.height,\n    viewBox: sizes.viewBox,\n  }\n}\n\n/**\n * Translate from DOM to SVG coordinates\n * @return {Point} coordinates in the SVG\n */\nfunction translateFromDomToSvgCoordinates(coordinates: Point): Point {\n  return svgUtils.translateFromDomToSvgCoordinates(\n    nonNull(svg.value, \"svg\"),\n    nonNull(viewport.value, \"viewport\"),\n    coordinates\n  )\n}\n\n/**\n * Translate from SVG to DOM coordinates\n * @return {Point} coordinates in the DOM\n */\nfunction translateFromSvgToDomCoordinates(coordinates: Point): Point {\n  return svgUtils.translateFromSvgToDomCoordinates(\n    nonNull(svg.value, \"svg\"),\n    nonNull(viewport.value, \"viewport\"),\n    coordinates\n  )\n}\n\n/**\n * Get graph as SVG text.\n * @return {string} SVG text\n * @deprecated\n */\nfunction getAsSvg(): string {\n  const target = exportSvgElement(\n    nonNull(svg.value, \"svg\"),\n    nonNull(viewport.value, \"viewport\"),\n    scale.value\n  )\n  return target.outerHTML\n}\n\n/**\n * Export graph as SVG text.\n * @return {string} SVG text\n */\nasync function exportAsSvgText(options: Partial<ExportOptions> = {}): Promise<string> {\n  const target = exportAsSvgElement(options)\n  return (await target).outerHTML\n}\n\n/**\n * Export graph as SVG element.\n * @return {SVGElement} SVG element\n */\nasync function exportAsSvgElement(options: Partial<ExportOptions> = {}): Promise<SVGElement> {\n  return exportSvgElementWithOptions(\n    nonNull(svg.value, \"svg\"),\n    nonNull(viewport.value, \"viewport\"),\n    scale.value,\n    options\n  )\n}\n\ndefineExpose({\n  // methods\n  fitToContents,\n  panToCenter,\n  getViewBox,\n  setViewBox,\n  transitionWhile,\n  startBoxSelection,\n  stopBoxSelection,\n  zoomIn,\n  zoomOut,\n  panTo,\n  panBy,\n  getPan,\n  getSizes,\n  translateFromDomToSvgCoordinates,\n  translateFromSvgToDomCoordinates,\n  getAsSvg,\n  exportAsSvgText,\n  exportAsSvgElement,\n})\n\n// local functions\n\nfunction applyZoomEnabled(\n  svgPanZoom: SvgPanZoomInstance,\n  enable: boolean,\n  enableDblClick: boolean,\n  enableMouseWheel: boolean\n): void {\n  svgPanZoom.setZoomEnabled(enable)\n  if (enable && enableDblClick) {\n    svgPanZoom.enableDblClickZoom()\n  } else {\n    svgPanZoom.disableDblClickZoom()\n  }\n  if (enable && enableMouseWheel) {\n    svgPanZoom.enableMouseWheelZoom()\n  } else {\n    svgPanZoom.disableMouseWheelZoom()\n  }\n}\n\nfunction isDoubleClickZoomEnabled(view: ViewConfig): boolean {\n  return view.zoomEnabled && view.doubleClickZoomEnabled\n}\n\nfunction isMouseWheelZoomEnabled(view: ViewConfig): boolean {\n  return view.zoomEnabled && view.mouseWheelZoomEnabled\n}\n\nfunction stopEventPropagation(event: Event) {\n  event.stopPropagation()\n}\n</script>\n\n<template>\n  <div ref=\"container\" class=\"v-network-graph v-ng-container\">\n    <svg\n      ref=\"svg\"\n      class=\"v-ng-canvas\"\n      :class=\"{ show, dragging, touches, 'box-selection-mode': isBoxSelectionMode }\"\n      width=\"100%\"\n      height=\"100%\"\n    >\n      <!-- outside of viewport -->\n      <slot\n        v-for=\"layerName in layerDefs['root']\"\n        :key=\"layerName\"\n        :name=\"layerName\"\n        :scale=\"scale\"\n      />\n\n      <defs v-if=\"Object.keys(markerState.markers).length > 0\">\n        <v-marker-head\n          v-for=\"(marker, id) in markerState.markers\"\n          :id=\"id\"\n          :key=\"id\"\n          :marker=\"marker\"\n          :scale=\"scale\"\n        />\n      </defs>\n\n      <!-- background-viewport:\n           area outside the scope of SVG text retrieval but targeted by pan/zoom. -->\n      <v-background-viewport v-if=\"isShowBackgroundViewport\">\n        <g v-for=\"layerName in layerDefs['background']\" :key=\"layerName\" class=\"v-ng-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n\n        <!-- grid -->\n        <v-background-grid v-if=\"isShowGrid\" />\n\n        <g v-for=\"layerName in layerDefs['grid']\" :key=\"layerName\" class=\"v-ng-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n      </v-background-viewport>\n\n      <!-- viewport: pan/zoom target and within the range of SVG text retrieval. -->\n      <g\n        ref=\"viewport\"\n        class=\"v-ng-viewport\"\n        :class=\"{ 'v-ng-transition': transitionOption.enabled }\"\n        :style=\"transitionStyles\"\n      >\n        <g v-for=\"layerName in layerDefs['base']\" :key=\"layerName\" class=\"v-ng-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n\n        <!-- Sortable built-in layers -->\n        <template v-for=\"layerName in builtInLayerOrder\" :key=\"layerName\">\n          <!-- Edges -->\n          <template v-if=\"layerName === 'edges'\">\n            <v-edges-layer>\n              <template v-if=\"'edge-overlay' in slots\" #edge-overlay=\"slotProps\">\n                <slot name=\"edge-overlay\" v-bind=\"slotProps\" />\n              </template>\n            </v-edges-layer>\n          </template>\n\n          <!-- Edge labels -->\n          <template v-else-if=\"layerName === 'edge-labels'\">\n            <v-edge-labels-layer\n              :enable-edge-label=\"'edge-label' in slots\"\n              :enable-edges-label=\"'edges-label' in slots\"\n            >\n              <template #edge-label=\"slotProps\">\n                <slot name=\"edge-label\" v-bind=\"slotProps\" />\n              </template>\n              <template #edges-label=\"slotProps\">\n                <slot name=\"edges-label\" v-bind=\"slotProps\" />\n              </template>\n            </v-edge-labels-layer>\n          </template>\n\n          <!-- Node focusring -->\n          <template v-else-if=\"layerName === 'focusring'\">\n            <v-focusring-layer />\n          </template>\n\n          <!-- Nodes -->\n          <template v-else-if=\"layerName === 'nodes'\">\n            <v-nodes-layer>\n              <template #override-node=\"slotProps\">\n                <slot name=\"override-node\" v-bind=\"slotProps\" />\n              </template>\n            </v-nodes-layer>\n          </template>\n\n          <!-- Node labels -->\n          <template v-else-if=\"layerName === 'node-labels'\">\n            <v-node-labels-layer>\n              <template #override-node-label=\"slotProps\">\n                <slot name=\"override-node-label\" v-bind=\"slotProps\" />\n              </template>\n            </v-node-labels-layer>\n          </template>\n\n          <!-- Paths -->\n          <template v-else-if=\"layerName === 'paths'\">\n            <v-paths-layer />\n          </template>\n\n          <!-- User defined layer -->\n          <template v-for=\"customLayerName in layerDefs[layerName]\" :key=\"customLayerName\">\n            <g class=\"v-ng-layer\">\n              <slot :name=\"customLayerName\" :scale=\"scale\" />\n            </g>\n          </template>\n        </template>\n      </g>\n\n      <!-- selection box -->\n      <v-selection-box\n        v-if=\"selectionBox\"\n        :box=\"selectionBox\"\n        :config=\"configs.view.selection.box\"\n      />\n    </svg>\n  </div>\n</template>\n\n<style lang=\"scss\">\n:where(.v-ng-container) {\n  width: 100%;\n  height: 100%;\n}\n\n.v-ng-container {\n  padding: 0;\n  position: relative;\n  user-select: none;\n}\n\n.v-ng-canvas {\n  -webkit-tap-highlight-color: transparent;\n  width: 100%;\n  height: 100%;\n  // Respond to disorder until the svgPanZoom library is activated\n  opacity: 0;\n  &.show {\n    opacity: 1;\n    transition: opacity 0.5s linear;\n  }\n}\n\n.v-ng-canvas.dragging {\n  * {\n    cursor: grabbing !important;\n  }\n  .v-ng-line {\n    transition: d 0s;\n  }\n}\n\n.v-ng-canvas.touches {\n  // prevent to perform browser's default action\n  touch-action: none;\n}\n\n.v-ng-canvas.box-selection-mode {\n  cursor: crosshair !important;\n  * {\n    cursor: crosshair !important;\n  }\n}\n\n// Disable transitions before initialization is completed\n.v-ng-canvas:not(.show) {\n  .v-ng-node,\n  .v-ng-node-label,\n  .v-ng-node-focusring,\n  .v-ng-edge,\n  .v-ng-edge-label,\n  .v-ng-path {\n    transition: none;\n    > * {\n      transition: none;\n    }\n  }\n}\n\n// transition options for #transitionWhile()\n.v-ng-viewport.v-ng-transition {\n  --transition-duration: 300ms;\n  --transition-function: linear;\n  .v-ng-node,\n  .v-ng-node-label,\n  .v-ng-node-focusring,\n  .v-ng-edge,\n  .v-ng-edge-label,\n  .v-ng-path {\n    transition: all var(--transition-duration) var(--transition-function);\n    > * {\n      transition: all var(--transition-duration) var(--transition-function);\n    }\n  }\n}\n\n.v-ng-line.animate,\n.v-ng-path.animate {\n  --animation-speed: 100;\n  animation: v-ng-dash 10s linear infinite;\n  stroke-dashoffset: var(--animation-speed);\n}\n@keyframes v-ng-dash {\n  to {\n    stroke-dashoffset: 0;\n  }\n}\n</style>\n","<template>\n  <defs>\n    <component :is=\"'style'\">\n      <slot />\n    </component>\n  </defs>\n</template>\n","<script setup lang=\"ts\">\nimport { computed, Ref, ref, watchEffect } from \"vue\"\nimport { EdgeLabelStyle } from \"@/common/configs\"\nimport { Edge, EdgeLabelArea } from \"@/common/types\"\nimport { VectorLine } from \"@/modules/calculation/line\"\nimport VText from \"@/components/base/VLabelText.vue\"\n\ninterface Props {\n  area: EdgeLabelArea\n  config: EdgeLabelStyle\n  text?: string\n  align?: \"center\" | \"source\" | \"target\"\n  verticalAlign?: \"center\" | \"above\" | \"below\"\n  // The followings are the definitions to avoid passing unwanted\n  // items to <text> when they are specified in v-bind.\n  edge?: Edge\n  hovered?: boolean\n  selected?: boolean\n  scale?: number\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  text: \"\",\n  align: \"center\",\n  verticalAlign: \"center\",\n  edge: undefined,\n  hovered: undefined,\n  selected: undefined,\n  scale: undefined,\n})\n\nconst x = ref(0)\nconst y = ref(0)\nconst textAnchor: Ref<\"middle\" | \"start\" | \"end\"> = ref(\"middle\")\nconst dominantBaseline: Ref<\"text-top\" | \"hanging\" | \"central\"> = ref(\"central\")\nconst angle = ref(0)\n\nwatchEffect(() => {\n  const s = props.area.source\n  const t = props.area.target\n  if (props.align === \"source\") {\n    if (s.above.x == t.above.x) {\n      textAnchor.value = s.above.y > t.above.y ? \"start\" : \"end\"\n    } else {\n      textAnchor.value = s.above.x < t.above.x ? \"start\" : \"end\"\n    }\n    if (props.verticalAlign === \"above\") {\n      x.value = s.above.x\n      y.value = s.above.y\n      dominantBaseline.value = \"text-top\"\n    } else if (props.verticalAlign === \"below\") {\n      x.value = s.below.x\n      y.value = s.below.y\n      dominantBaseline.value = \"hanging\"\n    } else {\n      // center\n      x.value = (s.above.x + s.below.x) / 2\n      y.value = (s.above.y + s.below.y) / 2\n      dominantBaseline.value = \"central\"\n    }\n  } else if (props.align === \"target\") {\n    if (s.above.x == t.above.x) {\n      textAnchor.value = s.above.y < t.above.y ? \"start\" : \"end\"\n    } else {\n      textAnchor.value = s.above.x > t.above.x ? \"start\" : \"end\"\n    }\n    if (props.verticalAlign === \"above\") {\n      x.value = t.above.x\n      y.value = t.above.y\n      dominantBaseline.value = \"text-top\"\n    } else if (props.verticalAlign === \"below\") {\n      x.value = t.below.x\n      y.value = t.below.y\n      dominantBaseline.value = \"hanging\"\n    } else {\n      // center\n      x.value = (t.above.x + t.below.x) / 2\n      y.value = (t.above.y + t.below.y) / 2\n      dominantBaseline.value = \"central\"\n    }\n  } else {\n    // center\n    textAnchor.value = \"middle\"\n    if (props.verticalAlign === \"above\") {\n      x.value = (s.above.x + t.above.x) / 2\n      y.value = (s.above.y + t.above.y) / 2\n      dominantBaseline.value = \"text-top\"\n    } else if (props.verticalAlign === \"below\") {\n      x.value = (s.below.x + t.below.x) / 2\n      y.value = (s.below.y + t.below.y) / 2\n      dominantBaseline.value = \"hanging\"\n    } else {\n      // center\n      x.value = (s.above.x + t.below.x) / 2\n      y.value = (s.above.y + t.below.y) / 2\n      dominantBaseline.value = \"central\"\n    }\n  }\n  let degree = VectorLine.fromPositions(s.above, t.above).v.angleDegree()\n  if (degree < -90 || degree >= 90) {\n    degree = degree + 180\n    if (degree > 180) {\n      degree -= 360\n    }\n  }\n  angle.value = degree\n})\n\n// If there is no background config and text overlaps the line,\n// automatically set the background.\nconst updatedConfig = computed(() => {\n  if (dominantBaseline.value === \"central\" && !props.config.background) {\n    return {\n      ...props.config,\n      background: {\n        visible: true,\n        color: \"#ffffff\",\n        padding: {\n          vertical: 1,\n          horizontal: 4,\n        },\n        borderRadius: 2,\n      },\n    }\n  } else {\n    return props.config\n  }\n})\n</script>\n\n<template>\n  <v-text\n    class=\"v-ng-edge-label\"\n    :text=\"text\"\n    :x=\"x\"\n    :y=\"y\"\n    :config=\"updatedConfig\"\n    :text-anchor=\"textAnchor\"\n    :dominant-baseline=\"dominantBaseline\"\n    :transform=\"`rotate(${angle} ${x} ${y})`\"\n  />\n  <!-- <g>\n    <circle\n      :cx=\"area.source.above.x\"\n      :cy=\"area.source.above.y\"\n      r=\"3\"\n      fill=\"red\"\n    />\n    <circle\n      :cx=\"area.target.above.x\"\n      :cy=\"area.target.above.y\"\n      r=\"3\"\n      fill=\"green\"\n    />\n    <circle\n      :cx=\"area.source.below.x\"\n      :cy=\"area.source.below.y\"\n      r=\"3\"\n      fill=\"blue\"\n    />\n    <circle\n      :cx=\"area.target.below.x\"\n      :cy=\"area.target.below.y\"\n      r=\"3\"\n      fill=\"orange\"\n    />\n  </g> -->\n</template>\n","import { Ref } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { SimpleLayout } from \"./simple\"\n\nconst DEFAULT_GRID = 10\n\nexport type GridLayoutParameters = {\n  grid?: number\n}\n\nexport class GridLayout extends SimpleLayout {\n  constructor(private options: GridLayoutParameters = {}) {\n    super()\n  }\n\n  protected setNodePosition(nodeLayout: Ref<Position>, pos: Position) {\n    const grid = this.options.grid || DEFAULT_GRID\n    nodeLayout.value.x = Math.floor(pos.x / grid) * grid\n    nodeLayout.value.y = Math.floor(pos.y / grid) * grid\n  }\n}\n","import { App, Plugin } from \"vue\"\n\n// Import vue components\nimport * as components from \"./components/index\"\n\n// install function executed by Vue.use()\nconst install: Exclude<Plugin[\"install\"], undefined> = function (app: App) {\n  Object.entries(components).forEach(([componentName, component]) => {\n    app.component(componentName, component)\n  })\n}\n\n// Create module definition for Vue.use()\nexport default install\n\nexport type VNetworkGraphInstance = InstanceType<typeof components.VNetworkGraph>\nexport type Instance = InstanceType<typeof components.VNetworkGraph>\n\n// To allow individual component use, export components\n// each can be registered via Vue.component()\nexport * from \"./components/index\"\n\nexport { getFullConfigs } from \"./common/config-defaults\"\n\nexport { SimpleLayout } from \"./layouts/simple\"\nexport { GridLayout } from \"./layouts/grid\"\n// export { ForceLayout } from \"./layouts/force\"\nexport type { LayoutHandler } from \"./layouts/handler\"\n\nexport * from \"./common/types\"\nexport * from \"./common/configs\"\nexport { Vector2D } from \"./modules/vector2d\"\n\n// Export for more advanced visualization. However, be aware of the\n// possibility of destructive specification changes in the future.\nexport { useStates } from \"./composables/state\"\n\nexport type { Box } from \"./modules/svg-pan-zoom-ex\"\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}