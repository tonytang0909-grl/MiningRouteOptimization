{"version":3,"file":"index.js","sources":["../src/common/types.ts","../src/common/common.ts","../src/composables/container.ts","../src/common/configs.ts","../src/utils/visual.ts","../src/layouts/simple.ts","../src/common/config-defaults.ts","../src/composables/config.ts","../src/composables/id.ts","../src/utils/object.ts","../src/modules/edge/group.ts","../src/modules/vector2d/methods.ts","../src/modules/vector2d/vector2d.ts","../src/modules/vector2d/index.ts","../src/modules/calculation/line.ts","../src/modules/calculation/point.ts","../src/modules/calculation/2d.ts","../src/modules/node/node.ts","../src/utils/collection.ts","../src/modules/calculation/path.ts","../src/composables/objectState.ts","../src/utils/string.ts","../src/composables/marker.ts","../src/composables/state.ts","../src/utils/map.ts","../src/composables/mouse/core.ts","../src/composables/mouse/node.ts","../src/composables/mouse/edge.ts","../src/composables/mouse/container.ts","../src/composables/mouse/path.ts","../src/utils/download.ts","../src/utils/svg.ts","../src/composables/mouse/boxSelection.ts","../src/composables/mouse/index.ts","../node_modules/mitt/dist/mitt.mjs","../src/composables/event-emitter.ts","../node_modules/@dash14/svg-pan-zoom/src/utilities.js","../node_modules/@dash14/svg-pan-zoom/src/uniwheel.js","../node_modules/@dash14/svg-pan-zoom/src/svg-utilities.js","../node_modules/@dash14/svg-pan-zoom/src/control-icons.js","../node_modules/@dash14/svg-pan-zoom/src/shadow-viewport.js","../node_modules/@dash14/svg-pan-zoom/src/svg-pan-zoom.js","../src/modules/svg-pan-zoom-ex.ts","../src/composables/svg-pan-zoom.ts","../src/composables/zoom.ts","../src/composables/transition.ts","../src/composables/object.ts","../src/utils/props.ts","../src/composables/selection.ts","../src/composables/layout.ts","../src/modules/collection/iterate.ts","../src/modules/collection/array.ts","../src/composables/layer.ts","../src/modules/vue/nextTick.ts","../src/components/marker/VMarkerHeadArrow.vue","../src/components/marker/VMarkerHeadAngle.vue","../src/components/marker/VMarkerHead.vue","../src/components/background/VBackgroundGrid.vue","../src/components/background/VBackgroundViewport.vue","../src/components/edge/VEdgeBackground.vue","../src/components/edge/VEdgeBackgrounds.vue","../src/components/base/VLine.vue","../src/components/base/VArc.vue","../src/components/edge/VEdgeCurved.vue","../src/components/edge/VEdge.vue","../src/components/base/VShape.vue","../src/components/base/VLabelText.vue","../src/components/edge/VEdgeSummarized.vue","../src/components/edge/VEdgeOverlay.vue","../src/components/edge/VEdgeGroups.vue","../src/components/layers/VEdgesLayer.vue","../src/components/edge/VEdgeLabelPlace.vue","../src/components/edge/VEdgeLabelsPlace.vue","../src/components/edge/VEdgeLabels.vue","../src/components/node/VNodeFocusRing.vue","../src/components/layers/VFocusringLayer.vue","../src/components/node/VNode.vue","../src/components/layers/VNodesLayer.vue","../src/modules/node/label.ts","../src/components/node/VNodeLabel.vue","../src/components/layers/VNodeLabelsLayer.vue","../src/components/path/VPath.vue","../src/components/path/VPaths.vue","../src/components/VNetworkGraph.vue","../src/components/base/VStyle.vue","../src/components/edge/VEdgeLabel.vue","../src/layouts/grid.ts","../src/index.ts"],"sourcesContent":["import { RecursivePartial } from \"./common\"\n\n/* ------------------------------------------ *\n * Core types\n * ------------------------------------------ */\n\nexport interface Position {\n  x: number\n  y: number\n}\n\nexport interface LinePosition {\n  p1: Position\n  p2: Position\n}\n\nexport interface Size {\n  width: number\n  height: number\n}\n\nexport interface Rectangle {\n  pos: Position\n  size: Size\n}\n\n/** An object with a field named id */\nexport interface IdentifiedObject {\n  id: string\n}\n\n/* ------------------------------------------ *\n * Network graph elements\n * ------------------------------------------ */\n\nexport interface Node {\n  name?: string\n  // any properties\n  [x: string]: any\n}\n\nexport type Nodes = Record<string, Node>\nexport type NodeWithId = Node & IdentifiedObject\n\nexport interface Edge {\n  source: string\n  target: string\n  // any properties\n  [x: string]: any\n}\n\nexport type Edges = Record<string, Edge>\nexport type EdgeWithId = Edge & IdentifiedObject\n\nexport type LayerName = \"edges\" | \"edge-labels\" | \"focusring\" | \"nodes\" | \"node-labels\" | \"paths\"\n\nexport type LayerPosition = LayerName | \"base\" | \"grid\" | \"background\" | \"root\"\n\nexport type Layers = Record<string, LayerPosition>\n\nexport const LayerPositions: readonly LayerPosition[] = [\n  \"paths\",\n  \"node-labels\",\n  \"nodes\",\n  \"focusring\",\n  \"edge-labels\",\n  \"edges\",\n  \"base\",\n  \"grid\",\n  \"background\",\n  \"root\",\n]\n\n/* ------------------------------------------ *\n * View\n * ------------------------------------------ */\n\nexport type ViewMode = \"default\" | \"node\" | \"edge\" | \"path\" | \"box-selection\"\n\n/* ------------------------------------------ *\n * Layouts\n * ------------------------------------------ */\n\nexport interface FixablePosition extends Position {\n  fixed?: boolean\n}\n\nexport type NodePositions = Record<string, FixablePosition>\n\nexport interface Layouts {\n  nodes: NodePositions\n}\n/** for User Specified */\nexport type UserLayouts = RecursivePartial<Layouts>\n\n/* ------------------------------------------ *\n * Edge labels\n * ------------------------------------------ */\n\nexport interface EdgePosition {\n  source: Position\n  target: Position\n}\n\nexport interface EdgeLabelArea {\n  source: {\n    above: Position\n    below: Position\n  }\n  target: {\n    above: Position\n    below: Position\n  }\n}\n\n/* ------------------------------------------ *\n * Paths\n * ------------------------------------------ */\n\nexport interface Path {\n  id?: string\n  edges: string[]\n  // any properties\n  [x: string]: any\n}\n\nexport type Paths = Record<string, Path>\n\n// When specified in a list, the ID is not needed for a while to\n// keep compatibility.\n// TODO: After a while, remove `| Path[]`.\nexport type InputPaths = Record<string, Path> | Path[]\n\n// line: point | curve: [control-point, control-point, target-point] | \"arc\" | move to next point: null\nexport type PositionOrCurve = Position | Position[] | string | null\n\n/* ------------------------------------------ *\n * Events\n * ------------------------------------------ */\n\nexport type ViewEvent<T extends Event> = { event: T }\nexport type NodeEvent<T extends Event> = { node: string; event: T }\nexport type EdgeEvent<T extends Event> =\n  | { edge: string; edges: string[]; summarized: false; event: T }\n  | { edge?: undefined; edges: string[]; summarized: true; event: T }\nexport type PathEvent<T extends Event> = { path: string; event: T }\n\n// For compatibility with previous versions\nexport type NodePointerEvent = NodeEvent<PointerEvent>\nexport type EdgePointerEvent = EdgeEvent<PointerEvent>\n\nexport type Events = {\n  \"view:load\": undefined\n  \"view:unload\": undefined\n  \"view:mode\": ViewMode\n  \"view:zoom\": number\n  \"view:pan\": { x: number; y: number }\n  \"view:fit\": undefined\n  \"view:resize\": { x: number; y: number; width: number; height: number }\n  \"view:click\": ViewEvent<MouseEvent>\n  \"view:dblclick\": ViewEvent<MouseEvent>\n  \"view:contextmenu\": ViewEvent<MouseEvent>\n  \"node:click\": NodeEvent<MouseEvent>\n  \"node:dblclick\": NodeEvent<MouseEvent>\n  \"node:pointerover\": NodeEvent<PointerEvent>\n  \"node:pointerout\": NodeEvent<PointerEvent>\n  \"node:pointerup\": NodeEvent<PointerEvent>\n  \"node:pointerdown\": NodeEvent<PointerEvent>\n  \"node:contextmenu\": NodeEvent<MouseEvent>\n  \"node:dragstart\": { [name: string]: Position }\n  \"node:pointermove\": { [name: string]: Position }\n  \"node:dragend\": { [name: string]: Position }\n  \"node:select\": string[]\n  \"edge:pointerup\": EdgeEvent<PointerEvent>\n  \"edge:pointerdown\": EdgeEvent<PointerEvent>\n  \"edge:click\": EdgeEvent<MouseEvent>\n  \"edge:dblclick\": EdgeEvent<MouseEvent>\n  \"edge:pointerover\": EdgeEvent<PointerEvent>\n  \"edge:pointerout\": EdgeEvent<PointerEvent>\n  \"edge:contextmenu\": EdgeEvent<MouseEvent>\n  \"edge:select\": string[]\n  \"path:select\": string[]\n  \"path:pointerup\": PathEvent<PointerEvent>\n  \"path:pointerdown\": PathEvent<PointerEvent>\n  \"path:click\": PathEvent<MouseEvent>\n  \"path:dblclick\": PathEvent<MouseEvent>\n  \"path:pointerover\": PathEvent<PointerEvent>\n  \"path:pointerout\": PathEvent<PointerEvent>\n  \"path:contextmenu\": PathEvent<MouseEvent>\n}\n\nexport type EventHandlers = {\n  \"*\"?: <T extends keyof Events>(type: T, event: Events[T]) => void\n} & {\n  [K in keyof Events]?: (event: Events[K]) => void\n}\n\nexport type OnClickHandler = (param: NodeEvent<MouseEvent>) => void\nexport type OnDragHandler = (param: { [name: string]: Position }) => void\n\n/* ------------------------------------------ *\n * SVG area\n * ------------------------------------------ */\n\nexport interface Point {\n  x: number\n  y: number\n}\n\nexport interface Sizes {\n  width: number\n  height: number\n  viewBox: {\n    x: number\n    y: number\n    width: number\n    height: number\n  }\n}\n","import { isReactive, reactive } from \"vue\"\n\n/* ------------------------------------------ *\n * Utility\n * ------------------------------------------ */\n\nexport type RecursivePartial<T> = {\n  [P in keyof T]?: T[P] extends (infer U)[]\n    ? RecursivePartial<U>[]\n    : T[P] extends (infer U)[] | undefined\n    ? RecursivePartial<U>[]\n    : // eslint-disable-next-line @typescript-eslint/ban-types\n    T[P] extends object\n    ? RecursivePartial<T[P]>\n    : // eslint-disable-next-line @typescript-eslint/ban-types\n    T[P] extends object | undefined\n    ? RecursivePartial<T[P]>\n    : T[P]\n}\n\ndeclare class Id<T extends string> {\n  private IDENTITY: T\n}\n\nexport type Reactive<T> = Id<\"Reactive\"> & T\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function Reactive<T extends object>(value: T): Reactive<T> {\n  if (isReactive(value)) {\n    return value as Reactive<T>\n  } else {\n    return reactive(value) as Reactive<T>\n  }\n}\n\nexport interface ReadonlyRef<T> {\n  readonly value: T\n}\n\nexport function nonNull<T>(val?: T | null, name = \"Parameter\"): T {\n  if (val === undefined || val === null) {\n    throw new Error(`${name} is null`)\n  }\n  return val\n}\n","import { provide, inject, InjectionKey, Ref } from \"vue\"\nimport { SvgPanZoomInstance } from \"@/modules/svg-pan-zoom-ex\"\nimport { nonNull } from \"@/common/common\"\n\ninterface ProvideContainers {\n  container: Ref<HTMLDivElement>\n  svg: Ref<SVGElement>\n  viewport: Ref<SVGGElement>\n  svgPanZoom: Ref<SvgPanZoomInstance | undefined>\n}\n\ninterface Containers {\n  container: Ref<HTMLDivElement | undefined>\n  svg: Ref<SVGElement | undefined>\n  viewport: Ref<SVGGElement | undefined>\n  svgPanZoom: Ref<SvgPanZoomInstance | undefined>\n}\n\nconst containersKey = Symbol(\"containers\") as InjectionKey<Containers>\n\nexport function provideContainers(containers: Containers): void {\n  provide(containersKey, containers)\n}\n\nexport function useContainers(): ProvideContainers {\n  const containers = nonNull(inject(containersKey), \"containers\")\n  return {\n    container: containers.container as Ref<HTMLDivElement>,\n    svg: containers.svg as Ref<SVGElement>,\n    viewport: containers.viewport as Ref<SVGGElement>,\n    svgPanZoom: containers.svgPanZoom\n  }\n}\n","import { SvgPanZoomInstance } from \"@/modules/svg-pan-zoom-ex\"\nimport { LayoutHandler } from \"../layouts/handler\"\nimport { RecursivePartial } from \"./common\"\nimport { Edge, Edges, LayerName, Node, Path, Position } from \"./types\"\n\ntype CallableValue<V, T> = V | ((target: T) => V)\n\ntype CallableValues<V, T> = {\n  [K in keyof V]: CallableValue<V[K], T>\n}\n\nexport class Config {\n  static value<V, T>(value: CallableValue<V, T>, target: T): V {\n    return value instanceof Function ? value(target) : value\n  }\n\n  static values<V, T>(value: CallableValues<V, T>, target: T): V {\n    if (Object.values(value).filter(v => v instanceof Function).length === 0) {\n      return value as V // all config are literals\n    }\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, v instanceof Function ? v(target) : v])\n    ) as V\n  }\n}\n\n/* View configuration */\n\nexport interface GridLine {\n  color: string\n  width: number\n  dasharray?: string | number\n}\n\nexport interface GridConfig {\n  visible: boolean\n  interval: number\n  thickIncrements: number | false\n  line: GridLine\n  thick: GridLine\n}\n\nexport interface BasicShapeStyle {\n  strokeWidth: number\n  strokeColor?: string\n  strokeDasharray?: string | number\n  color: string\n}\n\nexport interface ViewConfig {\n  scalingObjects: boolean\n  panEnabled: boolean\n  zoomEnabled: boolean\n  minZoomLevel: number\n  maxZoomLevel: number\n  doubleClickZoomEnabled: boolean\n  mouseWheelZoomEnabled: boolean\n  boxSelectionEnabled: boolean\n  fit?: boolean // Deprecated\n  autoPanAndZoomOnLoad: false | \"center-zero\" | \"center-content\" | \"fit-content\"\n  autoPanOnResize: boolean\n  layoutHandler: LayoutHandler\n  onSvgPanZoomInitialized?: (instance: SvgPanZoomInstance) => void\n  grid: GridConfig\n  selection: {\n    box: BasicShapeStyle\n    detector: (event: KeyboardEvent) => boolean\n  }\n  builtInLayerOrder: Readonly<LayerName[]>\n  onBeforeInitialDisplay?: (() => Promise<any>) | (() => any)\n}\n\n/* Shape style */\n\nexport type ShapeStyleBase = BasicShapeStyle\n\nexport type ShapeType = \"circle\" | \"rect\"\n\ninterface CircleShape extends ShapeStyleBase {\n  radius: number\n}\n\ninterface RectangleShape extends ShapeStyleBase {\n  width: number\n  height: number\n  borderRadius: number\n}\n\n// `Shape` is an object whose fields can change depending on\n// the type value.\n// Normally, Union Types would be used, but in order to minimize\n// the use of type guards when users build and use the configuration,\n// we define it as an object that contains all fields.\n\ntype ShapeBase<T extends ShapeType = ShapeType> = {\n  type: T\n}\n\nexport type ShapeStyle = ShapeBase & CircleShape & RectangleShape\nexport type CircleShapeStyle = ShapeBase<\"circle\"> & CircleShape\nexport type RectangleShapeStyle = ShapeBase<\"rect\"> & RectangleShape\nexport type AnyShapeStyle = CircleShapeStyle | RectangleShapeStyle\n\n/* Label style */\n\ninterface Padding {\n  vertical: number\n  horizontal: number\n}\nexport interface LabelBackgroundStyle {\n  visible: boolean\n  color?: string\n  padding?: number | Padding\n  borderRadius?: number\n}\n\nexport interface LabelStyle {\n  fontFamily?: string\n  fontSize: number\n  color: string\n  background?: LabelBackgroundStyle\n  lineHeight: number\n}\n\n/* Z-Order config */\n\nexport interface ZOrderConfig<T> {\n  enabled: boolean\n  zIndex: CallableValue<number, T>\n  bringToFrontOnHover: boolean\n  bringToFrontOnSelected: boolean\n}\n\n/* Object common config */\n\nexport interface ObjectConfigs<O> {\n  selectable: CallableValue<boolean, O> | number\n  zOrder: ZOrderConfig<O>\n}\n\n/* Node style */\n\nexport enum NodeLabelDirection {\n  CENTER = \"center\",\n  NORTH = \"north\",\n  NORTH_EAST = \"north-east\",\n  EAST = \"east\",\n  SOUTH_EAST = \"south-east\",\n  SOUTH = \"south\",\n  SOUTH_WEST = \"south-west\",\n  WEST = \"west\",\n  NORTH_WEST = \"north-west\",\n}\n\nexport type NodeLabelDirectionType =\n  | \"center\"\n  | \"north\"\n  | \"north-east\"\n  | \"east\"\n  | \"south-east\"\n  | \"south\"\n  | \"south-west\"\n  | \"west\"\n  | \"north-west\"\n\nexport interface OppositeNode {\n  nodeId: string\n  pos: Position\n}\n\n// { edgeId: { nodeId, pos } }\nexport type OppositeNodes = Record<string, OppositeNode>\n\nexport interface NodeLabelDirectionHandlerParams {\n  nodeId: string\n  pos: Position\n  oppositeNodes: OppositeNodes\n}\n\nexport type NodeLabelDirectionAutoAdjustmentHandler = (\n  params: NodeLabelDirectionHandlerParams\n) => NodeLabelDirectionType | null\n\nexport interface NodeLabelStyle extends LabelStyle {\n  visible: boolean\n  margin: number\n  direction: NodeLabelDirectionType\n  directionAutoAdjustment: boolean | NodeLabelDirectionAutoAdjustmentHandler\n  text: string\n  handleNodeEvents: boolean\n}\n\nexport interface NodeFocusRingStyle {\n  visible: boolean\n  width: number\n  padding: number\n  color: string\n  dasharray?: string | number\n}\n\nexport interface NodeConfig<N extends Node = Node> {\n  normal: CallableValues<ShapeStyle, N>\n  hover?: CallableValues<ShapeStyle, N>\n  selected?: CallableValues<ShapeStyle, N>\n  draggable: CallableValue<boolean, N>\n  selectable: CallableValue<boolean, N> | number\n  label: CallableValues<NodeLabelStyle, N>\n  focusring: NodeFocusRingStyle\n  zOrder: ZOrderConfig<N>\n  transition?: string\n}\n\n/* Edge style */\n\nexport interface StrokeStyle {\n  width: number\n  color: string\n  dasharray?: string | number\n  linecap?: \"butt\" | \"round\" | \"square\"\n  animate: boolean\n  animationSpeed: number\n}\n\nexport interface EdgeLabelStyle extends LabelStyle {\n  margin: number\n  padding: number\n}\n\nexport type EdgeHeadType = \"none\" | \"arrow\" | \"angle\" | \"circle\" | \"custom\"\nexport type MarkerUnits = \"strokeWidth\" | \"userSpaceOnUse\"\n\nexport interface MarkerStyle {\n  type: EdgeHeadType\n  width: number\n  height: number\n  margin: number\n  offset: number\n  units: MarkerUnits\n  color: string | null\n  customId?: string\n}\n\nexport type EdgeType = \"straight\" | \"curve\"\n\n// Orientation to be considered when keeping multiple edge alignments.\n//   \"clock\": Keep the forward/backward when viewed as a clock.\n//   \"vertical\": Keep the vertical alignment.\n//   \"horizontal\": Keep the horizontal alignment.\nexport type EdgeKeepOrderType = \"clock\" | \"vertical\" | \"horizontal\"\n\nexport interface SelfLoopEdgeStyle {\n  radius: number\n  offset: number\n  angle: number\n  isClockwise: boolean\n}\n\nexport interface EdgeConfig<E extends Edge = Edge> {\n  normal: CallableValues<StrokeStyle, E>\n  hover?: CallableValues<StrokeStyle, E>\n  selected: CallableValues<StrokeStyle, E>\n  selectable: CallableValue<boolean, E> | number\n  gap: number | ((edges: Edges, configs: Configs) => number)\n  type: EdgeType\n  marker: {\n    source: CallableValues<MarkerStyle, [E, StrokeStyle]>\n    target: CallableValues<MarkerStyle, [E, StrokeStyle]>\n  }\n  margin: number | null\n  summarize: boolean | ((edges: Edges, configs: Configs) => boolean | null)\n  summarized: {\n    label: CallableValues<LabelStyle, Record<string, E>>\n    shape: CallableValues<ShapeStyle, Record<string, E>>\n    stroke: CallableValues<StrokeStyle, Record<string, E>>\n  }\n  selfLoop: CallableValues<SelfLoopEdgeStyle, E>\n  keepOrder: EdgeKeepOrderType\n  label: CallableValues<EdgeLabelStyle, E>\n  zOrder: ZOrderConfig<E>\n}\n\n/* Path config */\nexport interface PathStrokeStyle extends StrokeStyle {\n  linejoin: \"miter\" | \"round\" | \"bevel\"\n}\n\nexport type PathEndType = \"centerOfNode\" | \"edgeOfNode\"\n\nexport interface PathConfig<P extends Path = Path> {\n  visible: boolean\n  clickable: CallableValue<boolean, P>\n  hoverable: CallableValue<boolean, P>\n  curveInNode: boolean\n  end: PathEndType\n  margin: CallableValue<number, P>\n\n  // @Deprecated\n  path: CallableValues<PathStrokeStyle, P>\n\n  normal: CallableValues<PathStrokeStyle, P>\n  hover?: CallableValues<PathStrokeStyle, P>\n  selected: CallableValues<PathStrokeStyle, P>\n\n  selectable: CallableValue<boolean, P> | number\n  zOrder: ZOrderConfig<P>\n  transition?: string\n}\n\n/* Configuration */\n\nexport interface Configs<N extends Node = Node, E extends Edge = Edge, P extends Path = Path> {\n  view: ViewConfig\n  node: NodeConfig<N>\n  edge: EdgeConfig<E>\n  path: PathConfig<P>\n}\n\n/** For specification by the user */\nexport type UserConfigs<\n  N extends Node = Node,\n  E extends Edge = Edge,\n  P extends Path = Path\n> = RecursivePartial<Configs<N, E, P>>\n\n/** Make a config with self object */\nexport function withSelf<T extends { [name: string]: any }>(callback: (self: T) => T): T {\n  const self = {} as T\n  return Object.assign(self, callback(self))\n}\n\n/** @deprecated */\nexport function configsWithType<\n  N extends Node = Node,\n  E extends Edge = Edge,\n  P extends Path = Path,\n  U extends UserConfigs<N, E, P> = UserConfigs<N, E, P>\n>(configs: U): U & UserConfigs<N, E, P> {\n  return configs\n}\n\n/** Define configurations */\nexport function defineConfigs<\n  N extends Node = Node,\n  E extends Edge = Edge,\n  P extends Path = Path,\n  U extends UserConfigs<N, E, P> = UserConfigs<N, E, P>\n>(configs: U): U & UserConfigs<N, E, P> {\n  return configs\n}\n","import { Node, Position, Size } from \"@/common/types\"\nimport { Config, NodeConfig, StrokeStyle } from \"@/common/configs\"\n\nexport function getNodeSize(node: Node, style: NodeConfig, scale: number): Size {\n  const shape = Config.values(style.normal, node)\n  if (shape.type == \"circle\") {\n    return {\n      width: shape.radius * 2 * scale,\n      height: shape.radius * 2 * scale,\n    }\n  } else {\n    return {\n      width: shape.width * scale,\n      height: shape.height * scale,\n    }\n  }\n}\n\nexport function areNodesCollision(\n  nodePos: Position,\n  nodeSize: Size,\n  targetNodePos: Position,\n  targetNodeSize: Size\n): boolean {\n  // x方向の衝突チェック\n  const distanceX = Math.abs(nodePos.x - targetNodePos.x)\n  const collisionX = distanceX < nodeSize.width / 2 + targetNodeSize.width / 2\n\n  // y方向の衝突チェック\n  const distanceY = Math.abs(nodePos.y - targetNodePos.y)\n  const collisionY = distanceY < nodeSize.height / 2 + targetNodeSize.height / 2\n  return collisionX && collisionY\n}\n\nexport function applyScaleToDasharray(dasharray: number | string | undefined, scale: number) {\n  let result: number | string = 0\n  if (scale === 1 || dasharray === undefined || dasharray === \"none\") {\n    result = dasharray ?? 0\n  } else if (typeof dasharray === \"string\") {\n    result = dasharray\n      .split(/\\s+/)\n      .map(v => parseInt(v) * scale)\n      .filter(v => !isNaN(v))\n      .join(\" \")\n  } else {\n    result = dasharray * scale\n  }\n  return result && result !== \"0\" ? result : undefined\n}\n\nexport function getDasharrayUnit(dasharray: number | string | undefined) {\n  let result: number | string = 0\n  if (dasharray === undefined || dasharray === \"none\") {\n    result = 0\n  } else if (typeof dasharray === \"string\") {\n    const array = dasharray\n      .split(/\\s+/)\n      .map(v => parseInt(v))\n      .filter(v => !isNaN(v))\n    if (array.length % 2 === 0) {\n      // ex: 1 2 -> -  -  -  - ...\n      result = array.reduce((s, n) => s + n, 0)\n    } else {\n      // ex: 1 2 3 -> -  --- --   -  --- ...\n      result = array.reduce((s, n) => s + n, 0) * 2\n    }\n  } else {\n    result = dasharray * 2 // 2 <- border and space\n  }\n  return result\n}\n\nexport function getAnimationSpeed(key: string, config: StrokeStyle, scale: number): Record<string, number|undefined> {\n  const speed = config.animate\n    ? getDasharrayUnit(config.dasharray) * config.animationSpeed * scale\n    : undefined\n  return {[key]: speed}\n}\n","import { Ref, toRef, watch } from \"vue\"\nimport { isEqual, round } from \"lodash-es\"\nimport { NodePositions, OnDragHandler, Position } from \"@/common/types\"\nimport { getNodeSize, areNodesCollision } from \"@/utils/visual\"\nimport { LayoutActivateParameters, LayoutHandler } from \"./handler\"\n\nconst NEW_NODE_POSITION_MARGIN = 20\n\nexport class SimpleLayout implements LayoutHandler {\n  private onDeactivate?: () => void\n\n  activate(parameters: LayoutActivateParameters): void {\n    const { nodePositions, nodes, configs, emitter, scale, svgPanZoom } = parameters\n    const onDrag: OnDragHandler = positions => {\n      for (const [id, pos] of Object.entries(positions)) {\n        const layout = this.getOrCreateNodePosition(nodePositions, id)\n        this.setNodePosition(layout, pos)\n      }\n    }\n\n    const setNewNodePositions = (nodeIds: string[]) => {\n      // decide new node's position\n      const newNodes = nodeIds.filter(n => !(n in nodePositions.value))\n      const area = svgPanZoom.getViewArea()\n      const s = scale.value\n      for (const nodeId of newNodes) {\n        const node = nodes.value[nodeId]\n        const nodeSize = getNodeSize(node, configs.node, s)\n        const candidate = { ...area.center }\n        for (;;) {\n          let collision = false\n          for (const [id, pos] of Object.entries(nodePositions.value)) {\n            if (nodeId === id) continue\n            const targetNode = nodes.value[id]\n            if (!targetNode) continue\n            const targetNodeSize = getNodeSize(targetNode, configs.node, s)\n            collision = areNodesCollision(candidate, nodeSize, pos, targetNodeSize)\n            if (collision) {\n              break\n            }\n          }\n          if (collision) {\n            // Slide the width of one node + margin in the horizontal direction.\n            // If it reaches the edge of the display area, it moves downward.\n            candidate.x += nodeSize.width + NEW_NODE_POSITION_MARGIN * s\n            if (candidate.x + nodeSize.width / 2 > area.box.right) {\n              candidate.x = area.center.x\n              candidate.y += nodeSize.height + NEW_NODE_POSITION_MARGIN * s\n            }\n          } else {\n            break\n          }\n        }\n        const layout = this.getOrCreateNodePosition(nodePositions, nodeId)\n        this.setNodePosition(layout, candidate)\n      }\n    }\n\n    setNewNodePositions(Object.keys(nodes.value))\n    const stopNodeWatch = watch(\n      () => isEqual(new Set(Object.keys(nodes.value)), new Set(Object.keys(nodePositions.value))),\n      (equality: boolean) => {\n        if (!equality) setNewNodePositions(Object.keys(nodes.value))\n      }\n    )\n\n    emitter.on(\"node:dragstart\", onDrag)\n    emitter.on(\"node:pointermove\", onDrag)\n    emitter.on(\"node:dragend\", onDrag)\n\n    this.onDeactivate = () => {\n      stopNodeWatch()\n      emitter.off(\"node:dragstart\", onDrag)\n      emitter.off(\"node:pointermove\", onDrag)\n      emitter.off(\"node:dragend\", onDrag)\n    }\n  }\n\n  deactivate(): void {\n    if (this.onDeactivate) {\n      this.onDeactivate()\n    }\n  }\n\n  protected setNodePosition(nodeLayout: Ref<Position>, pos: Position) {\n    nodeLayout.value.x = round(pos.x, 3)\n    nodeLayout.value.y = round(pos.y, 3)\n  }\n\n  private getOrCreateNodePosition(nodePositions: Ref<NodePositions>, node: string) {\n    const layout = toRef(nodePositions.value, node)\n    if (!layout.value) {\n      layout.value = { x: 0, y: 0 }\n    }\n    return layout\n  }\n}\n","import { merge } from \"lodash-es\"\nimport { reactive } from \"vue\"\nimport { SimpleLayout } from \"../layouts/simple\"\nimport { Config, Configs, NodeLabelDirection, UserConfigs, withSelf } from \"./configs\"\nimport { Edge, Edges, Node, Path } from \"./types\"\n\n/**\n * Get all default configs.\n * @returns configs\n */\nexport function getConfigDefaults(): Configs {\n  return {\n    view: {\n      scalingObjects: false,\n      panEnabled: true,\n      zoomEnabled: true,\n      minZoomLevel: 0.1,\n      maxZoomLevel: 64,\n      doubleClickZoomEnabled: true,\n      mouseWheelZoomEnabled: true,\n      boxSelectionEnabled: false,\n      autoPanAndZoomOnLoad: \"center-content\",\n      autoPanOnResize: true,\n      layoutHandler: new SimpleLayout(),\n      onSvgPanZoomInitialized: undefined,\n      grid: {\n        visible: false,\n        interval: 10,\n        thickIncrements: 5,\n        line: {\n          color: \"#e0e0e0\",\n          width: 1,\n          dasharray: 1,\n        },\n        thick: {\n          color: \"#cccccc\",\n          width: 1,\n          dasharray: 0,\n        },\n      },\n      selection: {\n        box: {\n          color: \"#0000ff20\",\n          strokeWidth: 1,\n          strokeColor: \"#aaaaff\",\n          strokeDasharray: 0,\n        },\n        detector: (event: KeyboardEvent) => {\n          const detect = /Mac OS/.test(navigator.userAgent) ? event.metaKey : event.ctrlKey\n          return event.type === \"keydown\" ? detect : !detect\n        },\n      },\n      builtInLayerOrder: [],\n      onBeforeInitialDisplay: undefined,\n    },\n    node: withSelf(self => ({\n      normal: {\n        type: \"circle\",\n        radius: 16,\n        // for rect -->\n        width: 32,\n        height: 32,\n        borderRadius: 4,\n        // <-- for rect\n        color: \"#4466cc\",\n        strokeWidth: 0,\n        strokeColor: \"#000000\",\n        strokeDasharray: 0,\n      },\n      hover: {\n        type: node => Config.value(self.normal.type, node) as any,\n        radius: node => (Config.value(self.normal.radius, node) ?? 0) + 2,\n        width: node => (Config.value(self.normal.width, node) ?? 0) + 2,\n        height: node => (Config.value(self.normal.height, node) ?? 0) + 2,\n        borderRadius: node => Config.value(self.normal.borderRadius, node) ?? 0,\n        strokeWidth: node => Config.value(self.normal.strokeWidth, node),\n        strokeColor: node => Config.value(self.normal.strokeColor, node),\n        strokeDasharray: node => Config.value(self.normal.strokeDasharray, node),\n        color: \"#3355bb\",\n      },\n      selected: undefined,\n      draggable: true,\n      selectable: false,\n      label: {\n        visible: true,\n        fontFamily: undefined,\n        fontSize: 11,\n        lineHeight: 1.1,\n        color: \"#000000\",\n        background: undefined,\n        // background: {\n        //   visible: true,\n        //   color: \"#ffffff\",\n        //   padding: {\n        //     vertical: 1,\n        //     horizontal: 4,\n        //   },\n        //   borderRadius: 2\n        // },\n        margin: 4,\n        direction: NodeLabelDirection.SOUTH,\n        directionAutoAdjustment: false,\n        text: \"name\",\n        handleNodeEvents: true,\n      },\n      focusring: {\n        visible: true,\n        width: 4,\n        padding: 3,\n        color: \"#eebb00\",\n      },\n      zOrder: {\n        enabled: false,\n        zIndex: 0,\n        bringToFrontOnHover: true,\n        bringToFrontOnSelected: true,\n      },\n      transition: undefined,\n    })),\n    edge: withSelf(self => ({\n      normal: {\n        width: 2,\n        color: \"#4466cc\",\n        dasharray: 0,\n        linecap: \"butt\",\n        animate: false,\n        animationSpeed: 50,\n      },\n      hover: {\n        width: edge => Config.value(self.normal.width, edge) + 1,\n        color: \"#3355bb\",\n        dasharray: edge => Config.value(self.normal.dasharray, edge),\n        linecap: edge => Config.value(self.normal.linecap, edge),\n        animate: edge => Config.value(self.normal.animate, edge),\n        animationSpeed: edge => Config.value(self.normal.animationSpeed, edge),\n      },\n      selected: {\n        width: edge => Config.value(self.normal.width, edge) + 1,\n        color: \"#dd8800\",\n        dasharray: edge => {\n          const w = Config.value(self.normal.width, edge)\n          return `${w * 1.5} ${w * 2}`\n        },\n        linecap: edge => Config.value(self.normal.linecap, edge),\n        animate: edge => Config.value(self.normal.animate, edge),\n        animationSpeed: edge => Config.value(self.normal.animationSpeed, edge),\n      },\n      selectable: false,\n      gap: 3,\n      type: \"straight\",\n      marker: {\n        source: {\n          type: \"none\",\n          width: 5,\n          height: 5,\n          margin: -1,\n          offset: 0,\n          units: \"strokeWidth\",\n          color: null,\n        },\n        target: {\n          type: \"none\",\n          width: 5,\n          height: 5,\n          margin: -1,\n          offset: 0,\n          units: \"strokeWidth\",\n          color: null,\n        },\n      },\n      margin: null,\n      summarize: (_edges: Edges, configs: Configs) => {\n        return configs.edge.type == \"curve\" ? false : null\n      },\n      summarized: {\n        label: {\n          fontSize: 10,\n          lineHeight: 1,\n          color: \"#4466cc\",\n        },\n        shape: {\n          type: \"rect\",\n          // for circle -->\n          radius: 6,\n          // <-- for circle\n          width: 12,\n          height: 12,\n          borderRadius: 3,\n          color: \"#ffffff\",\n          strokeWidth: 1,\n          strokeColor: \"#4466cc\",\n          strokeDasharray: undefined,\n        },\n        stroke: {\n          width: 5,\n          color: \"#4466cc\",\n          dasharray: undefined,\n          linecap: undefined,\n          animate: false,\n          animationSpeed: 50,\n        },\n      },\n      selfLoop: {\n        radius: 12,\n        isClockwise: true,\n        offset: 10,\n        angle: 270,\n      },\n      keepOrder: \"clock\",\n      label: {\n        fontFamily: undefined,\n        fontSize: 11,\n        lineHeight: 1.1,\n        color: \"#000000\",\n        background: undefined,\n        // background: {\n        //   visible: true,\n        //   color: \"#ffffff\",\n        //   padding: {\n        //     vertical: 1,\n        //     horizontal: 4,\n        //   },\n        //   borderRadius: 2\n        // },\n        margin: 4,\n        padding: 4,\n      },\n      zOrder: {\n        enabled: false,\n        zIndex: 0,\n        bringToFrontOnHover: true,\n        bringToFrontOnSelected: true,\n      },\n    })),\n    path: withSelf(self => ({\n      visible: false,\n      clickable: false,\n      hoverable: false,\n      curveInNode: false,\n      end: \"centerOfNode\",\n      margin: 0,\n      // @Deprecated\n      path: reactive({\n        width: 6,\n        color: p => {\n          const list = [\n            \"#d5000088\",\n            \"#c5116288\",\n            \"#aa00ff88\",\n            \"#6200ea88\",\n            \"#304ffe88\",\n            \"#2962ff88\",\n            \"#0091ea88\",\n            \"#00b8d488\",\n            \"#00bfa588\",\n            \"#00c85388\",\n            \"#64dd1788\",\n            \"#aeea0088\",\n            \"#ffd60088\",\n            \"#ffab0088\",\n            \"#ff6d0088\",\n            \"#dd2c0088\",\n          ]\n          const hash = p.edges\n            .map(s =>\n              s.split(\"\").reduce((a, b) => {\n                a = (a << 5) - a + b.charCodeAt(0)\n                return a & a\n              }, 0)\n            )\n            .reduce((a, b) => a + b, 0)\n          return list[Math.abs(hash) % list.length]\n        },\n        dasharray: undefined,\n        linecap: \"round\",\n        linejoin: \"round\",\n        animate: false,\n        animationSpeed: 50,\n      }),\n      normal: {\n        width: path => Config.value(self.path.width, path),\n        color: path => Config.value(self.path.color, path),\n        dasharray: path => Config.value(self.path.dasharray, path),\n        linecap: path => Config.value(self.path.linecap, path),\n        linejoin: path => Config.value(self.path.linejoin, path),\n        animate: path => Config.value(self.path.animate, path),\n        animationSpeed: path => Config.value(self.path.animationSpeed, path),\n      },\n      hover: {\n        width: path => Config.value(self.normal.width, path) + 2,\n        color: path => Config.value(self.normal.color, path),\n        dasharray: path => Config.value(self.normal.dasharray, path),\n        linecap: path => Config.value(self.normal.linecap, path),\n        linejoin: path => Config.value(self.normal.linejoin, path),\n        animate: path => Config.value(self.normal.animate, path),\n        animationSpeed: path => Config.value(self.normal.animationSpeed, path),\n      },\n      selected: {\n        width: path => Config.value(self.normal.width, path) + 2,\n        color: path => Config.value(self.normal.color, path),\n        dasharray: \"6 12\",\n        linecap: path => Config.value(self.normal.linecap, path),\n        linejoin: path => Config.value(self.normal.linejoin, path),\n        animate: path => Config.value(self.normal.animate, path),\n        animationSpeed: path => Config.value(self.normal.animationSpeed, path),\n      },\n      selectable: false,\n      zOrder: {\n        enabled: false,\n        zIndex: 0,\n        bringToFrontOnHover: true,\n        bringToFrontOnSelected: true,\n      },\n      transition: undefined,\n    })),\n  }\n}\n\nexport function getFullConfigs<N extends Node = Node, E extends Edge = Edge, P extends Path = Path>(\n  config?: UserConfigs<N, E, P>\n): Configs {\n  const configs = getConfigDefaults()\n  if (config) {\n    merge(configs, config)\n  }\n  return configs\n}\n","import { inject, InjectionKey, provide, reactive, Ref, watch } from \"vue\"\nimport { isPlainObject, merge, mergeWith } from \"lodash-es\"\nimport { nonNull } from \"@/common/common\"\nimport { Configs, UserConfigs } from \"@/common/configs\"\nimport { getConfigDefaults } from \"@/common/config-defaults\"\n\nconst injectionKey = Symbol(\"style\") as InjectionKey<Configs>\n\nfunction merger(destination: any, source: any) {\n  if (isPlainObject(destination)) {\n    return merge(destination, source)\n  } else {\n    return source // overwrite\n  }\n}\n\nexport function provideConfigs(configs: Ref<UserConfigs>) {\n  const results: Configs = reactive(getConfigDefaults())\n  const styleKeys = Object.keys(results) as (keyof Configs)[]\n  for (const key of styleKeys) {\n    watch(() => configs.value[key], () => {\n      mergeWith(results[key], configs.value[key] || {}, merger)\n    }, { immediate: true, deep: true })\n  }\n\n  provide(injectionKey, results)\n  return results\n}\n\nfunction injectConfig<T extends keyof Configs>(key: T) {\n  return nonNull(inject(injectionKey), `Configs(${key})`)[key]\n}\n\nexport function useAllConfigs() {\n  return nonNull(inject(injectionKey))\n}\n\nexport function useViewConfig() {\n  return injectConfig(\"view\")\n}\n\nexport function useNodeConfig() {\n  return injectConfig(\"node\")\n}\n\nexport function useEdgeConfig() {\n  return injectConfig(\"edge\")\n}\n\nexport function usePathConfig() {\n  return injectConfig(\"path\")\n}\n","let nextId = 1\n\n/** Generate unique ID in v-network-graph instances */\nexport function useId(): number {\n  return nextId++\n}\n","import { isEqual } from \"lodash-es\"\n\nexport function keyOf<T extends object>(obj: T): (keyof T)[] {\n  return Object.keys(obj) as Array<keyof T>\n}\n\nexport function entriesOf<T extends object, K extends keyof T>(obj: T): [K, T[K]][] {\n  return Object.entries(obj) as [K, T[K]][]\n}\n\nexport function updateObjectDiff<T extends Record<string, any>>(target: T, from: T) {\n  const keys = new Set<keyof T>(Object.keys(target))\n  entriesOf(from).forEach(([key, value]) => {\n    if (!isEqual(target[key], value)) {\n      target[key] = value\n    }\n    keys.delete(key)\n  })\n  keys.forEach(k => delete target[k])\n}\n\nexport function isPromise(obj: any): boolean {\n  return obj instanceof Promise || (obj && typeof obj.then === 'function')\n}\n","import { Ref, watchEffect } from \"vue\"\nimport { Reactive } from \"@/common/common\"\nimport { Edge, Edges, LinePosition, Nodes, Position } from \"@/common/types\"\nimport { Config, Configs, EdgeKeepOrderType } from \"@/common/configs\"\nimport { EdgeGroup, EdgeGroupStates, EdgeLayoutPoint } from \"@/models/edge\"\nimport { updateObjectDiff } from \"@/utils/object\"\n\n// -----------------------------------------------------------------------\n// Type definition\n// -----------------------------------------------------------------------\n\n// -----------------------------------------------------------------------\n// Exported functions\n// -----------------------------------------------------------------------\n\n/**\n * Make the states for edge group.\n * @param nodes nodes\n * @param edges edges\n * @param configs configs\n * @returns the states object for edge group\n */\nexport function makeEdgeGroupStates(\n  nodes: Ref<Nodes>,\n  edges: Ref<Edges>,\n  configs: Readonly<Configs>\n): Reactive<EdgeGroupStates> {\n  // Calculate position map\n  const state = Reactive<EdgeGroupStates>({\n    edgeLayoutPoints: {},\n    edgeGroups: {},\n    summarizedEdges: {},\n  })\n\n  watchEffect(() => {\n    const { edgeLayoutPoints, edgeGroups } = calculateEdgeGroupAndPositions(\n      configs,\n      nodes.value,\n      edges.value\n    )\n    updateObjectDiff(state.edgeLayoutPoints, edgeLayoutPoints)\n    updateObjectDiff(state.edgeGroups, edgeGroups)\n  })\n\n  // calc layout and check summarize\n  watchEffect(() => {\n    const summarizedEdges: Record<string, true> = {}\n    for (const [id, { edges, groupWidth }] of Object.entries(state.edgeGroups)) {\n      let summarize = false\n      if (groupWidth == 0) {\n        summarize = false\n      } else if (configs.edge.summarize instanceof Function) {\n        const s = configs.edge.summarize(edges, configs)\n        if (s === null) {\n          summarize = defaultCheckSummarize(nodes.value, edges, configs, groupWidth)\n        } else {\n          summarize = s\n        }\n      } else if (configs.edge.summarize) {\n        summarize = defaultCheckSummarize(nodes.value, edges, configs, groupWidth)\n      } else {\n        summarize = false\n      }\n      state.edgeGroups[id].summarize = summarize\n      if (summarize) {\n        Object.keys(edges).forEach(id => (summarizedEdges[id] = true))\n      }\n    }\n    updateObjectDiff(state.summarizedEdges, summarizedEdges)\n  })\n\n  return state\n}\n\n/**\n * Calculate the edge position by applying a shift.\n * @param p relative layout information of edges\n * @param isSummarized summarize or not\n * @param source position of source node\n * @param target position of target node\n * @param scale scale factor\n * @param keepOrder edge positional type config\n * @returns the edge position by applying a shift\n */\nexport function calculateEdgeShiftedPosition(\n  p: EdgeLayoutPoint | undefined,\n  isSummarized: boolean,\n  source: Position,\n  target: Position,\n  scale: number,\n  keepOrder: EdgeKeepOrderType\n): LinePosition {\n  if (!p) {\n    return { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } } // sanitized\n  }\n  if (isSummarized) {\n    // summarize\n    return calculateEdgePositionInner(p.edge, source, target, scale, 0, 0, keepOrder)\n  } else {\n    return calculateEdgePositionInner(\n      p.edge,\n      source,\n      target,\n      scale,\n      p.groupWidth,\n      p.pointInGroup,\n      keepOrder\n    )\n  }\n}\n\n// -----------------------------------------------------------------------\n// Private functions\n// -----------------------------------------------------------------------\n\nfunction calculateEdgeGroupAndPositions(configs: Configs, nodes: Nodes, edges: Edges) {\n  const edgeLayoutPoints: Record<string, EdgeLayoutPoint> = {}\n  const edgeGroups: Record<string, EdgeGroup> = {}\n\n  // edges in nodes\n  // const edgesInNodes: Record<string, EdgesInNodes> = {}\n\n  // edge groups between same nodes\n  const map: Record<string, Edges> = {}\n\n  for (const [id, edge] of Object.entries(edges)) {\n    if (!(edge.source in nodes && edge.target in nodes)) {\n      // reject if no node ID is found on the nodes\n      continue\n    }\n    const key = [edge.source, edge.target].sort().join(\"<=>\")\n    const values = map[key] || {}\n    values[id] = edge\n    map[key] = values\n\n    // edgesInNodes[edge.source] ||= {}\n    // edgesInNodes[edge.target] ||= {}\n    // edgesInNodes[edge.source][id] = { opposite: edge.target }\n    // edgesInNodes[edge.target][id] = { opposite: edge.source }\n  }\n\n  // Calculate the following:\n  // - the starting point of each line\n  // - the width between the centers of the lines at both ends\n  // *Note*: the drawing position of the line is the center of the line.\n  const calcGap =\n    configs.edge.gap instanceof Function\n      ? configs.edge.gap\n      : (_e: Edges, _c: Configs) => configs.edge.gap as number\n  for (const [key, edges] of Object.entries(map)) {\n    const edgeLen = Object.keys(edges).length\n    if (edgeLen == 0) continue\n\n    const gap = calcGap(edges, configs)\n    const [edgeId, edge] = Object.entries(edges)[0]\n    if (edgeLen === 1) {\n      edgeLayoutPoints[edgeId] = { edge, pointInGroup: 0, groupWidth: 0 }\n      edgeGroups[key] = { edges, groupWidth: 0, summarize: false }\n    } else {\n      let pointInGroup = 0\n      const lineHalfWidths = Object.entries(edges).map(([id, edge]) => {\n        let width = Config.value(configs.edge.normal.width, edge)\n        if (isNaN(+width)) {\n          console.warn(\n            \"[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]\",\n            id,\n            width\n          )\n          width = 1\n        }\n        return width / 2\n      })\n      const points = Object.entries(edges).map(([edgeId, edge], i) => {\n        if (i > 0) {\n          pointInGroup += lineHalfWidths[i - 1] + gap + lineHalfWidths[i]\n        }\n        return [edgeId, edge, pointInGroup] as [string, Edge, number]\n      })\n      const groupWidth = pointInGroup\n      points.forEach(([edgeId, edge, pointInGroup]) => {\n        edgeLayoutPoints[edgeId] = { edge, pointInGroup, groupWidth }\n      })\n      edgeGroups[key] = { edges, groupWidth, summarize: false }\n    }\n  }\n\n  return { edgeLayoutPoints, edgeGroups }\n}\n\nfunction defaultCheckSummarize(nodes: Nodes, edges: Edges, configs: Configs, width: number) {\n  // aggregate if the edge width and gap width exceed the size of the node\n  const edgeCount = Object.entries(edges).length\n  if (edgeCount === 1) return false\n\n  // const width =\n  //   Object.values(edges)\n  //     .map(e => Config.value(configs.edge.normal.width, e))\n  //     .reduce((sum, v) => sum + v, 0) +\n  //   configs.edge.gap * (edgeCount - 1)\n\n  const minWidth = Math.min(\n    ...Object.values(edges)\n      .flatMap(e => [nodes[e.source], nodes[e.target]])\n      .filter(v => v)\n      .map(node => {\n        const shape = Config.values(configs.node.normal, node)\n        if (shape.type === \"circle\") {\n          return shape.radius * 2\n        } else {\n          return Math.min(shape.width, shape.height)\n        }\n      })\n  )\n  return width > minWidth\n}\n\nfunction calculateEdgePositionInner(\n  edge: Edge,\n  source: Position | undefined,\n  target: Position | undefined,\n  scale: number,\n  groupWidth: number,\n  pointInGroup: number,\n  keepOrder: EdgeKeepOrderType\n): LinePosition {\n  let x1, y1, x2, y2\n  if (edge.source < edge.target) {\n    ;[x1, y1, x2, y2] = calculateLinePosition(\n      source?.x ?? 0,\n      source?.y ?? 0,\n      target?.x ?? 0,\n      target?.y ?? 0,\n      scale,\n      groupWidth,\n      pointInGroup,\n      keepOrder\n    )\n  } else {\n    ;[x2, y2, x1, y1] = calculateLinePosition(\n      target?.x ?? 0,\n      target?.y ?? 0,\n      source?.x ?? 0,\n      source?.y ?? 0,\n      scale,\n      groupWidth,\n      pointInGroup,\n      keepOrder\n    )\n  }\n  return { p1: { x: x1, y: y1 }, p2: { x: x2, y: y2 } }\n}\n\nfunction calculateLinePosition(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  scale: number,\n  groupWidth: number,\n  pointInGroup: number,\n  keepOrder: EdgeKeepOrderType\n): [number, number, number, number] {\n  const dx = x2 - x1\n  const dy = y2 - y1\n\n  // Shifting width from center\n  let diff = (groupWidth / 2 - pointInGroup) * scale\n\n  // Adjust the relative position.\n  if (diff !== 0 && keepOrder !== \"clock\") {\n    const radian = Math.atan2(y2 - y1, x2 - x1)\n    if (keepOrder === \"vertical\") {\n      // Keep the vertical alignment of multiple edges.\n      const perpendicular = Math.PI / 2\n      if (radian < -perpendicular || radian >= perpendicular) {\n        diff *= -1\n      }\n    } else if (keepOrder === \"horizontal\") {\n      // Keep the horizontal alignment of multiple edges.\n      if (radian < 0) {\n        diff *= -1\n      }\n    }\n  }\n\n  if (dx === 0) {\n    const sign = dy < 0 ? -1 : 1\n    return [x1 + diff * sign, y1, x2 + diff * sign, y2]\n  } else if (dy === 0) {\n    const sign = dx < 0 ? 1 : -1\n    return [x1, y1 + diff * sign, x2, y2 + diff * sign]\n  } else {\n    const slope = dy / dx\n    const moveSlope = -1 / slope\n    if (dy < 0) {\n      diff = -diff\n    }\n    const diffX = diff / Math.sqrt(1 + Math.pow(moveSlope, 2))\n    return [x1 + diffX, y1 + diffX * moveSlope, x2 + diffX, y2 + diffX * moveSlope]\n  }\n}\n","import { Point2D } from \"./core\"\n\nexport function add(v1: Point2D, v2: Point2D): Point2D\nexport function add<T extends Point2D>(v1: Point2D, v2: Point2D, target: T): T\nexport function add(v1: Point2D, v2: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v1.x + v2.x\n  target.y = v1.y + v2.y\n  return target\n}\n\nexport function subtract(v1: Point2D, v2: Point2D): Point2D\nexport function subtract<T extends Point2D>(v1: Point2D, v2: Point2D, target: T): T\nexport function subtract(v1: Point2D, v2: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v1.x - v2.x\n  target.y = v1.y - v2.y\n  return target\n}\n\nexport function multiply(v1: Point2D, v2: Point2D): Point2D\nexport function multiply<T extends Point2D>(v1: Point2D, v2: Point2D, target: T): T\nexport function multiply(v1: Point2D, v2: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v1.x * v2.x\n  target.y = v1.y * v2.y\n  return target\n}\n\nexport function multiplyScalar(v: Point2D, scalar: number): Point2D\nexport function multiplyScalar<T extends Point2D>(v: Point2D, scalar: number, target: T): T\nexport function multiplyScalar(v: Point2D, scalar: number, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v.x * scalar\n  target.y = v.y * scalar\n  return target\n}\n\nexport function divide(v1: Point2D, v2: Point2D): Point2D\nexport function divide<T extends Point2D>(v1: Point2D, v2: Point2D, target: T): T\nexport function divide(v1: Point2D, v2: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  target.x = v1.x / v2.x\n  target.y = v1.y / v2.y\n  return target\n}\n\nexport function dot(v1: Point2D, v2: Point2D): number {\n  return v1.x * v2.x + v1.y * v2.y\n}\n\nexport function cross(v1: Point2D, v2: Point2D): number {\n  return v1.x * v2.y - v1.y * v2.x\n}\n\nexport function lengthSquared(v: Point2D): number {\n  return v.x * v.x + v.y * v.y\n}\n\nexport function length(v: Point2D): number {\n  return Math.sqrt(lengthSquared(v))\n}\n\nexport function distanceSquared(v1: Point2D, v2: Point2D): number {\n  const dx = v1.x - v2.x\n  const dy = v1.y - v2.y\n  return dx * dx + dy * dy\n}\n\nexport function distance(v1: Point2D, v2: Point2D): number {\n  return Math.sqrt(distanceSquared(v1, v2))\n}\n\nexport function normalize(v: Point2D): Point2D\nexport function normalize<T extends Point2D>(v: Point2D, target: T): T\nexport function normalize(v: Point2D, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  const len = length(v)\n  if (len === 0) {\n    target.x = 1\n    target.y = 0\n  } else {\n    divide(v, { x: len, y: len }, target)\n  }\n  return target\n}\n\nexport function rotate(v: Point2D, angle: number): Point2D\nexport function rotate<T extends Point2D>(v: Point2D, angle: number, target: T): T\nexport function rotate(v: Point2D, angle: number, target?: Point2D): Point2D {\n  if (!target) {\n    target = { x: 0, y: 0 }\n  }\n  // rotate in radians CCW from +X axis\n  const newX = v.x * Math.cos(angle) - v.y * Math.sin(angle)\n  const newY = v.x * Math.sin(angle) + v.y * Math.cos(angle)\n  target.x = newX\n  target.y = newY\n  return target\n}\n\nconst DEGREES = 180 / Math.PI\n\nfunction rad2deg(rad: number) {\n  return rad * DEGREES\n}\n\nexport function angle(v: Point2D) {\n  return Math.atan2(v.y, v.x)\n}\n\nexport function angleDegree(v: Point2D) {\n  return rad2deg(angle(v))\n}\n","import { Point2D } from \"./core\"\nimport { add, angle, angleDegree, cross, distance, distanceSquared, divide } from \"./methods\"\nimport { dot, length, lengthSquared, multiply, multiplyScalar, normalize } from \"./methods\"\nimport { rotate, subtract } from \"./methods\"\n\nexport class Vector2D implements Point2D {\n  public x: number\n  public y: number\n\n  static fromArray(array: number[]) {\n    return new Vector2D(array[0] || 0, array[1] || 0)\n  }\n\n  static fromObject(obj: Point2D) {\n    return new Vector2D(obj.x, obj.y)\n  }\n\n  constructor(x: number, y: number) {\n    this.x = x\n    this.y = y\n  }\n\n  // instance methods\n  add(v: Point2D): Vector2D {\n    return add(this, v, this)\n  }\n\n  subtract(v: Point2D): Vector2D {\n    return subtract(this, v, this)\n  }\n\n  multiply(v: Point2D): Vector2D {\n    return multiply(this, v, this)\n  }\n\n  multiplyScalar(scalar: number): Vector2D {\n    return multiplyScalar(this, scalar, this)\n  }\n\n  divide(v: Point2D): Vector2D {\n    return divide(this, v, this)\n  }\n\n  dot(v: Point2D): number {\n    return dot(this, v)\n  }\n\n  cross(v: Point2D): number {\n    return cross(this, v)\n  }\n\n  lengthSquared(): number {\n    return lengthSquared(this)\n  }\n\n  length(): number {\n    return length(this)\n  }\n\n  distanceSquared(v: Point2D): number {\n    return distanceSquared(this, v)\n  }\n\n  distance(v: Point2D): number {\n    return distance(this, v)\n  }\n\n  normalize(): Vector2D {\n    return normalize(this, this)\n  }\n\n  angle(): number {\n    return angle(this)\n  }\n\n  angleDegree(): number {\n    return angleDegree(this)\n  }\n\n  rotate(angle: number): Vector2D {\n    return rotate(this, angle, this)\n  }\n\n  isEqualTo(v: Point2D): boolean {\n    return this.x === v.x && this.y === v.y\n  }\n\n  clone(): Vector2D {\n    return new Vector2D(this.x, this.y)\n  }\n\n  toObject(): Point2D {\n    return { x: this.x, y: this.y }\n  }\n\n  toArray(): [number, number] {\n    return [this.x, this.y]\n  }\n}\n","export { Vector2D } from \"./vector2d\"\nexport * from \"./methods\"\n\nimport { Vector2D } from \"./vector2d\"\nimport * as V from \"./methods\"\n\nexport default {\n  Vector2D,\n  ...V\n}\n","import { LinePosition, Position } from \"@/common/types\"\nimport { Vector2D } from \"@/modules/vector2d\"\n\n// ---------------------------\n// Line information by vectors\n// ---------------------------\n\nexport class VectorLine {\n  public source: Vector2D\n  public target: Vector2D\n  public v: Vector2D\n\n  constructor(source: Vector2D, target: Vector2D, v: Vector2D) {\n    this.source = source\n    this.target = target\n    this.v = v\n  }\n\n  static fromLinePosition(line: LinePosition): VectorLine {\n    const source = Vector2D.fromObject(line.p1)\n    const target = Vector2D.fromObject(line.p2)\n    return new VectorLine(source, target, toLineVector(source, target))\n  }\n\n  static fromPositions(sourcePos: Position, targetPos: Position): VectorLine {\n    const source = Vector2D.fromObject(sourcePos)\n    const target = Vector2D.fromObject(targetPos)\n    return new VectorLine(source, target, toLineVector(source, target))\n  }\n\n  static fromVectors(source: Vector2D, target: Vector2D): VectorLine {\n    return new VectorLine(source, target, toLineVector(source, target))\n  }\n}\n\nexport function toLineVector(source: Vector2D, target: Vector2D): Vector2D {\n  return target.clone().subtract(source)\n}\n\nexport function toVectorsFromLinePosition(line: LinePosition): [Vector2D, Vector2D] {\n  return [Vector2D.fromObject(line.p1), Vector2D.fromObject(line.p2)]\n}\n\nexport function getCenterOfLinePosition(line: LinePosition): Vector2D {\n  return new Vector2D((line.p1.x + line.p2.x) / 2, (line.p1.y + line.p2.y) / 2)\n}\n\n// -------------------------------\n// Calculation functions for Lines\n// -------------------------------\n\n/**\n * Convert two `Position` to `LinePosition`\n * @param p1 source position of the line\n * @param p2 target position of the line\n * @returns `LinePosition` instance\n */\n export function toLinePosition(p1: Position, p2: Position): LinePosition {\n  return { p1, p2 }\n}\n\n/**\n * Calculates the line position to which the margin is applied.\n * @param linePos original position of the line\n * @param sourceMargin margin for source side\n * @param targetMargin margin for target side\n * @returns the line position\n */\n export function applyMargin(\n  linePos: LinePosition,\n  sourceMargin: number,\n  targetMargin: number\n): LinePosition {\n  const line = VectorLine.fromLinePosition(linePos)\n  return applyMarginInner(line, sourceMargin, targetMargin)\n}\n\nfunction applyMarginInner(\n  line: VectorLine,\n  sourceMargin: number,\n  targetMargin: number\n): LinePosition {\n  const normalized = line.v.clone().normalize()\n\n  const sv = line.source.clone().add(normalized.clone().multiplyScalar(sourceMargin))\n\n  const tv = line.target.clone().subtract(normalized.clone().multiplyScalar(targetMargin))\n\n  let p1 = sv.toObject()\n  let p2 = tv.toObject()\n\n  const check = toLineVector(sv, tv)\n  if (line.v.angle() * check.angle() < 0) {\n    // reversed\n    const c1 = new Vector2D((p1.x + p2.x) / 2, (p1.y + p2.y) / 2)\n    const c2 = c1.clone().add(normalized.multiplyScalar(0.5))\n    p1 = c1.toObject()\n    p2 = c2.toObject()\n  }\n\n  return { p1, p2 }\n}\n\nexport function inverseLine(line: LinePosition): LinePosition {\n  return { p1: line.p2, p2: line.p1 }\n}\n\nexport function calculatePerpendicularLine(line: VectorLine) {\n  const n1 = line.v\n    .clone()\n    .normalize()\n    .rotate(Math.PI / 2)\n  return VectorLine.fromVectors(line.target, line.target.clone().add(n1))\n}\n","import V, { Vector2D } from \"@/modules/vector2d\"\nimport { VectorLine } from \"./line\"\n\n/**\n * Calculate the nearest point from a point to a line.\n * @param p point\n * @param line line\n * @returns point on the line\n */\nexport function getNearestPoint(p: Vector2D, line: VectorLine): Vector2D {\n  const n = line.v.clone().normalize()\n\n  // Let `a` be a vector from any one point on a line to a point\n  const lp = line.source\n  const a = V.subtract(p, lp)\n\n  // Inner product of `n` and `a`\n  const dot = n.dot(a)\n\n  // The nearest point is the sum of a point on the line and a\n  // vector of n multiplied by dot.\n  const near = lp.clone().add(n.multiplyScalar(dot))\n\n  return near\n}\n\n// /**\n//  * Calculate the distance of nearest point from a point to a line.\n//  * @param p point\n//  * @param line line\n//  * @returns distance\n//  */\n// export function getDistanceToNearestPoint(p: Vector2D, line: VectorLine): number {\n//   const p2 = line.source\n//   const v2 = line.v\n\n//   const v2len = v2.lengthSquared()\n//   if (v2len === 0) {\n//     return 0\n//   }\n//   const t = V.dot(v2, V.subtract(p, p2)) / v2len\n//   const tv2 = V.multiplyScalar(v2, t)\n//   const h = p2.clone().add(tv2)\n//   return h.subtract(p).length()\n// }\n\nexport function getIntersectionOfLineTargetAndCircle(\n  source: Vector2D,\n  target: Vector2D,\n  center: Vector2D,\n  radius: number\n): Vector2D | null {\n  // Does the node contain a point?\n  const length = V.lengthSquared(V.subtract(target, center))\n  const contains = length - radius * radius <= Math.pow(1, -10)\n\n  if (!contains) return null // Not contained.\n\n  // If contained, calculate the intersection point.\n\n  // Find the nearest point `h` between `c` and the line\n  const line = VectorLine.fromVectors(source, target)\n  const h = getNearestPoint(center, line)\n\n  // Let `hp` be the vector from `c` to `h`.\n  const hpLen = V.length(V.subtract(h, center))\n\n  // If `hpLen` is larger than the radius of the circle,\n  // there is no intersection.\n  if (radius < hpLen) return null\n\n  // When a straight line and a circle are tangent, `hpLen` is `r`.\n  // Then the point of contact is the nearest point between the\n  // center and the line.\n  if (radius === hpLen) return h\n\n  // Let `t` be the distance from `h` to the contact point, and\n  // derive t from the Three Square Theorem.\n  const t = Math.sqrt(radius ** 2 - hpLen ** 2)\n\n  // Let `tv` be the vector of the normalized direction vector of\n  // the line multiplied by t\n  // - intersection point 1：p + tv\n  // - intersection point 2：p - tv\n  const tv = line.v.normalize().multiplyScalar(t)\n\n  // Calculate the addition or subtraction depending on which side\n  // of the line to focus on.\n  return h.subtract(tv)\n}\n\nexport function getIntersectionOfLineTargetAndCircle2(\n  source: Vector2D,\n  target: Vector2D,\n  center: Vector2D,\n  radius: number,\n  nearBy: Vector2D\n): Vector2D | null {\n  // Does the node contain a point?\n  const length = V.lengthSquared(V.subtract(target, center))\n  const contains = length - radius * radius <= Math.pow(1, -10)\n\n  if (!contains) return null // Not contained.\n\n  // If contained, calculate the intersection point.\n\n  // Find the nearest point `h` between `c` and the line\n  const line = VectorLine.fromVectors(source, target)\n  const h = getNearestPoint(center, line)\n\n  // Let `hp` be the vector from `c` to `h`.\n  const hpLen = V.length(V.subtract(h, center))\n\n  // If `hpLen` is larger than the radius of the circle,\n  // there is no intersection.\n  if (radius < hpLen) return null\n\n  // When a straight line and a circle are tangent, `hpLen` is `r`.\n  // Then the point of contact is the nearest point between the\n  // center and the line.\n  if (radius === hpLen) return h\n\n  // Let `t` be the distance from `h` to the contact point, and\n  // derive t from the Three Square Theorem.\n  const t = Math.sqrt(radius ** 2 - hpLen ** 2)\n\n  // Let `tv` be the vector of the normalized direction vector of\n  // the line multiplied by t\n  // - intersection point 1：p + tv\n  // - intersection point 2：p - tv\n  const tv = line.v.normalize().multiplyScalar(t)\n  const ip1 = h.clone().add(tv)\n  const ip2 = h.clone().subtract(tv)\n\n  const d1 = nearBy.distance(ip1)\n  const d2 = nearBy.distance(ip2)\n\n  if (Math.abs(d1 - d2) < 2) {\n    // Calculate the addition or subtraction depending on which side\n    // of the line to focus on.\n    return ip2\n  }\n\n  return d1 < d2 ? ip1 : ip2\n}\n\n/**\n * Calculate the intersection of two lines.\n * @param line1 line 1\n * @param line2 line 2\n * @returns intersection point\n */\nexport function getIntersectionPointOfLines(line1: VectorLine, line2: VectorLine): Vector2D {\n  const v = V.subtract(line2.source, line1.source)\n\n  const v1 = line1.v\n  const v2 = line2.v\n\n  const t2 = V.cross(v, v1) / V.cross(v1, v2)\n\n  return line2.source.clone().add(v2.clone().multiplyScalar(t2))\n}\n\nexport function getIntersectionOfCircles(\n  center1: Vector2D,\n  radius1: number,\n  center2: Vector2D,\n  radius2: number,\n  near: Vector2D\n): Vector2D | null\nexport function getIntersectionOfCircles(\n  center1: Vector2D,\n  radius1: number,\n  center2: Vector2D,\n  radius2: number\n): [Vector2D, Vector2D] | null\nexport function getIntersectionOfCircles(\n  center1: Vector2D,\n  radius1: number,\n  center2: Vector2D,\n  radius2: number,\n  near?: Vector2D\n): Vector2D | [Vector2D, Vector2D] | null {\n  const c1 = center1\n  const c2 = center2\n\n  // vector of C1-->C2\n  const vC1C2 = c2.clone().subtract(c1)\n\n  // length of C1--C2\n  const a = vC1C2.length()\n\n  const sumR = radius1 + radius2\n  if (sumR < a) return null // no overlap\n\n  // When a circle is contained, there is no contact point.\n  const subR = Math.abs(radius1 - radius2)\n  if (a < subR) return null\n\n  // When the circles are circumscribed, [a] and the sum of\n  // radius of two circles are equal. And there is only one\n  // contact point.\n  if (a === sumR) {\n    const n = vC1C2.clone().normalize()\n    const p = center1.clone().add(n.multiplyScalar(radius1))\n    return near ? p : [p , p]\n  }\n\n  // When the circles are inscribed, [a] and the difference\n  // between the radius of two circles are equal. And there\n  // is only one point of contact.\n  if (a === subR) {\n    const n = vC1C2.clone().normalize()\n    const isLarge = radius1 > radius2\n    // Let [P] be the contact point:\n    // * C1 is larger : P = C1 + r1 * n\n    // * C1 is smaller: P = C1 - r1 * n\n    const p = center1.clone().add(n.multiplyScalar(isLarge ? radius1 : -radius1))\n    return near ? p : [p , p]\n  }\n\n  // All three sides of triangle C1C2P are known.\n  // [b] := length of C1--P\n  // [c] := length of C2--P\n  const b = radius1\n  const c = radius2\n\n  // The cos θ of angle C1 is given by the cosine theorem:\n  const cos = (a ** 2 + b ** 2 - c ** 2) / (2 * a * b)\n\n  // Let [H] be the point where the vertical line from [P] to\n  // C1--C2 is dropped, and let [rc] be the length of C1--H.\n  const rc = b * cos\n\n  // Let the length of the H--P be [rs]\n  const rs = Math.sqrt(b ** 2 - rc ** 2)\n\n  // normalized vector of vC1C2\n  const n1 = vC1C2.clone().normalize()\n\n  // vector with n1 rotated 90 degrees to the left\n  const n2 = new Vector2D(-n1.y, n1.x)\n\n  // The point of intersection [P]\n  // P  = C1 + tn1 + sn2\n  // P' = C1 + tn1 - sn2\n  const tn1 = n1.clone().multiplyScalar(rc)\n  const sn2 = n2.clone().multiplyScalar(rs)\n\n  const result1 = center1.clone().add(tn1).add(sn2)\n  const result2 = center1.clone().add(tn1).subtract(sn2)\n\n  if (near) {\n    const d1 = result1.distance(near)\n    const d2 = result2.distance(near)\n    return d1 < d2 ? result1 : result2\n  } else {\n    return [result1, result2]\n  }\n}\n","import { AnyShapeStyle, RectangleShapeStyle, StrokeStyle } from \"@/common/configs\"\nimport { EdgeLabelArea, LinePosition, Position } from \"@/common/types\"\nimport V, { Vector2D } from \"@/modules/vector2d\"\nimport * as PointUtils from \"./point\"\nimport * as LineUtils from \"./line\"\nimport { VectorLine } from \"./line\"\n\n// /**\n//  * Calculate whether a point is contained in a circle.\n//  * @param point point\n//  * @param center center of the circle\n//  * @param radius radius of the circle\n//  * @returns whether point is contained in a circle\n//  */\n// export function isPointContainedInCircle(\n//   point: Position,\n//   center: Position,\n//   radius: number\n// ): boolean {\n//   const p = Vector2D.fromObject(point)\n//   const c = Vector2D.fromObject(center)\n//   const v = p.subtract(c)\n//   return v.lengthSquared() < radius * radius\n// }\n\n// /**\n//  * Calculate the distance of the line.\n//  * @param line line\n//  * @returns distance\n//  */\n// export function calculateDistance(line: LinePosition): number {\n//   return V.distance(line.p1, line.p2)\n// }\n\n/**\n * Get the distance that a line should be away from the\n * edge to avoid contacting a rounded rectangle.\n * @param sourcePos source position of the line\n * @param targetPos target position of the line\n * @param rect rectangle style\n * @param scale scale factor\n * @returns distance from target position\n */\nfunction calculateDistanceToAvoidOverlapsWithRect(\n  sourcePos: Position,\n  targetPos: Position, // position of the target rounded rectangle\n  rect: RectangleShapeStyle,\n  scale: number\n) {\n  const centerLine = VectorLine.fromPositions(sourcePos, targetPos)\n  const halfWidth = ((rect.width + rect.strokeWidth) / 2) * scale\n  const halfHeight = ((rect.height + rect.strokeWidth) / 2) * scale\n\n  const borderRadius =\n    rect.borderRadius > 0 ? (rect.borderRadius + rect.strokeWidth / 2) * scale : 0\n\n  // check whether it crosses over the vertical or horizontal boundary\n  const angleVRad = (centerLine.v.angle() - Math.PI / 2) % Math.PI\n  const angleHRad = Math.PI / 2 - (angleVRad % Math.PI)\n  const w = halfHeight * Math.abs(Math.tan(angleVRad))\n  const h = halfWidth * Math.abs(Math.tan(angleHRad))\n  const isCrossedVLine = w <= halfWidth - borderRadius\n  const isCrossedHLine = h <= halfHeight - borderRadius\n  if (isCrossedVLine || isCrossedHLine || borderRadius === 0) {\n    if (isCrossedVLine) {\n      return Math.sqrt(halfHeight ** 2 + w ** 2)\n    } else {\n      return Math.sqrt(halfWidth ** 2 + h ** 2)\n    }\n  } else {\n    // on the border radius: calculate the center of circles\n    const left = targetPos.x - halfWidth + borderRadius\n    const top = targetPos.y - halfHeight + borderRadius\n    const right = targetPos.x + halfWidth - borderRadius\n    const bottom = targetPos.y + halfHeight - borderRadius\n    const vertexes = [\n      new Vector2D(left, top),\n      new Vector2D(right, top),\n      new Vector2D(right, bottom),\n      new Vector2D(left, bottom),\n    ]\n    const index = Math.floor(((centerLine.v.angleDegree() + 360) % 360) / 90)\n    const centerOfNearestCircle = vertexes[index]\n    const point = PointUtils.getIntersectionOfLineTargetAndCircle(\n      centerLine.source,\n      PointUtils.getNearestPoint(centerOfNearestCircle, centerLine),\n      centerOfNearestCircle,\n      borderRadius\n    )\n    return point\n      ? LineUtils.toLineVector(point, centerLine.target).length()\n      : LineUtils.toLineVector(centerOfNearestCircle, centerLine.target).length() + borderRadius\n  }\n}\n\n/**\n * Calculate the position to display the edge label from the\n * positions of the edge.\n * @param linePos line segment between the outermost of the nodes\n * @param edgeStyle stroke style of edges\n * @param margin margin from line\n * @param padding padding from outside\n * @param scale scale factor\n * @returns edge label display area\n */\nexport function calculateEdgeLabelArea(\n  linePos: LinePosition,\n  edgeStyle: StrokeStyle,\n  margin: number,\n  padding: number,\n  scale: number\n): EdgeLabelArea {\n  // the line segment between the outermost of the nodes\n  const line = VectorLine.fromLinePosition(linePos)\n  const normalized = line.v.clone().normalize()\n\n  // source side\n  const sv =\n    padding === 0\n      ? line.source\n      : line.source.clone().add(normalized.clone().multiplyScalar(padding * scale))\n\n  // target side\n  const tv =\n    padding === 0\n      ? line.target\n      : line.target.clone().subtract(normalized.clone().multiplyScalar(padding * scale))\n\n  // margin for edges\n  const labelMargin = (edgeStyle.width / 2 + margin) * scale\n  const vMargin = new Vector2D(-normalized.y, normalized.x).multiplyScalar(labelMargin)\n  let sourceAbove = V.subtract(sv, vMargin)\n  let sourceBelow = V.add(sv, vMargin)\n  let targetAbove = V.subtract(tv, vMargin)\n  let targetBelow = V.add(tv, vMargin)\n\n  const angle = line.v.angleDegree()\n  if (angle < -90 || angle >= 90) {\n    // upside down\n    ;[sourceAbove, sourceBelow] = [sourceBelow, sourceAbove]\n    ;[targetAbove, targetBelow] = [targetBelow, targetAbove]\n  }\n  return {\n    source: { above: sourceAbove, below: sourceBelow },\n    target: { above: targetAbove, below: targetBelow },\n  }\n}\n\n/**\n * Calculate the distances between center of node and edge of node.\n * @param sourceNodePos position of source node\n * @param targetNodePos position of target node\n * @param sourceNodeShape shape config of source node\n * @param targetNodeShape shape config of target node\n * @returns the distances\n */\nexport function calculateDistancesFromCenterOfNodeToEndOfNode(\n  sourceNodePos: Position,\n  targetNodePos: Position,\n  sourceNodeShape: AnyShapeStyle,\n  targetNodeShape: AnyShapeStyle\n): [number, number] {\n  // source side\n  let distance1: number\n  if (sourceNodeShape.type === \"circle\") {\n    distance1 = sourceNodeShape.radius + (sourceNodeShape.strokeWidth / 2)\n  } else {\n    distance1 = calculateDistanceToAvoidOverlapsWithRect(\n      targetNodePos,\n      sourceNodePos,\n      sourceNodeShape,\n      1 // scale\n    )\n  }\n\n  // target side\n  let distance2: number\n  if (targetNodeShape.type === \"circle\") {\n    distance2 = targetNodeShape.radius + (targetNodeShape.strokeWidth / 2)\n  } else {\n    distance2 = calculateDistanceToAvoidOverlapsWithRect(\n      sourceNodePos,\n      targetNodePos,\n      targetNodeShape,\n      1 // scale\n    )\n  }\n\n  return [distance1, distance2]\n}\n\n/**\n * Calculates the position of a given distance along the circumference.\n * @param pos original position\n * @param center center of the circle\n * @param radian radius of the circle\n * @returns the moved position\n */\nexport function moveOnCircumference(pos: Position, center: Position, radian: number) {\n  const { x, y } = pos\n  const dx = x - center.x\n  const dy = y - center.y\n\n  return {\n    x: dx * Math.cos(radian) - dy * Math.sin(radian) + center.x,\n    y: dx * Math.sin(radian) + dy * Math.cos(radian) + center.y,\n  }\n}\n\n/**\n * Reverse the direction of the angle.\n * @param theta angle\n * @returns reversed angle\n */\nexport function reverseAngleRadian(theta: number): number {\n  if (theta > 0) {\n    return -(Math.PI * 2 - theta)\n  } else {\n    return Math.PI * 2 + theta\n  }\n}\n\nexport function calculateBezierCurveControlPoint(\n  p1: Vector2D,\n  center: Vector2D,\n  p2: Vector2D,\n  theta0: number\n): Vector2D[] {\n  const control: Vector2D[] = []\n  const centerToSource = VectorLine.fromVectors(center, p1)\n  const centerToTarget = VectorLine.fromVectors(center, p2)\n\n  let theta = calculateRelativeAngleRadian(centerToSource, centerToTarget)\n  if (theta0 * theta < 0) {\n    theta = reverseAngleRadian(theta)\n  }\n  const middle = Vector2D.fromObject(moveOnCircumference(p1, center, -theta / 2))\n  const centerToMp = VectorLine.fromVectors(center, middle)\n  const mpTangent = LineUtils.calculatePerpendicularLine(centerToMp)\n\n  const theta1 = calculateRelativeAngleRadian(centerToSource, centerToMp)\n  let tangent = LineUtils.calculatePerpendicularLine(centerToSource)\n  if (Math.abs(theta1) < Math.PI / 2) {\n    const cp = PointUtils.getIntersectionPointOfLines(tangent, mpTangent)\n    control.push(cp)\n  } else {\n    // If greater than 90 degrees, go through the midpoint.\n    const mp = Vector2D.fromObject(moveOnCircumference(middle, center, theta1 / 2))\n    const tangent2 = LineUtils.calculatePerpendicularLine(\n      VectorLine.fromVectors(center, Vector2D.fromObject(mp))\n    )\n    const cp1 = PointUtils.getIntersectionPointOfLines(tangent, tangent2)\n    const cp2 = PointUtils.getIntersectionPointOfLines(tangent2, mpTangent)\n    control.push(cp1, mp, cp2)\n  }\n\n  control.push(middle)\n\n  const theta2 = calculateRelativeAngleRadian(centerToTarget, centerToMp)\n  tangent = LineUtils.calculatePerpendicularLine(centerToTarget)\n  if (Math.abs(theta2) < Math.PI / 2) {\n    const cp = PointUtils.getIntersectionPointOfLines(tangent, mpTangent)\n    control.push(cp)\n  } else {\n    // If greater than 90 degrees, go through the midpoint.\n    const mp = Vector2D.fromObject(moveOnCircumference(middle, center, theta2 / 2))\n    const tangent2 = LineUtils.calculatePerpendicularLine(\n      VectorLine.fromVectors(center, Vector2D.fromObject(mp))\n    )\n    const cp1 = PointUtils.getIntersectionPointOfLines(mpTangent, tangent2)\n    const cp2 = PointUtils.getIntersectionPointOfLines(tangent2, tangent)\n    control.push(cp1, mp, cp2)\n  }\n\n  return control\n}\n\nexport function calculateRelativeAngleRadian(line1: VectorLine, line2: VectorLine) {\n  return Math.atan2(\n    line1.v.y * line2.v.x - line1.v.x * line2.v.y,\n    line1.v.x * line2.v.x + line1.v.y * line2.v.y\n  )\n}\n\nexport function calculateCircleCenterAndRadiusBy3Points(\n  p1: Vector2D,\n  p2: Vector2D,\n  p3: Vector2D\n): [Vector2D, number] {\n  const x1 = p1.x\n  const y1 = p1.y\n  const x2 = p2.x\n  const y2 = p2.y\n  const x3 = p3.x\n  const y3 = p3.y\n  const x12 = x1 - x2\n  const y12 = y1 - y2\n  const x32 = x3 - x2\n  const y32 = y3 - y2\n\n  if ((x12 === 0 && y12 === 0) || (x32 === 0 && y32 === 0)) {\n    // Cannot determine the curve if two or more of the three points are in the same position.\n    return [p1, 0];\n  }\n\n  const x =\n    (y32 * (x12 * (x1 + x2) + y12 * (y1 + y2)) - y12 * (x32 * (x3 + x2) + y32 * (y3 + y2))) /\n    (2 * x12 * y32 - 2 * y12 * x32)\n  const y =\n    (-x32 * (x12 * (x1 + x2) + y12 * (y1 + y2)) + x12 * (x32 * (x3 + x2) + y32 * (y3 + y2))) /\n    (2 * x12 * y32 - 2 * y12 * x32)\n\n  const radius = Math.sqrt(Math.pow(x1 - x, 2) + Math.pow(y1 - y, 2))\n  const center = new Vector2D(x, y)\n  return [center, radius]\n}\n","import { AnyShapeStyle } from \"@/common/configs\"\n\nexport function getNodeRadius(shape: AnyShapeStyle) {\n  if (shape.type == \"circle\") {\n    return shape.radius\n  } else {\n    return Math.min(shape.width, shape.height) / 2\n  }\n}\n","\ntype Args<T> = [...(T | null)[], T]\n\nexport function findFirstNonNull<T>(...values: Args<T>): T {\n  return values.find(v => !!v) as T\n}\n","import { NodePositions, PositionOrCurve } from \"@/common/types\"\nimport { nonNull } from \"@/common/common\"\nimport { NodeStates } from \"@/models/node\"\nimport { EdgeStates, EdgeState } from \"@/models/edge\"\nimport { EdgeLine, EdgeObject, PathState } from \"@/models/path\"\nimport { PathEndType } from \"@/common/configs\"\nimport { findFirstNonNull } from \"@/utils/collection\"\nimport * as v2d from \"@/modules/calculation/2d\"\nimport * as PointUtils from \"@/modules/calculation/point\"\nimport { VectorLine } from \"@/modules/calculation/line\"\nimport * as LineUtils from \"@/modules/calculation/line\"\nimport * as NodeUtils from \"@/modules/node/node\"\nimport V, { Vector2D } from \"@/modules/vector2d\"\n\nconst EPSILON = Number.EPSILON * 100 // 2.2204... x 10‍−‍14.\n\nexport function calculatePathPoints(\n  path: PathState,\n  nodeStates: NodeStates,\n  nodeLayouts: NodePositions,\n  edgeStates: EdgeStates,\n  scale: number,\n  curveInNode: boolean,\n  pathEndType: PathEndType,\n  margin: number\n): PositionOrCurve[] {\n  // The relationship between the source/target of a link and the connection\n  // by path can be different.\n  // Detect node at connection point and determine source/target for the path.\n  const edges = path.edges\n\n  // Edge ID list -> List of Edge locations\n  const directions = path.directions // true: forward, false: reverse\n  const edgePos = edges.map((edge, i) => _getEdgeLine(edge, directions[i], edgeStates[edge.edgeId]))\n\n  // the results\n  const points: (Vector2D[] | Vector2D)[] = []\n\n  let isMarginOverRunStart = false\n  let isMarginOverRunEnd = false\n\n  // ----------------------------------------------------\n  // Determine the starting point.\n  // ----------------------------------------------------\n  {\n    const firstEdge = edgePos[0]\n    let nodeRadius = NodeUtils.getNodeRadius(nodeStates[firstEdge.source].shape) * scale\n    const lineMargin = margin + (pathEndType === \"edgeOfNode\" ? nodeRadius : 0)\n    const nextPoint =\n      lineMargin <= 0\n        ? firstEdge.line.source\n        : _calculateEdgeOfNode(firstEdge, lineMargin, nodeLayouts, true)\n    points.push(nextPoint)\n    nodeRadius = NodeUtils.getNodeRadius(nodeStates[firstEdge.target].shape) * scale\n    if (margin > 0) {\n      const distance = V.distance(firstEdge.line.source, firstEdge.line.target)\n      if (distance <= lineMargin + nodeRadius) {\n        isMarginOverRunStart = true\n      }\n    }\n  }\n\n  // ----------------------------------------------------\n  // Determine transit points.\n  // ----------------------------------------------------\n  const length = edges.length\n  for (let i = 1; i < length; i++) {\n    const prev = edgePos[i - 1]\n    const next = edgePos[i]\n\n    const nodeId = next.source\n    const nodePos = Vector2D.fromObject(nodeLayouts[nodeId] ?? { x: 0, y: 0 })\n\n    // The intersection point of two lines: [X]\n    const crossPoint = _getIntersectionOfLines(prev, next, nodePos)\n\n    // Place another small circle inside the node's circle and\n    // calculate transit points so that the path line is smooth.\n    //   Inner circle: [α] radius: `nodeCoreRadius`\n    //   Node circle : [β] radius: `nodeRadius`\n    const nodeRadius = NodeUtils.getNodeRadius(nodeStates[nodeId].shape) * scale\n    const nodeCoreRadius = Math.max(nodeRadius * (2 / 3), nodeRadius - 4 * scale)\n    const isForwardPrev = _isForward(prev)\n    const isForwardNext = _isForward(next)\n    const prevCoreIp = _getIntersectionOfLineAndNode(prev, nodePos, nodeCoreRadius, isForwardPrev)\n    const nextCoreIp = _getIntersectionOfLineAndNode(next, nodePos, nodeCoreRadius, !isForwardNext)\n    const prevNodeIp = _getIntersectionOfLineAndNode(prev, nodePos, nodeRadius, isForwardPrev)\n    const nextNodeIp = _getIntersectionOfLineAndNode(next, nodePos, nodeRadius, !isForwardNext)\n\n    // ----------------------------------------------------\n    // Calculate transit points in the node.\n    // ----------------------------------------------------\n    let pos: Vector2D | Vector2D[]\n    if (crossPoint) {\n      const d = V.distance(crossPoint, nodePos)\n      if (d < nodeCoreRadius) {\n        // (1) [α] includes [X]:\n        //  * [X]: control point in bezier\n        //  * intersection with [α]: transit point\n        pos = [\n          findFirstNonNull(prevCoreIp, prevNodeIp, prev.line.target),\n          crossPoint,\n          findFirstNonNull(nextCoreIp, nextNodeIp, next.line.source),\n        ]\n      } else if (d <= nodeRadius) {\n        // (2) [β] includes [X]:\n        //  * [X]: control point in bezier\n        let p1: Vector2D, p2: Vector2D\n        if (prevNodeIp && prevCoreIp) {\n          // the prev line intersects [α] and [β]:\n          // Of [α]x[line], [β]x[line], use the one closer to [X] as the transit point.\n          p1 =\n            V.distance(crossPoint, prevCoreIp) < V.distance(crossPoint, prevNodeIp)\n              ? prevCoreIp\n              : prevNodeIp\n        } else {\n          // the prev line intersects only with [β]:\n          // use [β]x[line] as the transit point.\n          p1 = prevNodeIp || prev.line.target\n        }\n        if (nextNodeIp && nextCoreIp) {\n          // the next line intersects with [α] and [β]:\n          // Of [α]x[line], [β]x[line], use the one closer to [X] as the transit point.\n          p2 =\n            V.distance(crossPoint, nextCoreIp) < V.distance(crossPoint, nextNodeIp)\n              ? nextCoreIp\n              : nextNodeIp\n        } else {\n          // the next line intersects only with [β]:\n          // use [β]x[line] as the transit point.\n          p2 = nextNodeIp || next.line.source\n        }\n        pos = [p1, crossPoint, p2]\n      } else {\n        // (3) [X] is out of the node([β])\n        if (prevCoreIp && nextCoreIp) {\n          // both lines intersect with [α]:\n          // use the [α]x[line] as transit point, and\n          // center of the node as control point in bezier.\n          pos = [prevCoreIp, nodePos, nextCoreIp]\n        } else if (prevNodeIp && nextNodeIp) {\n          // both lines intersect with [β]:\n          // use the [β]x[line] as transit point, and\n          // center of the node as control point in bezier.\n          pos = [prevNodeIp, nodePos, nextNodeIp]\n        } else {\n          // either or both lines do not intersect the node:\n          // [X] as transit point in bezier, and not place control points.\n          // [α]x[line] or [β]x[line] or end of [line] as the transit points, and\n          // center of the node as control point in bezier.\n          pos = [\n            findFirstNonNull(prevCoreIp, prevNodeIp, prev.line.target),\n            nodePos,\n            findFirstNonNull(nextCoreIp, nextNodeIp, next.line.source),\n          ]\n        }\n      }\n    } else {\n      // There is no intersection of two lines:\n      // center of the node as control point in bezier.\n      if (prevCoreIp && nextCoreIp) {\n        // both lines intersect with [α]:\n        // [α]x[line] as transit point.\n        pos = [prevCoreIp, nodePos, nextCoreIp]\n      } else if (prevNodeIp && nextNodeIp) {\n        // both lines intersect with [β]:\n        // [β]x[line] as transit point.\n        pos = [prevNodeIp, nodePos, nextNodeIp]\n      } else {\n        // either or both lines do not intersect the node:\n        // the end of the line as transit point.\n        pos = [prev.line.target, nodePos, next.line.source]\n      }\n    }\n\n    if (prev.curve) {\n      // ----------------------------------------------------\n      // Specify points on the curve.\n      // ----------------------------------------------------\n      // The starting point has already been added to `points`.\n      const lastPoints = points[points.length - 1]\n      if (lastPoints) {\n        const lastPoint =\n          lastPoints instanceof Array ? lastPoints[lastPoints.length - 1] : lastPoints\n        let nextPoint\n        if (pos instanceof Array) {\n          // Curved lines always end at the center of the node.\n          // To avoid smoothness, use only a transit point.\n          nextPoint = curveInNode ? pos[0] : pos[1]\n        } else {\n          nextPoint = pos\n        }\n        const control = v2d.calculateBezierCurveControlPoint(\n          lastPoint,\n          prev.curve.circle.center,\n          nextPoint,\n          prev.curve.theta\n        )\n        if (pos instanceof Array && curveInNode) {\n          points.push([...control, ...pos])\n        } else {\n          points.push([...control, nextPoint])\n        }\n      }\n    } else if (prev.loop) {\n      const [p1, p2, arc] = _makeArcString(nodePos, prev, nodeRadius)\n      points.push(p1)\n      points.push(arc)\n      if (pos instanceof Array && curveInNode) {\n        points.push([p2, pos[1], pos[2]])\n      } else {\n        points.push(pos[2])\n      }\n    } else {\n      if (curveInNode || !(pos instanceof Array)) {\n        points.push(pos)\n      } else {\n        if (next.curve) {\n          points.push(pos[1]) // use control point as transit point\n        } else if (next.loop) {\n          points.push(pos[0])\n        } else {\n          points.push(pos[0], pos[2]) // without control point to avoid smoothness\n        }\n      }\n    }\n  }\n\n  // ----------------------------------------------------\n  // Determine the terminate point.\n  // ----------------------------------------------------\n  {\n    const lastEdge = edgePos[edgePos.length - 1]\n    let nodeRadius = NodeUtils.getNodeRadius(nodeStates[lastEdge.target].shape) * scale\n    const lineMargin = margin + (pathEndType === \"edgeOfNode\" ? nodeRadius : 0)\n    const nextPoint =\n      lineMargin <= 0\n        ? lastEdge.line.target\n        : _calculateEdgeOfNode(lastEdge, lineMargin, nodeLayouts, false)\n    nodeRadius = NodeUtils.getNodeRadius(nodeStates[lastEdge.source].shape) * scale\n    if (lastEdge.loop) {\n      const nodePos = Vector2D.fromObject(nodeLayouts[lastEdge.target] ?? { x: 0, y: 0 })\n      const [p1, _, arc] = _makeArcString(nodePos, lastEdge, nodeRadius)\n      points.push(p1)\n      points.push(arc)\n    } else if (lastEdge.curve) {\n      // curve\n      const pos = points[points.length - 1]\n      const lastPoint = pos instanceof Array ? pos[pos.length - 1] : pos\n      const control = v2d.calculateBezierCurveControlPoint(\n        lastPoint,\n        lastEdge.curve.circle.center,\n        nextPoint,\n        lastEdge.curve.theta\n      )\n      points.push([...control, nextPoint])\n    } else {\n      // straight\n      points.push(nextPoint)\n    }\n    if (margin > 0) {\n      const distance = V.distance(lastEdge.line.source, lastEdge.line.target)\n      if (distance <= lineMargin + nodeRadius) {\n        isMarginOverRunEnd = true\n      }\n    }\n  }\n\n  if (isMarginOverRunStart) {\n    points.shift()\n    if (points[0] instanceof Array) {\n      points.unshift(points[0][0])\n    }\n  }\n  if (isMarginOverRunEnd) {\n    points.pop()\n  }\n\n  return points\n}\n\nexport function calculateDirectionsOfPathEdges(edges: EdgeObject[]): boolean[] {\n  const length = edges.length\n  if (length === 0) return []\n  if (length <= 1) return [true]\n\n  const directions: boolean[] = [] // true: forward, false: reverse\n  let lastNode: string | null = null\n  let isForward = true\n  for (let i = 0; i < length; i++) {\n    const source = edges[i].edge.source\n    const target = edges[i].edge.target\n    if (i === 0) {\n      if (length > 2) {\n        // If the next edge is an edge between the same nodes,\n        // check for more next edges.\n        const joint = _getJointNode(edges, 0)\n        if (joint === null) {\n          isForward = true\n        } else {\n          isForward = joint === target\n        }\n      } else {\n        isForward = [edges[1].edge.source, edges[1].edge.target].includes(target)\n      }\n    } else if (source === target) {\n      isForward = true // loop edge direction is always true\n    } else {\n      isForward = lastNode === source\n    }\n    directions.push(isForward)\n    lastNode = isForward ? target : source\n  }\n\n  return directions\n}\n\nfunction _getJointNode(edges: EdgeObject[], index: number): string | null {\n  const edgeObject0 = edges[index]\n  const edgeObject1 = edges[index + 1]\n  const currentEdge = [edgeObject0.edge.source, edgeObject0.edge.target].sort()\n  const nextEdge = [edgeObject1.edge.source, edgeObject1.edge.target].sort()\n\n  if (currentEdge[0] === currentEdge[1]) {\n    // current edge is looped\n    return currentEdge[0]\n  }\n\n  if (nextEdge[0] === nextEdge[1]) {\n    // next edge is looped\n    return nextEdge[0]\n  }\n\n  if (edgeObject0.edgeId === edgeObject1.edgeId || (currentEdge[0] === nextEdge[0] && currentEdge[1] === nextEdge[1])) {\n    // both edges are between same nodes\n    if (index >= edges.length - 2) {\n      // cannot be determined.\n      return null;\n    } else {\n      // check with next edge\n      const joint = _getJointNode(edges, index + 1)\n      if (joint === null) {\n        return null;\n      } else {\n        return joint === currentEdge[1] ? currentEdge[0] : currentEdge[1];\n      }\n    }\n  } else {\n    return nextEdge.includes(currentEdge[1]) ? currentEdge[1] : currentEdge[0]\n  }\n}\n\nfunction _calculateEdgeOfNode(\n  edge: EdgeLine,\n  nodeRadius: number,\n  nodeLayouts: NodePositions,\n  direction: boolean\n) {\n  const nodeId = direction ? edge.source : edge.target\n  const curve = edge.curve\n  if (curve) {\n    let moveRad = nodeRadius / curve.circle.radius\n    if (curve.theta > 0) {\n      moveRad *= -1\n    }\n    if (!direction) {\n      moveRad *= -1\n    }\n    return Vector2D.fromObject(\n      v2d.moveOnCircumference(\n        direction ? edge.line.source : edge.line.target,\n        curve.circle.center,\n        moveRad\n      )\n    )\n  } else {\n    let source: Vector2D, target: Vector2D\n    if (direction) {\n      source = edge.line.target\n      target = edge.line.source\n    } else {\n      source = edge.line.source\n      target = edge.line.target\n    }\n    // straight\n    if (nodeLayouts[nodeId]) {\n      const p = PointUtils.getIntersectionOfLineTargetAndCircle(\n        source,\n        target,\n        Vector2D.fromObject(nodeLayouts[nodeId]),\n        nodeRadius\n      )\n      return p === null ? source : p\n    } else {\n      return source\n    }\n  }\n}\n\nfunction _getIntersectionOfLines(\n  prev: EdgeLine,\n  next: EdgeLine,\n  nodePos: Vector2D\n): Vector2D | null {\n  let crossPoint: Vector2D | null = null\n  if (prev.loop || next.loop) {\n    crossPoint = null // not exist intersection point\n  } else if (prev.curve) {\n    if (next.curve) {\n      if (prev.line.target.isEqualTo(next.line.source)) {\n        return prev.line.target.clone()\n      }\n      // curve -- curve\n      crossPoint = PointUtils.getIntersectionOfCircles(\n        prev.curve.circle.center,\n        prev.curve.circle.radius,\n        next.curve.circle.center,\n        next.curve.circle.radius,\n        prev.curve.center\n      )\n    } else {\n      // curve -- straight\n      crossPoint = PointUtils.getIntersectionOfLineTargetAndCircle2(\n        next.line.target,\n        next.line.source,\n        prev.curve.circle.center,\n        prev.curve.circle.radius,\n        nodePos\n      )\n    }\n  } else {\n    if (next.curve) {\n      // straight -- curve\n      crossPoint = PointUtils.getIntersectionOfLineTargetAndCircle(\n        prev.line.source,\n        prev.line.target,\n        next.curve.circle.center,\n        next.curve.circle.radius\n      )\n    } else {\n      // straight -- straight\n      const prevSlope = _getSlope(prev.line)\n      const nextSlope = _getSlope(next.line)\n      const isParallel =\n        (!isFinite(prevSlope) && !isFinite(nextSlope)) || Math.abs(prevSlope - nextSlope) < EPSILON\n      if (isParallel) {\n        crossPoint = null // not exist intersection point\n      } else {\n        crossPoint = PointUtils.getIntersectionPointOfLines(prev.line, next.line)\n      }\n    }\n  }\n  return crossPoint\n}\n\nfunction _getIntersectionOfLineAndNode(\n  edge: EdgeLine,\n  nodeCenter: Vector2D,\n  nodeRadius: number,\n  targetSide: boolean\n): Vector2D | null {\n  if (edge.loop) {\n    const points = PointUtils.getIntersectionOfCircles(\n      nodeCenter,\n      nodeRadius,\n      edge.loop.center,\n      edge.loop.radius[0]\n    )\n    return points ? (targetSide ? points[0] : points[1]) : null\n  } else if (edge.curve) {\n    return PointUtils.getIntersectionOfCircles(\n      nodeCenter,\n      nodeRadius,\n      edge.curve.circle.center,\n      edge.curve.circle.radius,\n      Vector2D.fromObject(edge.curve.center)\n    )\n  } else {\n    return PointUtils.getIntersectionOfLineTargetAndCircle(\n      targetSide ? edge.line.source : edge.line.target,\n      targetSide ? edge.line.target : edge.line.source,\n      nodeCenter,\n      nodeRadius\n    )\n  }\n}\n\nfunction _getEdgeLine(edge: EdgeObject, direction: boolean, state: EdgeState): EdgeLine {\n  let position = state.origin\n  let source = edge.edge.source\n  let target = edge.edge.target\n  let curve = state.curve\n  const loop = state.loop\n  if (loop) {\n    position = state.position\n  } else if (!direction) {\n    position = LineUtils.inverseLine(position)\n    source = edge.edge.target\n    target = edge.edge.source\n    if (curve) {\n      curve = { ...curve, theta: -curve.theta }\n    }\n  }\n  const line = VectorLine.fromLinePosition(position)\n  const result: EdgeLine = {\n    edgeId: edge.edgeId,\n    source,\n    target,\n    line,\n    direction,\n    curve,\n    loop,\n  }\n  return result\n}\n\nfunction _getSlope(pos: VectorLine) {\n  return (pos.target.y - pos.source.y) / (pos.target.x - pos.source.x)\n}\n\nfunction _makeArcString(\n  nodePos: Vector2D,\n  edge: EdgeLine,\n  nodeRadius: number\n): [Vector2D, Vector2D, any] {\n  const { radius, center } = nonNull(edge.loop, \"Loop of edge parameter\")\n  const [rx, ry] = radius\n  const ends = PointUtils.getIntersectionOfCircles(nodePos, nodeRadius, center, radius[0])\n  let [end1, end2] = ends ? ends.reverse() : [edge.line.source, edge.line.target]\n  const isClockwise = _isForward(edge)\n  if (!isClockwise) {\n    [end1, end2] = [end2, end1]\n  }\n  const p1 = end1\n  const p2 = end2\n\n  const a1 = Vector2D.fromObject(p1).subtract(center).angleDegree()\n  const a2 = Vector2D.fromObject(p2).subtract(center).angleDegree()\n  const angle = (a2 + 360 - a1) % 360\n  let largeArc = angle >= 180 ? true : false\n  largeArc = isClockwise ? largeArc : !largeArc\n  const f1 = largeArc ? 1 : 0\n  const f2 = isClockwise ? 1 : 0\n\n  return [p1, p2, `A ${rx} ${ry} 0 ${f1} ${f2} ${p2.x} ${p2.y}`]\n}\n\nfunction _isForward(edge: EdgeLine) {\n  if (edge.loop) {\n    return edge.direction ? edge.loop.isClockwise : !edge.loop.isClockwise\n  } else {\n    return true\n  }\n}\n","// Management states of objects\n\nimport { computed, ComputedRef, reactive, Ref, unref, UnwrapRef, watch } from \"vue\"\nimport { Reactive } from \"@/common/common\"\nimport { Config, ObjectConfigs, ZOrderConfig } from \"@/common/configs\"\n\ntype Objects<T> = Record<string, T>\n\ninterface ObjectStateDatumBase {\n  id: string\n  selected: boolean\n  hovered: boolean\n  selectable: ComputedRef<boolean | number>\n  zIndex: ComputedRef<number>\n}\ntype ObjectState<S extends ObjectStateDatumBase> = UnwrapRef<S>\n\ntype PartiallyPartial<T, K extends keyof T> = Pick<T, K> & Partial<Omit<T, K>>\ntype NewStateDatum<T extends ObjectStateDatumBase> = PartiallyPartial<T, keyof ObjectStateDatumBase>\n\nexport function useObjectState<\n  T,\n  S extends ObjectStateDatumBase,\n  E extends { id: string; zIndex: number } = ObjectState<S>\n>(\n  objects: Ref<Record<string, T>>,\n  config: ObjectConfigs<T>,\n  selected: Reactive<Set<string>>,\n  hovered: Reactive<Set<string>>,\n  createState: (obj: Ref<Objects<T>>, id: string, state: NewStateDatum<S>) => void,\n  terminateState?: (id: string, state: ObjectState<S>) => void,\n  entriesForZOrder?: () => E[]\n): {\n  states: Record<string, ObjectState<S>>\n  zOrderedList: ComputedRef<E[]>\n} {\n  // Object states\n  const states: Record<string, ObjectState<S>> = reactive({})\n\n  // Handle object added/removed\n  watch(\n    () => new Set(Object.keys(objects.value)),\n    (idSet, prev) => {\n      if (!prev) prev = new Set([])\n      for (const id of idSet) {\n        if (prev.has(id)) continue\n        // object added\n        createNewState(objects, states, id, false, config, createState)\n        // adding to layouts is done by layout handler\n      }\n\n      for (const id of prev) {\n        if (idSet.has(id)) continue\n        // object removed\n        selected.delete(id)\n        hovered.delete(id)\n        terminateState?.(id, states[id] as ObjectState<S>)\n        delete states[id]\n      }\n    },\n    { immediate: true }\n  )\n\n  // Object selection\n  // - update `{obj}.selected` flag\n  watch(\n    () => [...selected],\n    (objects, prev) => {\n      const append = prev ? objects.filter(n => !prev.includes(n)) : objects\n      const removed = prev ? prev.filter(n => !objects.includes(n)) : []\n      append.forEach(id => {\n        const state = states[id]\n        if (state && !state.selected) state.selected = true\n      })\n      removed.forEach(id => {\n        const state = states[id]\n        if (state && state.selected) state.selected = false\n      })\n    },\n    { immediate: true } // for specified from the beginning\n  )\n\n  // - update `node.hovered` flag\n  watch(\n    () => [...hovered],\n    (nodes, prev) => {\n      const append = nodes.filter(n => !prev.includes(n))\n      const removed = prev.filter(n => !nodes.includes(n))\n      append.forEach(id => {\n        const state = states[id]\n        if (state && !state.hovered) state.hovered = true\n      })\n      removed.forEach(id => {\n        const state = states[id]\n        if (state && state.hovered) state.hovered = false\n      })\n    }\n  )\n\n  // z-order\n  // z-index applied Object List\n  const zOrderedList = computed(() => {\n    const list: E[] = entriesForZOrder ? entriesForZOrder() : (Object.values(states) as E[])\n    if (config.zOrder.enabled) {\n      return makeZOrderedList(list, config.zOrder, hovered, selected)\n    } else {\n      return list\n    }\n  })\n\n  return { states, zOrderedList }\n}\n\nfunction createNewState<T, S extends ObjectStateDatumBase>(\n  objects: Ref<Objects<T>>,\n  states: Record<string, ObjectState<S>>,\n  id: string,\n  selected: boolean,\n  config: ObjectConfigs<T>,\n  createState: (obj: Ref<Objects<T>>, id: string, state: NewStateDatum<S>) => void\n) {\n  const stateObject = <NewStateDatum<S>>{\n    id,\n    selected,\n    hovered: false,\n    selectable: computed(() => {\n      if (!objects.value[id]) return unref(stateObject.selectable) // Return the previous value\n      return Config.value(config.selectable, objects.value[id])\n    }),\n    zIndex: computed(() => {\n      if (!objects.value[id]) return unref(stateObject.zIndex) // Return the previous value\n      return Config.value(config.zOrder.zIndex, objects.value[id])\n    }),\n  }\n  states[id] = stateObject as ObjectState<S>\n  createState(objects, id, states[id] as NewStateDatum<S> /* get reactive object */)\n}\n\nfunction makeZOrderedList<S extends { id: string; zIndex: number }, T>(\n  states: S[],\n  zOrder: ZOrderConfig<T>,\n  hovered: Reactive<Set<string>>,\n  selected: Reactive<Set<string>>\n) {\n  if (zOrder.bringToFrontOnHover && zOrder.bringToFrontOnSelected) {\n    return states.sort((a, b) => {\n      const hover1 = hovered.has(a.id)\n      const hover2 = hovered.has(b.id)\n      if (hover1 != hover2) {\n        return hover1 ? 1 : -1\n      }\n      const selected1 = selected.has(a.id)\n      const selected2 = selected.has(b.id)\n      if (selected1 != selected2) {\n        return selected1 ? 1 : -1\n      }\n      return a.zIndex - b.zIndex\n    })\n  } else if (zOrder.bringToFrontOnHover) {\n    return states.sort((a, b) => {\n      const hover1 = hovered.has(a.id)\n      const hover2 = hovered.has(b.id)\n      if (hover1 != hover2) {\n        return hover1 ? 1 : -1\n      }\n      return a.zIndex - b.zIndex\n    })\n  } else if (zOrder.bringToFrontOnSelected) {\n    return states.sort((a, b) => {\n      const selected1 = selected.has(a.id)\n      const selected2 = selected.has(b.id)\n      if (selected1 != selected2) {\n        return selected1 ? 1 : -1\n      }\n      return a.zIndex - b.zIndex\n    })\n  } else {\n    return states.sort((a, b) => {\n      return a.zIndex - b.zIndex\n    })\n  }\n}\n","\nexport function convertToAscii(source: string): string {\n  if (typeof btoa === undefined) {\n    return Buffer.from(source).toString(\"base64\").replaceAll(\"=\", \"\")\n  } else {\n    return btoa(source).replaceAll(\"=\", \"\")\n  }\n}\n","import { reactive } from \"vue\"\nimport { MarkerStyle } from \"@/common/configs\"\nimport { convertToAscii } from \"@/utils/string\"\n\nexport type MarkerBuilder = (marker: MarkerStyle | null, isSource?: boolean) => string\n\nexport interface HeadMarker extends MarkerStyle {\n  color: string\n  isSource: boolean\n}\n\nexport interface MarkerState {\n  markers: Record<string, HeadMarker>\n  referenceCount: Record<string, number>\n}\n\nexport function makeMarkerState(): MarkerState {\n  const markers: Record<string, HeadMarker> = reactive({})\n  const referenceCount: Record<string, number> = {}\n  return { markers, referenceCount }\n}\n\nexport function useMarker(markerState: MarkerState) {\n  const { markers, referenceCount } = markerState\n\n  function addMarker(key: string, marker: HeadMarker) {\n    const m = referenceCount[key] ?? 0\n    referenceCount[key] = m + 1\n    if (!m) {\n      markers[key] = marker\n    }\n  }\n\n  function removeMarker(key: string) {\n    const m = referenceCount[key] ?? 0\n    if (m) {\n      if (m - 1 === 0) {\n        delete markers[key]\n        delete referenceCount[key]\n      } else {\n        referenceCount[key] = m - 1\n      }\n    }\n  }\n\n  function clearMarker(id: string | undefined) {\n    if (id) {\n      removeMarker(id)\n    }\n  }\n\n  function makeMarker(\n    marker: MarkerStyle,\n    isSource: boolean,\n    previousId: string | undefined,\n    strokeColor: string,\n    instanceId: number\n  ) {\n    if (marker.type === \"none\") {\n      clearMarker(previousId)\n      return undefined\n    }\n\n    if (marker.type === \"custom\") {\n      clearMarker(previousId)\n      return marker.customId\n    }\n\n    const headMarker = toHeadMarker(marker, isSource, strokeColor)\n    const id = buildKey(headMarker, instanceId)\n    if (id === previousId) {\n      return id\n    }\n    clearMarker(previousId)\n    addMarker(id, headMarker)\n    return id\n  }\n\n  return {\n    makeMarker,\n    clearMarker,\n  }\n}\n\nfunction toHeadMarker(marker: MarkerStyle, isSource: boolean, strokeColor: string) {\n  return {\n    ...marker,\n    color: marker.color ?? strokeColor,\n    isSource,\n  }\n}\n\nfunction buildKey(m: HeadMarker, instanceId: number) {\n  // If the same marker ID exists in the previous instance and is hidden by\n  // `display: none`, the marker in the other instance will disappear.\n  // For safety, marker IDs will be unique in the entire page.\n  const c = convertToAscii(m.color)\n  const d = m.isSource ? \"L\" : \"R\"\n  const u = m.units === \"strokeWidth\" ? \"rel\" : \"abs\"\n  return `marker_${instanceId}_${m.type}_${m.width}_${m.height}_${m.margin}_${m.offset}_${c}_${d}_${u}`\n}\n","// the states of nodes and edges\n\nimport { computed, ComputedRef, reactive, ref, Ref, toRef, unref } from \"vue\"\nimport { watch, watchEffect } from \"vue\"\nimport { inject, InjectionKey, provide } from \"vue\"\nimport { nonNull, Reactive } from \"@/common/common\"\nimport {\n  Config,\n  Configs,\n  EdgeConfig,\n  MarkerStyle,\n  NodeConfig,\n  OppositeNode,\n} from \"@/common/configs\"\nimport { StrokeStyle, ShapeStyle, SelfLoopEdgeStyle } from \"@/common/configs\"\nimport { Edge, Edges, Layouts, Node, Nodes, Path, Paths } from \"@/common/types\"\nimport { LinePosition, Position } from \"@/common/types\"\nimport { useId } from \"@/composables/id\"\nimport * as NodeModel from \"@/models/node\"\nimport * as EdgeModel from \"@/models/edge\"\nimport * as EdgeGroup from \"@/modules/edge/group\"\nimport * as PathModel from \"@/models/path\"\nimport * as v2d from \"@/modules/calculation/2d\"\nimport * as LineUtils from \"@/modules/calculation/line\"\nimport * as PointUtils from \"@/modules/calculation/point\"\nimport * as NodeUtils from \"@/modules/node/node\"\nimport { VectorLine } from \"@/modules/calculation/line\"\nimport { Vector2D } from \"@/modules/vector2d\"\nimport * as V2D from \"@/modules/vector2d\"\nimport { Point2D } from \"@/modules/vector2d/core\"\nimport { updateObjectDiff } from \"@/utils/object\"\nimport { calculateDirectionsOfPathEdges } from \"@/modules/calculation/path\"\nimport { useObjectState } from \"./objectState\"\nimport { MarkerState, useMarker } from \"./marker\"\n\n// -----------------------------------------------------------------------\n// Type definitions\n// -----------------------------------------------------------------------\n\nexport type { EdgeGroupStates } from \"@/models/edge\"\n\n// States of nodes\n\n// Provide states\n\ninterface States {\n  nodeStates: NodeModel.NodeStates\n  edgeStates: EdgeModel.EdgeStates\n  edgeGroupStates: EdgeModel.EdgeGroupStates\n  summarizedEdgeStates: EdgeModel.SummarizedEdgeStates\n  pathStates: PathModel.PathStates\n  nodeZOrderedList: ComputedRef<NodeModel.NodeState[]>\n  edgeZOrderedList: ComputedRef<EdgeModel.EdgeEntry[]>\n  pathZOrderedList: ComputedRef<PathModel.PathState[]>\n  layouts: Layouts\n}\n\nexport type ReadonlyStates = Readonly<States>\n\ninterface InputObjects<T> {\n  objects: Ref<T>\n  selected: Reactive<Set<string>>\n  hovered: Reactive<Set<string>>\n}\n\nexport function makeStateInput<T>(\n  objects: Ref<T>,\n  selected: Reactive<Set<string>>,\n  hovered: Reactive<Set<string>>\n) {\n  return {\n    objects,\n    selected,\n    hovered,\n  }\n}\n\n// -----------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------\n\nconst statesKey = Symbol(\"states\") as InjectionKey<States>\n\nconst NONE_MARKER: MarkerStyle = {\n  type: \"none\",\n  width: 0,\n  height: 0,\n  margin: 0,\n  offset: 0,\n  units: \"strokeWidth\",\n  color: null,\n}\n\n// -----------------------------------------------------------------------\n// Exported functions\n// -----------------------------------------------------------------------\n\nexport function provideStates(\n  nodes: InputObjects<Nodes>,\n  edges: InputObjects<Edges>,\n  paths: InputObjects<Paths>,\n  configs: Readonly<Configs>,\n  layouts: Reactive<Layouts>,\n  makerState: MarkerState,\n  scale: ComputedRef<number>\n) {\n  const summarizedEdgeStates: EdgeModel.SummarizedEdgeStates = reactive({})\n\n  // -----------------------------------------------------------------------\n  // States for nodes\n  // -----------------------------------------------------------------------\n\n  // { nodeId: { edgeId: opposingNodeId } }\n  const opposingNodes = Reactive<Record<string, Record<string, string>>>({})\n  watchEffect(() => {\n    const _nodes = Object.fromEntries(\n      Object.keys(nodes.objects.value).map(k => [k, {} as Record<string, string>])\n    )\n    Object.entries(edges.objects.value).forEach(([id, e]) => {\n      if (!_nodes?.[e.source]) _nodes[e.source] = {}\n      if (!_nodes?.[e.target]) _nodes[e.target] = {}\n      _nodes[e.source][id] = e.target\n      _nodes[e.target][id] = e.source\n    })\n    updateObjectDiff(opposingNodes, _nodes)\n  })\n\n  const {\n    states: nodeStates,\n    zOrderedList: nodeZOrderedList, //\n  } = useObjectState<Node, NodeModel.NodeStateDatum, NodeModel.NodeState>(\n    nodes.objects,\n    configs.node,\n    nodes.selected,\n    nodes.hovered,\n    (nodes, id, newState) => {\n      createNewNodeState(\n        nodes,\n        id,\n        newState as NodeModel.NodeStateDatum,\n        configs.node,\n        opposingNodes,\n        layouts\n      )\n    },\n    (nodeId, _state) => {\n      const positions = layouts.nodes\n      delete positions[nodeId]\n    }\n  )\n\n  // -----------------------------------------------------------------------\n  // States for edges\n  // -----------------------------------------------------------------------\n  // Instance ID number for using to make marker ID generation unique for the\n  // entire page.\n  // If the same marker ID exists in the previous instance and is hidden by\n  // `display: none`, the marker in the other instance will disappear.\n  // To be safe, markers should be unique in the entire page.\n  const instanceId = useId()\n\n  // grouping\n  const edgeGroupStates = EdgeGroup.makeEdgeGroupStates(nodes.objects, edges.objects, configs)\n\n  // edge entries for applying z-order\n  const edgeEntries = ref<EdgeModel.EdgeEntry[]>([])\n\n  const {\n    states: edgeStates,\n    zOrderedList: edgeZOrderedList, //\n  } = useObjectState<Edge, EdgeModel.EdgeStateDatum, EdgeModel.EdgeEntry>(\n    edges.objects,\n    configs.edge,\n    edges.selected,\n    edges.hovered,\n    (edges, id, newState) => {\n      createNewEdgeState(\n        edges,\n        id,\n        newState as EdgeModel.EdgeStateDatum,\n        configs.edge,\n        makerState,\n        nodeStates,\n        edgeGroupStates,\n        layouts,\n        scale,\n        instanceId\n      )\n    },\n    (_edgeId, state) => {\n      state.stopWatchHandle?.()\n    },\n    () => edgeEntries.value\n  )\n\n  // Edge item for display (an edge or summarized edges)\n  watchEffect(() => {\n    edgeEntries.value = createEdgeEntries(edgeGroupStates.edgeGroups, edgeStates)\n  })\n\n  watch(\n    edgeGroupStates.edgeGroups,\n    _ => createSummarizedEdgeStates(summarizedEdgeStates, edgeGroupStates, configs),\n    { immediate: true }\n  )\n\n  // -----------------------------------------------------------------------\n  // States for paths\n  // -----------------------------------------------------------------------\n\n  const {\n    states: pathStates,\n    zOrderedList: pathZOrderedList, //\n  } = useObjectState<Path, PathModel.PathStateDatum, PathModel.PathState>(\n    paths.objects,\n    configs.path,\n    paths.selected,\n    paths.hovered,\n    (paths, id, newState) => {\n      const state = newState as PathModel.PathStateDatum\n\n      state.clickable = computed(() => {\n        if (!paths.value[id]) return false\n        return Config.value(configs.path.clickable, paths.value[id])\n      })\n      state.hoverable = computed(() => {\n        if (!paths.value[id]) return false\n        return Config.value(configs.path.hoverable, paths.value[id])\n      })\n\n      state.path = paths.value[id]\n      state.edges = toEdgeObjects(state.path, edges)\n      state.directions = calculateDirectionsOfPathEdges(state.edges)\n\n      state.stopWatchHandle = watch(\n        () => paths.value[id].edges,\n        () => {\n          state.edges = toEdgeObjects(state.path, edges)\n          state.directions = calculateDirectionsOfPathEdges(state.edges)\n        }\n      )\n    },\n    (_, state) => {\n      state.stopWatchHandle?.()\n    }\n  )\n\n  const states = <States>{\n    nodeStates,\n    edgeStates,\n    edgeGroupStates,\n    summarizedEdgeStates,\n    pathStates,\n    layouts,\n    nodeZOrderedList,\n    edgeZOrderedList,\n    pathZOrderedList,\n  }\n  provide(statesKey, states)\n  return states\n}\n\nexport function isSummarizedEdges(item: EdgeModel.EdgeItem): item is EdgeModel.SummarizedEdgeItem {\n  return item.summarized\n}\n\nexport function useStates() {\n  return nonNull(inject(statesKey), \"states\") as ReadonlyStates\n}\n\n// -----------------------------------------------------------------------\n// Local functions\n// -----------------------------------------------------------------------\n\nfunction getNodeShape(node: Node, selected: boolean, hovered: boolean, config: NodeConfig) {\n  if (hovered && config.hover) {\n    return Config.values(config.hover, node)\n  } else {\n    return getNodeStaticShape(node, selected, config)\n  }\n}\n\nfunction getNodeStaticShape(node: Node, selected: boolean, config: NodeConfig) {\n  // get shape without hovered state\n  if (selected && config.selected) {\n    return Config.values(config.selected, node)\n  } else {\n    return Config.values(config.normal, node)\n  }\n}\n\nfunction createNewNodeState(\n  nodes: Ref<Nodes>,\n  id: string,\n  state: NodeModel.NodeStateDatum,\n  config: NodeConfig,\n  oppositeNodeIds: Reactive<Record<string, Record<string, string>>>,\n  layouts: Reactive<Layouts>\n) {\n  state.shape = computed(() => {\n    if (!nodes.value[id]) return unref(state.shape) // Return the previous value\n    return getNodeShape(nodes.value[id], state.selected, state.hovered, config)\n  })\n\n  state.staticShape = computed(() => {\n    if (!nodes.value[id]) return unref(state.staticShape) // Return the previous value\n    return getNodeStaticShape(nodes.value[id], state.selected, config)\n  })\n\n  state.label = computed(() => {\n    if (!nodes.value[id]) return unref(state.label) // Return the previous value\n    return Config.values(config.label, nodes.value[id])\n  })\n\n  state.labelText = computed(() => {\n    if (config.label.text instanceof Function) {\n      return unref(state.label).text\n    } else {\n      if (!nodes.value[id]) return unref(state.labelText) // Return the previous value\n      return nodes.value[id]?.[unref(state.label).text] ?? \"\"\n    }\n  })\n\n  state.draggable = computed(() => {\n    if (!nodes.value[id]) return unref(state.draggable) // Return the previous value\n    return Config.value(config.draggable, nodes.value[id])\n  })\n\n  state.oppositeNodeIds = toRef(oppositeNodeIds, id)\n\n  state.oppositeNodes = computed<Record<string, OppositeNode>>(() => {\n    return Object.entries(state.oppositeNodeIds).reduce(\n      (nodes, entry) => {\n        const [edgeId, nodeId] = entry as [string, string]\n        const pos = layouts.nodes[nodeId]\n        if (pos) nodes[edgeId] = { nodeId, pos: { ...pos } }\n        return nodes\n      },\n      {} as Record<string, OppositeNode>\n    )\n  })\n}\n\nfunction getEdgeStroke(edge: Edge, selected: boolean, hovered: boolean, config: EdgeConfig) {\n  if (selected) {\n    return Config.values(config.selected, edge)\n  } else if (hovered && config.hover) {\n    return Config.values(config.hover, edge)\n  } else {\n    return Config.values(config.normal, edge)\n  }\n}\n\nfunction toEdgeMarker(marker: MarkerStyle): MarkerStyle {\n  if (marker.type === \"none\") {\n    return NONE_MARKER\n  } else {\n    return marker\n  }\n}\n\nfunction createNewEdgeState(\n  edges: Ref<Edges>,\n  id: string,\n  state: EdgeModel.EdgeStateDatum,\n  config: EdgeConfig,\n  makerState: MarkerState,\n  nodeStates: NodeModel.NodeStates,\n  edgeGroupStates: Reactive<EdgeModel.EdgeGroupStates>,\n  layouts: Layouts,\n  scale: Ref<number>,\n  instanceId: number\n) {\n  const { makeMarker, clearMarker } = useMarker(makerState)\n\n  Object.assign(state, {\n    origin: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },\n    labelPosition: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },\n    position: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },\n  })\n\n  state.label = computed(() => {\n    if (!edges.value[id]) return unref(state.label) // Return the previous value\n    return Config.values(config.label, edges.value[id])\n  })\n\n  const line = computed<EdgeModel.Line>(() => {\n    const edge = edges.value[id]\n    const stroke = getEdgeStroke(edge, state.selected, state.hovered, config)\n    // Minimum error checking required for drawing\n    if (isNaN(+stroke.width)) {\n      console.warn(\n        \"[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]\",\n        id,\n        stroke.width\n      )\n      stroke.width = 1\n    }\n    if (stroke.color === undefined || stroke.color === null) {\n      console.warn(\n        \"[v-network-graph] Edge color is invalid value. id=[%s] value=[%s]\",\n        id,\n        stroke.color\n      )\n      stroke.color = \"#000000\"\n    }\n    let normalWidth = Config.value(config.normal.width, edge)\n    if (isNaN(+normalWidth)) {\n      normalWidth = 1\n    }\n    const source = toEdgeMarker(Config.values(config.marker.source, [edge, stroke]))\n    const target = toEdgeMarker(Config.values(config.marker.target, [edge, stroke]))\n    return { stroke, normalWidth, source, target }\n  })\n  state.line = line\n  const edgeLayoutPoint: Ref<EdgeModel.EdgeLayoutPoint | undefined> = toRef(\n    edgeGroupStates.edgeLayoutPoints,\n    id\n  )\n  const isEdgeSummarized: Ref<true | undefined> = toRef(edgeGroupStates.summarizedEdges, id)\n\n  const stopCalcHandle = watchEffect(() => {\n    const edge = edges.value[id]\n    if (!edge) return\n\n    const sourceShape = nodeStates[edge.source]?.staticShape\n    const targetShape = nodeStates[edge.target]?.staticShape\n    if (!sourceShape || !targetShape) {\n      return\n    }\n\n    const source = layouts.nodes[edge?.source] ?? { x: 0, y: 0 }\n    const target = layouts.nodes[edge?.target] ?? { x: 0, y: 0 }\n\n    // calculate the line segment between center of nodes\n    const shiftedPosition = EdgeGroup.calculateEdgeShiftedPosition(\n      edgeLayoutPoint.value,\n      isEdgeSummarized.value ?? false,\n      source,\n      target,\n      scale.value,\n      config.keepOrder\n    )\n\n    const [sourceShapeMargin, targetShapeMargin] =\n      v2d.calculateDistancesFromCenterOfNodeToEndOfNode(source, target, sourceShape, targetShape)\n\n    const s = scale.value\n\n    // calculate the line segment between the outermost of the nodes\n    state.labelPosition = LineUtils.applyMargin(\n      shiftedPosition,\n      sourceShapeMargin * s,\n      targetShapeMargin * s\n    )\n\n    // calculate margins\n    let sourceMargin = 0\n    let targetMargin = 0\n    const l = line.value\n    if (l.source.type !== \"none\") {\n      const marker = l.source\n      sourceMargin = marker.margin + marker.width\n      if (marker.units === \"strokeWidth\") {\n        sourceMargin *= l.normalWidth\n      }\n    }\n    if (l.target.type !== \"none\") {\n      const marker = l.target\n      targetMargin = marker.margin + marker.width\n      if (marker.units === \"strokeWidth\") {\n        targetMargin *= l.normalWidth\n      }\n    }\n\n    if (config.margin) {\n      sourceMargin += config.margin\n      targetMargin += config.margin\n    }\n\n    const isStartEdgeOfNode =\n      !!config.margin || l.source.type !== \"none\" || l.target.type !== \"none\"\n\n    // calculate self-loop edge\n    if (edge.source === edge.target) {\n      state.origin = LineUtils.toLinePosition(source, target)\n\n      const selfLoopStyle = Config.values(config.selfLoop, edge)\n      const [position, arc] = calculateArcPositionAndState(\n        source,\n        sourceShape,\n        selfLoopStyle,\n        isStartEdgeOfNode,\n        sourceMargin,\n        targetMargin,\n        edgeLayoutPoint.value?.pointInGroup ?? 0,\n        s\n      )\n      state.position = position\n      state.loop = arc\n      state.curve = undefined\n      return\n    } else {\n      state.loop = undefined\n    }\n\n    if (isStartEdgeOfNode) {\n      sourceMargin += sourceShapeMargin\n      targetMargin += targetShapeMargin\n    }\n\n    // calculate the line segments to be displayed with margins applied\n    const type = config.type\n    if (type === \"straight\" || isEdgeSummarized.value) {\n      state.origin = shiftedPosition\n      state.curve = undefined\n      if (sourceMargin === 0 && targetMargin === 0) {\n        state.position = state.origin\n      } else {\n        state.position = LineUtils.applyMargin(state.origin, sourceMargin * s, targetMargin * s)\n      }\n    } else {\n      // curve\n      state.origin = LineUtils.toLinePosition(source, target)\n\n      const shift = edgeLayoutPoint.value // undefined after node deletion\n        ? edgeLayoutPoint.value.groupWidth / 2 - edgeLayoutPoint.value.pointInGroup\n        : 0\n\n      const [position, curve] = calculateCurvePositionAndState(\n        state.origin,\n        shiftedPosition,\n        shift,\n        sourceMargin * s,\n        targetMargin * s\n      )\n      state.position = position\n      state.curve = curve\n    }\n  })\n\n  const stopUpdateMarkerHandle = watchEffect(() => {\n    if (!edges.value[id]) return\n    state.sourceMarkerId = makeMarker(\n      line.value.source,\n      true /* isSource */,\n      state.sourceMarkerId,\n      line.value.stroke.color,\n      instanceId\n    )\n    state.targetMarkerId = makeMarker(\n      line.value.target,\n      false /* isSource */,\n      state.targetMarkerId,\n      line.value.stroke.color,\n      instanceId\n    )\n  })\n\n  state.stopWatchHandle = () => {\n    stopCalcHandle()\n    stopUpdateMarkerHandle()\n    clearMarker(state.sourceMarkerId)\n    clearMarker(state.targetMarkerId)\n  }\n}\n\nfunction createEdgeEntries(\n  edgeGroups: Record<string, EdgeModel.EdgeGroup>,\n  edgeStates: EdgeModel.EdgeStates\n) {\n  return Object.entries(edgeGroups)\n    .map(([key, group]) => {\n      if (group.summarize) {\n        return <EdgeModel.SummarizedEdgeItem>{\n          id: Object.keys(group.edges)[0] ?? key,\n          summarized: true,\n          key,\n          group,\n          zIndex: Object.keys(group.edges)\n            .map(id => edgeStates[id]?.zIndex ?? 0)\n            .reduce((s, z) => Math.max(s, z)),\n        }\n      } else {\n        return Object.entries(group.edges).map(\n          ([id, edge]) =>\n            <EdgeModel.SingleEdgeItem>{\n              id,\n              summarized: false,\n              key: id,\n              edge,\n              zIndex: edgeStates[id]?.zIndex ?? 0,\n            }\n        )\n      }\n    })\n    .flat()\n}\n\nfunction calculateCurvePositionAndState(\n  originPosition: LinePosition,\n  shiftedPosition: LinePosition,\n  shift: number,\n  sourceMargin: number,\n  targetMargin: number\n): [LinePosition, EdgeModel.Curve | undefined] {\n  // The curve is assumed to be part of a perfect circle and is drawn\n  // as a Bezier curve.\n\n  const origin = VectorLine.fromLinePosition(originPosition)\n  const shifted = VectorLine.fromLinePosition(shiftedPosition)\n  const shiftedCenter = LineUtils.getCenterOfLinePosition(shiftedPosition)\n\n  // Calculate the center and radius of the circle of the curve.\n  const [center, radius] = v2d.calculateCircleCenterAndRadiusBy3Points(\n    origin.source,\n    origin.target,\n    shiftedCenter\n  )\n\n  let position: LinePosition\n  let curve: EdgeModel.Curve | undefined = undefined\n\n  if (radius === 0) {\n    return [originPosition, curve]\n  } else if (shift === 0) {\n    // The line connecting the centers of the nodes is regarded as a straight line.\n    if (sourceMargin === 0 && targetMargin === 0) {\n      position = originPosition\n    } else {\n      position = LineUtils.applyMargin(originPosition, sourceMargin, targetMargin)\n    }\n    return [position, curve]\n  }\n\n  // Apply margin to the line.\n  const centerToTop = VectorLine.fromVectors(center, shiftedCenter)\n\n  // Direction of rotation from source to center:\n  const theta0 = v2d.calculateRelativeAngleRadian(\n    VectorLine.fromVectors(center, origin.source),\n    centerToTop\n  )\n\n  if (sourceMargin === 0 && targetMargin === 0) {\n    position = originPosition\n  } else {\n    // The endpoints of the display line are the point on the circumference\n    // moved by the margin from the origin end points.\n    let sourceMoveRad = sourceMargin / radius\n    let targetMoveRad = targetMargin / radius\n\n    // Determine which direction to move.\n    if (theta0 > 0) {\n      sourceMoveRad *= -1\n      targetMoveRad *= -1\n    }\n    position = LineUtils.toLinePosition(\n      v2d.moveOnCircumference(origin.source, center, sourceMoveRad),\n      v2d.moveOnCircumference(origin.target, center, -targetMoveRad)\n    )\n\n    // If the endpoints are swapped by applying the margin,\n    // a short line is shown at the center.\n    let theta1 = v2d.calculateRelativeAngleRadian(\n      VectorLine.fromVectors(center, origin.source),\n      VectorLine.fromVectors(center, origin.target)\n    )\n    let theta2 = v2d.calculateRelativeAngleRadian(\n      VectorLine.fromPositions(center, position.p1),\n      VectorLine.fromPositions(center, position.p2)\n    )\n    if (theta0 * theta1 < 0) {\n      theta1 = v2d.reverseAngleRadian(theta1)\n      if (theta0 * theta2 < 0) {\n        theta2 = v2d.reverseAngleRadian(theta2)\n      }\n    }\n    if (theta1 * theta2 < 0) {\n      // reversed\n      const c = shiftedCenter.clone().add(shifted.v.normalize().multiplyScalar(0.5))\n      position = LineUtils.toLinePosition(shiftedCenter, c)\n      return [position, curve]\n    }\n  }\n\n  // Calculate the control/via points of a Bezier curve.\n  const [p1, p2] = LineUtils.toVectorsFromLinePosition(position)\n  const control = v2d\n    .calculateBezierCurveControlPoint(p1, center, p2, theta0)\n    .map(p => p.toObject())\n\n  curve = {\n    center: shiftedCenter,\n    theta: theta0,\n    circle: { center, radius },\n    control,\n  }\n  return [position, curve]\n}\n\nfunction calculateArcPositionAndState(\n  nodePos: Position,\n  nodeShape: ShapeStyle,\n  selfLoopStyle: SelfLoopEdgeStyle,\n  isStartEdgeOfNode: boolean,\n  sourceMargin: number,\n  targetMargin: number,\n  pointInGroup: number,\n  scale: number\n): [LinePosition, EdgeModel.Arc] {\n  const s = scale\n\n  // calculate the center position of the Arc\n  const radius = (selfLoopStyle.radius + pointInGroup / 2) * s\n  const d = selfLoopStyle.offset * s + radius\n  const rad = (selfLoopStyle.angle - 90) * (Math.PI / 180)\n  const center = Vector2D.fromObject({\n    x: nodePos.x + d * Math.cos(rad),\n    y: nodePos.y + d * Math.sin(rad),\n  })\n\n  const isClockwise = selfLoopStyle.isClockwise\n\n  let p1: Point2D | undefined, p2: Point2D | undefined\n  if (isStartEdgeOfNode) {\n    const intersects = PointUtils.getIntersectionOfCircles(\n      center,\n      radius,\n      Vector2D.fromObject(nodePos),\n      NodeUtils.getNodeRadius(nodeShape) * s\n    )\n    if (intersects) {\n      [p1, p2] = intersects\n      let direction = 1\n      if (!isClockwise) {\n        [p1, p2] = [p2, p1]\n        direction = -1\n      }\n      if (sourceMargin !== 0 || targetMargin !== 0) {\n        const sourceMoveRad = ((sourceMargin * s) / radius) * direction\n        const targetMoveRad = ((targetMargin * s) / radius) * direction\n        p1 = v2d.moveOnCircumference(p1, center, sourceMoveRad)\n        p2 = v2d.moveOnCircumference(p2, center, -targetMoveRad)\n      }\n    }\n  }\n  if (p1 === undefined || p2 === undefined) {\n    const radiusLine = Vector2D.fromObject(nodePos)\n      .subtract(center)\n      .normalize()\n      .multiplyScalar(radius)\n    let rad = 1 * (Math.PI / 180)\n    if (!isClockwise) rad *= -1\n    p1 = center.clone().add(V2D.rotate(radiusLine, rad))\n    p2 = center.clone().add(V2D.rotate(radiusLine, -rad))\n  }\n  const a1 = Vector2D.fromObject(p1).subtract(center).angleDegree()\n  const a2 = Vector2D.fromObject(p2).subtract(center).angleDegree()\n  const angle = (a2 + 360 - a1) % 360\n\n  const isLargeArc = angle >= 180 ? true : false\n  return [\n    { p1, p2 },\n    {\n      center,\n      radius: [radius, radius],\n      isLargeArc: isClockwise ? isLargeArc : !isLargeArc,\n      isClockwise,\n    },\n  ]\n}\n\nfunction createSummarizedEdgeStates(\n  summarizedEdgeStates: EdgeModel.SummarizedEdgeStates,\n  edgeGroupStates: Reactive<EdgeModel.EdgeGroupStates>,\n  configs: Configs\n) {\n  const groups = edgeGroupStates.edgeGroups\n  Object.entries(groups)\n    .filter(([id, group]) => group.summarize && !(id in summarizedEdgeStates))\n    .forEach(([id, group]) => {\n      const state = { stroke: undefined as any }\n      state.stroke = computed<StrokeStyle>(() =>\n        Config.values(configs.edge.summarized.stroke, group.edges)\n      )\n      summarizedEdgeStates[id] = state\n    })\n  Object.keys(summarizedEdgeStates).forEach(id => {\n    if (!edgeGroupStates.edgeGroups[id]?.summarize) {\n      delete summarizedEdgeStates[id]\n    }\n  })\n}\n\nfunction toEdgeObjects(path: Path, edges: InputObjects<Edges>) {\n  return path.edges\n    .map(edgeId => ({ edgeId, edge: edges.objects.value[edgeId] }))\n    .filter(e => e.edge)\n}\n","\nexport class MapUtil {\n  static valueOf<K, V>(map: Map<K, V>) {\n    return Array.from(map.values())\n  }\n}\n","import { Ref } from \"vue\"\nimport { Position, ViewMode } from \"@/common/types\"\n\nconst MOUSE_MOVE_DETECTION_THRESHOLD = 3 // Sensitivity to start dragging\nconst TOUCH_MOVE_DETECTION_THRESHOLD = 6 // Sensitivity to start dragging in touches\nexport const DOUBLE_CLICK_THRESHOLD = 500\n\nexport type SelectionMode = \"container\" | \"node\" | \"edge\" | \"path\"\n\n// state for each pointer of multi touch\nexport interface NodePointerState {\n  pointerId: number // pointer ID provided by the event\n  nodeId: string // pointer down node ID\n  moveCounter: number // count for pointermove event occurred\n  dragBasePosition: Position // drag started position\n  nodeBasePosition: Position // node position at drag started\n  latestPosition: Position // latest position\n  eventTarget: EventTarget | null // event target\n}\n\nexport interface EdgePointerState {\n  pointerId: number // pointer ID provided by the event\n  id: string | string[] // pointer down edge ID\n  eventTarget: EventTarget | null // event target\n}\n\nexport interface PathPointerState {\n  pointerId: number // pointer ID provided by the event\n  id: string // pointer down path ID\n  eventTarget: EventTarget | null // event target\n}\n\nexport interface ClickState {\n  lastTime: number\n  count: number\n  id: string // clicked object ID\n}\n\nexport interface InteractionModes {\n  selectionMode: Ref<SelectionMode>\n  viewMode: Ref<ViewMode>\n}\n\nexport function getPointerMoveDetectionThreshold(type: string): number {\n  return type === \"touch\" ? TOUCH_MOVE_DETECTION_THRESHOLD : MOUSE_MOVE_DETECTION_THRESHOLD\n}\n\nexport function detectClicks(\n  clickStates: Map<number, ClickState>,\n  pointerId: number,\n  id: string,\n  event: MouseEvent,\n): [MouseEvent, MouseEvent | undefined] {\n  // search click states\n  let clickState = clickStates.get(pointerId)\n  if (clickState) {\n    if (clickState.id !== id) {\n      // click an other object\n      clickState = undefined\n    }\n  } else {\n    const idAndState = Array.from(clickStates.entries()).find(([_, state]) => state.id === id)\n    if (idAndState) {\n      const [oldPointerId, state] = idAndState\n      clickStates.delete(oldPointerId)\n      clickState = state\n    }\n  }\n\n  let clickEvent: MouseEvent, doubleClickEvent: MouseEvent | undefined\n  [clickState, clickEvent, doubleClickEvent] = createClickEvents(clickState, event, id)\n\n  // update\n  clickStates.set(pointerId, clickState)\n\n  return [ clickEvent, doubleClickEvent ]\n}\n\nexport function createClickEvents(\n  clickState: ClickState | undefined,\n  event: MouseEvent,\n  id: string\n): [ClickState, MouseEvent, MouseEvent | undefined] {\n  const now = Date.now()\n  if (clickState && now - clickState.lastTime <= DOUBLE_CLICK_THRESHOLD) {\n    // continuous clicked\n    clickState.count++\n    clickState.lastTime = now\n  } else {\n    // single clicked\n    clickState = { count: 1, lastTime: now, id }\n  }\n\n  const initDict = {\n    view: window,\n    screenX: event.screenX,\n    screenY: event.screenY,\n    clientX: event.clientX,\n    clientY: event.clientY,\n    ctrlKey: event.ctrlKey,\n    shiftKey: event.shiftKey,\n    altKey: event.altKey,\n    metaKey: event.metaKey,\n    button: event.button,\n    buttons: event.buttons,\n    detail: clickState.count,\n  }\n\n  let clickEvent: MouseEvent\n  let doubleClickEvent: MouseEvent | undefined = undefined\n  if (event instanceof PointerEvent) {\n    Object.assign(initDict, {\n      pointerId: event.pointerId,\n      width: event.width,\n      height: event.height,\n      pressure: event.pressure,\n      tangentialPressure: event.tangentialPressure,\n      tiltX: event.tiltX,\n      tiltY: event.tiltY,\n      twist: event.twist,\n      pointerType: event.pointerType,\n      isPrimary: event.isPrimary,\n    })\n    clickEvent = new PointerEvent(\"click\", initDict)\n    if (clickState.count === 2) {\n      doubleClickEvent = new PointerEvent(\"dblclick\", initDict)\n    }\n  } else {\n    clickEvent = new MouseEvent(\"click\", initDict)\n    if (clickState.count === 2) {\n      doubleClickEvent = new MouseEvent(\"dblclick\", initDict)\n    }\n  }\n\n  return [clickState, clickEvent, doubleClickEvent]\n}\n\nexport function cleanClickState(states: Map<number, ClickState>) {\n  const now = Date.now()\n  Array.from(states.entries())\n    .filter(([_, state]) => now - state.lastTime > DOUBLE_CLICK_THRESHOLD)\n    .map(([pointerId, _]) => states.delete(pointerId))\n}\n","import { watch } from \"vue\"\nimport { Emitter } from \"mitt\"\nimport { Reactive, ReadonlyRef } from \"@/common/common\"\nimport { Events, Layouts, NodePositions, Position } from \"@/common/types\"\nimport { NodeStates } from \"@/models/node\"\nimport { entriesOf } from \"@/utils/object\"\nimport { MapUtil } from \"@/utils/map\"\nimport {\n  cleanClickState,\n  ClickState,\n  detectClicks,\n  getPointerMoveDetectionThreshold,\n  InteractionModes,\n  NodePointerState,\n} from \"./core\"\n\ntype PointerPosition = Pick<PointerEvent, \"pageX\" | \"pageY\" | \"pointerId\">\n\ninterface NodeInteractionState {\n  pointers: Map<number, NodePointerState> // <PointerId, ...>\n  follow: {\n    followedPointerId: number\n    nodeBasePositions: { [name: string]: Position }\n  }\n  hoveredNodesPre: Set<string> // to keep the hover state while dragging\n  clicks: Map<number, ClickState> // <PointerId, ...>\n}\n\nexport function makeNodeInteractionHandlers(\n  nodeStates: NodeStates,\n  layouts: Readonly<Layouts>,\n  modes: InteractionModes,\n  hoveredNodes: Reactive<Set<string>>,\n  selectedNodes: Reactive<Set<string>>,\n  zoomLevel: ReadonlyRef<number>,\n  emitter: Emitter<Events>\n) {\n  const state: NodeInteractionState = {\n    pointers: new Map(),\n    follow: {\n      followedPointerId: -1,\n      nodeBasePositions: {},\n    },\n    hoveredNodesPre: new Set(),\n    clicks: new Map(),\n  }\n\n  const nodePointerHandlers = {\n    pointermove: handleNodePointerMoveEvent,\n    pointerup: handleNodePointerUpEvent,\n    pointercancel: handleNodePointerCancelEvent,\n  }\n\n  function _updateFollowNodes(pointerState: NodePointerState) {\n    const isFollowed = state.follow.followedPointerId === pointerState.pointerId\n    const isSelectedNode = selectedNodes.has(pointerState.nodeId)\n\n    const removed = !(pointerState.pointerId in state.pointers)\n    if ((isFollowed && removed) || (isFollowed && !isSelectedNode)) {\n      // selected => unselected\n      const candidate = MapUtil.valueOf(state.pointers).find(p => selectedNodes.has(p.nodeId))\n      if (!candidate) {\n        state.follow = { followedPointerId: -1, nodeBasePositions: {} }\n        return\n      }\n      pointerState = candidate\n      state.follow.followedPointerId = pointerState.pointerId\n    } else {\n      const followed = state.pointers.get(state.follow.followedPointerId)\n      if (!followed) {\n        state.follow = { followedPointerId: -1, nodeBasePositions: {} }\n        return\n      }\n      pointerState = followed\n    }\n\n    if (isFollowed || isSelectedNode) {\n      // reset state for following:\n      // followed by selected nodes without user grabs\n      const userGrabs = MapUtil.valueOf(state.pointers).map(n => n.nodeId)\n      state.follow.nodeBasePositions = Object.fromEntries(\n        Array.from(selectedNodes)\n          .filter(n => !userGrabs.includes(n))\n          .filter(n => nodeStates[n]?.draggable)\n          .map(n => [n, _unwrapNodePosition(layouts.nodes, n)])\n      )\n      pointerState.dragBasePosition = { ...pointerState.latestPosition }\n      pointerState.nodeBasePosition = _unwrapNodePosition(layouts.nodes, pointerState.nodeId)\n    }\n  }\n\n  watch(selectedNodes, selected => {\n    const pointerState = state.pointers.get(state.follow.followedPointerId)\n    if (pointerState) {\n      _updateFollowNodes(pointerState)\n    }\n    if (selected.size > 0 && modes.selectionMode.value !== \"node\") {\n      modes.selectionMode.value = \"node\"\n    } else if (selected.size === 0 && modes.selectionMode.value === \"node\") {\n      modes.selectionMode.value = \"container\"\n    }\n  })\n\n  watch(modes.selectionMode, mode => {\n    if (mode !== \"node\") {\n      selectedNodes.clear()\n    }\n  })\n\n  function _calculateNodeNewPosition(pointerState: NodePointerState, event: PointerPosition) {\n    const dx = pointerState.dragBasePosition.x - event.pageX\n    const dy = pointerState.dragBasePosition.y - event.pageY\n    const positions =\n      state.follow.followedPointerId == pointerState.pointerId\n        ? {\n            [pointerState.nodeId]: pointerState.nodeBasePosition,\n            ...state.follow.nodeBasePositions,\n          }\n        : { [pointerState.nodeId]: pointerState.nodeBasePosition }\n    const z = zoomLevel.value\n\n    return Object.fromEntries(\n      Object.entries(positions).map(([node, pos]) => [\n        node,\n        {\n          x: pos.x - dx / z,\n          y: pos.y - dy / z,\n        },\n      ])\n    )\n  }\n\n  function handleNodeClickEvent(node: string, event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    // When a finger is placed on any object and another object is tapped,\n    // no click event is fired. Thus, click events are emulated by using\n    // pointerdown/up. The following is processing for emulated events only.\n\n    if (event.shiftKey && ![\"container\", \"node\"].includes(modes.selectionMode.value)) {\n      return\n    }\n    modes.selectionMode.value = \"node\"\n\n    const selectable = nodeStates[node]?.selectable ?? false\n    if (selectable) {\n      const isTouchAnySelectedNode =\n        MapUtil.valueOf(state.pointers).filter(p => selectedNodes.has(p.nodeId)).length > 0\n      if (event.shiftKey || isTouchAnySelectedNode) {\n        // select multiple nodes\n        if (selectedNodes.has(node)) {\n          selectedNodes.delete(node)\n        } else if (!(typeof selectable === \"number\" && selectedNodes.size >= selectable)) {\n          selectedNodes.add(node)\n        }\n      } else if (!selectedNodes.has(node)) {\n        // make the selectedNodes the clicked one\n        selectedNodes.clear()\n        selectedNodes.add(node)\n      }\n    }\n    emitter.emit(\"node:click\", { node, event })\n  }\n\n  function handleNodeDoubleClickEvent(node: string, event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    emitter.emit(\"node:dblclick\", { node, event })\n  }\n\n  function handleNodePointerMoveEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n    pointerState.latestPosition = { x: event.pageX, y: event.pageY }\n    pointerState.moveCounter++\n\n    const threshold = getPointerMoveDetectionThreshold(event.pointerType)\n    if (pointerState.moveCounter <= threshold) {\n      return // pending for click and drag distinguish\n    }\n\n    if (!nodeStates[pointerState.nodeId]?.draggable) {\n      return\n    }\n\n    if (pointerState.moveCounter === threshold + 1) {\n      const draggingNodes = _calculateNodeNewPosition(pointerState, {\n        pointerId: pointerState.pointerId,\n        pageX: pointerState.dragBasePosition.x,\n        pageY: pointerState.dragBasePosition.y,\n      })\n      emitter.emit(\"node:dragstart\", draggingNodes)\n    }\n    const draggingNodes = _calculateNodeNewPosition(pointerState, event)\n    emitter.emit(\"node:pointermove\", draggingNodes)\n  }\n\n  function handleNodePointerCancelEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    let pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    for (pointerState of state.pointers.values()) {\n      const node = pointerState.nodeId\n\n      const threshold = getPointerMoveDetectionThreshold(event.pointerType)\n      const isMoved = pointerState.moveCounter > threshold\n      if (isMoved) {\n        // pageX/Y in cancel event are zero => use latest position\n        const draggingNodes = _calculateNodeNewPosition(pointerState, {\n          pointerId: pointerState.pointerId,\n          pageX: pointerState.latestPosition.x,\n          pageY: pointerState.latestPosition.y,\n        })\n        emitter.emit(\"node:dragend\", draggingNodes)\n      }\n      emitter.emit(\"node:pointerup\", { node, event })\n    }\n\n    // reset state\n    state.pointers.clear()\n    state.follow = { followedPointerId: -1, nodeBasePositions: {} }\n    entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {\n      document.removeEventListener(ev, handler)\n    })\n    modes.viewMode.value = \"default\"\n  }\n\n  function handleNodePointerUpEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    state.pointers.delete(event.pointerId)\n\n    const node = pointerState.nodeId\n\n    const threshold = getPointerMoveDetectionThreshold(event.pointerType)\n    const isMoved = pointerState.moveCounter > threshold\n    if (isMoved) {\n      if (nodeStates[pointerState.nodeId]?.draggable) {\n        const draggingNodes = _calculateNodeNewPosition(pointerState, event)\n        emitter.emit(\"node:dragend\", draggingNodes)\n        emitter.emit(\"node:pointerup\", { node, event })\n      }\n    } else {\n      emitter.emit(\"node:pointerup\", { node, event })\n    }\n\n    if (!isMoved /* Don't fire the click event if the node is being dragged */) {\n      // click handling\n      const [clickEvent, doubleClickEvent] = detectClicks(\n        state.clicks,\n        pointerState.pointerId,\n        node,\n        event\n      )\n      pointerState.eventTarget?.dispatchEvent(clickEvent)\n      if (doubleClickEvent) {\n        pointerState.eventTarget?.dispatchEvent(doubleClickEvent)\n      }\n    }\n\n    if (state.pointers.size === 0) {\n      // re-initialize state\n      state.follow = { followedPointerId: -1, nodeBasePositions: {} }\n      entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler)\n      })\n      cleanClickState(state.clicks)\n      modes.viewMode.value = \"default\"\n    } else {\n      _updateFollowNodes(pointerState)\n    }\n\n    // reflect changes while dragging.\n    hoveredNodes.clear()\n    state.hoveredNodesPre.forEach(hoveredNodes.add, hoveredNodes)\n  }\n\n  function handleNodePointerDownEvent(node: string, event: PointerEvent) {\n    if (event.button == 2 /* right button */) {\n      return\n    }\n    event.stopPropagation()\n\n    if (![\"default\", \"node\"].includes(modes.viewMode.value)) {\n      return\n    }\n\n    if (state.pointers.size == 0) {\n      // Add event listeners\n      modes.viewMode.value = \"node\"\n      entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler)\n      })\n    }\n\n    // Create new pointer state\n    const pointerState: NodePointerState = {\n      pointerId: event.pointerId,\n      nodeId: node,\n      moveCounter: 0,\n      nodeBasePosition: _unwrapNodePosition(layouts.nodes, node),\n      dragBasePosition: { x: event.pageX, y: event.pageY },\n      latestPosition: { x: event.pageX, y: event.pageY },\n      eventTarget: event.currentTarget,\n    }\n    state.pointers.set(event.pointerId, pointerState)\n\n    if (selectedNodes.has(node)) {\n      if (state.follow.followedPointerId < 0) {\n        // pointer followed by selected nodes\n        state.follow.followedPointerId = event.pointerId\n        _updateFollowNodes(pointerState)\n      } else {\n        // current pointer is in charge of this node.\n        // do not follow another node anymore.\n        delete state.follow.nodeBasePositions[pointerState.nodeId]\n      }\n    }\n\n    emitter.emit(\"node:pointerdown\", { node, event })\n  }\n\n  function handleNodePointerOverEvent(node: string, event: PointerEvent) {\n    state.hoveredNodesPre.add(node)\n    if (state.pointers.size > 0) {\n      return // dragging\n    }\n    hoveredNodes.add(node)\n    emitter.emit(\"node:pointerover\", { node, event })\n  }\n\n  function handleNodePointerOutEvent(node: string, event: PointerEvent) {\n    state.hoveredNodesPre.delete(node)\n    if (state.pointers.size > 0) {\n      return // dragging\n    }\n    hoveredNodes.delete(node)\n    emitter.emit(\"node:pointerout\", { node, event })\n  }\n\n  function handleNodeContextMenu(node: string, event: MouseEvent) {\n    event.stopPropagation()\n    emitter.emit(\"node:contextmenu\", { node, event })\n  }\n\n  return {\n    handleNodePointerDownEvent,\n    handleNodePointerOverEvent,\n    handleNodePointerOutEvent,\n    handleNodeClickEvent,\n    handleNodeDoubleClickEvent,\n    handleNodeContextMenu,\n  }\n}\n\nfunction _unwrapNodePosition(nodes: Readonly<NodePositions>, node: string) {\n  const pos = nodes[node] ?? { x: 0, y: 0 }\n  return { ...pos } // unwrap reactivity\n}\n","import { watch } from \"vue\"\nimport { Emitter } from \"mitt\"\nimport { Reactive } from \"@/common/common\"\nimport { Events, EdgeEvent } from \"@/common/types\"\nimport { EdgeStates } from \"@/models/edge\"\nimport { entriesOf } from \"@/utils/object\"\nimport { MapUtil } from \"@/utils/map\"\nimport {\n  cleanClickState,\n  ClickState,\n  detectClicks,\n  EdgePointerState,\n  InteractionModes,\n} from \"./core\"\n\nexport function makeEdgeInteractionHandlers(\n  edgeStates: EdgeStates,\n  modes: InteractionModes,\n  hoveredEdges: Reactive<Set<string>>,\n  selectedEdges: Reactive<Set<string>>,\n  emitter: Emitter<Events>\n) {\n  const state = {\n    pointers: new Map<number, EdgePointerState>(), // <PointerId, ...>\n    pointerPeekCount: 0,\n    clicks: new Map<number, ClickState>(),\n  }\n\n  const edgePointerHandlers = {\n    pointerup: handleEdgePointerUpEvent,\n    pointercancel: handleEdgePointerCancelEvent,\n  }\n\n  watch(selectedEdges, selected => {\n    if (selected.size > 0 && modes.selectionMode.value !== \"edge\") {\n      modes.selectionMode.value = \"edge\"\n    } else if (selected.size === 0 && modes.selectionMode.value === \"edge\") {\n      modes.selectionMode.value = \"container\"\n    }\n  })\n\n  watch(modes.selectionMode, mode => {\n    if (mode !== \"edge\") {\n      selectedEdges.clear()\n    }\n  })\n\n  function handleEdgePointerDownEvent(edge: string, event: PointerEvent) {\n    if (event.button == 2 /* right button */) {\n      return\n    }\n    event.stopPropagation()\n\n    if (![\"default\", \"edge\"].includes(modes.viewMode.value)) {\n      return\n    }\n\n    if (state.pointers.size == 0) {\n      // Add event listeners\n      modes.viewMode.value = \"edge\"\n      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler)\n      })\n      state.pointerPeekCount = 0\n    }\n\n    state.pointerPeekCount++\n\n    // Create new pointer state\n    const pointerState: EdgePointerState = {\n      pointerId: event.pointerId,\n      id: edge,\n      eventTarget: event.currentTarget,\n    }\n    state.pointers.set(event.pointerId, pointerState)\n\n    emitter.emit(\"edge:pointerdown\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgePointerUpEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    state.pointers.delete(event.pointerId)\n\n    const edge = pointerState.id\n    emitter.emit(\"edge:pointerup\", _makeEdgeEventObject(edge, event))\n\n    // click handling\n    const [clickEvent, doubleClickEvent] = detectClicks(\n      state.clicks,\n      pointerState.pointerId,\n      edge instanceof Array ? edge.join(\",\") : edge,\n      event,\n    )\n    pointerState.eventTarget?.dispatchEvent(clickEvent)\n    if (doubleClickEvent) {\n      pointerState.eventTarget?.dispatchEvent(doubleClickEvent)\n    }\n\n    if (state.pointers.size === 0) {\n      // reset state\n      state.pointerPeekCount = 0\n      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler)\n      })\n      cleanClickState(state.clicks)\n      modes.viewMode.value = \"default\"\n    }\n  }\n\n  function handleEdgePointerCancelEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    for (const pointerState of state.pointers.values()) {\n      const edge = pointerState.id\n      emitter.emit(\"edge:pointerup\", _makeEdgeEventObject(edge, event))\n    }\n\n    // reset state\n    state.pointers.clear()\n    state.pointerPeekCount = 0\n    entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n      document.removeEventListener(ev, handler)\n    })\n    emitter.emit(\"view:mode\", \"default\")\n  }\n\n  function handleEdgeClickEvent(edge: string | string[], event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    // When a finger is placed on any object and another object is tapped,\n    // no click event is fired. Thus, click events are emulated by using\n    // pointerdown/up. The following is processing for emulated events only.\n\n    if (event.shiftKey && ![\"container\", \"edge\"].includes(modes.selectionMode.value)) {\n      return\n    }\n    modes.selectionMode.value = \"edge\"\n\n    const edges = edge instanceof Array ? edge : [edge]\n\n    const isTouchAnySelectedEdge =\n      MapUtil.valueOf(state.pointers).filter(p => {\n        const edges = p.id instanceof Array ? p.id : [p.id]\n        return edges.every(edge => selectedEdges.has(edge))\n      }).length > 0\n\n    if (edge instanceof Array) {\n      // select only selectable edge\n      const selectableEdges = edges.find(edge => edgeStates[edge]?.selectable)\n      if (selectableEdges) {\n        if (event.shiftKey || isTouchAnySelectedEdge) {\n          if (edges.some(edge => selectedEdges.has(edge))) {\n            edges.forEach(edge => selectedEdges.delete(edge))\n          } else {\n            edges.forEach(edge => {\n              const selectable = edgeStates[edge]?.selectable\n              if (!(typeof selectable === \"number\" && selectedEdges.size >= selectable)) {\n                selectedEdges.add(edge)\n              }\n            })\n          }\n        } else {\n          // make the selectedEdges the clicked summarized one\n          selectedEdges.clear()\n          edges.forEach(edge => selectedEdges.add(edge))\n        }\n      }\n    } else {\n      const selectable = edgeStates[edge]?.selectable\n      if (selectable) {\n        if (event.shiftKey || isTouchAnySelectedEdge) {\n          if (selectedEdges.has(edge)) {\n            selectedEdges.delete(edge)\n          } else if (!(typeof selectable === \"number\" && selectedEdges.size >= selectable)) {\n            selectedEdges.add(edge)\n          }\n        } else if (!selectedEdges.has(edge)) {\n          // make the selectedEdges the clicked one\n          selectedEdges.clear()\n          selectedEdges.add(edge)\n        }\n      }\n    }\n    emitter.emit(\"edge:click\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgeDoubleClickEvent(edge: string | string[], event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    emitter.emit(\"edge:dblclick\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgePointerOverEvent(edge: string, event: PointerEvent) {\n    hoveredEdges.add(edge)\n    emitter.emit(\"edge:pointerover\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgePointerOutEvent(edge: string, event: PointerEvent) {\n    hoveredEdges.delete(edge)\n    emitter.emit(\"edge:pointerout\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgeContextMenu(edge: string, event: MouseEvent) {\n    event.stopPropagation()\n    emitter.emit(\"edge:contextmenu\", _makeEdgeEventObject(edge, event))\n  }\n\n  function handleEdgesPointerDownEvent(edges: string[], event: PointerEvent) {\n    if (event.button == 2 /* right button */) {\n      return\n    }\n    event.stopPropagation()\n\n    if (![\"default\", \"edge\"].includes(modes.viewMode.value)) {\n      return\n    }\n\n    if (state.pointers.size == 0) {\n      // Add event listeners\n      modes.viewMode.value = \"edge\"\n      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler)\n      })\n      state.pointerPeekCount = 0\n    }\n\n    state.pointerPeekCount++\n\n    // Create new pointer state\n    const pointerState: EdgePointerState = {\n      pointerId: event.pointerId,\n      id: edges,\n      eventTarget: event.currentTarget,\n    }\n    state.pointers.set(event.pointerId, pointerState)\n    emitter.emit(\"edge:pointerdown\", _makeEdgeEventObject(edges, event))\n  }\n\n  function handleEdgesPointerOverEvent(edges: string[], event: PointerEvent) {\n    edges.forEach(edge => hoveredEdges.add(edge))\n    emitter.emit(\"edge:pointerover\", _makeEdgeEventObject(edges, event))\n  }\n\n  function handleEdgesPointerOutEvent(edges: string[], event: PointerEvent) {\n    edges.forEach(edge => hoveredEdges.delete(edge))\n    emitter.emit(\"edge:pointerout\", _makeEdgeEventObject(edges, event))\n  }\n\n  function handleEdgesClickEvent(edges: string[], event: MouseEvent) {\n    handleEdgeClickEvent(edges, event)\n  }\n\n  function handleEdgesDoubleClickEvent(edges: string[], event: MouseEvent) {\n    handleEdgeDoubleClickEvent(edges, event)\n  }\n\n  function handleEdgesContextMenu(edges: string[], event: MouseEvent) {\n    event.stopPropagation()\n    emitter.emit(\"edge:contextmenu\", _makeEdgeEventObject(edges, event))\n  }\n\n  return {\n    handleEdgePointerDownEvent,\n    handleEdgePointerOverEvent,\n    handleEdgePointerOutEvent,\n    handleEdgeClickEvent,\n    handleEdgeDoubleClickEvent,\n    handleEdgeContextMenu,\n    handleEdgesPointerDownEvent,\n    handleEdgesPointerOverEvent,\n    handleEdgesPointerOutEvent,\n    handleEdgesClickEvent,\n    handleEdgesDoubleClickEvent,\n    handleEdgesContextMenu,\n  }\n}\n\nfunction _makeEdgeEventObject<T extends Event>(edge: string | string[], event: T): EdgeEvent<T> {\n  if (edge instanceof Array) {\n    return {\n      edges: edge,\n      event,\n      summarized: true,\n    }\n  } else {\n    return {\n      edge,\n      edges: [edge],\n      event,\n      summarized: false,\n    }\n  }\n}\n","import { onMounted, onUnmounted, Ref, watch } from \"vue\"\nimport { Emitter } from \"mitt\"\nimport { Events } from \"@/common/types\"\nimport { entriesOf } from \"@/utils/object\"\nimport {\n  ClickState,\n  createClickEvents,\n  getPointerMoveDetectionThreshold,\n  InteractionModes,\n} from \"./core\"\n\nexport function setupContainerInteractionHandlers(\n  container: Ref<SVGElement | undefined>,\n  modes: InteractionModes,\n  isSvgWheelZoomEnabled: Ref<boolean>,\n  emitter: Emitter<Events>\n) {\n  const state = {\n    moveCounter: 0,\n    pointerCounter: 0,\n    clickState: undefined as ClickState | undefined,\n  }\n\n  // measure the number of move events in the pointerdown state\n  // and use it to determine the click when pointerup.\n  const containerPointerHandlers = {\n    pointermove: handleContainerPointerMoveEvent,\n    pointerup: handleContainerPointerUpEvent,\n    pointercancel: handleContainerPointerUpEvent,\n  }\n\n  function handleContainerPointerDownEvent(_: PointerEvent) {\n    state.moveCounter = 0\n    if (state.pointerCounter === 0) {\n      // Add to event listener\n      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler, { passive: true })\n      })\n    }\n    state.pointerCounter++\n  }\n\n  function handleContainerPointerMoveEvent(_: PointerEvent) {\n    state.moveCounter++\n  }\n\n  function handleContainerPointerUpEvent(event: PointerEvent) {\n    state.pointerCounter--\n    if (state.pointerCounter <= 0) {\n      state.pointerCounter = 0\n      // Remove from event listener\n      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler)\n      })\n      const threshold = getPointerMoveDetectionThreshold(event.pointerType)\n      if (state.moveCounter <= threshold) {\n        // Click container (without mouse move)\n        if (event.shiftKey && modes.selectionMode.value !== \"container\") {\n          return\n        }\n        modes.selectionMode.value = \"container\"\n\n        // click handling\n        const [clickState, clickEvent, doubleClickEvent] = createClickEvents(\n          state.clickState,\n          event,\n          \"view\"\n        )\n        state.clickState = clickState\n        container.value!.dispatchEvent(clickEvent)\n        if (doubleClickEvent) {\n          container.value!.dispatchEvent(doubleClickEvent)\n        }\n      }\n    }\n  }\n\n  function handleContainerClickEvent(event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    // When a finger is placed on any object and another object is tapped,\n    // no click event is fired. Thus, click events are emulated by using\n    // pointerdown/up. The following is processing for emulated events only.\n    event.stopPropagation()\n    emitter.emit(\"view:click\", { event })\n  }\n\n  function handleContainerDoubleClickEvent(event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    event.stopPropagation()\n    emitter.emit(\"view:dblclick\", { event })\n  }\n\n  function handleContainerContextMenuEvent(event: MouseEvent) {\n    emitter.emit(\"view:contextmenu\", { event })\n\n    if (state.pointerCounter > 0) {\n      // reset pointer down state\n      state.pointerCounter = 0\n      // Remove from event listener\n      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {\n        container.value?.removeEventListener(ev, handler)\n      })\n    }\n  }\n\n  const preventDefault = (e: MouseEvent) => {\n    e.preventDefault()\n  }\n\n  onMounted(() => {\n    const c = container.value\n    if (!c) return\n    c.addEventListener(\"pointerdown\", handleContainerPointerDownEvent, { passive: true })\n    c.addEventListener(\"click\", handleContainerClickEvent, { passive: false })\n    c.addEventListener(\"dblclick\", handleContainerDoubleClickEvent, { passive: false })\n    c.addEventListener(\"contextmenu\", handleContainerContextMenuEvent, { passive: false })\n    if (isSvgWheelZoomEnabled.value) {\n      c.addEventListener(\"wheel\", preventDefault, { passive: false })\n    }\n  })\n\n  onUnmounted(() => {\n    const c = container.value\n    if (!c) return\n    c.removeEventListener(\"pointerdown\", handleContainerPointerDownEvent)\n    c.removeEventListener(\"click\", handleContainerClickEvent)\n    c.removeEventListener(\"dblclick\", handleContainerDoubleClickEvent)\n    c.removeEventListener(\"contextmenu\", handleContainerContextMenuEvent)\n    if (isSvgWheelZoomEnabled.value) {\n      c.removeEventListener(\"wheel\", preventDefault)\n    }\n  })\n\n  watch(isSvgWheelZoomEnabled, (enabled, old) => {\n    const c = container.value\n    if (!c || enabled === old) return\n\n    if (enabled) {\n      c.addEventListener(\"wheel\", preventDefault, { passive: false })\n    } else {\n      c.removeEventListener(\"wheel\", preventDefault)\n    }\n  })\n}\n","import { Ref, watch } from \"vue\"\nimport { Reactive } from \"@/common/common\"\nimport { Events, PathEvent } from \"@/common/types\"\nimport { PathStates } from \"@/models/path\"\nimport {\n  cleanClickState,\n  ClickState,\n  detectClicks,\n  InteractionModes,\n  PathPointerState,\n} from \"./core\"\nimport { entriesOf } from \"@/utils/object\"\nimport { MapUtil } from \"@/utils/map\"\nimport { Emitter } from \"mitt\"\n\nexport function makePathInteractionHandlers(\n  pathStates: PathStates,\n  modes: InteractionModes,\n  hoveredPaths: Reactive<Set<string>>,\n  selectedPaths: Reactive<Set<string>>,\n  isInCompatibilityModeForPath: Ref<boolean>,\n  emitter: Emitter<Events>\n) {\n  const state = {\n    pointers: new Map<number, PathPointerState>(), // <PointerId, ...>\n    pointerPeekCount: 0,\n    clicks: new Map<number, ClickState>(),\n  }\n\n  function _makePathEventObject<T extends Event>(path: string, event: T): PathEvent<T> {\n    if (isInCompatibilityModeForPath.value) {\n      return { path: (pathStates[path]?.path ?? path) as any, event }\n    } else {\n      return { path, event }\n    }\n  }\n\n  const pathPointerHandlers = {\n    pointerup: handlePathPointerUpEvent,\n    pointercancel: handlePathPointerCancelEvent,\n  }\n\n  watch(selectedPaths, selected => {\n    if (selected.size > 0 && modes.selectionMode.value !== \"path\") {\n      modes.selectionMode.value = \"path\"\n    } else if (selected.size === 0 && modes.selectionMode.value === \"path\") {\n      modes.selectionMode.value = \"container\"\n    }\n  })\n\n  watch(modes.selectionMode, mode => {\n    if (mode !== \"path\") {\n      selectedPaths.clear()\n    }\n  })\n\n  function handlePathPointerDownEvent(path: string, event: PointerEvent) {\n    if (!pathStates[path]?.clickable) {\n      return\n    }\n\n    if (event.button == 2 /* right button */) {\n      return\n    }\n    event.stopPropagation()\n\n    if (![\"default\", \"path\"].includes(modes.viewMode.value)) {\n      return\n    }\n\n    if (state.pointers.size == 0) {\n      // Add event listeners\n      modes.viewMode.value = \"path\"\n      entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {\n        document.addEventListener(ev, handler)\n      })\n      state.pointerPeekCount = 0\n    }\n\n    state.pointerPeekCount++\n\n    // Create new pointer state\n    const pointerState: PathPointerState = {\n      pointerId: event.pointerId,\n      id: path,\n      eventTarget: event.currentTarget,\n    }\n    state.pointers.set(event.pointerId, pointerState)\n\n    emitter.emit(\"path:pointerdown\", _makePathEventObject(path, event))\n  }\n\n  function handlePathPointerUpEvent(event: PointerEvent) {\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    event.stopPropagation()\n\n    state.pointers.delete(event.pointerId)\n\n    const path = pointerState.id\n    emitter.emit(\"path:pointerup\", _makePathEventObject(path, event))\n\n    // click handling\n    const [clickEvent, doubleClickEvent] = detectClicks(\n      state.clicks,\n      pointerState.pointerId,\n      path,\n      event\n    )\n    pointerState.eventTarget?.dispatchEvent(clickEvent)\n    if (doubleClickEvent) {\n      pointerState.eventTarget?.dispatchEvent(doubleClickEvent)\n    }\n\n    if (state.pointers.size === 0) {\n      // reset state\n      state.pointerPeekCount = 0\n      entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {\n        document.removeEventListener(ev, handler)\n      })\n      cleanClickState(state.clicks)\n      modes.viewMode.value = \"default\"\n    }\n  }\n\n  function handlePathPointerCancelEvent(event: PointerEvent) {\n    const pointerState = state.pointers.get(event.pointerId)\n    if (!pointerState) {\n      return\n    }\n\n    event.stopPropagation()\n\n    for (const pointerState of state.pointers.values()) {\n      const path = pointerState.id\n      emitter.emit(\"path:pointerup\", _makePathEventObject(path, event))\n    }\n\n    // reset state\n    state.pointers.clear()\n    state.pointerPeekCount = 0\n    entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {\n      document.removeEventListener(ev, handler)\n    })\n    emitter.emit(\"view:mode\", \"default\")\n  }\n\n  function handlePathPointerOverEvent(path: string, event: PointerEvent) {\n    if (!pathStates[path]?.hoverable) {\n      return\n    }\n    hoveredPaths.add(path)\n    emitter.emit(\"path:pointerover\", _makePathEventObject(path, event))\n  }\n\n  function handlePathPointerOutEvent(path: string, event: PointerEvent) {\n    if (!pathStates[path]?.hoverable) {\n      return\n    }\n    hoveredPaths.delete(path)\n    emitter.emit(\"path:pointerout\", _makePathEventObject(path, event))\n  }\n\n  function handlePathClickEvent(path: string, event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    // When a finger is placed on any object and another object is tapped,\n    // no click event is fired. Thus, click events are emulated by using\n    // pointerdown/up. The following is processing for emulated events only.\n\n    if (!pathStates[path]?.clickable) {\n      return\n    }\n\n    if (event.shiftKey && ![\"container\", \"path\"].includes(modes.selectionMode.value)) {\n      return\n    }\n    modes.selectionMode.value = \"path\"\n\n    const selectable = pathStates[path]?.selectable ?? false\n    if (selectable) {\n      const isTouchAnySelectedPath =\n        MapUtil.valueOf(state.pointers).filter(p => selectedPaths.has(p.id)).length > 0\n      if (event.shiftKey || isTouchAnySelectedPath) {\n        // select multiple nodes\n        if (selectedPaths.has(path)) {\n          selectedPaths.delete(path)\n        } else if (!(typeof selectable === \"number\" && selectedPaths.size >= selectable)) {\n          selectedPaths.add(path)\n        }\n      } else if (!selectedPaths.has(path)) {\n        // make the selectedPaths the clicked one\n        selectedPaths.clear()\n        selectedPaths.add(path)\n      }\n    }\n    emitter.emit(\"path:click\", _makePathEventObject(path, event))\n  }\n\n  function handlePathDoubleClickEvent(path: string, event: MouseEvent) {\n    if (event.isTrusted) return // native event\n    if (!pathStates[path]?.clickable) {\n      return\n    }\n    emitter.emit(\"path:dblclick\", _makePathEventObject(path, event))\n  }\n\n  function handlePathContextMenu(path: string, event: MouseEvent) {\n    if (!pathStates[path]?.clickable) {\n      return\n    }\n    event.stopPropagation()\n    emitter.emit(\"path:contextmenu\", _makePathEventObject(path, event))\n  }\n\n  return {\n    handlePathPointerDownEvent,\n    handlePathPointerOverEvent,\n    handlePathPointerOutEvent,\n    handlePathClickEvent,\n    handlePathDoubleClickEvent,\n    handlePathContextMenu,\n  }\n}\n","\nexport async function urlContentToDataUrl(url: string) {\n  const response = await fetch(url)\n  const blob = await response.blob()\n  return new Promise<string>((onSuccess, onError) => {\n    try {\n      const reader = new FileReader()\n      reader.onload = function() { onSuccess(this.result as string) } ;\n      reader.readAsDataURL(blob) ;\n    } catch (e) {\n      onError(e)\n    }\n  });\n}\n","import { Point } from \"@/common/types\"\nimport { urlContentToDataUrl } from \"./download\"\n\nexport interface ExportOptions {\n  embedImages: boolean\n}\n\nexport function translateFromDomToSvgCoordinates(\n  svg: SVGSVGElement,\n  viewport: SVGGElement,\n  coordinates: Point\n): Point {\n  const point = svg.createSVGPoint()\n  point.x = coordinates.x\n  point.y = coordinates.y\n  const svgPoint = point.matrixTransform(viewport.getCTM()?.inverse())\n  return { x: svgPoint.x, y: svgPoint.y }\n}\n\nexport function translateFromSvgToDomCoordinates(\n  svg: SVGSVGElement,\n  viewport: SVGGElement,\n  coordinates: Point\n): Point {\n  const point = svg.createSVGPoint()\n  point.x = coordinates.x\n  point.y = coordinates.y\n  const domPoint = point.matrixTransform(viewport.getCTM() as DOMMatrixInit)\n  return { x: domPoint.x, y: domPoint.y }\n}\n\nexport function exportSvgElement(\n  element: SVGElement,\n  svgViewport: SVGGElement,\n  scale: number\n): SVGElement {\n  const target = element.cloneNode(true) as SVGElement\n\n  const box = svgViewport.getBBox()\n  const z = 1 / scale\n  const svgRect = {\n    x: Math.floor((box.x - 10) * z),\n    y: Math.floor((box.y - 10) * z),\n    width: Math.ceil((box.width + 20) * z),\n    height: Math.ceil((box.height + 20) * z),\n  }\n  target.setAttribute(\"width\", svgRect.width.toString())\n  target.setAttribute(\"height\", svgRect.height.toString())\n\n  const v = target.querySelector(\".v-ng-viewport\") as SVGGElement\n  v.setAttribute(\"transform\", `translate(${-svgRect.x} ${-svgRect.y}), scale(${z})`)\n  v.removeAttribute(\"style\")\n\n  target.setAttribute(\"viewBox\", `0 0 ${svgRect.width} ${svgRect.height}`)\n  target.removeAttribute(\"style\")\n\n  // remove comments\n  const iter = document.createNodeIterator(target, NodeFilter.SHOW_COMMENT)\n  while (iter.nextNode()) {\n    const commentNode = iter.referenceNode\n    commentNode.parentNode?.removeChild(commentNode)\n  }\n  return target\n}\n\nasync function replaceImageSourceToDataUrl(image: SVGImageElement) {\n  let useNS = false\n  let href = image.getAttribute(\"href\")\n  if (!href) {\n    useNS = true\n    href = image.getAttribute(\"xlink:href\")\n  }\n  if (!href || href.startsWith(\"data:\")) return\n\n  try {\n    const dataUrl = await urlContentToDataUrl(href)\n    image.setAttribute(useNS ? \"xlink:href\" : \"href\", dataUrl)\n  } catch (e) {\n    // output log and ignore\n    console.warn(\"Image download failed.\", href)\n    return\n  }\n}\n\nexport async function exportSvgElementWithOptions(\n  element: SVGElement,\n  svgViewport: SVGGElement,\n  scale: number,\n  options: Partial<ExportOptions> = {}\n): Promise<SVGElement> {\n  const target = exportSvgElement(element, svgViewport, scale)\n\n  if (options.embedImages) {\n    // replace image to data-uri\n    const images = Array.from(target.querySelectorAll(\"image\"))\n    const promises = images.map(img => replaceImageSourceToDataUrl(img))\n    await Promise.all(promises)\n  }\n\n  return target\n}\n","import { computed, onMounted, onUnmounted, ref, Ref, watch } from \"vue\"\nimport { debounce } from \"lodash-es\"\nimport { nonNull, Reactive } from \"@/common/common\"\nimport { Configs } from \"@/common/configs\"\nimport { Layouts, NodePositions, Point, Rectangle } from \"@/common/types\"\nimport { Vector2D } from \"@/modules/vector2d\"\nimport { NodeStates } from \"@/models/node\"\nimport { translateFromDomToSvgCoordinates } from \"@/utils/svg\"\nimport { InteractionModes } from \"./core\"\n\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\n\nexport type StopTrigger = \"pointerup\" | \"click\" | \"manual\"\nexport type SelectionType = \"append\" | \"invert\"\n\nexport interface BoxSelectionOption {\n  stop: StopTrigger\n  type: SelectionType\n  withShiftKey: SelectionType | \"same\"\n}\n\n// ------------------------------------------------------------------\n// Export functions\n// ------------------------------------------------------------------\n\nexport function makeBoxSelectionMethods(\n  container: Ref<SVGElement | undefined>,\n  modes: InteractionModes,\n  layouts: Readonly<Layouts>,\n  nodeStates: NodeStates,\n  selectedNodes: Reactive<Set<string>>,\n  configs: Configs\n) {\n  const isBoxSelectionEnabled = computed(\n    () => !!configs.node.selectable && configs.view.boxSelectionEnabled\n  )\n  const isBoxSelectionMode = computed(() => modes.viewMode.value === \"box-selection\")\n\n  // ------------------------------------------------------------------\n  // States\n  // ------------------------------------------------------------------\n  const viewport = ref<SVGGElement>()\n  const selectionBox = ref<Rectangle>()\n  const states = {\n    pointers: new Set<number>(), // Set of pointers being pressed\n    points: new Map<number, Point>(), // Point indicated by each pointer\n    startPoint: null as Point | null, // Point where the drag started\n    selectedNodesAtSelectStarted: new Set<string>(), // Nodes selected at the start of the selection\n    selectionType: \"append\" as SelectionType, // Selection method for nodes included in the dragged range\n    options: {\n      // options specified by user at start of selection mode\n      stopTrigger: \"pointerup\" as StopTrigger,\n      selectionType: \"append\" as SelectionType,\n      selectionTypeWithShiftKey: \"same\" as SelectionType | \"same\",\n    },\n  }\n\n  // ------------------------------------------------------------------\n  // Private functions\n  // ------------------------------------------------------------------\n\n  const updateNodesSelection = debounce(\n    () => {\n      _updateNodesSelection(\n        nonNull(container.value, \"container\") as SVGSVGElement,\n        nonNull(viewport.value, \"viewport\"),\n        selectionBox,\n        layouts.nodes,\n        nodeStates,\n        selectedNodes,\n        states.selectedNodesAtSelectStarted,\n        states.selectionType\n      )\n    },\n    50,\n    { maxWait: 100 }\n  )\n\n  // ------------------------------------------------------------------\n  // Pointer event handlers\n  // ------------------------------------------------------------------\n  const pointerEventHandler = new PointerEventRegistrar(\n    container,\n    handlePointerDownEvent,\n    handlePointerUpEvent,\n    handlePointerMoveEvent,\n    handleClickEvent,\n    handleKeyDownEvent\n  )\n\n  function handleClickEvent(event: MouseEvent) {\n    if (states.options.stopTrigger !== \"click\") return\n    if (states.pointers.size > 0) return\n\n    const point = { x: event.offsetX, y: event.offsetY }\n    if (states.startPoint && Vector2D.fromObject(states.startPoint).distance(point) > 10) {\n      return // ignore in dragging\n    }\n    stopBoxSelection()\n  }\n\n  function handlePointerDownEvent(event: PointerEvent) {\n    event.stopPropagation()\n\n    const point = { x: event.offsetX, y: event.offsetY }\n    if (states.pointers.size === 0) {\n      states.startPoint = point\n\n      pointerEventHandler.activate()\n\n      states.selectedNodesAtSelectStarted.clear()\n      selectedNodes.forEach(nodeId => states.selectedNodesAtSelectStarted.add(nodeId))\n      if (states.options.selectionTypeWithShiftKey === \"same\") {\n        states.selectionType = states.options.selectionType\n      } else {\n        states.selectionType = event.shiftKey\n          ? states.options.selectionTypeWithShiftKey\n          : states.options.selectionType\n      }\n    }\n    if (!states.pointers.has(event.pointerId)) {\n      states.pointers.add(event.pointerId)\n    }\n    states.points.set(event.pointerId, point)\n    updateRectangle()\n  }\n\n  function handlePointerUpEvent(event: PointerEvent) {\n    states.pointers.delete(event.pointerId)\n    if (states.pointers.size === 1) {\n      const rect = nonNull(container.value).getBoundingClientRect()\n      const point = { x: event.x - rect.x, y: event.y - rect.y }\n      states.startPoint = point\n    } else if (states.pointers.size === 0) {\n      pointerEventHandler.deactivate()\n      if (states.options.stopTrigger === \"pointerup\") {\n        stopBoxSelection()\n      }\n      states.selectedNodesAtSelectStarted.clear()\n    }\n    updateRectangle()\n  }\n\n  function handlePointerMoveEvent(event: PointerEvent) {\n    const rect = nonNull(container.value).getBoundingClientRect()\n    const point = { x: event.x - rect.x, y: event.y - rect.y }\n    states.points.set(event.pointerId, point)\n    updateRectangle()\n    updateNodesSelection()\n  }\n\n  function handleKeyDownEvent(event: KeyboardEvent) {\n    if (event.key === \"Escape\" && states.options.stopTrigger !== \"manual\") {\n      event.stopPropagation()\n      stopBoxSelection()\n    }\n  }\n\n  function updateRectangle() {\n    let pos1: Point | undefined\n    let pos2: Point | undefined\n    const pointerArray = Array.from(states.pointers)\n    if (pointerArray.length >= 2) {\n      const first = pointerArray[0]\n      const last = pointerArray[pointerArray.length - 1]\n      pos1 = states.points.get(first)\n      pos2 = states.points.get(last)\n    } else if (states.startPoint && pointerArray.length === 1) {\n      const first = pointerArray[0]\n      pos1 = states.startPoint\n      pos2 = states.points.get(first)\n    } else {\n      pos1 = undefined\n      pos2 = undefined\n    }\n    if (pos1 && pos2) {\n      // calculate left top position and size\n      selectionBox.value = {\n        pos: {\n          x: Math.min(pos1.x, pos2.x),\n          y: Math.min(pos1.y, pos2.y),\n        },\n        size: {\n          width: Math.abs(pos2.x - pos1.x),\n          height: Math.abs(pos2.y - pos1.y),\n        },\n      }\n      if (selectionBox.value.size.width === 0) {\n        selectionBox.value.size.width = 1\n      }\n      if (selectionBox.value.size.height === 0) {\n        selectionBox.value.size.height = 1\n      }\n    } else if (selectionBox.value) {\n      selectionBox.value = undefined\n    }\n  }\n\n  // ------------------------------------------------------------------\n  // Ctrl/Cmd key box selection\n  // ------------------------------------------------------------------\n  const keyEventRegistrar = new KeyEventRegistrar(\n    container,\n    // key down\n    (event: KeyboardEvent) => {\n      if (!isBoxSelectionEnabled.value) return\n      if (configs.view.selection.detector(event)) {\n        startBoxSelection({\n          stop: \"manual\",\n          type: \"append\",\n          withShiftKey: \"invert\",\n        })\n        keyEventRegistrar.activate()\n      }\n    },\n    // key up\n    (event: KeyboardEvent) => {\n      if (!isBoxSelectionEnabled.value) return\n      if (configs.view.selection.detector(event)) {\n        if (states.pointers.size === 0) {\n          stopBoxSelection()\n        } else {\n          states.options.stopTrigger = \"pointerup\"\n        }\n        keyEventRegistrar.deactivate()\n      }\n    }\n  )\n\n  watch(isBoxSelectionEnabled, value => {\n    if (value) {\n      keyEventRegistrar.register()\n    } else {\n      keyEventRegistrar.unregister()\n    }\n  })\n\n  // ------------------------------------------------------------------\n  // Lifecycle process\n  // ------------------------------------------------------------------\n\n  onMounted(() => {\n    viewport.value = container.value?.querySelector(\".v-ng-viewport\") as SVGGElement\n    if (isBoxSelectionEnabled.value) {\n      keyEventRegistrar.register()\n    }\n  })\n\n  onUnmounted(() => {\n    stopBoxSelection()\n    if (isBoxSelectionEnabled.value) {\n      keyEventRegistrar.unregister()\n    }\n  })\n\n  // ------------------------------------------------------------------\n  // Expose functions\n  // ------------------------------------------------------------------\n\n  function startBoxSelection(options: Partial<BoxSelectionOption> = {}) {\n    // Even if it's already in selection mode, behavior changes are acceptable.\n    states.options = {\n      stopTrigger: options.stop ?? \"pointerup\",\n      selectionType: options.type ?? \"append\",\n      selectionTypeWithShiftKey: options.withShiftKey ?? \"same\",\n    }\n\n    if (modes.viewMode.value === \"box-selection\") return\n    modes.viewMode.value = \"box-selection\"\n\n    states.pointers.clear()\n    pointerEventHandler.register()\n  }\n\n  function stopBoxSelection() {\n    if (modes.viewMode.value !== \"box-selection\") return\n    modes.viewMode.value = \"default\"\n    pointerEventHandler.unregister()\n  }\n\n  return { isBoxSelectionMode, selectionBox, startBoxSelection, stopBoxSelection }\n}\n\n// ------------------------------------------------------------------\n// Package local functions\n// ------------------------------------------------------------------\n\nfunction _updateNodesSelection(\n  svg: SVGSVGElement,\n  viewport: SVGGElement,\n  selectionBox: Ref<Rectangle | undefined>,\n  nodePositions: Readonly<NodePositions>,\n  nodeStates: Readonly<NodeStates>,\n  selectedNodes: Reactive<Set<string>>,\n  selectedNodesAtSelectStarted: Set<string>,\n  selectionType: SelectionType\n) {\n  if (!selectionBox.value) return\n  const box = selectionBox.value\n  const pos1 = translateFromDomToSvgCoordinates(svg, viewport, box.pos)\n  const pos2 = translateFromDomToSvgCoordinates(svg, viewport, {\n    x: box.pos.x + box.size.width,\n    y: box.pos.y + box.size.height,\n  })\n\n  // find enclosed nodes\n  const enclosedNodes = new Set(\n    Object.entries(nodePositions)\n      .filter(([_, pos]) => {\n        return pos1.x <= pos.x && pos.x <= pos2.x && pos1.y <= pos.y && pos.y <= pos2.y\n      })\n      .map(([nodeId, _]) => nodeId)\n  )\n\n  if (selectionType === \"append\") {\n    selectedNodes.forEach(nodeId => {\n      if (!enclosedNodes.has(nodeId)) {\n        selectedNodes.delete(nodeId)\n      }\n    })\n    enclosedNodes.forEach(nodeId => {\n      const selectable = nodeStates[nodeId]?.selectable ?? false\n      if (\n        selectable === true ||\n        (typeof selectable === \"number\" && selectedNodes.size < selectable)\n      ) {\n        selectedNodes.add(nodeId)\n      }\n    })\n  } else {\n    // selectionType === \"invert\"\n    const temporary = new Set<string>(selectedNodesAtSelectStarted)\n    temporary.forEach(nodeId => {\n      if (enclosedNodes.has(nodeId)) {\n        temporary.delete(nodeId)\n      }\n    })\n    enclosedNodes.forEach(nodeId => {\n      if (!selectedNodesAtSelectStarted.has(nodeId)) {\n        const selectable = nodeStates[nodeId]?.selectable ?? false\n        if (\n          selectable === true ||\n          (typeof selectable === \"number\" && temporary.size < selectable)\n        ) {\n          temporary.add(nodeId)\n        }\n      }\n    })\n    // replace\n    selectedNodes.clear()\n    temporary.forEach(nodeId => selectedNodes.add(nodeId))\n  }\n}\n\n// ------------------------------------------------------------------\n// Event register/unregister\n// ------------------------------------------------------------------\n\ntype KeyboardEventHandler = (event: KeyboardEvent) => void\ntype PointerEventHandler = (event: PointerEvent) => void\ntype MouseEventHandler = (event: MouseEvent) => void\n\nclass PointerEventRegistrar {\n  _container: Ref<SVGElement | undefined>\n  _handlePointerDownEvent: PointerEventHandler\n  _handlePointerUpEvent: PointerEventHandler\n  _handlePointerMoveEvent: PointerEventHandler\n  _handleClickEvent: MouseEventHandler\n  _handleKeyDownEvent: KeyboardEventHandler\n  _ignoreEvent: PointerEventHandler\n\n  constructor(\n    container: Ref<SVGElement | undefined>,\n    handlePointerDownEvent: PointerEventHandler,\n    handlePointerUpEvent: PointerEventHandler,\n    handlePointerMoveEvent: PointerEventHandler,\n    handleClickEvent: MouseEventHandler,\n    handleKeyDownEvent: KeyboardEventHandler\n  ) {\n    this._container = container\n    this._handlePointerDownEvent = handlePointerDownEvent\n    this._handlePointerUpEvent = handlePointerUpEvent\n    this._handlePointerMoveEvent = handlePointerMoveEvent\n    this._handleClickEvent = handleClickEvent\n    this._handleKeyDownEvent = handleKeyDownEvent\n    this._ignoreEvent = (event: PointerEvent) => event.stopPropagation()\n  }\n\n  register() {\n    const options = { capture: true, passive: false }\n    const container = nonNull(this._container.value, \"container\")\n    container.addEventListener(\"pointerdown\", this._handlePointerDownEvent, options)\n    container.addEventListener(\"click\", this._handleClickEvent, options)\n    container.addEventListener(\"pointerenter\", this._ignoreEvent, options)\n    container.addEventListener(\"pointerleave\", this._ignoreEvent, options)\n    document.addEventListener(\"keydown\", this._handleKeyDownEvent, options)\n  }\n\n  activate() {\n    const options = { capture: true, passive: false }\n    document.addEventListener(\"pointermove\", this._handlePointerMoveEvent, options)\n    document.addEventListener(\"pointerup\", this._handlePointerUpEvent, options)\n  }\n\n  deactivate() {\n    const options = { capture: true }\n    document.removeEventListener(\"pointermove\", this._handlePointerMoveEvent, options)\n    document.removeEventListener(\"pointerup\", this._handlePointerUpEvent, options)\n  }\n\n  unregister() {\n    this.deactivate()\n    const options = { capture: true }\n    if (this._container.value) {\n      const container = this._container.value\n      container.removeEventListener(\"pointerdown\", this._handlePointerDownEvent, options)\n      container.removeEventListener(\"click\", this._handleClickEvent, options)\n      container.removeEventListener(\"pointerenter\", this._ignoreEvent, options)\n      container.removeEventListener(\"pointerleave\", this._ignoreEvent, options)\n      document.removeEventListener(\"keydown\", this._handleKeyDownEvent, options)\n    }\n  }\n}\n\nclass KeyEventRegistrar {\n  _container: Ref<SVGElement | undefined>\n  _handleKeyDownEvent: KeyboardEventHandler\n  _handleKeyUpEvent: KeyboardEventHandler\n  _preventDefault: MouseEventHandler\n\n  constructor(\n    container: Ref<SVGElement | undefined>,\n    handleKeyDownEvent: KeyboardEventHandler,\n    handleKeyUpEvent: KeyboardEventHandler\n  ) {\n    this._container = container\n    this._handleKeyDownEvent = handleKeyDownEvent\n    this._handleKeyUpEvent = handleKeyUpEvent\n    this._preventDefault = (event: MouseEvent) => {\n      event.stopPropagation()\n      event.preventDefault()\n    }\n  }\n\n  register() {\n    document.addEventListener(\"keydown\", this._handleKeyDownEvent, { capture: true, passive: true })\n  }\n\n  activate() {\n    document.addEventListener(\"keyup\", this._handleKeyUpEvent, { capture: true, passive: true })\n    const container = nonNull(this._container.value, \"container\")\n    container.addEventListener(\"contextmenu\", this._preventDefault, { passive: false })\n  }\n\n  deactivate() {\n    document.removeEventListener(\"keyup\", this._handleKeyUpEvent, { capture: true })\n    if (this._container.value) {\n      const container = this._container.value\n      container.removeEventListener(\"contextmenu\", this._preventDefault)\n    }\n  }\n\n  unregister() {\n    this.deactivate()\n    document.removeEventListener(\"keydown\", this._handleKeyDownEvent, { capture: true })\n  }\n}\n","// Module responsible for selection state and mouse/touch operations\n\nimport { inject, InjectionKey, provide, ref, Ref, watch } from \"vue\"\nimport { Emitter } from \"mitt\"\nimport { nonNull, Reactive, ReadonlyRef } from \"@/common/common\"\nimport { Events, Layouts, Rectangle } from \"@/common/types\"\nimport { NodeStates } from \"@/models/node\"\nimport { EdgeStates } from \"@/models/edge\"\nimport { PathStates } from \"@/models/path\"\nimport { Configs } from \"@/common/configs\"\nimport { InteractionModes } from \"./core\"\nimport { makeNodeInteractionHandlers } from \"./node\"\nimport { makeEdgeInteractionHandlers } from \"./edge\"\nimport { setupContainerInteractionHandlers } from \"./container\"\nimport { makePathInteractionHandlers } from \"./path\"\nimport { BoxSelectionOption, makeBoxSelectionMethods } from \"./boxSelection\"\n\ntype NodeEventHandler<T extends Event = PointerEvent> = (node: string, event: T) => void\ntype EdgeEventHandler<T extends Event = PointerEvent> = (edge: string, event: T) => void\ntype EdgesEventHandler<T extends Event = PointerEvent> = (edges: string[], event: T) => void\ntype PathEventHandler<T extends Event = PointerEvent> = (path: string, event: T) => void\n\ninterface MouseEventHandlers {\n  selectedNodes: Reactive<Set<string>>\n  hoveredNodes: Reactive<Set<string>>\n  selectedEdges: Reactive<Set<string>>\n  hoveredEdges: Reactive<Set<string>>\n  selectedPaths: Reactive<Set<string>>\n  hoveredPaths: Reactive<Set<string>>\n\n  // for Nodes\n  handleNodePointerDownEvent: NodeEventHandler\n  handleNodePointerOverEvent: NodeEventHandler\n  handleNodePointerOutEvent: NodeEventHandler\n  handleNodeClickEvent: NodeEventHandler<MouseEvent>\n  handleNodeDoubleClickEvent: NodeEventHandler<MouseEvent>\n  handleNodeContextMenu: NodeEventHandler<MouseEvent>\n\n  // for Edges\n  handleEdgePointerDownEvent: EdgeEventHandler\n  handleEdgePointerOverEvent: EdgeEventHandler\n  handleEdgePointerOutEvent: EdgeEventHandler\n  handleEdgeClickEvent: EdgeEventHandler<MouseEvent>\n  handleEdgeDoubleClickEvent: EdgeEventHandler<MouseEvent>\n  handleEdgeContextMenu: EdgeEventHandler<MouseEvent>\n  handleEdgesPointerDownEvent: EdgesEventHandler\n  handleEdgesPointerOverEvent: EdgesEventHandler\n  handleEdgesPointerOutEvent: EdgesEventHandler\n  handleEdgesClickEvent: EdgesEventHandler<MouseEvent>\n  handleEdgesDoubleClickEvent: EdgesEventHandler<MouseEvent>\n  handleEdgesContextMenu: EdgesEventHandler<MouseEvent>\n\n  // for Paths\n  handlePathPointerDownEvent: PathEventHandler\n  handlePathPointerOverEvent: PathEventHandler\n  handlePathPointerOutEvent: PathEventHandler\n  handlePathClickEvent: PathEventHandler<MouseEvent>\n  handlePathDoubleClickEvent: PathEventHandler<MouseEvent>\n  handlePathContextMenu: PathEventHandler<MouseEvent>\n\n  // for Box Selection\n  isBoxSelectionMode: Ref<boolean>\n  selectionBox: Ref<Rectangle>\n  startBoxSelection: (options?: Partial<BoxSelectionOption>) => void\n  stopBoxSelection: () => void\n}\nconst mouseEventHandlersKey = Symbol(\"mouseEventHandlers\") as InjectionKey<MouseEventHandlers>\n\nexport function provideMouseOperation(\n  container: Ref<SVGElement | undefined>,\n  layouts: Readonly<Layouts>,\n  zoomLevel: ReadonlyRef<number>,\n  nodeStates: NodeStates,\n  edgeStates: EdgeStates,\n  pathStates: PathStates,\n  selectedNodes: Reactive<Set<string>>,\n  selectedEdges: Reactive<Set<string>>,\n  selectedPaths: Reactive<Set<string>>,\n  hoveredNodes: Reactive<Set<string>>,\n  hoveredEdges: Reactive<Set<string>>,\n  hoveredPaths: Reactive<Set<string>>,\n  isInCompatibilityModeForPath: Ref<boolean>,\n  isSvgWheelZoomEnabled: Ref<boolean>,\n  configs: Configs,\n  emitter: Emitter<Events>\n): MouseEventHandlers {\n  const modes: InteractionModes = {\n    selectionMode: ref(\"container\"),\n    viewMode: ref(\"default\"),\n  }\n\n  if (selectedNodes.size > 0) {\n    modes.selectionMode.value = \"node\"\n  } else if (selectedEdges.size > 0) {\n    modes.selectionMode.value = \"edge\"\n  } else if (selectedPaths.size > 0) {\n    modes.selectionMode.value = \"path\"\n  }\n\n  watch(modes.viewMode, mode => {\n    emitter.emit(\"view:mode\", mode)\n  })\n\n  setupContainerInteractionHandlers(container, modes, isSvgWheelZoomEnabled, emitter)\n\n  const provides = <MouseEventHandlers>{\n    selectedNodes,\n    hoveredNodes,\n    selectedEdges,\n    hoveredEdges,\n    selectedPaths,\n    hoveredPaths,\n    ...makeNodeInteractionHandlers(\n      nodeStates,\n      layouts,\n      modes,\n      hoveredNodes,\n      selectedNodes,\n      zoomLevel,\n      emitter\n    ),\n    ...makeEdgeInteractionHandlers(edgeStates, modes, hoveredEdges, selectedEdges, emitter),\n    ...makePathInteractionHandlers(\n      pathStates,\n      modes,\n      hoveredPaths,\n      selectedPaths,\n      isInCompatibilityModeForPath,\n      emitter\n    ),\n    ...makeBoxSelectionMethods(\n      container,\n      modes,\n      layouts,\n      nodeStates,\n      selectedNodes,\n      configs\n    ),\n  }\n  provide(mouseEventHandlersKey, provides)\n  return provides\n}\n\nexport function useMouseOperation(): MouseEventHandlers {\n  return nonNull(inject(mouseEventHandlersKey), \"mouseEventHandlers\")\n}\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n","import { provide, inject, InjectionKey } from \"vue\"\nimport mitt, { Emitter } from \"mitt\"\nimport { nonNull } from \"@/common/common\"\nimport { Events } from \"@/common/types\"\n\nconst eventEmitterKey = Symbol(\"emitter\") as InjectionKey<Emitter<Events>>\n\nexport function provideEventEmitter(): Emitter<Events> {\n  // event bus\n  const emitter = mitt<Events>()\n  provide(eventEmitterKey, emitter)\n  return emitter\n}\n\nexport function useEventEmitter(): Emitter<Events> {\n  return nonNull(inject(eventEmitterKey), \"event emitter\")\n}\n","module.exports = {\n  /**\n   * Get global this object\n   *\n   * @return {Object}        global this object\n   */\n  getGlobalThis: function () {\n    if (typeof globalThis !== \"undefined\") return globalThis;\n    if (typeof self !== \"undefined\") return self;\n    if (typeof window !== \"undefined\") return window;\n    if (typeof global !== \"undefined\") return global;\n    // Note: this might still return the wrong result!\n    if (typeof this !== \"undefined\") return this;\n    throw new Error(\"Unable to locate global `this`\");\n  },\n\n  /**\n   * Extends an object\n   *\n   * @param  {Object} target object to extend\n   * @param  {Object} source object to take properties from\n   * @return {Object}        extended object\n   */\n  extend: function (target, source) {\n    target = target || {};\n    for (var prop in source) {\n      // Go recursively\n      if (this.isObject(source[prop])) {\n        target[prop] = this.extend(target[prop], source[prop]);\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n    return target;\n  },\n\n  /**\n   * Checks if an object is a DOM element\n   *\n   * @param  {Object}  o HTML element or String\n   * @return {Boolean}   returns true if object is a DOM element\n   */\n  isElement: function (o) {\n    return (\n      o instanceof HTMLElement ||\n      o instanceof SVGElement ||\n      o instanceof SVGSVGElement || //DOM2\n      (o &&\n        typeof o === \"object\" &&\n        o !== null &&\n        o.nodeType === 1 &&\n        typeof o.nodeName === \"string\")\n    );\n  },\n\n  /**\n   * Checks if an object is an Object\n   *\n   * @param  {Object}  o Object\n   * @return {Boolean}   returns true if object is an Object\n   */\n  isObject: function (o) {\n    return Object.prototype.toString.call(o) === \"[object Object]\";\n  },\n\n  /**\n   * Checks if variable is Number\n   *\n   * @param  {Integer|Float}  n\n   * @return {Boolean}   returns true if variable is Number\n   */\n  isNumber: function (n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  },\n\n  /**\n   * Search for an SVG element\n   *\n   * @param  {Object|String} elementOrSelector DOM Element or selector String\n   * @return {Object|Null}                   SVG or null\n   */\n  getSvg: function (elementOrSelector) {\n    var element, svg;\n\n    if (!this.isElement(elementOrSelector)) {\n      // If selector provided\n      if (\n        typeof elementOrSelector === \"string\" ||\n        elementOrSelector instanceof String\n      ) {\n        // Try to find the element\n        element = document.querySelector(elementOrSelector);\n\n        if (!element) {\n          throw new Error(\n            \"Provided selector did not find any elements. Selector: \" +\n              elementOrSelector\n          );\n          return null;\n        }\n      } else {\n        throw new Error(\"Provided selector is not an HTML object nor String\");\n        return null;\n      }\n    } else {\n      element = elementOrSelector;\n    }\n\n    if (element.tagName.toLowerCase() === \"svg\") {\n      svg = element;\n    } else {\n      if (element.tagName.toLowerCase() === \"object\") {\n        svg = element.contentDocument.documentElement;\n      } else {\n        if (element.tagName.toLowerCase() === \"embed\") {\n          svg = element.getSVGDocument().documentElement;\n        } else {\n          if (element.tagName.toLowerCase() === \"img\") {\n            throw new Error(\n              'Cannot script an SVG in an \"img\" element. Please use an \"object\" element or an in-line SVG.'\n            );\n          } else {\n            throw new Error(\"Cannot get SVG.\");\n          }\n          return null;\n        }\n      }\n    }\n\n    return svg;\n  },\n\n  /**\n   * Attach a given context to a function\n   * @param  {Function} fn      Function\n   * @param  {Object}   context Context\n   * @return {Function}           Function with certain context\n   */\n  proxy: function (fn, context) {\n    return function () {\n      return fn.apply(context, arguments);\n    };\n  },\n\n  /**\n   * Returns object type\n   * Uses toString that returns [object SVGPoint]\n   * And than parses object type from string\n   *\n   * @param  {Object} o Any object\n   * @return {String}   Object type\n   */\n  getType: function (o) {\n    return Object.prototype.toString\n      .apply(o)\n      .replace(/^\\[object\\s/, \"\")\n      .replace(/\\]$/, \"\");\n  },\n\n  /**\n   * If it is a touch event than add clientX and clientY to event object\n   *\n   * @param  {Event} evt\n   * @param  {SVGSVGElement} svg\n   */\n  mouseAndTouchNormalize: function (evt, svg) {\n    // If no clientX then fallback\n    if (evt.clientX === void 0 || evt.clientX === null) {\n      // Fallback\n      evt.clientX = 0;\n      evt.clientY = 0;\n\n      // If it is a touch event\n      if (evt.touches !== void 0 && evt.touches.length) {\n        if (evt.touches[0].clientX !== void 0) {\n          evt.clientX = evt.touches[0].clientX;\n          evt.clientY = evt.touches[0].clientY;\n        } else if (evt.touches[0].pageX !== void 0) {\n          var rect = svg.getBoundingClientRect();\n\n          evt.clientX = evt.touches[0].pageX - rect.left;\n          evt.clientY = evt.touches[0].pageY - rect.top;\n        }\n        // If it is a custom event\n      } else if (evt.originalEvent !== void 0) {\n        if (evt.originalEvent.clientX !== void 0) {\n          evt.clientX = evt.originalEvent.clientX;\n          evt.clientY = evt.originalEvent.clientY;\n        }\n      }\n    }\n  },\n\n  /**\n   * If it is a touch event than add clientX and clientY to event object\n   *\n   * @param  {Event} evt\n   * @param  {SVGSVGElement} svg\n   * @param  {Number} touch\n   */\n  touchNormalize: function (evt, svg, touch) {\n    // If it is a touch event\n    if (evt.touches !== void 0 && evt.touches.length) {\n      if (evt.touches[touch].clientX !== void 0) {\n        evt.clientX = evt.touches[touch].clientX;\n        evt.clientY = evt.touches[touch].clientY;\n      } else if (evt.touches[touch].pageX !== void 0) {\n        var rect = svg.getBoundingClientRect();\n\n        evt.clientX = evt.touches[touch].pageX - rect.left;\n        evt.clientY = evt.touches[touch].pageY - rect.top;\n      }\n      // If it is a custom event\n    } else {\n      // If no clientX then fallback\n      if (evt.clientX === void 0 || evt.clientX === null) {\n        // Fallback\n        evt.clientX = 0;\n        evt.clientY = 0;\n        if (evt.originalEvent !== void 0) {\n          if (evt.originalEvent.clientX !== void 0) {\n            evt.clientX = evt.originalEvent.clientX;\n            evt.clientY = evt.originalEvent.clientY;\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * Check if an event is a double click/tap\n   * TODO: For touch gestures use a library (hammer.js) that takes in account other events\n   * (touchmove and touchend). It should take in account tap duration and traveled distance\n   *\n   * @param  {Event}  evt\n   * @param  {Event}  prevEvt Previous Event\n   * @return {Boolean}\n   */\n  isDblClick: function (evt, prevEvt) {\n    // Double click detected by browser\n    if (evt.detail === 2) {\n      return true;\n    }\n    // Try to compare events\n    else if (prevEvt !== void 0 && prevEvt !== null) {\n      var timeStampDiff = evt.timeStamp - prevEvt.timeStamp, // should be lower than 250 ms\n        touchesDistance = Math.sqrt(\n          Math.pow(evt.clientX - prevEvt.clientX, 2) +\n            Math.pow(evt.clientY - prevEvt.clientY, 2)\n        );\n\n      return timeStampDiff < 250 && touchesDistance < 10;\n    }\n\n    // Nothing found\n    return false;\n  },\n\n  /**\n   * Returns current timestamp as an integer\n   *\n   * @return {Number}\n   */\n  now:\n    Date.now ||\n    function () {\n      return new Date().getTime();\n    },\n\n  // From underscore.\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  throttle: function (func, wait, options) {\n    var that = this;\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) {\n      options = {};\n    }\n    var later = function () {\n      previous = options.leading === false ? 0 : that.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = args = null;\n      }\n    };\n    return function () {\n      var now = that.now();\n      if (!previous && options.leading === false) {\n        previous = now;\n      }\n      var remaining = wait - (now - previous);\n      context = this; // eslint-disable-line consistent-this\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) {\n          context = args = null;\n        }\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  },\n\n  /**\n   * Create a requestAnimationFrame simulation\n   *\n   * @param  {Number|String} refreshRate\n   * @return {Function}\n   */\n  createRequestAnimationFrame: function (refreshRate) {\n    var timeout = null;\n\n    // Convert refreshRate to timeout\n    if (refreshRate !== \"auto\" && refreshRate < 60 && refreshRate > 1) {\n      timeout = Math.floor(1000 / refreshRate);\n    }\n\n    if (timeout === null) {\n      return window.requestAnimationFrame || requestTimeout(33);\n    } else {\n      return requestTimeout(timeout);\n    }\n  },\n\n  /**\n   * Calculate distance of points\n   *\n   * @param  {SVGPoint} point1\n   * @param  {SVGPoint} point2\n   * @return {Number}\n   */\n  calculateDistance: function (point1, point2) {\n    var dx = point1.x - point2.x;\n    var dy = point1.y - point2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  },\n};\n\n/**\n * Create a callback that will execute after a given timeout\n *\n * @param  {Function} timeout\n * @return {Function}\n */\nfunction requestTimeout(timeout) {\n  return function (callback) {\n    window.setTimeout(callback, timeout);\n  };\n}\n","// uniwheel 0.1.2 (customized)\n// A unified cross browser mouse wheel event handler\n// https://github.com/teemualap/uniwheel\n\nvar Utils = require(\"./utilities\");\n\nmodule.exports = (function() {\n  //Full details: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel\n\n  var prefix = \"\",\n    _addEventListener,\n    _removeEventListener,\n    support,\n    fns = [];\n  var passiveTrueOption = { passive: true };\n  var passiveFalseOption = { passive: false };\n\n  // detect event model\n  if (Utils.getGlobalThis().addEventListener) {\n    _addEventListener = \"addEventListener\";\n    _removeEventListener = \"removeEventListener\";\n  } else {\n    _addEventListener = \"attachEvent\";\n    _removeEventListener = \"detachEvent\";\n    prefix = \"on\";\n  }\n\n  function getSupport() {\n    if (!support) {\n      support =\n        \"onwheel\" in document.createElement(\"div\")\n          ? \"wheel\" // Modern browsers support \"wheel\"\n          : document.onmousewheel !== undefined\n          ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\n          : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n    }\n    return support;\n  }\n\n  function createCallback(element, callback) {\n    // detect available wheel event\n\n    var fn = function(originalEvent) {\n      !originalEvent && (originalEvent = window.event);\n\n      // create a normalized event object\n      var event = {\n        // keep a ref to the original event object\n        originalEvent: originalEvent,\n        target: originalEvent.target || originalEvent.srcElement,\n        type: \"wheel\",\n        deltaMode: originalEvent.type == \"MozMousePixelScroll\" ? 0 : 1,\n        deltaX: 0,\n        delatZ: 0,\n        preventDefault: function() {\n          originalEvent.preventDefault\n            ? originalEvent.preventDefault()\n            : (originalEvent.returnValue = false);\n        }\n      };\n\n      // calculate deltaY (and deltaX) according to the event\n      if (getSupport() == \"mousewheel\") {\n        event.deltaY = (-1 / 40) * originalEvent.wheelDelta;\n        // Webkit also support wheelDeltaX\n        originalEvent.wheelDeltaX &&\n          (event.deltaX = (-1 / 40) * originalEvent.wheelDeltaX);\n      } else {\n        event.deltaY = originalEvent.detail;\n      }\n\n      // it's time to fire the callback\n      return callback(event);\n    };\n\n    fns.push({\n      element: element,\n      fn: fn\n    });\n\n    return fn;\n  }\n\n  function getCallback(element) {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].element === element) {\n        return fns[i].fn;\n      }\n    }\n    return function() {};\n  }\n\n  function removeCallback(element) {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].element === element) {\n        return fns.splice(i, 1);\n      }\n    }\n  }\n\n  function _addWheelListener(elem, eventName, callback, isPassiveListener) {\n    var cb;\n\n    if (getSupport() === \"wheel\") {\n      cb = callback;\n    } else {\n      cb = createCallback(elem, callback);\n    }\n\n    elem[_addEventListener](\n      prefix + eventName,\n      cb,\n      isPassiveListener ? passiveTrueOption : passiveFalseOption\n    );\n  }\n\n  function _removeWheelListener(elem, eventName, callback, isPassiveListener) {\n    var cb;\n\n    if (getSupport() === \"wheel\") {\n      cb = callback;\n    } else {\n      cb = getCallback(elem);\n    }\n\n    elem[_removeEventListener](\n      prefix + eventName,\n      cb,\n      isPassiveListener ? passiveTrueOption : passiveFalseOption\n    );\n\n    removeCallback(elem);\n  }\n\n  function addWheelListener(elem, callback, isPassiveListener) {\n    _addWheelListener(elem, getSupport(), callback, isPassiveListener);\n\n    // handle MozMousePixelScroll in older Firefox\n    if (getSupport() == \"DOMMouseScroll\") {\n      _addWheelListener(\n        elem,\n        \"MozMousePixelScroll\",\n        callback,\n        isPassiveListener\n      );\n    }\n  }\n\n  function removeWheelListener(elem, callback, isPassiveListener) {\n    _removeWheelListener(elem, getSupport(), callback, isPassiveListener);\n\n    // handle MozMousePixelScroll in older Firefox\n    if (getSupport() == \"DOMMouseScroll\") {\n      _removeWheelListener(\n        elem,\n        \"MozMousePixelScroll\",\n        callback,\n        isPassiveListener\n      );\n    }\n  }\n\n  return {\n    on: addWheelListener,\n    off: removeWheelListener\n  };\n})();\n","var Utils = require(\"./utilities\"),\n  _browser = \"unknown\";\n\n// http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\nif (\n  /*@cc_on!@*/ false ||\n  (typeof document != \"undefined\" && !!document.documentMode)\n) {\n  // internet explorer\n  _browser = \"ie\";\n}\n\nmodule.exports = {\n  svgNS: \"http://www.w3.org/2000/svg\",\n  xmlNS: \"http://www.w3.org/XML/1998/namespace\",\n  xmlnsNS: \"http://www.w3.org/2000/xmlns/\",\n  xlinkNS: \"http://www.w3.org/1999/xlink\",\n  evNS: \"http://www.w3.org/2001/xml-events\",\n\n  /**\n   * Get svg dimensions: width and height\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {Object}     {width: 0, height: 0}\n   */\n  getBoundingClientRectNormalized: function (svg) {\n    if (svg.clientWidth && svg.clientHeight) {\n      return { width: svg.clientWidth, height: svg.clientHeight };\n    } else if (!!svg.getBoundingClientRect()) {\n      return svg.getBoundingClientRect();\n    } else {\n      throw new Error(\"Cannot get BoundingClientRect for SVG.\");\n    }\n  },\n\n  /**\n   * Gets g element with class of \"viewport\" or creates it if it doesn't exist\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {SVGElement}     g (group) element\n   */\n  getOrCreateViewport: function (svg, selector) {\n    var viewport = null;\n\n    if (Utils.isElement(selector)) {\n      viewport = selector;\n    } else {\n      viewport = svg.querySelector(selector);\n    }\n\n    // Check if there is just one main group in SVG\n    if (!viewport) {\n      var childNodes = Array.prototype.slice\n        .call(svg.childNodes || svg.children)\n        .filter(function (el) {\n          return el.nodeName !== \"defs\" && el.nodeName !== \"#text\";\n        });\n\n      // Node name should be SVGGElement and should have no transform attribute\n      // Groups with transform are not used as viewport because it involves parsing of all transform possibilities\n      if (\n        childNodes.length === 1 &&\n        childNodes[0].nodeName === \"g\" &&\n        childNodes[0].getAttribute(\"transform\") === null\n      ) {\n        viewport = childNodes[0];\n      }\n    }\n\n    // If no favorable group element exists then create one\n    if (!viewport) {\n      var viewportId =\n        \"viewport-\" + new Date().toISOString().replace(/\\D/g, \"\");\n      viewport = document.createElementNS(this.svgNS, \"g\");\n      viewport.setAttribute(\"id\", viewportId);\n\n      // Internet Explorer (all versions?) can't use childNodes, but other browsers prefer (require?) using childNodes\n      var svgChildren = svg.childNodes || svg.children;\n      if (!!svgChildren && svgChildren.length > 0) {\n        for (var i = svgChildren.length; i > 0; i--) {\n          // Move everything into viewport except defs\n          if (svgChildren[svgChildren.length - i].nodeName !== \"defs\") {\n            viewport.appendChild(svgChildren[svgChildren.length - i]);\n          }\n        }\n      }\n      svg.appendChild(viewport);\n    }\n\n    // Parse class names\n    var classNames = [];\n    if (viewport.getAttribute(\"class\")) {\n      classNames = viewport.getAttribute(\"class\").split(\" \");\n    }\n\n    // Set class (if not set already)\n    if (!~classNames.indexOf(\"svg-pan-zoom_viewport\")) {\n      classNames.push(\"svg-pan-zoom_viewport\");\n      viewport.setAttribute(\"class\", classNames.join(\" \"));\n    }\n\n    return viewport;\n  },\n\n  /**\n   * Set SVG attributes\n   *\n   * @param  {SVGSVGElement} svg\n   */\n  setupSvgAttributes: function (svg) {\n    // Setting default attributes\n    svg.setAttribute(\"xmlns\", this.svgNS);\n    svg.setAttributeNS(this.xmlnsNS, \"xmlns:xlink\", this.xlinkNS);\n    svg.setAttributeNS(this.xmlnsNS, \"xmlns:ev\", this.evNS);\n\n    // Needed for Internet Explorer, otherwise the viewport overflows\n    if (svg.parentNode !== null) {\n      var style = svg.getAttribute(\"style\") || \"\";\n      if (style.toLowerCase().indexOf(\"overflow\") === -1) {\n        svg.setAttribute(\"style\", \"overflow: hidden; \" + style);\n      }\n    }\n  },\n\n  /**\n   * How long Internet Explorer takes to finish updating its display (ms).\n   */\n  internetExplorerRedisplayInterval: 300,\n\n  /**\n   * Forces the browser to redisplay all SVG elements that rely on an\n   * element defined in a 'defs' section. It works globally, for every\n   * available defs element on the page.\n   * The throttling is intentionally global.\n   *\n   * This is only needed for IE. It is as a hack to make markers (and 'use' elements?)\n   * visible after pan/zoom when there are multiple SVGs on the page.\n   * See bug report: https://connect.microsoft.com/IE/feedback/details/781964/\n   * also see svg-pan-zoom issue: https://github.com/ariutta/svg-pan-zoom/issues/62\n   */\n  refreshDefsGlobal: Utils.throttle(\n    function () {\n      var allDefs = document.querySelectorAll(\"defs\");\n      var allDefsCount = allDefs.length;\n      for (var i = 0; i < allDefsCount; i++) {\n        var thisDefs = allDefs[i];\n        thisDefs.parentNode.insertBefore(thisDefs, thisDefs);\n      }\n    },\n    this ? this.internetExplorerRedisplayInterval : null\n  ),\n\n  /**\n   * Sets the current transform matrix of an element\n   *\n   * @param {SVGElement} element\n   * @param {SVGMatrix} matrix  CTM\n   * @param {SVGElement} defs\n   */\n  setCTM: function (element, matrix, defs) {\n    var that = this,\n      s =\n        \"matrix(\" +\n        matrix.a +\n        \",\" +\n        matrix.b +\n        \",\" +\n        matrix.c +\n        \",\" +\n        matrix.d +\n        \",\" +\n        matrix.e +\n        \",\" +\n        matrix.f +\n        \")\";\n\n    element.setAttributeNS(null, \"transform\", s);\n    if (\"transform\" in element.style) {\n      element.style.transform = s;\n    } else if (\"-ms-transform\" in element.style) {\n      element.style[\"-ms-transform\"] = s;\n    } else if (\"-webkit-transform\" in element.style) {\n      element.style[\"-webkit-transform\"] = s;\n    }\n\n    // IE has a bug that makes markers disappear on zoom (when the matrix \"a\" and/or \"d\" elements change)\n    // see http://stackoverflow.com/questions/17654578/svg-marker-does-not-work-in-ie9-10\n    // and http://srndolha.wordpress.com/2013/11/25/svg-line-markers-may-disappear-in-internet-explorer-11/\n    if (_browser === \"ie\" && !!defs) {\n      // this refresh is intended for redisplaying the SVG during zooming\n      defs.parentNode.insertBefore(defs, defs);\n      // this refresh is intended for redisplaying the other SVGs on a page when panning a given SVG\n      // it is also needed for the given SVG itself, on zoomEnd, if the SVG contains any markers that\n      // are located under any other element(s).\n      window.setTimeout(function () {\n        that.refreshDefsGlobal();\n      }, that.internetExplorerRedisplayInterval);\n    }\n  },\n\n  /**\n   * Instantiate an SVGPoint object with given event coordinates\n   *\n   * @param {Event} evt\n   * @param  {SVGSVGElement} svg\n   * @return {SVGPoint}     point\n   */\n  getEventPoint: function (evt, svg) {\n    var point = svg.createSVGPoint();\n\n    Utils.mouseAndTouchNormalize(evt, svg);\n\n    point.x = evt.clientX;\n    point.y = evt.clientY;\n\n    return point;\n  },\n\n  /**\n   * Instantiate an SVGPoint object with given touch event coordinates\n   *\n   * @param {Event} evt\n   * @param  {SVGSVGElement} svg\n   * @param  {Number} touch\n   * @return {SVGPoint}     point\n   */\n  getTouchPoint: function (evt, svg, touch) {\n    var point = svg.createSVGPoint();\n\n    Utils.touchNormalize(evt, svg, touch);\n\n    point.x = evt.clientX;\n    point.y = evt.clientY;\n\n    return point;\n  },\n\n  /**\n   * Get SVG center point\n   *\n   * @param  {SVGSVGElement} svg\n   * @return {SVGPoint}\n   */\n  getSvgCenterPoint: function (svg, width, height) {\n    return this.createSVGPoint(svg, width / 2, height / 2);\n  },\n\n  /**\n   * Create a SVGPoint with given x and y\n   *\n   * @param  {SVGSVGElement} svg\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {SVGPoint}\n   */\n  createSVGPoint: function (svg, x, y) {\n    var point = svg.createSVGPoint();\n    point.x = x;\n    point.y = y;\n\n    return point;\n  },\n};\n","var SvgUtils = require(\"./svg-utilities\");\n\nmodule.exports = {\n  enable: function (instance) {\n    // Select (and create if necessary) defs\n    var defs = instance.svg.querySelector(\"defs\");\n    if (!defs) {\n      defs = document.createElementNS(SvgUtils.svgNS, \"defs\");\n      instance.svg.appendChild(defs);\n    }\n\n    // Check for style element, and create it if it doesn't exist\n    var styleEl = defs.querySelector(\"style#svg-pan-zoom-controls-styles\");\n    if (!styleEl) {\n      var style = document.createElementNS(SvgUtils.svgNS, \"style\");\n      style.setAttribute(\"id\", \"svg-pan-zoom-controls-styles\");\n      style.setAttribute(\"type\", \"text/css\");\n      style.textContent =\n        \".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }\";\n      defs.appendChild(style);\n    }\n\n    // Zoom Group\n    var zoomGroup = document.createElementNS(SvgUtils.svgNS, \"g\");\n    zoomGroup.setAttribute(\"id\", \"svg-pan-zoom-controls\");\n    zoomGroup.setAttribute(\n      \"transform\",\n      \"translate(\" +\n        (instance.width - 70) +\n        \" \" +\n        (instance.height - 76) +\n        \") scale(0.75)\"\n    );\n    zoomGroup.setAttribute(\"class\", \"svg-pan-zoom-control\");\n\n    // Control elements\n    zoomGroup.appendChild(this._createZoomIn(instance));\n    zoomGroup.appendChild(this._createZoomReset(instance));\n    zoomGroup.appendChild(this._createZoomOut(instance));\n\n    // Finally append created element\n    instance.svg.appendChild(zoomGroup);\n\n    // Cache control instance\n    instance.controlIcons = zoomGroup;\n  },\n\n  _createZoomIn: function (instance) {\n    var zoomIn = document.createElementNS(SvgUtils.svgNS, \"g\");\n    zoomIn.setAttribute(\"id\", \"svg-pan-zoom-zoom-in\");\n    zoomIn.setAttribute(\"transform\", \"translate(30.5 5) scale(0.015)\");\n    zoomIn.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    zoomIn.addEventListener(\n      \"click\",\n      function () {\n        instance.getPublicInstance().zoomIn();\n      },\n      false\n    );\n    zoomIn.addEventListener(\n      \"touchstart\",\n      function () {\n        instance.getPublicInstance().zoomIn();\n      },\n      false\n    );\n\n    var zoomInBackground = document.createElementNS(SvgUtils.svgNS, \"rect\"); // TODO change these background space fillers to rounded rectangles so they look prettier\n    zoomInBackground.setAttribute(\"x\", \"0\");\n    zoomInBackground.setAttribute(\"y\", \"0\");\n    zoomInBackground.setAttribute(\"width\", \"1500\"); // larger than expected because the whole group is transformed to scale down\n    zoomInBackground.setAttribute(\"height\", \"1400\");\n    zoomInBackground.setAttribute(\"class\", \"svg-pan-zoom-control-background\");\n    zoomIn.appendChild(zoomInBackground);\n\n    var zoomInShape = document.createElementNS(SvgUtils.svgNS, \"path\");\n    zoomInShape.setAttribute(\n      \"d\",\n      \"M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z\"\n    );\n    zoomInShape.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    zoomIn.appendChild(zoomInShape);\n\n    return zoomIn;\n  },\n\n  _createZoomReset: function (instance) {\n    // reset\n    var resetPanZoomControl = document.createElementNS(SvgUtils.svgNS, \"g\");\n    resetPanZoomControl.setAttribute(\"id\", \"svg-pan-zoom-reset-pan-zoom\");\n    resetPanZoomControl.setAttribute(\"transform\", \"translate(5 35) scale(0.4)\");\n    resetPanZoomControl.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    resetPanZoomControl.addEventListener(\n      \"click\",\n      function () {\n        instance.getPublicInstance().reset();\n      },\n      false\n    );\n    resetPanZoomControl.addEventListener(\n      \"touchstart\",\n      function () {\n        instance.getPublicInstance().reset();\n      },\n      false\n    );\n\n    var resetPanZoomControlBackground = document.createElementNS(\n      SvgUtils.svgNS,\n      \"rect\"\n    ); // TODO change these background space fillers to rounded rectangles so they look prettier\n    resetPanZoomControlBackground.setAttribute(\"x\", \"2\");\n    resetPanZoomControlBackground.setAttribute(\"y\", \"2\");\n    resetPanZoomControlBackground.setAttribute(\"width\", \"182\"); // larger than expected because the whole group is transformed to scale down\n    resetPanZoomControlBackground.setAttribute(\"height\", \"58\");\n    resetPanZoomControlBackground.setAttribute(\n      \"class\",\n      \"svg-pan-zoom-control-background\"\n    );\n    resetPanZoomControl.appendChild(resetPanZoomControlBackground);\n\n    var resetPanZoomControlShape1 = document.createElementNS(\n      SvgUtils.svgNS,\n      \"path\"\n    );\n    resetPanZoomControlShape1.setAttribute(\n      \"d\",\n      \"M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z\"\n    );\n    resetPanZoomControlShape1.setAttribute(\n      \"class\",\n      \"svg-pan-zoom-control-element\"\n    );\n    resetPanZoomControl.appendChild(resetPanZoomControlShape1);\n\n    var resetPanZoomControlShape2 = document.createElementNS(\n      SvgUtils.svgNS,\n      \"path\"\n    );\n    resetPanZoomControlShape2.setAttribute(\n      \"d\",\n      \"M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z\"\n    );\n    resetPanZoomControlShape2.setAttribute(\n      \"class\",\n      \"svg-pan-zoom-control-element\"\n    );\n    resetPanZoomControl.appendChild(resetPanZoomControlShape2);\n\n    return resetPanZoomControl;\n  },\n\n  _createZoomOut: function (instance) {\n    // zoom out\n    var zoomOut = document.createElementNS(SvgUtils.svgNS, \"g\");\n    zoomOut.setAttribute(\"id\", \"svg-pan-zoom-zoom-out\");\n    zoomOut.setAttribute(\"transform\", \"translate(30.5 70) scale(0.015)\");\n    zoomOut.setAttribute(\"class\", \"svg-pan-zoom-control\");\n    zoomOut.addEventListener(\n      \"click\",\n      function () {\n        instance.getPublicInstance().zoomOut();\n      },\n      false\n    );\n    zoomOut.addEventListener(\n      \"touchstart\",\n      function () {\n        instance.getPublicInstance().zoomOut();\n      },\n      false\n    );\n\n    var zoomOutBackground = document.createElementNS(SvgUtils.svgNS, \"rect\"); // TODO change these background space fillers to rounded rectangles so they look prettier\n    zoomOutBackground.setAttribute(\"x\", \"0\");\n    zoomOutBackground.setAttribute(\"y\", \"0\");\n    zoomOutBackground.setAttribute(\"width\", \"1500\"); // larger than expected because the whole group is transformed to scale down\n    zoomOutBackground.setAttribute(\"height\", \"1400\");\n    zoomOutBackground.setAttribute(\"class\", \"svg-pan-zoom-control-background\");\n    zoomOut.appendChild(zoomOutBackground);\n\n    var zoomOutShape = document.createElementNS(SvgUtils.svgNS, \"path\");\n    zoomOutShape.setAttribute(\n      \"d\",\n      \"M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z\"\n    );\n    zoomOutShape.setAttribute(\"class\", \"svg-pan-zoom-control-element\");\n    zoomOut.appendChild(zoomOutShape);\n\n    return zoomOut;\n  },\n\n  disable: function (instance) {\n    if (instance.controlIcons) {\n      instance.controlIcons.parentNode.removeChild(instance.controlIcons);\n      instance.controlIcons = null;\n    }\n  },\n};\n","var SvgUtils = require(\"./svg-utilities\"),\n  Utils = require(\"./utilities\");\n\nvar ShadowViewport = function (viewport, options) {\n  this.init(viewport, options);\n};\n\n/**\n * Initialization\n *\n * @param  {SVGElement} viewport\n * @param  {Object} options\n */\nShadowViewport.prototype.init = function (viewport, options) {\n  // DOM Elements\n  this.viewport = viewport;\n  this.options = options;\n\n  // State cache\n  this.originalState = { zoom: 1, x: 0, y: 0 };\n  this.activeState = { zoom: 1, x: 0, y: 0 };\n\n  this.updateCTMCached = Utils.proxy(this.updateCTM, this);\n\n  // Create a custom requestAnimationFrame taking in account refreshRate\n  this.requestAnimationFrame = Utils.createRequestAnimationFrame(\n    this.options.refreshRate\n  );\n\n  // ViewBox\n  this.viewBox = { x: 0, y: 0, width: 0, height: 0 };\n  this.cacheViewBox();\n\n  // Process CTM\n  var newCTM = this.processCTM();\n\n  // Update viewport CTM and cache zoom and pan\n  this.setCTM(newCTM);\n\n  // Update CTM in this frame\n  this.updateCTM();\n};\n\n/**\n * Cache initial viewBox value\n * If no viewBox is defined, then use viewport size/position instead for viewBox values\n */\nShadowViewport.prototype.cacheViewBox = function () {\n  var svgViewBox = this.options.svg.getAttribute(\"viewBox\");\n\n  if (svgViewBox) {\n    var viewBoxValues = svgViewBox\n      .split(/[\\s\\,]/)\n      .filter(function (v) {\n        return v;\n      })\n      .map(parseFloat);\n\n    // Cache viewbox x and y offset\n    this.viewBox.x = viewBoxValues[0];\n    this.viewBox.y = viewBoxValues[1];\n    this.viewBox.width = viewBoxValues[2];\n    this.viewBox.height = viewBoxValues[3];\n\n    var zoom = Math.min(\n      this.options.width / this.viewBox.width,\n      this.options.height / this.viewBox.height\n    );\n\n    // Update active state\n    this.activeState.zoom = isFinite(zoom) ? zoom : 1;\n    this.activeState.x = (this.options.width - this.viewBox.width * zoom) / 2;\n    this.activeState.y = (this.options.height - this.viewBox.height * zoom) / 2;\n\n    // Force updating CTM\n    this.updateCTMOnNextFrame();\n\n    this.options.svg.removeAttribute(\"viewBox\");\n  } else {\n    this.simpleViewBoxCache();\n  }\n};\n\n/**\n * Recalculate viewport sizes and update viewBox cache\n */\nShadowViewport.prototype.simpleViewBoxCache = function () {\n  var bBox = this.viewport.getBBox();\n\n  this.viewBox.x = bBox.x;\n  this.viewBox.y = bBox.y;\n  this.viewBox.width = bBox.width;\n  this.viewBox.height = bBox.height;\n};\n\n/**\n * Returns a viewbox object. Safe to alter\n *\n * @return {Object} viewbox object\n */\nShadowViewport.prototype.getViewBox = function () {\n  return Utils.extend({}, this.viewBox);\n};\n\n/**\n * Get initial zoom and pan values. Save them into originalState\n * Parses viewBox attribute to alter initial sizes\n *\n * @return {CTM} CTM object based on options\n */\nShadowViewport.prototype.processCTM = function () {\n  var newCTM = this.getCTM();\n\n  if (this.options.fit || this.options.contain) {\n    var newScale;\n    if (this.options.fit) {\n      newScale = Math.min(\n        this.options.width / this.viewBox.width,\n        this.options.height / this.viewBox.height\n      );\n    } else {\n      newScale = Math.max(\n        this.options.width / this.viewBox.width,\n        this.options.height / this.viewBox.height\n      );\n    }\n\n    newScale = isFinite(newScale) ? newScale : 1;\n\n    newCTM.a = newScale; //x-scale\n    newCTM.d = newScale; //y-scale\n    newCTM.e = -this.viewBox.x * newScale; //x-transform\n    newCTM.f = -this.viewBox.y * newScale; //y-transform\n  }\n\n  if (this.options.center) {\n    var offsetX =\n        (this.options.width -\n          (this.viewBox.width + this.viewBox.x * 2) * newCTM.a) *\n        0.5,\n      offsetY =\n        (this.options.height -\n          (this.viewBox.height + this.viewBox.y * 2) * newCTM.a) *\n        0.5;\n\n    newCTM.e = offsetX;\n    newCTM.f = offsetY;\n  }\n\n  // Cache initial values. Based on activeState and fix+center opitons\n  this.originalState.zoom = newCTM.a;\n  this.originalState.x = newCTM.e;\n  this.originalState.y = newCTM.f;\n\n  return newCTM;\n};\n\n/**\n * Return originalState object. Safe to alter\n *\n * @return {Object}\n */\nShadowViewport.prototype.getOriginalState = function () {\n  return Utils.extend({}, this.originalState);\n};\n\n/**\n * Return actualState object. Safe to alter\n *\n * @return {Object}\n */\nShadowViewport.prototype.getState = function () {\n  return Utils.extend({}, this.activeState);\n};\n\n/**\n * Get zoom scale\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.getZoom = function () {\n  return this.activeState.zoom;\n};\n\n/**\n * Get zoom scale for pubilc usage\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.getRelativeZoom = function () {\n  return this.activeState.zoom / this.originalState.zoom;\n};\n\n/**\n * Compute zoom scale for pubilc usage\n *\n * @return {Float} zoom scale\n */\nShadowViewport.prototype.computeRelativeZoom = function (scale) {\n  return scale / this.originalState.zoom;\n};\n\n/**\n * Get pan\n *\n * @return {Object}\n */\nShadowViewport.prototype.getPan = function () {\n  return { x: this.activeState.x, y: this.activeState.y };\n};\n\n/**\n * Return cached viewport CTM value that can be safely modified\n *\n * @return {SVGMatrix}\n */\nShadowViewport.prototype.getCTM = function () {\n  var safeCTM = this.options.svg.createSVGMatrix();\n\n  // Copy values manually as in FF they are not itterable\n  safeCTM.a = this.activeState.zoom;\n  safeCTM.b = 0;\n  safeCTM.c = 0;\n  safeCTM.d = this.activeState.zoom;\n  safeCTM.e = this.activeState.x;\n  safeCTM.f = this.activeState.y;\n\n  return safeCTM;\n};\n\n/**\n * Set a new CTM\n *\n * @param {SVGMatrix} newCTM\n */\nShadowViewport.prototype.setCTM = function (newCTM) {\n  var willZoom = this.isZoomDifferent(newCTM),\n    willPan = this.isPanDifferent(newCTM);\n\n  if (willZoom || willPan) {\n    // Before zoom\n    if (willZoom) {\n      // If returns false then cancel zooming\n      if (\n        this.options.beforeZoom(\n          this.getRelativeZoom(),\n          this.computeRelativeZoom(newCTM.a)\n        ) === false\n      ) {\n        newCTM.a = newCTM.d = this.activeState.zoom;\n        willZoom = false;\n      } else {\n        this.updateCache(newCTM);\n        this.options.onZoom(this.getRelativeZoom());\n      }\n    }\n\n    // Before pan\n    if (willPan) {\n      var preventPan = this.options.beforePan(this.getPan(), {\n          x: newCTM.e,\n          y: newCTM.f,\n        }),\n        // If prevent pan is an object\n        preventPanX = false,\n        preventPanY = false;\n\n      // If prevent pan is Boolean false\n      if (preventPan === false) {\n        // Set x and y same as before\n        newCTM.e = this.getPan().x;\n        newCTM.f = this.getPan().y;\n\n        preventPanX = preventPanY = true;\n      } else if (Utils.isObject(preventPan)) {\n        // Check for X axes attribute\n        if (preventPan.x === false) {\n          // Prevent panning on x axes\n          newCTM.e = this.getPan().x;\n          preventPanX = true;\n        } else if (Utils.isNumber(preventPan.x)) {\n          // Set a custom pan value\n          newCTM.e = preventPan.x;\n        }\n\n        // Check for Y axes attribute\n        if (preventPan.y === false) {\n          // Prevent panning on x axes\n          newCTM.f = this.getPan().y;\n          preventPanY = true;\n        } else if (Utils.isNumber(preventPan.y)) {\n          // Set a custom pan value\n          newCTM.f = preventPan.y;\n        }\n      }\n\n      // Update willPan flag\n      // Check if newCTM is still different\n      if ((preventPanX && preventPanY) || !this.isPanDifferent(newCTM)) {\n        willPan = false;\n      } else {\n        this.updateCache(newCTM);\n        this.options.onPan(this.getPan());\n      }\n    }\n\n    // Check again if should zoom or pan\n    if (willZoom || willPan) {\n      this.updateCTMOnNextFrame();\n    }\n  }\n};\n\nShadowViewport.prototype.isZoomDifferent = function (newCTM) {\n  return this.activeState.zoom !== newCTM.a;\n};\n\nShadowViewport.prototype.isPanDifferent = function (newCTM) {\n  return this.activeState.x !== newCTM.e || this.activeState.y !== newCTM.f;\n};\n\n/**\n * Update cached CTM and active state\n *\n * @param {SVGMatrix} newCTM\n */\nShadowViewport.prototype.updateCache = function (newCTM) {\n  this.activeState.zoom = newCTM.a;\n  this.activeState.x = newCTM.e;\n  this.activeState.y = newCTM.f;\n};\n\nShadowViewport.prototype.pendingUpdate = false;\n\n/**\n * Place a request to update CTM on next Frame\n */\nShadowViewport.prototype.updateCTMOnNextFrame = function () {\n  if (!this.pendingUpdate) {\n    // Lock\n    this.pendingUpdate = true;\n\n    // Throttle next update\n    this.requestAnimationFrame.call(window, this.updateCTMCached);\n  }\n};\n\n/**\n * Update viewport CTM with cached CTM\n */\nShadowViewport.prototype.updateCTM = function () {\n  var ctm = this.getCTM();\n\n  // Updates SVG element\n  SvgUtils.setCTM(this.viewport, ctm, this.defs);\n\n  // Free the lock\n  this.pendingUpdate = false;\n\n  // Notify about the update\n  if (this.options.onUpdatedCTM) {\n    this.options.onUpdatedCTM(ctm);\n  }\n};\n\nmodule.exports = function (viewport, options) {\n  return new ShadowViewport(viewport, options);\n};\n","var Wheel = require(\"./uniwheel\"),\n  ControlIcons = require(\"./control-icons\"),\n  Utils = require(\"./utilities\"),\n  SvgUtils = require(\"./svg-utilities\"),\n  ShadowViewport = require(\"./shadow-viewport\");\n\nvar SvgPanZoom = function (svg, options) {\n  this.init(svg, options);\n};\n\nvar optionsDefaults = {\n  viewportSelector: \".svg-pan-zoom_viewport\", // Viewport selector. Can be querySelector string or SVGElement\n  panEnabled: true, // enable or disable panning (default enabled)\n  controlIconsEnabled: false, // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)\n  zoomEnabled: true, // enable or disable zooming (default enabled)\n  dblClickZoomEnabled: true, // enable or disable zooming by double clicking (default enabled)\n  mouseWheelZoomEnabled: true, // enable or disable zooming by mouse wheel (default enabled)\n  preventMouseEventsDefault: true, // enable or disable preventDefault for mouse events\n  zoomScaleSensitivity: 0.1, // Zoom sensitivity\n  minZoom: 0.5, // Minimum Zoom level\n  maxZoom: 10, // Maximum Zoom level\n  fit: true, // enable or disable viewport fit in SVG (default true)\n  contain: false, // enable or disable viewport contain the svg (default false)\n  center: true, // enable or disable viewport centering in SVG (default true)\n  refreshRate: \"auto\", // Maximum number of frames per second (altering SVG's viewport)\n  beforeZoom: null,\n  onZoom: null,\n  beforePan: null,\n  onPan: null,\n  customEventsHandler: null,\n  eventsListenerElement: null,\n  onUpdatedCTM: null,\n};\n\nvar passiveListenerTrueOption = { passive: true };\nvar passiveListenerFalseOption = { passive: false };\n\nSvgPanZoom.prototype.init = function (svg, options) {\n  var that = this;\n\n  this.svg = svg;\n  this.defs = svg.querySelector(\"defs\");\n\n  // Add default attributes to SVG\n  SvgUtils.setupSvgAttributes(this.svg);\n\n  // Set options\n  this.options = Utils.extend(Utils.extend({}, optionsDefaults), options);\n\n  // Set default state\n  this.state = \"none\";\n\n  // Get dimensions\n  var boundingClientRectNormalized =\n    SvgUtils.getBoundingClientRectNormalized(svg);\n  this.width = boundingClientRectNormalized.width;\n  this.height = boundingClientRectNormalized.height;\n\n  // Init shadow viewport\n  this.viewport = ShadowViewport(\n    SvgUtils.getOrCreateViewport(this.svg, this.options.viewportSelector),\n    {\n      svg: this.svg,\n      width: this.width,\n      height: this.height,\n      fit: this.options.fit,\n      contain: this.options.contain,\n      center: this.options.center,\n      refreshRate: this.options.refreshRate,\n      // Put callbacks into functions as they can change through time\n      beforeZoom: function (oldScale, newScale) {\n        if (that.viewport && that.options.beforeZoom) {\n          return that.options.beforeZoom(oldScale, newScale);\n        }\n      },\n      onZoom: function (scale) {\n        if (that.viewport && that.options.onZoom) {\n          return that.options.onZoom(scale);\n        }\n      },\n      beforePan: function (oldPoint, newPoint) {\n        if (that.viewport && that.options.beforePan) {\n          return that.options.beforePan(oldPoint, newPoint);\n        }\n      },\n      onPan: function (point) {\n        if (that.viewport && that.options.onPan) {\n          return that.options.onPan(point);\n        }\n      },\n      onUpdatedCTM: function (ctm) {\n        if (that.viewport && that.options.onUpdatedCTM) {\n          return that.options.onUpdatedCTM(ctm);\n        }\n      },\n    }\n  );\n\n  // Wrap callbacks into public API context\n  var publicInstance = this.getPublicInstance();\n  publicInstance.setBeforeZoom(this.options.beforeZoom);\n  publicInstance.setOnZoom(this.options.onZoom);\n  publicInstance.setBeforePan(this.options.beforePan);\n  publicInstance.setOnPan(this.options.onPan);\n  publicInstance.setOnUpdatedCTM(this.options.onUpdatedCTM);\n\n  if (this.options.controlIconsEnabled) {\n    ControlIcons.enable(this);\n  }\n\n  // Init events handlers\n  this.lastMouseWheelEventTime = Date.now();\n  this.setupHandlers();\n};\n\n/**\n * Register event handlers\n */\nSvgPanZoom.prototype.setupHandlers = function () {\n  var that = this,\n    prevEvt = null; // use for touchstart event to detect double tap\n\n  this.eventListeners = {\n    // Mouse down group\n    pointerdown: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      var result = that.handleMouseDown(evt, prevEvt);\n      prevEvt = evt;\n      return result;\n    },\n    touchstart: function (evt) {\n      var result = that.handleTouchStart(evt, prevEvt);\n      prevEvt = evt;\n      return result;\n    },\n\n    // Mouse up group\n    pointerup: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseUp(evt);\n    },\n    touchend: function (evt) {\n      return that.handleTouchEnd(evt);\n    },\n\n    // Mouse move group\n    pointermove: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseMove(evt);\n    },\n    touchmove: function (evt) {\n      return that.handleTouchMove(evt);\n    },\n\n    // Mouse leave group\n    pointerleave: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseUp(evt);\n    },\n    pointercancel: function (evt) {\n      if (evt.pointerType === \"touch\") return;\n      return that.handleMouseUp(evt);\n    },\n    touchleave: function (evt) {\n      return that.handleTouchEnd(evt);\n    },\n    touchcancel: function (evt) {\n      return that.handleTouchEnd(evt);\n    },\n  };\n\n  // Init custom events handler if available\n  // eslint-disable-next-line eqeqeq\n  if (this.options.customEventsHandler != null) {\n    this.options.customEventsHandler.init({\n      svgElement: this.svg,\n      eventsListenerElement: this.options.eventsListenerElement,\n      instance: this.getPublicInstance(),\n    });\n\n    // Custom event handler may halt builtin listeners\n    var haltEventListeners =\n      this.options.customEventsHandler.haltEventListeners;\n    if (haltEventListeners && haltEventListeners.length) {\n      for (var i = haltEventListeners.length - 1; i >= 0; i--) {\n        if (this.eventListeners.hasOwnProperty(haltEventListeners[i])) {\n          delete this.eventListeners[haltEventListeners[i]];\n        }\n      }\n    }\n  }\n\n  // Bind eventListeners\n  for (var event in this.eventListeners) {\n    // Attach event to eventsListenerElement or SVG if not available\n    (this.options.eventsListenerElement || this.svg).addEventListener(\n      event,\n      this.eventListeners[event],\n      !this.options.preventMouseEventsDefault\n        ? passiveListenerTrueOption\n        : passiveListenerFalseOption\n    );\n  }\n\n  // Zoom using mouse wheel\n  if (this.options.mouseWheelZoomEnabled) {\n    this.options.mouseWheelZoomEnabled = false; // set to false as enable will set it back to true\n    this.enableMouseWheelZoom();\n  }\n};\n\n/**\n * Enable ability to zoom using mouse wheel\n */\nSvgPanZoom.prototype.enableMouseWheelZoom = function () {\n  if (!this.options.mouseWheelZoomEnabled) {\n    var that = this;\n\n    // Mouse wheel listener\n    this.wheelListener = function (evt) {\n      return that.handleMouseWheel(evt);\n    };\n\n    // Bind wheelListener\n    var isPassiveListener = !this.options.preventMouseEventsDefault;\n    Wheel.on(\n      this.options.eventsListenerElement || this.svg,\n      this.wheelListener,\n      isPassiveListener\n    );\n\n    this.options.mouseWheelZoomEnabled = true;\n  }\n};\n\n/**\n * Disable ability to zoom using mouse wheel\n */\nSvgPanZoom.prototype.disableMouseWheelZoom = function () {\n  if (this.options.mouseWheelZoomEnabled) {\n    var isPassiveListener = !this.options.preventMouseEventsDefault;\n    Wheel.off(\n      this.options.eventsListenerElement || this.svg,\n      this.wheelListener,\n      isPassiveListener\n    );\n    this.options.mouseWheelZoomEnabled = false;\n  }\n};\n\n/**\n * Handle mouse wheel event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleMouseWheel = function (evt) {\n  if (!this.options.zoomEnabled || this.state !== \"none\") {\n    return;\n  }\n\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  // Default delta in case that deltaY is not available\n  var delta = evt.deltaY || 1,\n    timeDelta = Date.now() - this.lastMouseWheelEventTime,\n    divider = 3 + Math.max(0, 30 - timeDelta);\n\n  // Update cache\n  this.lastMouseWheelEventTime = Date.now();\n\n  // Make empirical adjustments for browsers that give deltaY in pixels (deltaMode=0)\n  if (\"deltaMode\" in evt && evt.deltaMode === 0 && evt.wheelDelta) {\n    delta = evt.deltaY === 0 ? 0 : Math.abs(evt.wheelDelta) / evt.deltaY;\n  }\n\n  delta =\n    -0.3 < delta && delta < 0.3\n      ? delta\n      : ((delta > 0 ? 1 : -1) * Math.log(Math.abs(delta) + 10)) / divider;\n\n  var inversedScreenCTM = this.svg.getScreenCTM().inverse(),\n    relativeMousePoint = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n      inversedScreenCTM\n    ),\n    zoom = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * delta); // multiplying by neg. 1 so as to make zoom in/out behavior match Google maps behavior\n\n  this.zoomAtPoint(zoom, relativeMousePoint);\n};\n\n/**\n * Zoom in at a SVG point\n *\n * @param  {SVGPoint} point\n * @param  {Float} zoomScale    Number representing how much to zoom\n * @param  {Boolean} zoomAbsolute Default false. If true, zoomScale is treated as an absolute value.\n *                                Otherwise, zoomScale is treated as a multiplied (e.g. 1.10 would zoom in 10%)\n */\nSvgPanZoom.prototype.zoomAtPoint = function (zoomScale, point, zoomAbsolute) {\n  var originalState = this.viewport.getOriginalState();\n\n  if (!zoomAbsolute) {\n    // Fit zoomScale in set bounds\n    if (\n      this.getZoom() * zoomScale <\n      this.options.minZoom * originalState.zoom\n    ) {\n      zoomScale = (this.options.minZoom * originalState.zoom) / this.getZoom();\n    } else if (\n      this.getZoom() * zoomScale >\n      this.options.maxZoom * originalState.zoom\n    ) {\n      zoomScale = (this.options.maxZoom * originalState.zoom) / this.getZoom();\n    }\n  } else {\n    // Fit zoomScale in set bounds\n    zoomScale = Math.max(\n      this.options.minZoom * originalState.zoom,\n      Math.min(this.options.maxZoom * originalState.zoom, zoomScale)\n    );\n    // Find relative scale to achieve desired scale\n    zoomScale = zoomScale / this.getZoom();\n  }\n\n  var oldCTM = this.viewport.getCTM(),\n    relativePoint = point.matrixTransform(oldCTM.inverse()),\n    modifier = this.svg\n      .createSVGMatrix()\n      .translate(relativePoint.x, relativePoint.y)\n      .scale(zoomScale)\n      .translate(-relativePoint.x, -relativePoint.y),\n    newCTM = oldCTM.multiply(modifier);\n\n  if (newCTM.a !== oldCTM.a) {\n    this.viewport.setCTM(newCTM);\n  }\n};\n\n/**\n * Zoom at center point\n *\n * @param  {Float} scale\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.zoom = function (scale, absolute) {\n  this.zoomAtPoint(\n    scale,\n    SvgUtils.getSvgCenterPoint(this.svg, this.width, this.height),\n    absolute\n  );\n};\n\n/**\n * Zoom used by public instance\n *\n * @param  {Float} scale\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.publicZoom = function (scale, absolute) {\n  if (absolute) {\n    scale = this.computeFromRelativeZoom(scale);\n  }\n\n  this.zoom(scale, absolute);\n};\n\n/**\n * Zoom at point used by public instance\n *\n * @param  {Float} scale\n * @param  {SVGPoint|Object} point    An object that has x and y attributes\n * @param  {Boolean} absolute Marks zoom scale as relative or absolute\n */\nSvgPanZoom.prototype.publicZoomAtPoint = function (scale, point, absolute) {\n  if (absolute) {\n    // Transform zoom into a relative value\n    scale = this.computeFromRelativeZoom(scale);\n  }\n\n  // If not a SVGPoint but has x and y then create a SVGPoint\n  if (Utils.getType(point) !== \"SVGPoint\") {\n    if (\"x\" in point && \"y\" in point) {\n      point = SvgUtils.createSVGPoint(this.svg, point.x, point.y);\n    } else {\n      throw new Error(\"Given point is invalid\");\n    }\n  }\n\n  this.zoomAtPoint(scale, point, absolute);\n};\n\n/**\n * Get zoom scale\n *\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.getZoom = function () {\n  return this.viewport.getZoom();\n};\n\n/**\n * Get zoom scale for public usage\n *\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.getRelativeZoom = function () {\n  return this.viewport.getRelativeZoom();\n};\n\n/**\n * Compute actual zoom from public zoom\n *\n * @param  {Float} zoom\n * @return {Float} zoom scale\n */\nSvgPanZoom.prototype.computeFromRelativeZoom = function (zoom) {\n  return zoom * this.viewport.getOriginalState().zoom;\n};\n\n/**\n * Set zoom to initial state\n */\nSvgPanZoom.prototype.resetZoom = function () {\n  var originalState = this.viewport.getOriginalState();\n\n  this.zoom(originalState.zoom, true);\n};\n\n/**\n * Set pan to initial state\n */\nSvgPanZoom.prototype.resetPan = function () {\n  this.pan(this.viewport.getOriginalState());\n};\n\n/**\n * Set pan and zoom to initial state\n */\nSvgPanZoom.prototype.reset = function () {\n  this.resetZoom();\n  this.resetPan();\n};\n\n/**\n * Handle double click event\n * See handleMouseDown() for alternate detection method\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleDblClick = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  // Check if target was a control button\n  if (this.options.controlIconsEnabled) {\n    var targetClass = evt.target.getAttribute(\"class\") || \"\";\n    if (targetClass.indexOf(\"svg-pan-zoom-control\") > -1) {\n      return false;\n    }\n  }\n\n  var zoomFactor;\n\n  if (evt.shiftKey) {\n    zoomFactor = 1 / ((1 + this.options.zoomScaleSensitivity) * 2); // zoom out when shift key pressed\n  } else {\n    zoomFactor = (1 + this.options.zoomScaleSensitivity) * 2;\n  }\n\n  var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n    this.svg.getScreenCTM().inverse()\n  );\n  this.zoomAtPoint(zoomFactor, point);\n};\n\n/**\n * Handle click event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleMouseDown = function (evt, prevEvt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  Utils.mouseAndTouchNormalize(evt, this.svg);\n\n  // Double click detection; more consistent than ondblclick\n  if (this.options.dblClickZoomEnabled && Utils.isDblClick(evt, prevEvt)) {\n    this.handleDblClick(evt);\n  } else {\n    // Pan mode\n    this.state = \"pan\";\n    this.firstEventCTM = this.viewport.getCTM();\n    this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n      this.firstEventCTM.inverse()\n    );\n  }\n};\n\n/**\n * Handle mouse move event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleMouseMove = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  if (this.state === \"pan\" && this.options.panEnabled) {\n    // Pan mode\n    var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n        this.firstEventCTM.inverse()\n      ),\n      viewportCTM = this.firstEventCTM.translate(\n        point.x - this.stateOrigin.x,\n        point.y - this.stateOrigin.y\n      );\n\n    this.viewport.setCTM(viewportCTM);\n  }\n};\n\n/**\n * Handle mouse button release event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleMouseUp = function (evt) {\n  if (this.options.preventMouseEventsDefault) {\n    if (evt.preventDefault) {\n      evt.preventDefault();\n    } else {\n      evt.returnValue = false;\n    }\n  }\n\n  if (this.state === \"pan\") {\n    // Quit pan mode\n    this.state = \"none\";\n  }\n};\n\n/**\n * Handle click event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleTouchStart = function (evt, prevEvt) {\n  if (evt.touches.length == 1) {\n    this.handleMouseDown(evt, prevEvt);\n  } else {\n    if (this.options.preventMouseEventsDefault) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else {\n        evt.returnValue = false;\n      }\n    }\n\n    this.firstEventCTM = this.viewport.getCTM();\n    var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);\n    var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);\n    this.firstDistance = Utils.calculateDistance(touch1, touch2);\n    touch1.x = (touch1.x + touch2.x) / 2;\n    touch1.y = (touch1.y + touch2.y) / 2;\n    this.stateOrigin = touch1.matrixTransform(this.firstEventCTM.inverse());\n    this.firstZoomLevel = this.getZoom();\n  }\n};\n\n/**\n * Handle mouse move event\n *\n * @param  {Event} evt\n */\nSvgPanZoom.prototype.handleTouchMove = function (evt) {\n  if (evt.touches.length == 1) {\n    this.handleMouseMove(evt);\n  } else {\n    // pan and zoom\n    if (this.options.preventMouseEventsDefault) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else {\n        evt.returnValue = false;\n      }\n    }\n    if (!this.options.panEnabled && !this.options.zoomEnabled) {\n      return;\n    }\n\n    var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);\n    var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);\n    var center = this.svg.createSVGPoint();\n    center.x = (touch1.x + touch2.x) / 2;\n    center.y = (touch1.y + touch2.y) / 2;\n\n    if (this.state === \"pan\" && this.options.panEnabled) {\n      // Pan mode\n      var point = center.matrixTransform(this.firstEventCTM.inverse());\n      var viewportCTM = this.firstEventCTM.translate(\n        point.x - this.stateOrigin.x,\n        point.y - this.stateOrigin.y\n      );\n      this.viewport.setCTM(viewportCTM);\n    }\n\n    if (this.options.zoomEnabled) {\n      // zoom\n      var distance = Utils.calculateDistance(touch1, touch2);\n      var scale = distance / this.firstDistance;\n      var inversedScreenCTM = this.svg.getScreenCTM().inverse();\n      var relativeTouchPoint = center.matrixTransform(inversedScreenCTM);\n      this.zoomAtPoint(this.firstZoomLevel * scale, relativeTouchPoint, true);\n    }\n  }\n};\n\n/**\n * Handle mouse button release event\n *\n * @param {Event} evt\n */\nSvgPanZoom.prototype.handleTouchEnd = function (evt) {\n  if (evt.touches.length == 0) {\n    this.handleMouseUp(evt);\n  } else {\n    if (this.options.preventMouseEventsDefault) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else {\n        evt.returnValue = false;\n      }\n    }\n\n    this.firstEventCTM = this.viewport.getCTM();\n    if (evt.touches.length == 1) {\n      this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(\n        this.firstEventCTM.inverse()\n      );\n    } else {\n      var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);\n      var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);\n      this.firstDistance = Utils.calculateDistance(touch1, touch2);\n      touch1.x = (touch1.x + touch2.x) / 2;\n      touch1.y = (touch1.y + touch2.y) / 2;\n      this.stateOrigin = touch1.matrixTransform(this.firstEventCTM.inverse());\n    }\n  }\n};\n\n/**\n * Adjust viewport size (only) so it will fit in SVG\n * Does not center image\n */\nSvgPanZoom.prototype.fit = function () {\n  var viewBox = this.viewport.getViewBox(),\n    newScale = Math.min(\n      this.width / viewBox.width,\n      this.height / viewBox.height\n    );\n\n  this.zoom(newScale, true);\n};\n\n/**\n * Adjust viewport size (only) so it will contain the SVG\n * Does not center image\n */\nSvgPanZoom.prototype.contain = function () {\n  var viewBox = this.viewport.getViewBox(),\n    newScale = Math.max(\n      this.width / viewBox.width,\n      this.height / viewBox.height\n    );\n\n  this.zoom(newScale, true);\n};\n\n/**\n * Adjust viewport pan (only) so it will be centered in SVG\n * Does not zoom/fit/contain image\n */\nSvgPanZoom.prototype.center = function () {\n  var viewBox = this.viewport.getViewBox(),\n    offsetX =\n      (this.width - (viewBox.width + viewBox.x * 2) * this.getZoom()) * 0.5,\n    offsetY =\n      (this.height - (viewBox.height + viewBox.y * 2) * this.getZoom()) * 0.5;\n\n  this.getPublicInstance().pan({ x: offsetX, y: offsetY });\n};\n\n/**\n * Update content cached BorderBox\n * Use when viewport contents change\n */\nSvgPanZoom.prototype.updateBBox = function () {\n  this.viewport.simpleViewBoxCache();\n};\n\n/**\n * Pan to a rendered position\n *\n * @param  {Object} point {x: 0, y: 0}\n */\nSvgPanZoom.prototype.pan = function (point) {\n  var viewportCTM = this.viewport.getCTM();\n  viewportCTM.e = point.x;\n  viewportCTM.f = point.y;\n  this.viewport.setCTM(viewportCTM);\n};\n\n/**\n * Relatively pan the graph by a specified rendered position vector\n *\n * @param  {Object} point {x: 0, y: 0}\n */\nSvgPanZoom.prototype.panBy = function (point) {\n  var viewportCTM = this.viewport.getCTM();\n  viewportCTM.e += point.x;\n  viewportCTM.f += point.y;\n  this.viewport.setCTM(viewportCTM);\n};\n\n/**\n * Get pan vector\n *\n * @return {Object} {x: 0, y: 0}\n */\nSvgPanZoom.prototype.getPan = function () {\n  var state = this.viewport.getState();\n\n  return { x: state.x, y: state.y };\n};\n\n/**\n * Recalculates cached svg dimensions and controls position\n */\nSvgPanZoom.prototype.resize = function () {\n  // Get dimensions\n  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(\n    this.svg\n  );\n  this.width = boundingClientRectNormalized.width;\n  this.height = boundingClientRectNormalized.height;\n\n  // Recalculate original state\n  var viewport = this.viewport;\n  viewport.options.width = this.width;\n  viewport.options.height = this.height;\n  viewport.processCTM();\n\n  // Reposition control icons by re-enabling them\n  if (this.options.controlIconsEnabled) {\n    this.getPublicInstance().disableControlIcons();\n    this.getPublicInstance().enableControlIcons();\n  }\n};\n\n/**\n * Unbind mouse events, free callbacks and destroy public instance\n */\nSvgPanZoom.prototype.destroy = function () {\n  var that = this;\n\n  // Free callbacks\n  this.beforeZoom = null;\n  this.onZoom = null;\n  this.beforePan = null;\n  this.onPan = null;\n  this.onUpdatedCTM = null;\n\n  // Destroy custom event handlers\n  // eslint-disable-next-line eqeqeq\n  if (this.options.customEventsHandler != null) {\n    this.options.customEventsHandler.destroy({\n      svgElement: this.svg,\n      eventsListenerElement: this.options.eventsListenerElement,\n      instance: this.getPublicInstance(),\n    });\n  }\n\n  // Unbind eventListeners\n  for (var event in this.eventListeners) {\n    (this.options.eventsListenerElement || this.svg).removeEventListener(\n      event,\n      this.eventListeners[event],\n      !this.options.preventMouseEventsDefault\n        ? passiveListenerTrueOption\n        : passiveListenerFalseOption\n    );\n  }\n\n  // Unbind wheelListener\n  this.disableMouseWheelZoom();\n\n  // Remove control icons\n  this.getPublicInstance().disableControlIcons();\n\n  // Remove instance from instancesStore\n  instancesStore = instancesStore.filter(function (instance) {\n    return instance.svg !== that.svg;\n  });\n\n  // Delete options and its contents\n  delete this.options;\n\n  // Delete viewport to make public shadow viewport functions uncallable\n  delete this.viewport;\n\n  // Destroy public instance and rewrite getPublicInstance\n  delete this.publicInstance;\n  delete this.pi;\n  this.getPublicInstance = function () {\n    return null;\n  };\n};\n\n/**\n * Returns a public instance object\n *\n * @return {Object} Public instance object\n */\nSvgPanZoom.prototype.getPublicInstance = function () {\n  var that = this;\n\n  // Create cache\n  if (!this.publicInstance) {\n    this.publicInstance = this.pi = {\n      // Pan\n      enablePan: function () {\n        that.options.panEnabled = true;\n        return that.pi;\n      },\n      disablePan: function () {\n        that.options.panEnabled = false;\n        return that.pi;\n      },\n      isPanEnabled: function () {\n        return !!that.options.panEnabled;\n      },\n      pan: function (point) {\n        that.pan(point);\n        return that.pi;\n      },\n      panBy: function (point) {\n        that.panBy(point);\n        return that.pi;\n      },\n      getPan: function () {\n        return that.getPan();\n      },\n      // Pan event\n      setBeforePan: function (fn) {\n        that.options.beforePan =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      setOnPan: function (fn) {\n        that.options.onPan =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      // Zoom and Control Icons\n      enableZoom: function () {\n        that.options.zoomEnabled = true;\n        return that.pi;\n      },\n      disableZoom: function () {\n        that.options.zoomEnabled = false;\n        return that.pi;\n      },\n      isZoomEnabled: function () {\n        return !!that.options.zoomEnabled;\n      },\n      enableControlIcons: function () {\n        if (!that.options.controlIconsEnabled) {\n          that.options.controlIconsEnabled = true;\n          ControlIcons.enable(that);\n        }\n        return that.pi;\n      },\n      disableControlIcons: function () {\n        if (that.options.controlIconsEnabled) {\n          that.options.controlIconsEnabled = false;\n          ControlIcons.disable(that);\n        }\n        return that.pi;\n      },\n      isControlIconsEnabled: function () {\n        return !!that.options.controlIconsEnabled;\n      },\n      // Double click zoom\n      enableDblClickZoom: function () {\n        that.options.dblClickZoomEnabled = true;\n        return that.pi;\n      },\n      disableDblClickZoom: function () {\n        that.options.dblClickZoomEnabled = false;\n        return that.pi;\n      },\n      isDblClickZoomEnabled: function () {\n        return !!that.options.dblClickZoomEnabled;\n      },\n      // Mouse wheel zoom\n      enableMouseWheelZoom: function () {\n        that.enableMouseWheelZoom();\n        return that.pi;\n      },\n      disableMouseWheelZoom: function () {\n        that.disableMouseWheelZoom();\n        return that.pi;\n      },\n      isMouseWheelZoomEnabled: function () {\n        return !!that.options.mouseWheelZoomEnabled;\n      },\n      // Zoom scale and bounds\n      setZoomScaleSensitivity: function (scale) {\n        that.options.zoomScaleSensitivity = scale;\n        return that.pi;\n      },\n      setMinZoom: function (zoom) {\n        that.options.minZoom = zoom;\n        return that.pi;\n      },\n      setMaxZoom: function (zoom) {\n        that.options.maxZoom = zoom;\n        return that.pi;\n      },\n      // Zoom event\n      setBeforeZoom: function (fn) {\n        that.options.beforeZoom =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      setOnZoom: function (fn) {\n        that.options.onZoom =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      // Zooming\n      zoom: function (scale) {\n        that.publicZoom(scale, true);\n        return that.pi;\n      },\n      zoomBy: function (scale) {\n        that.publicZoom(scale, false);\n        return that.pi;\n      },\n      zoomAtPoint: function (scale, point) {\n        that.publicZoomAtPoint(scale, point, true);\n        return that.pi;\n      },\n      zoomAtPointBy: function (scale, point) {\n        that.publicZoomAtPoint(scale, point, false);\n        return that.pi;\n      },\n      zoomIn: function () {\n        this.zoomBy(1 + that.options.zoomScaleSensitivity);\n        return that.pi;\n      },\n      zoomOut: function () {\n        this.zoomBy(1 / (1 + that.options.zoomScaleSensitivity));\n        return that.pi;\n      },\n      getZoom: function () {\n        return that.getRelativeZoom();\n      },\n      // CTM update\n      setOnUpdatedCTM: function (fn) {\n        that.options.onUpdatedCTM =\n          fn === null ? null : Utils.proxy(fn, that.publicInstance);\n        return that.pi;\n      },\n      // Reset\n      resetZoom: function () {\n        that.resetZoom();\n        return that.pi;\n      },\n      resetPan: function () {\n        that.resetPan();\n        return that.pi;\n      },\n      reset: function () {\n        that.reset();\n        return that.pi;\n      },\n      // Fit, Contain and Center\n      fit: function () {\n        that.fit();\n        return that.pi;\n      },\n      contain: function () {\n        that.contain();\n        return that.pi;\n      },\n      center: function () {\n        that.center();\n        return that.pi;\n      },\n      // Size and Resize\n      updateBBox: function () {\n        that.updateBBox();\n        return that.pi;\n      },\n      resize: function () {\n        that.resize();\n        return that.pi;\n      },\n      getSizes: function () {\n        return {\n          width: that.width,\n          height: that.height,\n          realZoom: that.getZoom(),\n          viewBox: that.viewport.getViewBox(),\n        };\n      },\n      // Destroy\n      destroy: function () {\n        that.destroy();\n        return that.pi;\n      },\n    };\n  }\n\n  return this.publicInstance;\n};\n\n/**\n * Stores pairs of instances of SvgPanZoom and SVG\n * Each pair is represented by an object {svg: SVGSVGElement, instance: SvgPanZoom}\n *\n * @type {Array}\n */\nvar instancesStore = [];\n\nvar svgPanZoom = function (elementOrSelector, options) {\n  var svg = Utils.getSvg(elementOrSelector);\n\n  if (svg === null) {\n    return null;\n  } else {\n    // Look for existent instance\n    for (var i = instancesStore.length - 1; i >= 0; i--) {\n      if (instancesStore[i].svg === svg) {\n        return instancesStore[i].instance.getPublicInstance();\n      }\n    }\n\n    // If instance not found - create one\n    instancesStore.push({\n      svg: svg,\n      instance: new SvgPanZoom(svg, options),\n    });\n\n    // Return just pushed instance\n    return instancesStore[\n      instancesStore.length - 1\n    ].instance.getPublicInstance();\n  }\n};\n\nmodule.exports = svgPanZoom;\n","import svgPanZoom, * as SvgPanZoom from \"@dash14/svg-pan-zoom\"\n\nexport interface Box {\n  top: number\n  bottom: number\n  left: number\n  right: number\n}\n\ninterface ViewArea {\n  box: Box\n  center: SvgPanZoom.Point\n}\n\nexport interface SvgPanZoomInstance extends SvgPanZoom.Instance {\n  fitToContents(): SvgPanZoomInstance\n  getViewArea(): ViewArea\n  getViewBox(): Box\n  setViewBox(box: Box): void\n  getRealZoom(): number\n  applyAbsoluteZoomLevel(zoomLevel: number, minZoomLevel: number, maxZoomLevel: number): void\n  setPanEnabled(enabled: boolean): SvgPanZoomInstance\n  setZoomEnabled(enabled: boolean): SvgPanZoomInstance\n}\n\nexport interface CustomEventOptions {\n  svgElement: SVGSVGElement;\n  instance: SvgPanZoomInstance;\n}\n\nexport interface CustomEventHandler {\n  init: (options: CustomEventOptions) => void;\n  haltEventListeners: string[];\n  destroy: (options: CustomEventOptions) => void;\n}\n\nexport interface SvgPanZoomOptions extends Omit<SvgPanZoom.Options, \"customEventsHandler\"> {\n  customEventsHandler?: CustomEventHandler; // (default null)\n}\n\nexport interface SvgPanZoomInternal extends SvgPanZoomInstance {\n  _isPanEnabled: boolean\n  _isZoomEnabled: boolean\n  _internalIsPanEnabled(): boolean\n  _internalEnablePan(): void\n  _internalDisablePan(): void\n  _internalIsZoomEnabled(): boolean\n  _internalEnableZoom(): void\n  _internalDisableZoom(): void\n}\n\nconst methods: Partial<SvgPanZoomInternal> = {\n  fitToContents(this: SvgPanZoomInternal) {\n    this.fit()\n      .center()\n      .zoomOut() // Zoom out two steps.\n      .zoomOut()\n    return this\n  },\n  getViewArea(this: SvgPanZoomInternal) {\n    const sizes = this.getSizes()\n    const pan = this.getPan()\n    const scale = sizes.realZoom\n    pan.x /= scale\n    pan.y /= scale\n    const viewport = {\n      width: sizes.width / scale,\n      height: sizes.height / scale,\n    }\n    return {\n      box: {\n        top: -pan.y,\n        bottom: viewport.height - pan.y,\n        left: -pan.x,\n        right: viewport.width - pan.x,\n      },\n      center: {\n        x: viewport.width / 2 - pan.x,\n        y: viewport.height / 2 - pan.y,\n      },\n    }\n  },\n  getViewBox(this: SvgPanZoomInternal): Box {\n    return this.getViewArea().box\n  },\n  setViewBox(this: SvgPanZoomInternal, box: Box) {\n    // Adjust zoom and pan to include the box.\n    // If the aspect ratio is different from the box, pan to\n    // include the box with keeping the center.\n    const width = box.right - box.left\n    const height = box.bottom - box.top\n    const { width: sizeWidth, height: sizeHeight } = this.getSizes()\n    const ratio = width / height\n    const currentRatio = sizeWidth / sizeHeight\n    const newWidth = ratio < currentRatio ? height * currentRatio : width\n    const newHeight = ratio > currentRatio ? width / currentRatio : height\n    const absoluteZoom = Math.min(\n      sizeWidth / newWidth,\n      sizeHeight / newHeight\n    )\n    const realZoom = this.getRealZoom()\n    const relativeZoom = this.getZoom()\n    const originalZoom = realZoom / relativeZoom\n    this.zoom(absoluteZoom / originalZoom)\n\n    const center = {\n      x: (box.left + width / 2) * absoluteZoom,\n      y: (box.top + height / 2) * absoluteZoom\n    }\n    this.pan({\n      x: -(center.x) + newWidth / 2 * absoluteZoom,\n      y: -(center.y) + newHeight / 2 * absoluteZoom\n    })\n  },\n  getRealZoom(this: SvgPanZoomInternal) {\n    return this.getSizes().realZoom\n  },\n  applyAbsoluteZoomLevel(this: SvgPanZoomInternal, zoomLevel: number, minZoomLevel: number, maxZoomLevel: number) {\n    // normalize\n    const min = Math.max(0.0001, minZoomLevel)\n    const max = Math.max(min, maxZoomLevel)\n    const zoom = Math.max(Math.min(max, zoomLevel), min)\n\n    const realZoom = this.getRealZoom()\n    const relativeZoom = this.getZoom()\n    const originalZoom = realZoom / relativeZoom\n\n    this.setMinZoom(min / originalZoom)\n      .setMaxZoom(max / originalZoom)\n      .zoom(zoom / originalZoom)\n  },\n  isPanEnabled(this: SvgPanZoomInternal) {\n    return this._isPanEnabled\n  },\n  enablePan(this: SvgPanZoomInternal) {\n    this._isPanEnabled = true\n    this._internalEnablePan()\n    return this\n  },\n  disablePan(this: SvgPanZoomInternal) {\n    this._isPanEnabled = false\n    this._internalDisablePan()\n    return this\n  },\n  isZoomEnabled(this: SvgPanZoomInternal) {\n    return this._isZoomEnabled\n  },\n  enableZoom(this: SvgPanZoomInternal) {\n    this._isZoomEnabled = true\n    this._internalEnableZoom()\n    return this\n  },\n  disableZoom(this: SvgPanZoomInternal) {\n    this._isZoomEnabled = false\n    this._internalDisableZoom()\n    return this\n  },\n  setPanEnabled(this: SvgPanZoomInternal, enabled: boolean) {\n    if (enabled) {\n      this.enablePan()\n    } else {\n      this.disablePan()\n    }\n    return this\n  },\n  setZoomEnabled(this: SvgPanZoomInternal, enabled: boolean) {\n    if (enabled) {\n      this.enableZoom()\n      this.enableDblClickZoom()\n    } else {\n      this.disableZoom()\n      this.disableDblClickZoom()\n    }\n    return this\n  },\n}\n\nfunction constructor(\n  svgPanZoom: SvgPanZoom.Instance,\n  options: SvgPanZoomOptions,\n): SvgPanZoomInternal {\n  const instance = svgPanZoom as SvgPanZoomInternal\n  instance._isPanEnabled = options.panEnabled ?? true\n  instance._isZoomEnabled = options?.zoomEnabled ?? true\n  instance._internalIsPanEnabled = instance.isPanEnabled\n  instance._internalEnablePan = instance.enablePan\n  instance._internalDisablePan = instance.disablePan\n  instance._internalIsZoomEnabled = instance.isZoomEnabled\n  instance._internalEnableZoom = instance.enableZoom\n  instance._internalDisableZoom = instance.disableZoom\n  Object.assign(svgPanZoom, methods)\n  return instance\n}\n\nexport function createSvgPanZoomEx(\n  svg: SVGElement,\n  options: SvgPanZoomOptions\n): SvgPanZoomInstance {\n\n  const userInit = options.customEventsHandler?.init ?? ((_: any) => {})\n  const userDestroy = options.customEventsHandler?.destroy ?? ((_: any) => {})\n  const haltEventListeners = options.customEventsHandler?.haltEventListeners ?? []\n\n  if (options.mouseWheelZoomEnabled === undefined) {\n    options.mouseWheelZoomEnabled = options.zoomEnabled\n  }\n\n  options.customEventsHandler = {\n    init: o => {\n      constructor(o.instance, options)\n      userInit(o)\n    },\n    destroy: o => userDestroy(o),\n    haltEventListeners\n  }\n\n  return svgPanZoom(svg, options as SvgPanZoom.Options) as SvgPanZoomInternal\n}\n","import { ref, Ref, onMounted, onUnmounted } from \"vue\"\nimport { nonNull } from \"@/common/common\"\nimport { createSvgPanZoomEx, SvgPanZoomInstance, SvgPanZoomOptions } from \"@/modules/svg-pan-zoom-ex\"\n\ntype Callback = () => void\n\nenum State {\n  INITIAL = 0,\n  MOUNTED = 1,\n  UNMOUNTED = 2\n}\n\nexport function useSvgPanZoom(svg: Ref<SVGSVGElement | undefined>, options: SvgPanZoomOptions) {\n  const instance = ref<SvgPanZoomInstance>()\n  let state = State.INITIAL\n  const mountedCallbacks: Callback[] = []\n  const unmountedCallbacks: Callback[] = []\n\n  const instanceMounted = () => {\n    state = State.MOUNTED\n    mountedCallbacks.forEach(c => c())\n    mountedCallbacks.length = 0 // clear\n  }\n\n  const instanceUnmounted = () => {\n    state = State.UNMOUNTED\n    unmountedCallbacks.forEach(c => c())\n    unmountedCallbacks.length = 0 // clear\n  }\n\n  onMounted(() => {\n    const element = nonNull(svg.value, \"<svg>\")\n    // hook init/destroy custom events\n    const userInit = options.customEventsHandler?.init ?? ((_: any) => {})\n    const userDestroy = options.customEventsHandler?.destroy ?? ((_: any) => {})\n    const haltEventListeners = options.customEventsHandler?.haltEventListeners ?? []\n\n    options.customEventsHandler = {\n      init: o => {\n        instance.value = o.instance\n        userInit(o)\n        instanceMounted()\n      },\n      destroy: o => {\n        instanceUnmounted()\n        userDestroy(o)\n      },\n      haltEventListeners\n    }\n\n    const initialize = () => {\n      const rect = element.getBoundingClientRect()\n      // In svg-pan-zoom, the shadow viewport is generated based with\n      // size on initialization. At this time, if the width and height\n      // are zero, an exception will occur during the calculation.\n      // Therefore, initialization is performed after allocating the area.\n      // Note that even after onMounted, the area is not allocated at\n      // the time of page switching with Nuxt.\n      if (rect.width !== 0 && rect.height !== 0) {\n        createSvgPanZoomEx(element, options)\n      } else {\n        setTimeout(initialize, 200)\n      }\n    }\n    initialize()\n  })\n\n  onUnmounted(() => {\n    instance.value?.destroy()\n    instance.value = undefined\n  })\n\n  const onSvgPanZoomMounted = (callback: Callback) => {\n    if (state === State.INITIAL) {\n      mountedCallbacks.push(callback)\n    } else if (state === State.MOUNTED) {\n      callback()\n    }\n  }\n\n  const onSvgPanZoomUnmounted = (callback: Callback) => {\n    if (state === State.INITIAL || state === State.MOUNTED) {\n      unmountedCallbacks.push(callback)\n    } else {\n      callback()\n    }\n  }\n\n  return { svgPanZoom: instance, onSvgPanZoomMounted, onSvgPanZoomUnmounted }\n}\n","import { provide, inject, InjectionKey, Ref, computed } from \"vue\"\nimport { nonNull } from \"@/common/common\"\nimport { ViewConfig } from \"@/common/configs\"\n\ninterface ZoomProvides {\n  zoomLevel: Ref<number>,\n  scale: Ref<number>\n}\n\nconst zoomLevelKey = Symbol(\"zoomLevel\") as InjectionKey<ZoomProvides>\n\nexport function provideZoomLevel(zoomLevel: Ref<number>, viewStyle: ViewConfig) {\n  const scale = computed(() => {\n    return viewStyle.scalingObjects ? 1 : (1 / zoomLevel.value)\n  })\n  provide(zoomLevelKey, {\n    zoomLevel,\n    scale\n  })\n  return { scale }\n}\n\nexport function useZoomLevel(): ZoomProvides {\n  return nonNull(inject(zoomLevelKey), \"zoomLevel\")\n}\n","import { nextTick, ref } from \"vue\"\n\ntype TimingFunction = \"ease\" | \"linear\" | \"ease-in\" | \"ease-out\" | \"ease-in-out\" | string\n\n/** Parameters of transition */\ninterface TransitionParameters {\n  enabled: boolean\n  duration: number\n  timingFunction: TimingFunction\n}\n\ntype CallbackFunction = () => void | Promise<void>\n\nfunction isPromise(obj: any): boolean {\n  return obj instanceof Promise || (obj && typeof obj.then === \"function\")\n}\n\nexport function useTransitionWhile() {\n  let timerId: number | null = null\n  const transitionOption = ref<TransitionParameters>({\n    enabled: false,\n    duration: 300,\n    timingFunction: \"linear\"\n  })\n\n  function transitionWhile(\n    func: CallbackFunction,\n    duration = 300,\n    timingFunction: TimingFunction = \"linear\"\n  ) {\n    if (timerId) {\n      clearTimeout(timerId)\n      timerId = null\n    }\n    transitionOption.value = {\n      enabled: true,\n      duration,\n      timingFunction\n    }\n\n    nextTick(async () => {\n      const promise = func()\n      if (isPromise(promise)) {\n        await promise\n      }\n\n      if (timerId) {\n        clearTimeout(timerId)\n      }\n      timerId = window?.setTimeout(() => {\n        transitionOption.value.enabled = false\n        timerId = null\n      }, duration)\n    })\n  }\n\n  return { transitionWhile, transitionOption }\n}\n\n","import { ref, Ref, watchEffect } from \"vue\"\nimport { InputPaths, Path } from \"@/common/types\"\n\nexport function useTranslatePathsToObject(input: Ref<InputPaths>) {\n  const objects = ref<Record<string, Path>>({})\n\n  const isInCompatibilityModeForPath = ref(false)\n  let nextId = 1\n  const idStore = new Map<Path, string>()\n\n  // translate for compatibility\n  watchEffect(() => {\n    if (input.value instanceof Array) {\n      const containKeys = new Set<string>([])\n      objects.value = Object.fromEntries(\n        input.value.map(path => {\n          let id = path.id\n          if (!id) {\n            if (!isInCompatibilityModeForPath.value) {\n              isInCompatibilityModeForPath.value = true\n              console.warn(\n                \"[v-network-graph] Please specify the `id` field for the `Path` object.\" +\n                  \" Currently, this works for compatibility,\" +\n                  \" but in the future, the id field will be required.\"\n              )\n            }\n            id = idStore.get(path)\n            if (!id) {\n              id = \"path-\" + nextId++\n              idStore.set(path, id)\n            }\n          }\n          containKeys.add(id)\n          return [id, path]\n        })\n      )\n      if (isInCompatibilityModeForPath.value) {\n        for (const [path, id] of Array.from(idStore.entries())) {\n          if (!containKeys.has(id)) {\n            idStore.delete(path)\n          }\n        }\n      }\n    } else {\n      objects.value = input.value\n    }\n  })\n\n  return { objects, isInCompatibilityModeForPath }\n}\n","import { watch, reactive, ref, Ref } from \"vue\"\nimport { isEqual } from \"lodash-es\"\nimport { Reactive } from \"../common/common\"\n\nexport function bindProp<T extends object, K extends keyof T>(\n  props: T,\n  name: K,\n  emit: (event: `update:${K & string}`, ...args: any[]) => void,\n  filter?: (arg: T[K]) => T[K]\n): Ref<T[K]> {\n  // Build two-way binding ties.\n\n  // Since it is not always passed in props (emit does not\n  // rewrite it), always keep a ref for self management.\n\n  if (filter) {\n    const prop = ref<T[K]>(filter(props[name])) as Ref<T[K]>\n    const update = (filtered: T[K]) => {\n      if (!isEqual(filtered, prop.value)) {\n        prop.value = filtered\n      }\n      if (!isEqual(filtered, props[name])) {\n        emit(`update:${name as string & K}`, filtered)\n      }\n    }\n    watch(() => filter(prop.value), update)\n    watch(() => props[name],v => update(filter(v)))\n    if (prop.value !== props[name]) {\n      emit(`update:${name as string & K}`, prop.value)\n    }\n    return prop\n  }\n\n  const prop = ref<T[K]>(props[name]) as Ref<T[K]>\n  watch(\n    () => props[name],\n    v => {\n      if (!isEqual(v, prop.value)) {\n        prop.value = v\n      }\n    }\n  )\n  watch(prop, v => {\n    if (!isEqual(v, props[name])) {\n      emit(`update:${name as string & K}`, v)\n    }\n  })\n  return prop\n}\n\ntype KeysOfType<Obj, Val> = {\n  [K in keyof Obj]-?: Obj[K] extends Val ? K : never\n}[keyof Obj]\n\nexport function bindPropKeySet<T extends object, K extends string & KeysOfType<T, string[]>>(\n  props: T,\n  name: K,\n  sourceObject: Ref<{ [name: string]: any }>,\n  emit: (event: `update:${K & string}`, ...args: any[]) => void\n): Reactive<Set<string>> {\n  // Generate two-way bindings for a given prop.\n  // Assumes that the specified prop indicates the key of the object.\n  const bound = reactive<Set<string>>(new Set())\n  watch(\n    () => props[name],\n    () => {\n      // Since it is not recognized as a string[] by type checking,\n      // use any for now.\n      const prop: string[] = props[name] as any\n      const filtered = prop.filter(n => n in sourceObject.value)\n      if (!isEqual(filtered, Array.from(bound))) {\n        bound.clear()\n        filtered.forEach(bound.add, bound)\n      }\n    },\n    { deep: true, immediate: true }\n  )\n  watch(bound, () => {\n    const array = Array.from(bound)\n    if (!isEqual(props[name], array)) {\n      emit(`update:${name}` as const, array)\n    }\n  })\n  return Reactive(bound)\n}\n","import { inject, InjectionKey, provide } from \"vue\"\nimport { nonNull, Reactive } from \"@/common/common\"\n\ninterface Selections {\n  selectedNodes: Reactive<Set<string>>\n  selectedEdges: Reactive<Set<string>>\n  selectedPaths: Reactive<Set<string>>\n}\n\nconst injectionKey = Symbol(\"selection\") as InjectionKey<Selections>\n\nexport function provideSelections(\n  selectedNodes: Reactive<Set<string>>,\n  selectedEdges: Reactive<Set<string>>,\n  selectedPaths: Reactive<Set<string>>\n) {\n  provide(injectionKey, {\n    selectedNodes,\n    selectedEdges,\n    selectedPaths,\n  })\n}\n\nexport function useSelections(): Selections {\n  return nonNull(inject(injectionKey), \"Selections\")\n}\n","import { inject, InjectionKey, provide } from \"vue\"\nimport { nonNull, Reactive } from \"@/common/common\"\nimport { Layouts } from \"@/common/types\"\n\nconst injectionKey = Symbol(\"layouts\") as InjectionKey<Reactive<Layouts>>\n\nexport function provideLayouts(layouts: Reactive<Layouts>) {\n  provide(injectionKey, layouts)\n}\n\nexport function useLayouts(): Layouts {\n  return nonNull(inject(injectionKey), \"Layouts\")\n}\n","\nexport function pairwise<T>(arr: T[], func: (p1: T, p2: T) => void) {\n  for (let i = 0; i < arr.length - 1; i++) {\n    func(arr[i], arr[i + 1])\n  }\n}\n","\nexport function removeItem<T extends number | string>(arr: T[], value: T): void {\n  const i = arr.indexOf(value)\n  if (i >= 0) arr.splice(i, 1)\n}\n\nexport function insertAfter<T extends number | string>(arr: T[], base: T, value: T): void {\n  const i = arr.indexOf(base)\n  if (i < 0) return\n  arr.splice(i + 1, 0, value)\n}\n","import { computed, ComputedRef, Slots } from \"vue\"\nimport { uniq } from \"lodash-es\"\nimport { Configs } from \"@/common/configs\"\nimport { LayerName } from \"@/common/types\"\nimport { pairwise } from \"@/modules/collection/iterate\"\nimport { insertAfter, removeItem } from \"@/modules/collection/array\"\n\nexport function useBuiltInLayerOrder<T extends Configs>(\n  configs: T,\n  slots: Readonly<Slots>\n): ComputedRef<LayerName[]> {\n  const builtInLayers: Readonly<LayerName[]> = [\n    \"edges\",\n    \"edge-labels\",\n    \"focusring\",\n    \"nodes\",\n    \"node-labels\",\n    \"paths\",\n  ] as const\n\n  return computed<LayerName[]>(() => {\n    const request = uniq(configs.view.builtInLayerOrder)\n      .filter(layer => {\n        const defined = builtInLayers.includes(layer)\n        if (!defined) {\n          console.warn(`Layer ${layer} is not a built-in layer.`)\n        }\n        return defined\n      })\n      .reverse()\n    const order = [...builtInLayers]\n    pairwise(request, (lower, higher) => {\n      removeItem(order, higher)\n      insertAfter(order, lower, higher)\n    })\n\n    // Remove unused layers\n    if (!(\"edge-label\" in slots || \"edges-label\" in slots)) {\n      removeItem(order, \"edge-labels\")\n    }\n    if (!configs.node.focusring.visible) {\n      removeItem(order, \"focusring\")\n    }\n    if (configs.node.label.visible === false) {\n      removeItem(order, \"node-labels\")\n    }\n    if (!configs.path.visible) {\n      removeItem(order, \"paths\")\n    }\n\n    return order\n  })\n}\n","import { nextTick } from \"vue\"\n\nexport const asyncNextTick = () => {\n  return new Promise((resolve) => nextTick(resolve as () => void))\n}\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { MarkerUnits } from \"@/common/configs\"\n\nconst props = defineProps<{\n  width: number\n  height: number\n  refX: number\n  color: string\n  isSource: boolean\n  units: MarkerUnits\n}>()\n\nconst arrowPoints = computed(() => {\n  const w = props.width\n  const h = props.height\n  if (props.isSource) {\n    return `${w} ${h}, 0 ${h / 2}, ${w} 0`\n  } else {\n    return `0 0, ${w} ${h / 2}, 0 ${h}`\n  }\n})\n</script>\n\n<template>\n  <polygon :points=\"arrowPoints\" :fill=\"color\" />\n</template>\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { MarkerUnits } from \"@/common/configs\"\n\nconst props = defineProps<{\n  width: number\n  height: number\n  refX: number\n  color: string\n  isSource: boolean\n  units: MarkerUnits\n}>()\n\nconst angleStroke = computed(() => {\n  return props.units === \"strokeWidth\" ? 1 : Math.min(props.width, props.height) / 5\n})\n\nconst anglePoints = computed(() => {\n  const m = angleStroke.value / 2\n  const w = props.width\n  const h = props.height\n  if (props.isSource) {\n    return `${w - m} ${h - m}, ${m} ${h / 2}, ${w - m} ${m}`\n  } else {\n    return `${m} ${m}, ${w - m} ${h / 2}, ${m} ${h - m}`\n  }\n})\n</script>\n\n<template>\n  <polyline\n    :points=\"anglePoints\"\n    fill=\"none\"\n    :stroke-width=\"angleStroke\"\n    :stroke=\"color\"\n    stroke-linecap=\"round\"\n    stroke-linejoin=\"round\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { EdgeHeadType } from \"@/common/configs\"\nimport { HeadMarker } from \"@/composables/marker\"\nimport VMarkerHeadArrow from \"./VMarkerHeadArrow.vue\"\nimport VMarkerHeadAngle from \"./VMarkerHeadAngle.vue\"\nimport VMarkerHeadCircle from \"./VMarkerHeadCircle.vue\"\n\ntype MarkerType = Exclude<EdgeHeadType, \"none\" | \"custom\">\n\nconst types: Record<MarkerType, any> = {\n  arrow: VMarkerHeadArrow,\n  angle: VMarkerHeadAngle,\n  circle: VMarkerHeadCircle,\n}\n\nconst props = defineProps<{\n  id: string\n  marker: HeadMarker\n  scale: number\n}>()\n\nconst width = computed(\n  () => props.marker.width * (props.marker.units === \"strokeWidth\" ? 1 : props.scale)\n)\n\nconst height = computed(\n  () => props.marker.height * (props.marker.units === \"strokeWidth\" ? 1 : props.scale)\n)\n\nconst refX = computed(() => {\n  const margin = props.marker.margin * (props.marker.units === \"strokeWidth\" ? 1 : props.scale)\n  return props.marker.isSource ? width.value + margin : -margin\n})\n\nconst refYOffset = computed(() => {\n  const offset = props.marker.offset * (props.marker.units === \"strokeWidth\" ? 1 : props.scale)\n  return props.marker.isSource ? offset : -offset\n})\n</script>\n\n<template>\n  <marker\n    v-if=\"marker.type !== 'none' && marker.type !== 'custom'\"\n    :id=\"id\"\n    :markerWidth=\"width\"\n    :markerHeight=\"height\"\n    :refX=\"refX\"\n    :refY=\"height / 2 + refYOffset\"\n    orient=\"auto\"\n    :markerUnits=\"marker.units\"\n    class=\"v-ng-marker\"\n  >\n    <component\n      :is=\"types[marker.type]\"\n      :width=\"width\"\n      :height=\"height\"\n      :refX=\"refX\"\n      :color=\"marker.color\"\n      :is-source=\"marker.isSource\"\n      :units=\"marker.units\"\n    />\n  </marker>\n</template>\n","<script setup lang=\"ts\">\nimport { onMounted, ref, watchEffect } from \"vue\"\nimport { Point, Size } from \"@/common/types\"\nimport { useViewConfig } from \"@/composables/config\"\nimport { useContainers } from \"@/composables/container\"\nimport { useEventEmitter } from \"@/composables/event-emitter\"\nimport { useZoomLevel } from \"@/composables/zoom\"\n\n// [index, pos, start, end, attrs][]\ntype LineDefinitions = [number, number, number, number, Record<string, any>][]\n\nconst { container, svgPanZoom } = useContainers()\nconst { zoomLevel } = useZoomLevel()\nconst emitter = useEventEmitter()\nconst config = useViewConfig()\n\n// left-top point in SVG coordinates\nconst basePoint = ref<Point>({ x: 0, y: 0 })\n\n// container size in pixel\nconst viewport = ref<Size>({ width: 500, height: 500 })\n\nonMounted(() => {\n  const pan = svgPanZoom.value?.getPan()\n  if (pan) {\n    basePoint.value = {\n      x: -pan.x,\n      y: -pan.y,\n    }\n  }\n  const rect = container.value.getBoundingClientRect()\n  viewport.value = {\n    width: rect.width,\n    height: rect.height,\n  }\n})\n\nemitter.on(\"view:resize\", rect => {\n  viewport.value = { width: rect.width, height: rect.height }\n})\n\nemitter.on(\"view:pan\", pan => {\n  basePoint.value = { x: -pan.x, y: -pan.y }\n})\n\nemitter.on(\"view:zoom\", () => {\n  const pan = svgPanZoom.value?.getPan()\n  if (pan) {\n    basePoint.value = { x: -pan.x, y: -pan.y }\n  }\n})\n\nconst thickVerticals = ref<LineDefinitions>([])\nconst thickHorizontals = ref<LineDefinitions>([])\nconst normalVerticals = ref<LineDefinitions>([])\nconst normalHorizontals = ref<LineDefinitions>([])\n\n// make grid lines\nwatchEffect(() => {\n  const thickH: LineDefinitions = []\n  const thickV: LineDefinitions = []\n  const normalH: LineDefinitions = []\n  const normalV: LineDefinitions = []\n\n  const s = 1 / zoomLevel.value\n  const gi = config.grid.interval\n  const x = basePoint.value.x * s\n  const y = basePoint.value.y * s\n  const width = Math.floor(viewport.value.width / gi + 1) * gi\n  const height = Math.floor(viewport.value.height / gi + 1) * gi\n  const maxWidth = (basePoint.value.x + width) * s\n  const maxHeight = (basePoint.value.y + height) * s\n  const inc = config.grid.thickIncrements // interval to make the line thicker\n  const normalDasharray = config.grid.line.dasharray\n  const thickDasharray = config.grid.thick.dasharray\n\n  let thickAttrs = {\n    stroke: config.grid.thick.color,\n    \"stroke-width\": config.grid.thick.width,\n    \"stroke-dasharray\": thickDasharray,\n    \"stroke-dashoffset\": thickDasharray ? x / s : undefined,\n  }\n\n  let normalAttrs = {\n    stroke: config.grid.line.color,\n    \"stroke-width\": config.grid.line.width,\n    \"stroke-dasharray\": normalDasharray,\n    \"stroke-dashoffset\": normalDasharray ? x / s : undefined,\n  }\n\n  // horizontal lines\n  const w = (basePoint.value.x + width) * s\n  for (let i = y; i <= maxHeight; i += gi) {\n    const index = Math.floor(i / gi)\n    if (inc && index % inc === 0) {\n      thickH.push([index, index * gi, x, w, thickAttrs])\n    } else {\n      normalH.push([index, index * gi, x, w, normalAttrs])\n    }\n  }\n\n  thickAttrs = { ...thickAttrs }\n  thickAttrs[\"stroke-dashoffset\"] = thickDasharray ? y / s : undefined\n\n  normalAttrs = { ...normalAttrs }\n  normalAttrs[\"stroke-dashoffset\"] = normalDasharray ? y / s : undefined\n\n  // vertical lines\n  const h = (basePoint.value.y + height) * s\n  for (let i = x; i <= maxWidth; i += gi) {\n    const index = Math.floor(i / gi)\n    if (inc && index % inc === 0) {\n      thickV.push([index, index * gi, y, h, thickAttrs])\n    } else {\n      normalV.push([index, index * gi, y, h, normalAttrs])\n    }\n  }\n\n  thickHorizontals.value = thickH\n  thickVerticals.value = thickV\n  normalHorizontals.value = normalH\n  normalVerticals.value = normalV\n})\n</script>\n\n<template>\n  <g class=\"v-ng-background-grid\" shape-rendering=\"crispEdges\">\n    <!-- normal -->\n    <path\n      v-for=\"[i, v, x, w, attrs] in normalHorizontals\"\n      :key=\"`nv${i}`\"\n      :d=\"`M ${x} ${v} L ${w} ${v}`\"\n      v-bind=\"attrs\"\n      style=\"vector-effect: non-scaling-stroke\"\n    />\n    <path\n      v-for=\"[i, v, y, h, attrs] in normalVerticals\"\n      :key=\"`nh${i}`\"\n      :d=\"`M ${v} ${y} L ${v} ${h}`\"\n      v-bind=\"attrs\"\n      style=\"vector-effect: non-scaling-stroke\"\n    />\n    <!-- thick -->\n    <path\n      v-for=\"[i, v, x, w, attrs] in thickHorizontals\"\n      :key=\"`tv${i}`\"\n      :d=\"`M ${x} ${v} L ${w} ${v}`\"\n      v-bind=\"attrs\"\n      style=\"vector-effect: non-scaling-stroke\"\n    />\n    <path\n      v-for=\"[i, v, y, h, attrs] in thickVerticals\"\n      :key=\"`th${i}`\"\n      :d=\"`M ${v} ${y} L ${v} ${h}`\"\n      v-bind=\"attrs\"\n      style=\"vector-effect: non-scaling-stroke\"\n    />\n  </g>\n</template>\n\n<style lang=\"scss\">\n.v-ng-background-grid {\n  pointer-events: none;\n}\n</style>\n","<script setup lang=\"ts\">\nimport { onMounted, onUnmounted, ref } from \"vue\"\nimport { useContainers } from \"@/composables/container\"\n\n// By detecting and copying changes in the `transform` and `style`\n// attributes reflected by svg-pan-zoom, it follows changes in the\n// display area caused by panning and zooming.\n\nconst { viewport } = useContainers()\n\n// ref=\"background\"\nconst background = ref<SVGGElement>()\n\nconst updateAttributes = (attrs: string[], bgLayer: SVGGElement, vpLayer: SVGGElement) => {\n  attrs.forEach(attr => bgLayer.setAttribute(attr, vpLayer.getAttribute(attr) ?? \"\"))\n}\n\nconst observer = new MutationObserver(records => {\n  if (!background.value) return\n  const attrs = records.map(r => r.attributeName ?? \"\").filter(Boolean)\n  updateAttributes(attrs, background.value, viewport.value)\n})\n\nonMounted(() => {\n  const attrs = [\"transform\", \"style\"]\n  observer.observe(viewport.value, {\n    attributes: true,\n    attributeFilter: attrs,\n  })\n  if (!background.value) return\n  updateAttributes(attrs, background.value, viewport.value)\n})\n\nonUnmounted(() => {\n  observer.disconnect()\n})\n</script>\n\n<template>\n  <g ref=\"background\" class=\"v-ng-background-viewport\">\n    <slot />\n  </g>\n</template>\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { chunk } from \"lodash-es\"\nimport { Position } from \"@/common/types\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useEdgeConfig } from \"@/composables/config\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport { useZoomLevel } from \"@/composables/zoom\"\n\ninterface Props {\n  id: string\n  state: EdgeState\n  sourcePos?: Position\n  targetPos?: Position\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  sourcePos: undefined,\n  targetPos: undefined,\n})\n\nconst { scale } = useZoomLevel()\n\nconst config = useEdgeConfig()\nconst {\n  handleEdgePointerDownEvent,\n  handleEdgePointerOverEvent,\n  handleEdgePointerOutEvent,\n  handleEdgeClickEvent,\n  handleEdgeDoubleClickEvent,\n  handleEdgeContextMenu,\n} = useMouseOperation()\n\nconst pathD = computed(() => {\n  const p = props.state.position\n  if (props.state.loop) {\n    const { radius, isLargeArc, isClockwise } = props.state.loop\n    const [rx, ry] = radius\n    const f1 = isLargeArc ? 1 : 0\n    const f2 = isClockwise ? 1 : 0\n    return `M ${p.p1.x} ${p.p1.y} A ${rx} ${ry} 0 ${f1} ${f2} ${p.p2.x} ${p.p2.y}`\n  } else if (config.type === \"straight\" || !props.state.curve) {\n    return `M ${p.p1.x} ${p.p1.y} L ${p.p2.x} ${p.p2.y}`\n  } else {\n    const points = [...props.state.curve.control, { x: p.p2.x, y: p.p2.y }]\n    const d: string[] = []\n    d.push(`M ${p.p1.x} ${p.p1.y}`)\n    chunk(points, 2).forEach(([p1, p2]) => d.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`))\n    return d.join(\" \")\n  }\n})\n\nconst strokeWidth = computed(() => (props.state.line.stroke.width + 10) * scale.value)\n</script>\n\n<template>\n  <path\n    :class=\"{ 'v-ng-line-background': true, selectable: state.selectable }\"\n    :d=\"pathD\"\n    stroke=\"transparent\"\n    :stroke-width=\"strokeWidth\"\n    fill=\"none\"\n    @pointerdown.stop=\"handleEdgePointerDownEvent(id, $event)\"\n    @pointerenter.passive=\"handleEdgePointerOverEvent(id, $event)\"\n    @pointerleave.passive=\"handleEdgePointerOutEvent(id, $event)\"\n    @click.stop=\"handleEdgeClickEvent(id, $event)\"\n    @dblclick.stop=\"handleEdgeDoubleClickEvent(id, $event)\"\n    @contextmenu=\"handleEdgeContextMenu(id, $event)\"\n  />\n</template>\n\n<style lang=\"scss\">\n.v-ng-line-background {\n  &.selectable {\n    cursor: pointer;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { useStates } from \"@/composables/state\"\nimport VEdgeBackground from \"./VEdgeBackground.vue\"\n\nconst { edgeStates, edgeGroupStates, layouts } = useStates()\n</script>\n\n<template>\n  <template v-for=\"{ summarize, edges } in edgeGroupStates.edgeGroups\">\n    <template v-if=\"!summarize\">\n      <template v-for=\"(edge, id) in edges\" :key=\"id\">\n        <v-edge-background\n          :id=\"id\"\n          :state=\"edgeStates[id]\"\n          :source-pos=\"layouts.nodes[edge.source]\"\n          :target-pos=\"layouts.nodes[edge.target]\"\n        />\n      </template>\n    </template>\n  </template>\n</template>\n","<script setup lang=\"ts\">\nimport { CSSProperties, computed } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { StrokeStyle } from \"@/common/configs\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray, getDasharrayUnit } from \"@/utils/visual\"\n\nconst props = defineProps<{\n  p1: Position\n  p2: Position\n  config: StrokeStyle\n}>()\n\nconst { scale } = useZoomLevel()\n\nconst strokeWidth = computed(() => {\n  return props.config.width * scale.value\n})\n\nconst strokeDasharray = computed(() => {\n  return applyScaleToDasharray(props.config.dasharray, scale.value)\n})\n\nconst animationSpeed = computed(() => {\n  const speed = props.config.animate\n    ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value\n    : false\n  return speed ? ({ \"--animation-speed\": speed } as CSSProperties) : undefined\n})\n</script>\n\n<template>\n  <path\n    :class=\"{ 'v-ng-line': true, animate: config.animate }\"\n    :d=\"`M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`\"\n    :stroke=\"config.color\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n    :stroke-linecap=\"config.linecap\"\n    :style=\"animationSpeed\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { CSSProperties, computed } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { StrokeStyle } from \"@/common/configs\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray, getDasharrayUnit } from \"@/utils/visual\"\n\nconst props = defineProps<{\n  p1: Position\n  p2: Position\n  radius: number[]\n  isLargeArc: boolean\n  isClockwise: boolean\n  config: StrokeStyle\n}>()\n\nconst { scale } = useZoomLevel()\n\nconst strokeWidth = computed(() => {\n  return props.config.width * scale.value\n})\n\nconst strokeDasharray = computed(() => {\n  return applyScaleToDasharray(props.config.dasharray, scale.value)\n})\n\nconst animationSpeed = computed(() => {\n  const speed = props.config.animate\n    ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value\n    : false\n  return speed ? ({ \"--animation-speed\": speed } as CSSProperties) : undefined\n})\n\nconst pathD = computed(() => {\n  const { p1, p2, radius, isLargeArc, isClockwise } = props\n  const [rx, ry] = radius\n  const f1 = isLargeArc ? 1 : 0\n  const f2 = isClockwise ? 1 : 0\n  return `M ${p1.x} ${p1.y} A ${rx} ${ry} 0 ${f1} ${f2} ${p2.x} ${p2.y}`\n})\n</script>\n\n<template>\n  <path\n    :class=\"{ 'v-ng-line': true, animate: config.animate }\"\n    :d=\"pathD\"\n    :stroke=\"config.color\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n    :stroke-linecap=\"config.linecap\"\n    :style=\"animationSpeed\"\n    fill=\"none\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { CSSProperties, computed } from \"vue\"\nimport { chunk } from \"lodash-es\"\nimport { StrokeStyle } from \"@/common/configs\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray, getDasharrayUnit } from \"@/utils/visual\"\n\ninterface Props {\n  state: EdgeState\n  config: StrokeStyle\n  markerStart?: string\n  markerEnd?: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  markerStart: undefined,\n  markerEnd: undefined,\n})\n\nconst { scale } = useZoomLevel()\n\nconst pathD = computed(() => {\n  const p = props.state.position\n  const points = [...(props.state.curve?.control ?? []), { x: p.p2.x, y: p.p2.y }]\n  const d: string[] = []\n  d.push(`M ${p.p1.x} ${p.p1.y}`)\n  chunk(points, 2).forEach(([p1, p2]) => d.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`))\n  return d.join(\" \")\n})\n\nconst strokeWidth = computed(() => {\n  return props.config.width * scale.value\n})\n\nconst strokeDasharray = computed(() => {\n  return applyScaleToDasharray(props.config.dasharray, scale.value)\n})\n\nconst animationSpeed = computed(() => {\n  const speed = props.config.animate\n    ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value\n    : false\n  return speed ? ({ \"--animation-speed\": speed } as CSSProperties) : undefined\n})\n</script>\n\n<template>\n  <!-- <circle\n    v-if=\"state.curve\"\n    :cx=\"state.curve.circle.center.x\"\n    :cy=\"state.curve.circle.center.y\"\n    :r=\"state.curve.circle.radius\"\n    fill=\"#ff000080\"\n  />\n  <circle\n    v-for=\"cp in state.curve?.control\"\n    :key=\"JSON.stringify(cp)\"\n    :cx=\"cp.x\"\n    :cy=\"cp.y\"\n    :r=\"2\"\n    fill=\"#0000ff\"\n  /> -->\n  <path\n    :class=\"{ 'v-ng-line': true, animate: config.animate }\"\n    :d=\"pathD\"\n    fill=\"none\"\n    :stroke=\"config.color\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n    :stroke-linecap=\"config.linecap\"\n    :style=\"animationSpeed\"\n    :marker-start=\"markerStart\"\n    :marker-end=\"markerEnd\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { Position } from \"@/common/types\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useEdgeConfig } from \"@/composables/config\"\nimport VLine from \"@/components/base/VLine.vue\"\nimport VArc from \"@/components/base/VArc.vue\"\nimport VEdgeCurved from \"./VEdgeCurved.vue\"\n\ninterface Props {\n  id: string\n  state: EdgeState\n  sourcePos?: Position\n  targetPos?: Position\n}\n\nwithDefaults(defineProps<Props>(), {\n  sourcePos: undefined,\n  targetPos: undefined,\n})\n\nconst config = useEdgeConfig()\n</script>\n\n<template>\n  <v-arc\n    v-if=\"state.loop\"\n    v-bind=\"state.position\"\n    :radius=\"state.loop.radius\"\n    :is-large-arc=\"state.loop.isLargeArc\"\n    :is-clockwise=\"state.loop.isClockwise\"\n    :class=\"{ selectable: state.selectable, hover: state.hovered, selected: state.selected }\"\n    :config=\"state.line.stroke\"\n    :marker-start=\"state.sourceMarkerId ? `url('#${state.sourceMarkerId}')` : undefined\"\n    :marker-end=\"state.targetMarkerId ? `url('#${state.targetMarkerId}')` : undefined\"\n    class=\"v-ng-edge\"\n  />\n  <v-line\n    v-else-if=\"config.type == 'straight' || !state.curve\"\n    :data-edge-id=\"id\"\n    v-bind=\"state.position\"\n    :class=\"{ selectable: state.selectable, hover: state.hovered, selected: state.selected }\"\n    :config=\"state.line.stroke\"\n    :marker-start=\"state.sourceMarkerId ? `url('#${state.sourceMarkerId}')` : undefined\"\n    :marker-end=\"state.targetMarkerId ? `url('#${state.targetMarkerId}')` : undefined\"\n    class=\"v-ng-edge\"\n  />\n  <v-edge-curved\n    v-else\n    :data-edge-id=\"id\"\n    :class=\"{ selectable: state.selectable, hover: state.hovered, selected: state.selected }\"\n    :state=\"state\"\n    :config=\"state.line.stroke\"\n    :marker-start=\"state.sourceMarkerId ? `url('#${state.sourceMarkerId}')` : undefined\"\n    :marker-end=\"state.targetMarkerId ? `url('#${state.targetMarkerId}')` : undefined\"\n    class=\"v-ng-edge\"\n  />\n</template>\n\n<style lang=\"scss\">\n$transition: 0.1s linear;\n\n.v-ng-edge {\n  transition:\n    stroke $transition,\n    stroke-width $transition;\n  pointer-events: none;\n}\n</style>\n","<script setup lang=\"ts\">\nimport { ref, watchEffect } from \"vue\"\nimport { AnyShapeStyle } from \"@/common/configs\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray } from \"@/utils/visual\"\n\ninterface Props {\n  baseX?: number\n  baseY?: number\n  config: AnyShapeStyle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  baseX: 0,\n  baseY: 0,\n})\n\nconst { scale } = useZoomLevel()\n\nconst x = ref(props.baseX)\nconst y = ref(props.baseY)\nconst strokeWidth = ref(0)\nconst strokeColor = ref(\"#000000\")\nconst strokeDasharray = ref<string | number | undefined>(undefined)\nconst radius = ref(0)\nconst width = ref(0)\nconst height = ref(0)\nconst borderRadius = ref(0)\n\nwatchEffect(() => {\n  const s = scale.value\n  strokeWidth.value = props.config.strokeWidth * s\n  strokeColor.value = props.config.strokeColor ?? \"none\"\n  strokeDasharray.value = applyScaleToDasharray(props.config.strokeDasharray, s)\n\n  if (props.config.type === \"circle\") {\n    x.value = props.baseX\n    y.value = props.baseY\n    radius.value = props.config.radius * s\n  } else {\n    width.value = props.config.width * s\n    height.value = props.config.height * s\n    borderRadius.value = props.config.borderRadius * s\n    x.value = props.baseX - width.value / 2\n    y.value = props.baseY - height.value / 2\n  }\n})\n</script>\n\n<template>\n  <circle\n    v-if=\"config.type === 'circle'\"\n    class=\"v-ng-shape-circle\"\n    :cx=\"x\"\n    :cy=\"y\"\n    :r=\"radius\"\n    :fill=\"config.color\"\n    :stroke=\"strokeColor\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n  />\n  <rect\n    v-else\n    class=\"v-ng-shape-rect\"\n    :x=\"x\"\n    :y=\"y\"\n    :width=\"width\"\n    :height=\"height\"\n    :rx=\"borderRadius\"\n    :ry=\"borderRadius\"\n    :fill=\"config.color\"\n    :stroke=\"strokeColor\"\n    :stroke-width=\"strokeWidth\"\n    :stroke-dasharray=\"strokeDasharray\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { computed, reactive, Ref, ref, useAttrs, watch, onMounted, onUnmounted } from \"vue\"\nimport { LabelStyle } from \"@/common/configs\"\nimport { useZoomLevel } from \"@/composables/zoom\"\n\ntype Rect = { x: number; y: number; width: number; height: number }\n\ninterface Props {\n  text: string\n  x?: number\n  y?: number\n  dominantBaseline?: string\n  config: LabelStyle\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  x: 0,\n  y: 0,\n  dominantBaseline: \"central\",\n})\n\nconst attrs = useAttrs()\n\nconst { scale } = useZoomLevel()\n\nconst texts = computed(() => props.text?.toString().split(/\\r?\\n/) ?? \"\")\n\nconst fontSize = computed(() => {\n  return (attrs[\"font-size\"] as number) ?? props.config.fontSize * scale.value\n})\n\nconst lineHeight = computed(() => fontSize.value * props.config.lineHeight)\n\nconst topDeltaY = computed(() => {\n  const dominantBaseline = props.dominantBaseline\n  if (dominantBaseline === \"hanging\") {\n    return 0\n  } else if (dominantBaseline === \"central\") {\n    return -(lineHeight.value * (texts.value.length - 1)) / 2\n  } else {\n    // \"auto\", \"text-top\"\n    return -lineHeight.value * (texts.value.length - 1)\n  }\n})\n\nconst element = ref<SVGTextElement>()\nconst transform = ref(\"\") // copy from <text>\nconst pos = reactive<Rect>({ x: 0, y: 0, width: 0, height: 0 })\nconst backgroundRectPos = computed(() => {\n  const config = props.config.background\n  if (!config) return pos\n  let paddingVertical, paddingHorizontal\n  if (config.padding instanceof Object) {\n    paddingVertical = config.padding.vertical\n    paddingHorizontal = config.padding.horizontal\n  } else {\n    paddingVertical = config.padding ?? 0\n    paddingHorizontal = config.padding ?? 0\n  }\n  const lineMargin = lineHeight.value - fontSize.value\n  return {\n    x: pos.x - paddingHorizontal * scale.value,\n    y: pos.y - paddingVertical * scale.value - lineMargin / 2,\n    width: pos.width + paddingHorizontal * 2 * scale.value,\n    height: pos.height + paddingVertical * 2 * scale.value + lineMargin,\n  }\n})\n\nlet observer: MutationObserver | undefined\nconst updateObserver = () => {\n  if (props.config.background && props.config.background.visible) {\n    if (!observer && element.value) {\n      observer = enableMutationObserver(element.value, pos, transform)\n    }\n  } else {\n    observer?.disconnect()\n    observer = undefined\n  }\n}\n\nonMounted(() => updateObserver())\nwatch(\n  () => props.config.background && props.config.background.visible,\n  (v, prev) => {\n    if (v == prev) return\n    updateObserver()\n  }\n)\nonUnmounted(() => {\n  observer?.disconnect()\n  observer = undefined\n})\n\nfunction updateBackgroundPosition(\n  element: SVGTextElement,\n  pos: Rect,\n  transform: Ref<string | undefined>\n) {\n  const bbox = element.getBBox()\n  pos.x = bbox.x\n  pos.y = bbox.y\n  pos.width = bbox.width\n  pos.height = bbox.height\n  transform.value = element.getAttribute(\"transform\") ?? undefined\n}\n\nfunction enableMutationObserver(\n  element: SVGTextElement,\n  pos: Rect,\n  transform: Ref<string | undefined>\n) {\n  const observer = new MutationObserver(() => {\n    updateBackgroundPosition(element, pos, transform)\n  })\n  observer.observe(element, {\n    attributes: true,\n    attributeFilter: [\"x\", \"y\", \"transform\", \"font-size\"],\n  })\n  updateBackgroundPosition(element, pos, transform)\n  return observer\n}\n</script>\n\n<template>\n  <rect\n    v-if=\"config.background && config.background.visible\"\n    class=\"v-ng-text-background\"\n    v-bind=\"backgroundRectPos\"\n    :rx=\"(config.background?.borderRadius ?? 0) * scale\"\n    :ry=\"(config.background?.borderRadius ?? 0) * scale\"\n    :fill=\"config.background?.color ?? '#ffffff'\"\n    :transform=\"transform\"\n  />\n  <text\n    ref=\"element\"\n    class=\"v-ng-text\"\n    v-bind=\"$attrs\"\n    :x=\"x\"\n    :y=\"y\"\n    :dominant-baseline=\"dominantBaseline\"\n    :font-family=\"$attrs['font-family'] ? `${$attrs['font-family']}` : config.fontFamily\"\n    :font-size=\"fontSize\"\n    :fill=\"$attrs.fill ? `${$attrs.fill}` : config.color\"\n  >\n    <template v-if=\"texts.length <= 1\">\n      {{ text }}\n    </template>\n    <template v-else>\n      <!--\n        In Safari, it seems that `<tspan>` does not inherit the\n        `dominant-baseline` attribute from its parent `<text>` element.\n        Therefore, set the dominant-baseline directly on `<tspan>`.\n        Chrome and Firefox do not have this issue.\n        refs. https://stackoverflow.com/questions/41985077/centering-an-svg-element-chrome-vs-safari/42023579#42023579\n      -->\n      <tspan\n        v-for=\"(t, i) in texts\"\n        :key=\"i\"\n        :x=\"x\"\n        :dy=\"i == 0 ? topDeltaY : lineHeight\"\n        :dominant-baseline=\"dominantBaseline\"\n      >{{ t }}</tspan>\n    </template>\n  </text>\n</template>\n","<script setup lang=\"ts\">\nimport { computed, ref, watchEffect } from \"vue\"\nimport { Edges, NodePositions, LinePosition, Position } from \"@/common/types\"\nimport { Config } from \"@/common/configs\"\nimport { useEdgeConfig } from \"@/composables/config\"\nimport { useStates } from \"@/composables/state\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport VLine from \"@/components/base/VLine.vue\"\nimport VShape from \"@/components/base/VShape.vue\"\nimport VText from \"@/components/base/VLabelText.vue\"\n\nconst props = defineProps<{\n  edges: Edges\n  layouts: NodePositions\n}>()\n\nconst config = useEdgeConfig()\nconst {\n  handleEdgesPointerDownEvent,\n  handleEdgesPointerOverEvent,\n  handleEdgesPointerOutEvent,\n  handleEdgesClickEvent,\n  handleEdgesDoubleClickEvent,\n  handleEdgesContextMenu,\n} = useMouseOperation()\n\nconst { edgeStates } = useStates()\n\n// Since the specified edges are in the same pair,\n// get the first one and draw it.\nconst pos = ref<LinePosition>({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } })\nconst centerPos = ref<Position>({ x: 0, y: 0 })\n\nwatchEffect(() => {\n  const edgeId = Object.keys(props.edges).find(edgeId => edgeId in edgeStates)\n  if (edgeId) {\n    pos.value = edgeStates[edgeId].position\n    centerPos.value = {\n      x: (pos.value.p1.x + pos.value.p2.x) / 2,\n      y: (pos.value.p1.y + pos.value.p2.y) / 2,\n    }\n  }\n})\n\nconst edgeIds = computed(() => Object.keys(props.edges))\nconst labelConfig = computed(() => Config.values(config.summarized.label, props.edges))\nconst shapeConfig = computed(() => Config.values(config.summarized.shape, props.edges))\nconst strokeConfig = computed(() => Config.values(config.summarized.stroke, props.edges))\n\nconst hovered = computed(() => edgeIds.value.some(edge => edgeStates[edge].hovered))\nconst selectable = computed(() => edgeIds.value.some(edge => edgeStates[edge].selectable))\nconst selected = computed(() => edgeIds.value.some(edge => edgeStates[edge].selected))\n</script>\n\n<template>\n  <g\n    :class=\"{ 'v-ng-line-summarized': true, hovered, selectable, selected }\"\n    @pointerdown.stop=\"handleEdgesPointerDownEvent(edgeIds, $event)\"\n    @pointerenter.passive=\"handleEdgesPointerOverEvent(edgeIds, $event)\"\n    @pointerleave.passive=\"handleEdgesPointerOutEvent(edgeIds, $event)\"\n    @click.stop=\"handleEdgesClickEvent(edgeIds, $event)\"\n    @dblclick.stop=\"handleEdgesDoubleClickEvent(edgeIds, $event)\"\n    @contextmenu=\"handleEdgesContextMenu(edgeIds, $event)\"\n  >\n    <v-line v-bind=\"pos\" :config=\"strokeConfig\" :data-edge-id=\"edgeIds[0]\" />\n    <v-shape :base-x=\"centerPos.x\" :base-y=\"centerPos.y\" :config=\"shapeConfig\" />\n    <v-text\n      :text=\"Object.keys(edges).length.toString()\"\n      :x=\"centerPos.x\"\n      :y=\"centerPos.y\"\n      :config=\"labelConfig\"\n      text-anchor=\"middle\"\n      dominant-baseline=\"central\"\n    />\n  </g>\n</template>\n\n<style lang=\"scss\">\n.v-ng-line-summarized {\n  &.selectable {\n    cursor: pointer;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { Edge, EdgePosition, Edges, LinePosition, Point } from \"@/common/types\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { useContainers } from \"@/composables/container\"\nimport { Config } from \"@/common/configs\"\nimport { useEdgeConfig } from \"@/composables/config\"\n\ninterface Props {\n  edgeId?: string\n  edge?: Edge\n  edges?: Edges\n  state: EdgeState\n  isSummarized: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  edgeId: undefined,\n  edge: undefined,\n  edges: () => ({}),\n})\n\nconst { svg } = useContainers()\nconst { scale } = useZoomLevel()\nconst edgeConfig = useEdgeConfig()\n\nfunction getStrokeConfig() {\n  if (props.isSummarized) {\n    return Config.values(edgeConfig.summarized.stroke, props.edges)\n  } else {\n    return props.state.line.stroke\n  }\n}\n\nfunction toEdgePosition(line: LinePosition): EdgePosition {\n  return { source: line.p1, target: line.p2 }\n}\n\nfunction calculateCenterPoint(state: EdgeState): Point {\n  if (state.curve) {\n    return state.curve.center\n  } else {\n    const p1 = state.origin.p1\n    const p2 = state.origin.p2\n    return {\n      x: (p1.x + p2.x) / 2,\n      y: (p1.y + p2.y) / 2,\n    }\n  }\n}\n\nfunction getPathTotalLength() {\n  if (!svg.value) return 0\n  const edgeId = props.edgeId ?? Object.keys(props.edges)[0]\n  const path = svg.value.querySelector<SVGPathElement>(`path[data-edge-id=\"${edgeId}\"]`)\n  if (!path) return 0\n  return path.getTotalLength()\n}\n\nfunction calculatePointAtLength(distance: number): Point {\n  if (!svg.value || !isFinite(distance)) return props.state.position.p1\n\n  // for detecting changes and re-calculation\n  props.state\n\n  const edgeId = props.edgeId ?? Object.keys(props.edges)[0]\n\n  const path = svg.value.querySelector<SVGPathElement>(`path[data-edge-id=\"${edgeId}\"]`)\n  if (!path) return props.state.position.p1\n\n  const p = path.getPointAtLength(distance)\n  return { x: p.x, y: p.y }\n}\n</script>\n\n<template>\n  <g class=\"v-ng-edge-overlay\">\n    <slot\n      v-if=\"isSummarized\"\n      :edges=\"edges\"\n      :is-summarized=\"isSummarized\"\n      :stroke=\"getStrokeConfig()\"\n      :position=\"toEdgePosition(state.origin)\"\n      :center=\"calculateCenterPoint(state)\"\n      :hovered=\"state.hovered\"\n      :selected=\"state.selected\"\n      :scale=\"scale\"\n      :length=\"getPathTotalLength()\"\n      :point-at-length=\"calculatePointAtLength\"\n    />\n    <slot\n      v-else\n      :edge-id=\"edgeId\"\n      :edge=\"edge\"\n      :edges=\"{ [edgeId!]: edge }\"\n      :is-summarized=\"isSummarized\"\n      :stroke=\"getStrokeConfig()\"\n      :position=\"toEdgePosition(state.origin)\"\n      :center=\"calculateCenterPoint(state)\"\n      :hovered=\"state.hovered\"\n      :selected=\"state.selected\"\n      :scale=\"scale\"\n      :length=\"getPathTotalLength()\"\n      :point-at-length=\"calculatePointAtLength\"\n    />\n  </g>\n</template>\n","<script setup lang=\"ts\">\nimport { useStates, isSummarizedEdges } from \"@/composables/state\"\nimport VEdge from \"./VEdge.vue\"\nimport VEdgeSummarized from \"./VEdgeSummarized.vue\"\nimport VEdgeOverlay from \"./VEdgeOverlay.vue\"\n\ndefineProps<{\n  hasEdgeOverlaySlot: boolean\n}>()\n\nconst { edgeStates, edgeZOrderedList, layouts } = useStates()\n\n// type FlattenEdge = {\n//     key: string\n//     summarize: true\n//     edges: Edges\n//     id?: undefined\n//     edge?: undefined\n// } | {\n//     key: string\n//     summarize: false\n//     edges?: undefined\n//     id: string\n//     edge: Edge\n// }\n\n// const flattenEdges = computed(() => {\n//   const results: FlattenEdge[] = []\n//   for (const [key, {summarize, edges}] of Object.entries(edgeGroupStates.edgeGroups)) {\n//     if (summarize) {\n//       results.push({ key, summarize, edges })\n//     } else {\n//       results.push(...Object.entries(edges).map(([id, edge]) => ({ key, summarize, id, edge })))\n//     }\n//   }\n//   return results\n// })\n</script>\n\n<template>\n  <template v-for=\"entry in edgeZOrderedList\">\n    <template v-if=\"isSummarizedEdges(entry)\">\n      <v-edge-summarized\n        :key=\"entry.key\"\n        :edges=\"entry.group.edges\"\n        :layouts=\"layouts.nodes\"\n      />\n      <v-edge-overlay\n        v-if=\"hasEdgeOverlaySlot\"\n        :key=\"entry.key\"\n        :edges=\"entry.group.edges\"\n        :state=\"edgeStates[Object.keys(entry.group.edges)[0]]\"\n        :is-summarized=\"true\"\n      >\n        <template #default=\"slotProps\">\n          <slot v-bind=\"slotProps\" />\n        </template>\n      </v-edge-overlay>\n    </template>\n    <template v-else>\n      <v-edge\n        :id=\"entry.key\"\n        :key=\"entry.key\"\n        :state=\"edgeStates[entry.key]\"\n        :source-pos=\"layouts.nodes[entry.edge.source]\"\n        :target-pos=\"layouts.nodes[entry.edge.target]\"\n      />\n      <v-edge-overlay\n        v-if=\"hasEdgeOverlaySlot\"\n        :key=\"entry.key\"\n        :edge-id=\"entry.key\"\n        :edge=\"entry.edge\"\n        :state=\"edgeStates[entry.key]\"\n        :is-summarized=\"false\"\n      >\n        <template #default=\"slotProps\">\n          <slot v-bind=\"slotProps\" />\n        </template>\n      </v-edge-overlay>\n    </template>\n  </template>\n</template>\n","<script setup lang=\"ts\">\nimport { computed, useSlots } from \"vue\"\n\nimport VEdgeBackgrounds from \"../edge/VEdgeBackgrounds.vue\"\nimport VEdgeGroups from \"../edge/VEdgeGroups.vue\"\n\nconst slots = useSlots()\n\nconst hasEdgeOverlaySlot = computed(() => \"edge-overlay\" in slots)\n</script>\n\n<template>\n  <!-- edges -->\n  <g class=\"v-ng-layer-edges\">\n    <v-edge-backgrounds />\n    <v-edge-groups :has-edge-overlay-slot=\"hasEdgeOverlaySlot\">\n      <template v-if=\"hasEdgeOverlaySlot\" #default=\"slotProps\">\n        <slot name=\"edge-overlay\" v-bind=\"slotProps\" />\n      </template>\n    </v-edge-groups>\n  </g>\n</template>\n","<!--\n  When using slots in v-for, unnecessary update hooks are called,\n  resulting in performance degradation.\n  This can be avoided by placing a component inside the v-for and\n  placing a fixed number of slots inside that component.\n  ref: https://github.com/vuejs/core/issues/6833\n-->\n<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { Edge } from \"@/common/types\"\nimport { EdgeState } from \"@/models/edge\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport * as v2d from \"@/modules/calculation/2d\"\n\ninterface Props {\n  edgeId: string\n  edge: Edge\n  state: EdgeState\n}\n\nconst props = defineProps<Props>()\nconst { scale } = useZoomLevel()\n\nconst area = computed(() => {\n  return v2d.calculateEdgeLabelArea(\n    props.state.labelPosition,\n    props.state.line.stroke,\n    props.state.label.margin,\n    props.state.label.padding,\n    scale.value\n  )\n})\n</script>\n<template>\n  <slot\n    v-if=\"!state.loop\"\n    :edge-id=\"edgeId\"\n    :edge=\"edge\"\n    :config=\"state.label\"\n    :area=\"area\"\n    :hovered=\"state.hovered\"\n    :selected=\"state.selected\"\n    :scale=\"scale\"\n  />\n</template>\n","<!--\n  When using slots in v-for, unnecessary update hooks are called,\n  resulting in performance degradation.\n  This can be avoided by placing a component inside the v-for and\n  placing a fixed number of slots inside that component.\n  ref: https://github.com/vuejs/core/issues/6833\n-->\n<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { Edges } from \"@/common/types\"\nimport { EdgeState, SummarizedEdgeState } from \"@/models/edge\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport * as v2d from \"@/modules/calculation/2d\"\n\ninterface Props {\n  edges: Edges\n  state: EdgeState\n  summarizeState?: SummarizedEdgeState\n}\n\nconst props = defineProps<Props>()\nconst { scale } = useZoomLevel()\n\nconst area = computed(() => {\n  return v2d.calculateEdgeLabelArea(\n    props.state.labelPosition,\n    props.summarizeState?.stroke ?? props.state.line.stroke,\n    props.state.label.margin,\n    props.state.label.padding,\n    scale.value\n  )\n})\n</script>\n<template>\n  <slot\n    v-if=\"!state.loop\"\n    :edges=\"edges\"\n    :config=\"state.label\"\n    :area=\"area\"\n    :hovered=\"state.hovered\"\n    :selected=\"state.selected\"\n    :scale=\"scale\"\n  />\n</template>\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { EdgeGroup } from \"@/models/edge\"\nimport { useStates } from \"@/composables/state\"\nimport VEdgeLabelPlace from \"./VEdgeLabelPlace.vue\"\nimport VEdgeLabelsPlace from \"./VEdgeLabelsPlace.vue\"\n\ninterface Props {\n  enableEdgeLabel: boolean\n  enableEdgesLabel: boolean\n}\n\nwithDefaults(defineProps<Props>(), {\n  enableEdgeLabel: false,\n  enableEdgesLabel: false,\n})\n\nconst { edgeStates, edgeGroupStates, summarizedEdgeStates } = useStates()\n\nconst edgeGroups = computed(() => {\n  const individual: Record<string, EdgeGroup> = {}\n  const summarized: Record<string, EdgeGroup> = {}\n  Object.entries(edgeGroupStates.edgeGroups).forEach(([id, group]) => {\n    if (Object.keys(group.edges).length > 0) {\n      if (group.summarize) {\n        summarized[id] = group\n      } else {\n        individual[id] = group\n      }\n    }\n  })\n  return { individual, summarized }\n})\n\nfunction getRepresentativeEdgeKey(group: EdgeGroup) {\n  return Object.keys(group.edges)[0]\n}\n</script>\n\n<template>\n  <g class=\"v-ng-edge-labels\">\n    <template v-if=\"enableEdgeLabel\">\n      <template v-for=\"(group, id) in edgeGroups.individual\" :key=\"id\">\n        <template v-for=\"(edge, edgeId) in group.edges\" :key=\"edgeId\">\n          <v-edge-label-place\n            :edge-id=\"edgeId\"\n            :edge=\"edge\"\n            :state=\"edgeStates[edgeId]\"\n          >\n            <template #default=\"slotProps\">\n              <slot name=\"edge-label\" v-bind=\"slotProps\" />\n            </template>\n          </v-edge-label-place>\n        </template>\n      </template>\n    </template>\n    <template v-if=\"enableEdgesLabel\">\n      <template v-for=\"(group, id) in edgeGroups.summarized\" :key=\"id\">\n        <v-edge-labels-place\n          :edges=\"group.edges\"\n          :state=\"edgeStates[getRepresentativeEdgeKey(group)]\"\n          :summarize-state=\"summarizedEdgeStates[getRepresentativeEdgeKey(group)]\"\n        >\n          <template #default=\"slotProps\">\n            <slot name=\"edges-label\" v-bind=\"slotProps\" />\n          </template>\n        </v-edge-labels-place>\n      </template>\n    </template>\n  </g>\n</template>\n\n<style lang=\"scss\">\n.v-ng-edge-labels {\n  .v-ng-text,\n  .v-ng-text-background {\n    pointer-events: none;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, reactive, watchEffect } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { CircleShapeStyle, RectangleShapeStyle, ShapeStyle } from \"@/common/configs\"\nimport { NodeState } from \"@/models/node\"\nimport { useNodeConfig } from \"@/composables/config\"\nimport VShape from \"@/components/base/VShape.vue\"\n\ninterface Props {\n  id: string\n  state: NodeState\n  pos: Position\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  pos: undefined,\n})\n\nconst x = computed(() => props.pos?.x || 0)\nconst y = computed(() => props.pos?.y || 0)\n\nconst config = useNodeConfig()\nconst shapeConfig = reactive<ShapeStyle>({} as any)\n\nwatchEffect(() => {\n  const shapeStyle = props.state.shape\n  if (shapeStyle.type === \"circle\") {\n    const shape: CircleShapeStyle = {\n      type: \"circle\",\n      radius:\n        shapeStyle.radius +\n        (shapeStyle.strokeWidth ?? 0) / 2 +\n        config.focusring.padding +\n        config.focusring.width / 2,\n      color: \"none\",\n      strokeWidth: config.focusring.width,\n      strokeColor: config.focusring.color,\n      strokeDasharray: config.focusring.dasharray,\n    }\n    Object.assign(shapeConfig, shape)\n  } else {\n    const shape: RectangleShapeStyle = {\n      type: \"rect\",\n      width:\n        shapeStyle.width +\n        (shapeStyle.strokeWidth ?? 0) +\n        config.focusring.padding * 2 +\n        config.focusring.width,\n      height:\n        shapeStyle.height +\n        (shapeStyle.strokeWidth ?? 0) +\n        config.focusring.padding * 2 +\n        config.focusring.width,\n      borderRadius:\n        shapeStyle.borderRadius > 0 ? shapeStyle.borderRadius + config.focusring.padding : 0,\n      color: \"none\",\n      strokeWidth: config.focusring.width,\n      strokeColor: config.focusring.color,\n      strokeDasharray: config.focusring.dasharray,\n    }\n    Object.assign(shapeConfig, shape)\n  }\n})\n</script>\n\n<template>\n  <v-shape\n    class=\"v-ng-node-focusring\"\n    :base-x=\"x\"\n    :base-y=\"y\"\n    :config=\"shapeConfig\"\n  />\n</template>\n\n<style lang=\"scss\">\n$transition: 0.1s linear;\n\n.v-ng-node-focusring {\n  pointer-events: none;\n}\n\n:where(.v-ng-shape-circle) {\n  transition: r $transition;\n}\n:where(.v-ng-shape-rect) {\n  transition:\n    x $transition,\n    y $transition,\n    width $transition,\n    height $transition;\n}\n:where(.dragging .v-ng-shape-circle),\n:where(.dragging .v-ng-shape-rect) {\n  transition: none;\n}\n</style>\n","<script setup lang=\"ts\">\nimport VNodeFocusRing from \"@/components/node/VNodeFocusRing.vue\"\nimport { useStates } from \"@/composables/state\"\nimport { useSelections } from \"@/composables/selection\"\nimport { useLayouts } from \"@/composables/layout\"\n\nconst { nodeStates } = useStates()\nconst { selectedNodes } = useSelections()\nconst layouts = useLayouts()\n</script>\n\n<template>\n  <!-- node selections (focus ring) -->\n  <g class=\"v-ng-layer-nodes-selections\">\n    <v-node-focus-ring\n      v-for=\"nodeId in selectedNodes\"\n      :id=\"nodeId\"\n      :key=\"nodeId\"\n      :state=\"nodeStates[nodeId]\"\n      :pos=\"layouts.nodes[nodeId]\"\n    />\n  </g>\n</template>\n","<script setup lang=\"ts\">\nimport { computed } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { NodeState } from \"@/models/node\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport VShape from \"@/components/base/VShape.vue\"\n\ninterface Props {\n  id: string\n  state: NodeState\n  pos?: Position\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  pos: undefined,\n})\n\nconst x = computed(() => props.pos?.x || 0)\nconst y = computed(() => props.pos?.y || 0)\n\nconst { scale } = useZoomLevel()\n\nconst {\n  handleNodePointerDownEvent,\n  handleNodePointerOverEvent,\n  handleNodePointerOutEvent,\n  handleNodeClickEvent,\n  handleNodeDoubleClickEvent,\n  handleNodeContextMenu,\n} = useMouseOperation()\n</script>\n\n<template>\n  <g\n    :class=\"{ 'v-ng-node': true, hover: state.hovered, selected: state.selected }\"\n    :transform=\"`translate(${x} ${y})`\"\n    @pointerdown.stop=\"handleNodePointerDownEvent(id, $event)\"\n    @pointerenter.passive=\"handleNodePointerOverEvent(id, $event)\"\n    @pointerleave.passive=\"handleNodePointerOutEvent(id, $event)\"\n    @click.stop=\"handleNodeClickEvent(id, $event)\"\n    @dblclick.stop=\"handleNodeDoubleClickEvent(id, $event)\"\n    @contextmenu=\"handleNodeContextMenu(id, $event)\"\n  >\n    <slot\n      name=\"override-node\"\n      :node-id=\"id\"\n      :scale=\"scale\"\n      :config=\"state.shape\"\n      :class=\"{ draggable: state.draggable, selectable: state.selectable }\"\n    >\n      <v-shape\n        :config=\"state.shape\"\n        :class=\"{\n          'v-ng-node-default': true,\n          draggable: state.draggable,\n          selectable: state.selectable,\n        }\"\n      />\n    </slot>\n  </g>\n</template>\n\n<style lang=\"scss\">\n$transition: 0.1s linear;\n\n.v-ng-node {\n  :where(.v-ng-shape-circle) {\n    transition:\n      fill $transition,\n      stroke $transition,\n      stroke-width $transition,\n      r $transition;\n  }\n  :where(.v-ng-shape-rect) {\n    transition:\n      fill $transition,\n      stroke $transition,\n      stroke-width $transition,\n      x $transition,\n      y $transition,\n      width $transition,\n      height $transition;\n  }\n\n  :where(.v-ng-node-default.v-ng-shape-circle) {\n    pointer-events: none;\n  }\n  :where(.v-ng-node-default.v-ng-shape-rect) {\n    pointer-events: none;\n  }\n\n  .draggable,\n  .selectable {\n    pointer-events: all;\n    cursor: pointer;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, useSlots } from \"vue\"\nimport { useNodeConfig } from \"@/composables/config\"\nimport { useLayouts } from \"@/composables/layout\"\nimport { useStates } from \"@/composables/state\"\nimport VNode from \"@/components/node/VNode.vue\"\n\nconst slots = useSlots()\nconst hasOverrideNodeSlot = computed(() => \"override-node\" in slots)\nconst { nodeZOrderedList } = useStates()\n\nconst configs = useNodeConfig()\nconst layouts = useLayouts()\n</script>\n\n<template>\n  <template v-if=\"hasOverrideNodeSlot\">\n    <transition-group\n      :name=\"configs.transition\"\n      :css=\"!!configs.transition\"\n      tag=\"g\"\n      class=\"v-ng-layer-nodes\"\n    >\n      <v-node\n        v-for=\"nodeState in nodeZOrderedList\"\n        :id=\"nodeState.id\"\n        :key=\"nodeState.id\"\n        :state=\"nodeState\"\n        :pos=\"layouts.nodes[nodeState.id]\"\n      >\n        <!-- override the node -->\n        <template #override-node=\"slotProps\">\n          <slot name=\"override-node\" v-bind=\"slotProps\" />\n        </template>\n      </v-node>\n    </transition-group>\n  </template>\n  <template v-else>\n    <!--\n      If a `v-node` contains a slot and no external slot is specified,\n      `v-ng-layer-nodes` element will be needlessly redrawn and all\n      `v-node` components get update notifications. Therefore, if there is\n      no external slot, do not specify a slot in the `v-node` component. -->\n    <transition-group\n      :name=\"configs.transition\"\n      :css=\"!!configs.transition\"\n      tag=\"g\"\n      class=\"v-ng-layer-nodes\"\n    >\n      <v-node\n        v-for=\"nodeState in nodeZOrderedList\"\n        :id=\"nodeState.id\"\n        :key=\"nodeState.id\"\n        :state=\"nodeState\"\n        :pos=\"layouts.nodes[nodeState.id]\"\n      />\n    </transition-group>\n  </template>\n</template>\n","import { NodeLabelDirection, NodeLabelDirectionType, OppositeNodes } from \"@/common/configs\"\nimport { Position } from \"@/common/types\"\nimport { subtract, angleDegree } from \"@/modules/vector2d\"\n\nconst labelDirections: Record<NodeLabelDirectionType, number> = {\n  [NodeLabelDirection.NORTH]: 0,\n  [NodeLabelDirection.NORTH_EAST]: 1,\n  [NodeLabelDirection.EAST]: 2,\n  [NodeLabelDirection.SOUTH_EAST]: 3,\n  [NodeLabelDirection.SOUTH]: 4,\n  [NodeLabelDirection.SOUTH_WEST]: 5,\n  [NodeLabelDirection.WEST]: 6,\n  [NodeLabelDirection.NORTH_WEST]: 7,\n  [NodeLabelDirection.CENTER]: -1,\n}\n\nconst denyAngles: ((a: number, loop: boolean) => boolean)[] = [\n  /* N */ (a, loop) => inRange(a, 0, loop ? 90 : 60),\n  /* NE */ (a, loop) => inRange(a, 45, loop ? 90 : 45),\n  /* E */ (a, loop) => inRange(a, 90, loop ? 60 : 30),\n  /* SE */ (a, loop) => inRange(a, 135, loop ? 90 : 45),\n  /* S */ (a, loop) => inRange(a, 180, loop ? 90 : 60),\n  /* SW */ (a, loop) => inRange(a, 225, loop ? 90 : 45),\n  /* W */ (a, loop) => inRange(a, 270, loop ? 60 : 30),\n  /* NW */ (a, loop) => inRange(a, 315, loop ? 90 : 45),\n]\n\nexport function handleNodeLabelAutoAdjustment(\n  nodeId: string,\n  currentPos: Position,\n  oppositeNodes: OppositeNodes,\n  getLoopCenter: (edgeId: string) => Position | undefined,\n  defaultDirection: NodeLabelDirectionType\n): NodeLabelDirectionType {\n  if (defaultDirection === NodeLabelDirection.CENTER) {\n    return NodeLabelDirection.CENTER\n  }\n\n  // Avoid overlapping edges from the node.\n  const angles: [number, boolean][] = []\n  Object.entries(oppositeNodes).forEach(([edgeId, oppositeNode]) => {\n    let isSelfLoop = false\n    if (oppositeNode.nodeId === nodeId) {\n      // self looped edge\n      const center = getLoopCenter(edgeId)\n      if (center) {\n        isSelfLoop = true\n        oppositeNode = {\n          ...oppositeNode,\n          pos: { x: center.x, y: center.y },\n        }\n      }\n    }\n    // angleDegree(): east=0, north=90, west=180, south=-90\n    // -> Divide into 10 azimuths except horizontal, and assign indexes including\n    //    horizontal in clockwise direction\n    const angle = (angleDegree(subtract(oppositeNode.pos, currentPos)) + 360 + 90) % 360\n    angles.push([angle, isSelfLoop])\n  })\n\n  const directionIndex = directionToIndex(defaultDirection)\n\n  // order of priority.\n  const candidates = [\n    directionIndex,\n    (directionIndex + 4) % 8, // priority is given to diagonals\n    (directionIndex + 2) % 8,\n    (directionIndex - 2 + 8) % 8,\n    (directionIndex + 1) % 8,\n    (directionIndex - 1 + 8) % 8,\n    (directionIndex + 3) % 8,\n    (directionIndex - 3 + 8) % 8,\n  ]\n\n  const azimuth = candidates.find(c => {\n    return angles.every(a => !denyAngles[c](...a))\n  })\n  if (azimuth === undefined) {\n    return defaultDirection\n  } else {\n    return indexToDirection(azimuth, defaultDirection)\n  }\n}\n\nfunction inRange(target: number, center: number, amount: number): boolean {\n  target %= 360\n  const min = (center - amount + 360) % 360\n  const max = (center + amount) % 360\n  if (min <= max) {\n    return min < target && target < max\n  } else {\n    return min < target || target < max\n  }\n}\n\nfunction directionToIndex(direction: NodeLabelDirectionType) {\n  return labelDirections[direction] ?? 0\n}\n\nfunction indexToDirection(index: number, defaultValue: NodeLabelDirectionType) {\n  return (Object.entries(labelDirections)[index]?.[0] ?? defaultValue) as NodeLabelDirectionType\n}\n","<script setup lang=\"ts\">\nimport { computed, ref, watchEffect } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { NodeLabelDirection } from \"@/common/configs\"\nimport { NodeState } from \"@/models/node\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { useNodeConfig } from \"@/composables/config\"\nimport { useStates } from \"@/composables/state\"\nimport { handleNodeLabelAutoAdjustment } from \"@/modules/node/label\"\nimport VLabelText from \"@/components/base/VLabelText.vue\"\n\ninterface Props {\n  id: string\n  state: NodeState\n  pos?: Position\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  pos: undefined,\n})\n\nconst configs = useNodeConfig()\nconst { edgeStates } = useStates()\nconst { scale } = useZoomLevel()\n\nconst {\n  handleNodePointerDownEvent,\n  handleNodePointerOverEvent,\n  handleNodePointerOutEvent,\n  handleNodeClickEvent,\n  handleNodeDoubleClickEvent,\n  handleNodeContextMenu,\n} = useMouseOperation()\n\nconst x = computed(() => props.pos?.x || 0)\nconst y = computed(() => props.pos?.y || 0)\n\nconst labelMargin = computed(() => {\n  if (props.state.label.direction === NodeLabelDirection.CENTER) {\n    return 0\n  } else {\n    return props.state.label.margin * scale.value\n  }\n})\n\nconst labelShiftV = ref(0) // Amount of label shift (vertical)\nconst labelShiftH = ref(0) // Amount of label shift (horizontal)\nconst labelDiagonalShiftV = ref(0) // Amount of shift in diagonal direction (vertical)\nconst labelDiagonalShiftH = ref(0) // Amount of shift in diagonal direction (horizontal)\n\nconst labelDirection = computed(() => {\n  const direction = props.state.label.direction\n  const autoAdjustment = props.state.label.directionAutoAdjustment\n  if (autoAdjustment === false) {\n    return direction\n  }\n\n  const pos = { x: x.value, y: y.value }\n  if (autoAdjustment === true) {\n    return handleNodeLabelAutoAdjustment(\n      props.state.id,\n      pos,\n      props.state.oppositeNodes,\n      (edgeId: string) => edgeStates[edgeId]?.loop?.center,\n      direction\n    )\n  } else {\n    return (\n      autoAdjustment({\n        nodeId: props.state.id,\n        pos,\n        oppositeNodes: props.state.oppositeNodes,\n      }) ?? direction\n    )\n  }\n})\n\nconst textAnchor = computed(() => {\n  switch (labelDirection.value) {\n    case NodeLabelDirection.CENTER:\n    case NodeLabelDirection.NORTH:\n    case NodeLabelDirection.SOUTH:\n      return \"middle\"\n    case NodeLabelDirection.EAST:\n    case NodeLabelDirection.NORTH_EAST:\n    case NodeLabelDirection.SOUTH_EAST:\n      return \"start\"\n    case NodeLabelDirection.WEST:\n    case NodeLabelDirection.NORTH_WEST:\n    case NodeLabelDirection.SOUTH_WEST:\n    default:\n      return \"end\"\n  }\n})\n\nconst dominantBaseline = computed(() => {\n  switch (labelDirection.value) {\n    case NodeLabelDirection.NORTH:\n    case NodeLabelDirection.NORTH_EAST:\n    case NodeLabelDirection.NORTH_WEST:\n      return \"text-top\"\n    case NodeLabelDirection.SOUTH:\n    case NodeLabelDirection.SOUTH_EAST:\n    case NodeLabelDirection.SOUTH_WEST:\n      return \"hanging\"\n    case NodeLabelDirection.CENTER:\n    case NodeLabelDirection.EAST:\n    case NodeLabelDirection.WEST:\n    default:\n      return \"central\"\n  }\n})\n\nconst labelX = computed(() => {\n  switch (labelDirection.value) {\n    case NodeLabelDirection.CENTER:\n    case NodeLabelDirection.NORTH:\n    case NodeLabelDirection.SOUTH:\n      return 0\n    case NodeLabelDirection.EAST:\n      return labelShiftH.value\n    case NodeLabelDirection.WEST:\n      return -labelShiftH.value\n    case NodeLabelDirection.NORTH_EAST:\n    case NodeLabelDirection.SOUTH_EAST:\n      return labelDiagonalShiftH.value\n    case NodeLabelDirection.NORTH_WEST:\n    case NodeLabelDirection.SOUTH_WEST:\n    default:\n      return -labelDiagonalShiftH.value\n  }\n})\n\nconst labelY = computed(() => {\n  switch (labelDirection.value) {\n    case NodeLabelDirection.NORTH:\n      return -labelShiftV.value\n    case NodeLabelDirection.SOUTH:\n      return labelShiftV.value\n    case NodeLabelDirection.CENTER:\n    case NodeLabelDirection.EAST:\n    case NodeLabelDirection.WEST:\n      return 0\n    case NodeLabelDirection.NORTH_EAST:\n    case NodeLabelDirection.NORTH_WEST:\n      return -labelDiagonalShiftV.value\n    case NodeLabelDirection.SOUTH_EAST:\n    case NodeLabelDirection.SOUTH_WEST:\n    default:\n      return labelDiagonalShiftV.value\n  }\n})\n\nwatchEffect(() => {\n  const s = scale.value\n  const shape = props.state.shape\n  if (shape.type == \"circle\") {\n    const radius = shape.radius * s\n    const m = radius + labelMargin.value\n    const diagonalMargin = Math.sqrt(m ** 2 / 2)\n    labelShiftV.value = radius + labelMargin.value\n    labelShiftH.value = radius + labelMargin.value\n    labelDiagonalShiftV.value = diagonalMargin\n    labelDiagonalShiftH.value = diagonalMargin\n  } else {\n    const borderRadius = shape.borderRadius * s\n    const width = shape.width * s\n    const height = shape.height * s\n    const m = borderRadius + labelMargin.value\n    const diagonalMargin = Math.sqrt(m ** 2 / 2)\n    labelShiftV.value = height / 2 + labelMargin.value\n    labelShiftH.value = width / 2 + labelMargin.value\n    labelDiagonalShiftV.value = height / 2 - borderRadius + diagonalMargin\n    labelDiagonalShiftH.value = width / 2 - borderRadius + diagonalMargin\n  }\n})\n\nconst eventHandlers = computed(() => (id: string) => {\n  if (configs.label.handleNodeEvents) {\n    return {\n      pointerdown: (e: PointerEvent) => {\n        e.stopPropagation()\n        handleNodePointerDownEvent(id, e)\n      },\n      pointerenter: (e: PointerEvent) => handleNodePointerOverEvent(id, e),\n      pointerleave: (e: PointerEvent) => handleNodePointerOutEvent(id, e),\n      click: (e: MouseEvent) => {\n        e.stopPropagation()\n        handleNodeClickEvent(id, e)\n      },\n      dblclick: (e: MouseEvent) => {\n        e.stopPropagation()\n        handleNodeDoubleClickEvent(id, e)\n      },\n      contextmenu: (e: MouseEvent) => {\n        handleNodeContextMenu(id, e)\n      },\n    }\n  } else {\n    return {}\n  }\n})\n\nconst groupClasses = computed(() => {\n  const handleEvents = configs.label.handleNodeEvents\n  return {\n    \"v-ng-node-label\": true,\n    hover: handleEvents && props.state.hovered,\n    selected: handleEvents && props.state.selected,\n  }\n})\n\nconst labelClasses = computed(() => {\n  const handleEvents = configs.label.handleNodeEvents\n  return {\n    draggable: handleEvents && props.state.draggable,\n    selectable: handleEvents && props.state.selectable,\n  }\n})\n</script>\n\n<template>\n  <g\n    :class=\"groupClasses\"\n    :transform=\"`translate(${x} ${y})`\"\n    v-on=\"eventHandlers(id)\"\n  >\n    <slot\n      name=\"override-node-label\"\n      :node-id=\"id\"\n      :scale=\"scale\"\n      :text=\"state.labelText\"\n      :x=\"labelX\"\n      :y=\"labelY\"\n      :config=\"state.label\"\n      :shape=\"state.shape\"\n      :text-anchor=\"textAnchor\"\n      :dominant-baseline=\"dominantBaseline\"\n      :class=\"labelClasses\"\n    >\n      <v-label-text\n        :text=\"state.labelText\"\n        :x=\"0\"\n        :y=\"0\"\n        :config=\"state.label\"\n        :text-anchor=\"textAnchor\"\n        :dominant-baseline=\"dominantBaseline\"\n        :class=\"labelClasses\"\n        :transform=\"`translate(${labelX} ${labelY})`\"\n      />\n    </slot>\n  </g>\n</template>\n\n<style lang=\"scss\">\n$transition: 0.1s linear;\n\n:where(.v-ng-node-label) {\n  > :where(*) {\n    cursor: default;\n    user-select: none;\n    transition: transform $transition;\n  }\n\n  .draggable,\n  .selectable {\n    pointer-events: all;\n    cursor: pointer;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, useSlots } from \"vue\"\nimport { useNodeConfig } from \"@/composables/config\"\nimport { useLayouts } from \"@/composables/layout\"\nimport { useStates } from \"@/composables/state\"\nimport { NodeState } from \"@/models/node\"\nimport VNodeLabel from \"@/components/node/VNodeLabel.vue\"\n\nconst slots = useSlots()\nconst hasOverrideNodeLabelSlot = computed(() => \"override-node-label\" in slots)\nconst { nodeZOrderedList } = useStates()\n\nconst configs = useNodeConfig()\nconst layouts = useLayouts()\n\nconst nodeStates = computed(() => onlyHasDisplayLabel(nodeZOrderedList.value))\n\nfunction onlyHasDisplayLabel(nodeZOrderedList: NodeState[]): NodeState[] {\n  return nodeZOrderedList.filter(state => {\n    return state.label.visible && (state.labelText ?? false)\n  })\n}\n</script>\n\n<template>\n  <template v-if=\"hasOverrideNodeLabelSlot\">\n    <transition-group\n      :name=\"configs.transition\"\n      :css=\"!!configs.transition\"\n      tag=\"g\"\n      class=\"v-ng-layer-node-labels\"\n    >\n      <v-node-label\n        v-for=\"nodeState in nodeStates\"\n        :id=\"nodeState.id\"\n        :key=\"nodeState.id\"\n        :state=\"nodeState\"\n        :pos=\"layouts.nodes[nodeState.id]\"\n      >\n        <!-- override the node label -->\n        <template #override-node-label=\"slotProps\">\n          <slot name=\"override-node-label\" v-bind=\"slotProps\" />\n        </template>\n      </v-node-label>\n    </transition-group>\n  </template>\n  <template v-else>\n    <transition-group\n      :name=\"configs.transition\"\n      :css=\"!!configs.transition\"\n      tag=\"g\"\n      class=\"v-ng-layer-node-labels\"\n    >\n      <v-node-label\n        v-for=\"nodeState in nodeStates\"\n        :id=\"nodeState.id\"\n        :key=\"nodeState.id\"\n        :state=\"nodeState\"\n        :pos=\"layouts.nodes[nodeState.id]\"\n      />\n    </transition-group>\n  </template>\n</template>\n","<script setup lang=\"ts\">\nimport { chunk } from \"lodash-es\"\nimport { CSSProperties, computed } from \"vue\"\nimport { PositionOrCurve } from \"@/common/types\"\nimport { Config } from \"@/common/configs\"\nimport { PathState } from \"@/models/path\"\nimport { usePathConfig } from \"@/composables/config\"\nimport { useZoomLevel } from \"@/composables/zoom\"\nimport { applyScaleToDasharray, getDasharrayUnit } from \"@/utils/visual\"\nimport { useStates } from \"@/composables/state\"\nimport { calculatePathPoints } from \"@/modules/calculation/path\"\n\nconst props = defineProps<{\n  path: PathState\n}>()\n\nconst { nodeStates, edgeStates, layouts } = useStates()\nconst { scale } = useZoomLevel()\nconst pathConfig = usePathConfig()\n\nfunction calcPathPoints(path: PathState): PositionOrCurve[] {\n  if (path.edges.length === 0) return []\n  const margin = Config.value(pathConfig.margin, path.path) * scale.value\n  return calculatePathPoints(\n    path,\n    nodeStates,\n    layouts.nodes,\n    edgeStates,\n    scale.value,\n    pathConfig.curveInNode,\n    pathConfig.end,\n    margin\n  )\n}\n\nfunction calcPathD(path: PathState) {\n  const points = calcPathPoints(path)\n  let move = true\n  return points\n    .map(p => {\n      if (p === null) {\n        move = true\n      } else if (typeof p === \"string\") {\n        return p\n      } else if (p instanceof Array) {\n        p = [...p]\n        const list = []\n        if (p.length % 2 === 1) {\n          const x = p[0]\n          p = p.slice(1)\n          list.push(`L ${x.x} ${x.y}`)\n        }\n        chunk(p, 2).map(([p1, p2]) => list.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`))\n        return list.join(\" \")\n      } else {\n        const m = move\n        move = false\n        return `${m ? \"M \" : \"L \"}${p.x} ${p.y}`\n      }\n    })\n    .join(\" \")\n}\n\nconst config = computed(() => {\n  const state = props.path\n  if (state.selected) {\n    return Config.values(pathConfig.selected, state.path)\n  } else if (state.hovered && pathConfig.hover) {\n    return Config.values(pathConfig.hover, state.path)\n  } else {\n    return Config.values(pathConfig.normal, state.path)\n  }\n})\n\nconst strokeDasharray = computed(() => {\n  return applyScaleToDasharray(config.value.dasharray, scale.value)\n})\n\nconst animationSpeed = computed(() => {\n  const speed = config.value.animate\n    ? getDasharrayUnit(config.value.dasharray) * config.value.animationSpeed * scale.value\n    : false\n  return speed ? ({ \"--animation-speed\": speed } as CSSProperties) : undefined\n})\n</script>\n\n<template>\n  <path\n    :class=\"{\n      'v-ng-path': true,\n      animate: config.animate,\n      clickable: path.clickable,\n      hoverable: path.hoverable,\n    }\"\n    :d=\"calcPathD(path)\"\n    fill=\"none\"\n    :stroke=\"config.color\"\n    :stroke-width=\"config.width * scale\"\n    :stroke-dasharray=\"strokeDasharray\"\n    :stroke-linecap=\"config.linecap\"\n    :stroke-linejoin=\"config.linejoin\"\n    :style=\"animationSpeed\"\n  />\n</template>\n\n<style lang=\"scss\">\n$transition: 0.1s linear;\n\n.v-path {\n  pointer-events: none;\n  transition:\n    stroke $transition,\n    stroke-width $transition;\n\n  &.clickable {\n    pointer-events: stroke;\n    cursor: pointer;\n  }\n  &.hoverable {\n    pointer-events: stroke;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { useStates } from \"@/composables/state\"\nimport { usePathConfig } from \"@/composables/config\"\nimport { useMouseOperation } from \"@/composables/mouse\"\nimport VPath from \"./VPath.vue\"\n\nconst { pathZOrderedList } = useStates()\nconst pathConfig = usePathConfig()\n\nconst {\n  handlePathPointerDownEvent,\n  handlePathPointerOverEvent,\n  handlePathPointerOutEvent,\n  handlePathClickEvent,\n  handlePathDoubleClickEvent,\n  handlePathContextMenu,\n} = useMouseOperation()\n</script>\n\n<template>\n  <transition-group\n    :name=\"pathConfig.transition\"\n    :css=\"!!pathConfig.transition\"\n    tag=\"g\"\n    class=\"v-ng-paths\"\n  >\n    <template v-for=\"path in pathZOrderedList\" :key=\"path.id\">\n      <v-path\n        :path=\"path\"\n        @pointerdown=\"handlePathPointerDownEvent(path.id, $event)\"\n        @pointerenter.passive=\"handlePathPointerOverEvent(path.id, $event)\"\n        @pointerleave.passive=\"handlePathPointerOutEvent(path.id, $event)\"\n        @click.stop=\"handlePathClickEvent(path.id, $event)\"\n        @dblclick.stop=\"handlePathDoubleClickEvent(path.id, $event)\"\n        @contextmenu=\"handlePathContextMenu(path.id, $event)\"\n      />\n    </template>\n  </transition-group>\n</template>\n","<script setup lang=\"ts\">\nimport { readonly, ref, toRef, useSlots, computed, nextTick, watch, CSSProperties } from \"vue\"\nimport { EventHandlers, Nodes, Edges, InputPaths, Layouts, UserLayouts } from \"@/common/types\"\nimport { Layers, LayerPosition, LayerPositions, Point, Sizes } from \"@/common/types\"\nimport { Reactive, nonNull } from \"@/common/common\"\nimport { UserConfigs, ViewConfig } from \"@/common/configs\"\nimport { provideContainers } from \"@/composables/container\"\nimport { provideConfigs } from \"@/composables/config\"\nimport { provideStates, makeStateInput } from \"@/composables/state\"\nimport { provideMouseOperation } from \"@/composables/mouse\"\nimport { provideEventEmitter } from \"@/composables/event-emitter\"\nimport { makeMarkerState } from \"@/composables/marker\"\nimport { useSvgPanZoom } from \"@/composables/svg-pan-zoom\"\nimport { provideZoomLevel } from \"@/composables/zoom\"\nimport { useTransitionWhile } from \"@/composables/transition\"\nimport { useTranslatePathsToObject } from \"@/composables/object\"\nimport { bindProp, bindPropKeySet } from \"@/utils/props\"\nimport * as svgUtils from \"@/utils/svg\"\nimport { SvgPanZoomInstance, Box } from \"@/modules/svg-pan-zoom-ex\"\nimport { exportSvgElement, exportSvgElementWithOptions, ExportOptions } from \"@/utils/svg\"\nimport { provideSelections } from \"@/composables/selection\"\nimport { provideLayouts } from \"@/composables/layout\"\nimport { useBuiltInLayerOrder } from \"@/composables/layer\"\nimport { asyncNextTick } from \"@/modules/vue/nextTick\"\nimport { isPromise } from \"@/utils/object\"\nimport VSelectionBox from \"./base/VSelectionBox.vue\"\nimport VMarkerHead from \"./marker/VMarkerHead.vue\"\nimport VBackgroundGrid from \"./background/VBackgroundGrid.vue\"\nimport VBackgroundViewport from \"./background/VBackgroundViewport.vue\"\nimport VEdgesLayer from \"./layers/VEdgesLayer.vue\"\nimport VEdgeLabelsLayer from \"./layers/VEdgeLabelsLayer.vue\"\nimport VFocusringLayer from \"./layers/VFocusringLayer.vue\"\nimport VNodesLayer from \"./layers/VNodesLayer.vue\"\nimport VNodeLabelsLayer from \"./layers/VNodeLabelsLayer.vue\"\nimport VPathsLayer from \"./layers/VPathsLayer.vue\"\n\nconst SYSTEM_SLOTS = [\n  \"override-node\",\n  \"override-node-label\",\n  \"edge-overlay\",\n  \"edge-label\",\n  \"edges-label\",\n]\n\nenum State {\n  INITIAL = 0,\n  LOADED = 1,\n  UNLOADED = 2,\n}\n\ninterface Props {\n  nodes?: Nodes\n  edges?: Edges\n  paths?: InputPaths\n  layouts?: UserLayouts\n  zoomLevel?: number\n  selectedNodes?: string[]\n  selectedEdges?: string[]\n  selectedPaths?: string[]\n  configs?: UserConfigs\n  layers?: Layers\n  eventHandlers?: EventHandlers\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  nodes: () => ({}),\n  edges: () => ({}),\n  paths: () => ({}),\n  layouts: () => ({}),\n  zoomLevel: 1,\n  selectedNodes: () => [],\n  selectedEdges: () => [],\n  selectedPaths: () => [],\n  configs: () => ({}),\n  layers: () => ({}),\n  eventHandlers: () => ({}),\n})\n\nconst emit = defineEmits<{\n  (e: \"update:zoomLevel\", v: number): void\n  (e: \"update:selectedNodes\", v: string[]): void\n  (e: \"update:selectedEdges\", v: string[]): void\n  (e: \"update:selectedPaths\", v: string[]): void\n  (e: \"update:layouts\", v: Layouts): void\n}>()\n\nconst slots = useSlots()\n\nconst nodesRef = toRef(props, \"nodes\")\nconst edgesRef = toRef(props, \"edges\")\nconst { objects: pathsRef, isInCompatibilityModeForPath } = useTranslatePathsToObject(\n  toRef(props, \"paths\")\n)\n\n// Event Bus\nconst emitter = provideEventEmitter()\nObject.entries(props.eventHandlers).forEach(([type, event]) => {\n  emitter.on(type as any, event as any)\n})\n\n// Style settings\nconst configs = provideConfigs(toRef(props, \"configs\"))\n\n// Additional layers\nconst layerDefs = computed(() => {\n  const definedSlots = new Set(Object.keys(slots))\n  SYSTEM_SLOTS.forEach(s => definedSlots.delete(s))\n\n  const layers = Object.fromEntries(LayerPositions.map(n => [n, [] as string[]]))\n  Object.assign(\n    layers,\n    Object.entries(props.layers).reduce(\n      (accum, [name, type]) => {\n        definedSlots.delete(name)\n        if (type in accum) {\n          accum[type].push(name)\n        } else {\n          accum[type] = [name]\n        }\n        return accum\n      },\n      {} as Record<LayerPosition, string[]>\n    )\n  )\n  // The default slot and any slots not defined in the layers into root.\n  layers[\"root\"].push(...definedSlots)\n  return layers as Record<LayerPosition, string[]>\n})\n\n// Grid layer\nconst isShowGrid = computed(() => configs.view.grid.visible)\nconst isShowBackgroundViewport = computed(() => {\n  const layers = layerDefs.value\n  return isShowGrid.value || layers[\"background\"].length > 0 || layers[\"grid\"].length > 0\n})\n\nconst builtInLayerOrder = useBuiltInLayerOrder(configs, slots)\n\n// -----------------------------------------------------------------------\n// SVG\n// -----------------------------------------------------------------------\nconst container = ref<HTMLDivElement>()\nconst svg = ref<SVGElement & SVGSVGElement>()\nconst viewport = ref<SVGGElement>()\nconst state = ref<State>(State.INITIAL)\nconst show = computed(() => state.value !== State.INITIAL)\n\nconst zoomLevel = bindProp(props, \"zoomLevel\", emit, v => {\n  v = Math.max(v, configs.view.minZoomLevel)\n  v = Math.min(v, configs.view.maxZoomLevel)\n  return v\n})\n\n// SVG pan / zoom\nconst { svgPanZoom, onSvgPanZoomMounted, onSvgPanZoomUnmounted } = useSvgPanZoom(svg, {\n  viewportSelector: \".v-ng-viewport\",\n  minZoom: configs.view.minZoomLevel, // temporary\n  maxZoom: configs.view.maxZoomLevel, // temporary\n  dblClickZoomEnabled: isDoubleClickZoomEnabled(configs.view),\n  mouseWheelZoomEnabled: isMouseWheelZoomEnabled(configs.view),\n  fit: configs.view.autoPanAndZoomOnLoad === \"fit-content\",\n  center: configs.view.autoPanAndZoomOnLoad !== false,\n  zoomEnabled: configs.view.zoomEnabled,\n  preventMouseEventsDefault: false,\n  onZoom: _ => {\n    if (state.value === State.UNLOADED) return\n    const z = svgPanZoom.value?.getRealZoom() ?? 1\n    if (Math.abs(zoomLevel.value - z) >= 1.0e-6) {\n      zoomLevel.value = z\n      emitter.emit(\"view:zoom\", z)\n    }\n  },\n  panEnabled: configs.view.panEnabled,\n  onPan: p => {\n    if (state.value === State.UNLOADED) return\n    emitter.emit(\"view:pan\", p)\n  },\n})\n\nprovideContainers({ container, svg, viewport, svgPanZoom })\n\n// Observe container resizing\nconst rectSize = { width: 0, height: 0 }\nconst resizeObserver = globalThis.ResizeObserver\n  ? new ResizeObserver(() => {\n      svgPanZoom.value?.resize()\n      if (!configs.view.autoPanOnResize) return\n      // Pan to keep the view area centered\n      const r = container.value?.getBoundingClientRect()\n      if (r) {\n        const x = -(rectSize.width - r.width) / 2\n        const y = -(rectSize.height - r.height) / 2\n        svgPanZoom.value?.panBy({ x, y })\n        const { width, height } = r\n        if (rectSize.width !== width || rectSize.height !== height) {\n          Object.assign(rectSize, { width, height })\n          emitter.emit(\"view:resize\", { x: r.x, y: r.y, width, height })\n        }\n      }\n    })\n  : undefined\nonSvgPanZoomMounted(() => {\n  const c = nonNull(container.value, \"svg-pan-zoom container\")\n  resizeObserver?.observe(c)\n  configs.view.onSvgPanZoomInitialized?.(nonNull(svgPanZoom.value, \"svg-pan-zoom instance\"))\n  const r = c.getBoundingClientRect()\n  const { width, height } = r\n  Object.assign(rectSize, { width, height })\n  viewport.value?.addEventListener(\"touchstart\", stopEventPropagation, { passive: false })\n})\nonSvgPanZoomUnmounted(() => {\n  resizeObserver?.disconnect()\n  viewport.value?.removeEventListener(\"touchstart\", stopEventPropagation)\n})\n\nconst applyAbsoluteZoomLevel = (absoluteZoomLevel: number) => {\n  svgPanZoom.value?.applyAbsoluteZoomLevel(\n    absoluteZoomLevel,\n    configs.view.minZoomLevel,\n    configs.view.maxZoomLevel\n  )\n}\n\nwatch(\n  () => configs.view.panEnabled,\n  v => {\n    svgPanZoom.value?.setPanEnabled(v)\n  }\n)\nwatch(\n  () => [\n    configs.view.zoomEnabled,\n    isDoubleClickZoomEnabled(configs.view),\n    isMouseWheelZoomEnabled(configs.view),\n  ],\n  () => {\n    const svgPanZoomInstance = svgPanZoom.value\n    if (!svgPanZoomInstance) return\n    applyZoomEnabled(\n      svgPanZoomInstance,\n      configs.view.zoomEnabled,\n      configs.view.doubleClickZoomEnabled,\n      configs.view.mouseWheelZoomEnabled\n    )\n  }\n)\n\nwatch(zoomLevel, v => applyAbsoluteZoomLevel(v))\nwatch(\n  () => [configs.view.minZoomLevel, configs.view.maxZoomLevel],\n  _ => {\n    applyAbsoluteZoomLevel(zoomLevel.value)\n  }\n)\n\n// Provide zoom level / scaling parameter\nconst { scale } = provideZoomLevel(zoomLevel, configs.view)\n\nonSvgPanZoomMounted(() => {\n  // apply initial zoom level\n  const initialZoomLevel = props.zoomLevel\n  applyAbsoluteZoomLevel(initialZoomLevel)\n})\n\n// To resolve the problem that the center position and\n// magnification rate may not be recognized.\nconst updateBorderBox = async () => {\n  if (Object.keys(props.nodes).length > 0) {\n    svgPanZoom.value?.updateBBox()\n    await asyncNextTick()\n  }\n}\n\n// Scales the content to fit in the SVG area.\nconst fitToContents = async () => {\n  await updateBorderBox()\n  if (svgPanZoom.value) {\n    svgPanZoom.value.fitToContents()\n    emitter.emit(\"view:fit\", undefined)\n  }\n}\n\n// Place content in the center of the SVG area.\nconst panToCenter = async () => {\n  await updateBorderBox()\n  svgPanZoom.value?.center()\n}\n\n// Get viewport box\nconst getViewBox = () =>\n  svgPanZoom.value?.getViewBox() ?? {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n  }\n\n// Get viewport box\nconst setViewBox = (box: Box) => svgPanZoom.value?.setViewBox(box)\n\n// -----------------------------------------------------------------------\n// States of selected nodes/edges\n// -----------------------------------------------------------------------\nconst currentSelectedNodes = bindPropKeySet(props, \"selectedNodes\", nodesRef, emit)\nwatch(currentSelectedNodes, nodes => emitter.emit(\"node:select\", Array.from(nodes)))\n\nconst currentSelectedEdges = bindPropKeySet(props, \"selectedEdges\", edgesRef, emit)\nwatch(currentSelectedEdges, edges => emitter.emit(\"edge:select\", Array.from(edges)))\n\nconst currentSelectedPaths = bindPropKeySet(props, \"selectedPaths\", pathsRef, emit)\nwatch(currentSelectedPaths, paths => emitter.emit(\"path:select\", Array.from(paths)))\n\nprovideSelections(currentSelectedNodes, currentSelectedEdges, currentSelectedPaths)\n\nconst hoveredNodes = Reactive(new Set<string>())\nconst hoveredEdges = Reactive(new Set<string>())\nconst hoveredPaths = Reactive(new Set<string>())\nconst currentLayouts = Reactive<Layouts>({ nodes: {} })\n\nprovideLayouts(currentLayouts)\n\n// two-way binding\nwatch(\n  () => props.layouts,\n  () => Object.assign(currentLayouts, props.layouts),\n  { deep: true, immediate: true }\n)\nwatch(currentLayouts, () => emit(\"update:layouts\", currentLayouts), { deep: true })\n\n// -----------------------------------------------------------------------\n// SVG Markers\n// -----------------------------------------------------------------------\nconst markerState = makeMarkerState()\n\n// -----------------------------------------------------------------------\n// Mouse processing\n// -----------------------------------------------------------------------\n\n// mouse pointer change on dragging\nconst dragging = ref<boolean>(false)\nemitter.on(\"node:dragstart\", _ => (dragging.value = true))\nemitter.on(\"node:dragend\", _ => (dragging.value = false))\nemitter.on(\"view:mode\", mode => {\n  // avoid pan/zoom when using nodes and edges with multi-touch\n  if (configs.view.panEnabled) {\n    if (mode === \"default\") {\n      svgPanZoom.value?.enablePan()\n    } else {\n      svgPanZoom.value?.disablePan()\n    }\n  }\n  if (configs.view.zoomEnabled) {\n    if (mode === \"default\") {\n      svgPanZoom.value?.enableZoom()\n    } else {\n      svgPanZoom.value?.disableZoom()\n    }\n  }\n})\n\nconst touches = computed(() => {\n  return configs.view.panEnabled || configs.view.zoomEnabled || configs.node.draggable\n})\n\nconst { nodeStates, edgeStates, pathStates } = provideStates(\n  makeStateInput(nodesRef, currentSelectedNodes, hoveredNodes),\n  makeStateInput(edgesRef, currentSelectedEdges, hoveredEdges),\n  makeStateInput(pathsRef, currentSelectedPaths, hoveredPaths),\n  readonly(configs),\n  currentLayouts,\n  markerState,\n  scale\n)\n\nconst isSvgWheelZoomEnabled = computed(() => isMouseWheelZoomEnabled(configs.view))\n\n// mouse and touch support\nconst { isBoxSelectionMode, selectionBox, startBoxSelection, stopBoxSelection } =\n  provideMouseOperation(\n    svg,\n    readonly(currentLayouts),\n    readonly(zoomLevel),\n    nodeStates,\n    edgeStates,\n    pathStates,\n    currentSelectedNodes,\n    currentSelectedEdges,\n    currentSelectedPaths,\n    hoveredNodes,\n    hoveredEdges,\n    hoveredPaths,\n    isInCompatibilityModeForPath,\n    isSvgWheelZoomEnabled,\n    configs,\n    emitter\n  )\n\n// -----------------------------------------------------------------------\n// Node layout handler\n// -----------------------------------------------------------------------\n\nconst activateParams = () => ({\n  layouts: Reactive(currentLayouts.nodes), // deprecated parameter.\n  nodePositions: toRef(currentLayouts, \"nodes\"),\n  nodes: nodesRef,\n  edges: edgesRef,\n  configs: readonly(configs),\n  scale: readonly(scale),\n  emitter,\n  svgPanZoom: nonNull(svgPanZoom.value),\n})\nwatch(\n  () => configs.view.layoutHandler,\n  (newHandler, oldHandler) => {\n    oldHandler.deactivate()\n    newHandler.activate(activateParams())\n  }\n)\n\n// -----------------------------------------------------------------------\n// Transition of element positions\n// -----------------------------------------------------------------------\n\n// #transitionWhile() method\nconst { transitionWhile, transitionOption } = useTransitionWhile()\nconst transitionStyles = computed(() => {\n  const o = transitionOption.value\n  return (\n    o.enabled\n      ? {\n          \"--transition-duration\": o.duration + \"ms\",\n          \"--transition-function\": o.timingFunction,\n        }\n      : {}\n  ) as CSSProperties\n})\n\n// -----------------------------------------------------------------------\n// Events\n// -----------------------------------------------------------------------\n\nonSvgPanZoomMounted(async () => {\n  // Wait promise for network loading\n  if (configs.view.onBeforeInitialDisplay) {\n    const promise = configs.view.onBeforeInitialDisplay()\n    if (isPromise(promise)) {\n      await promise\n    }\n  }\n\n  // pan to center\n  const svg = nonNull(svgPanZoom.value, \"svg-pan-zoom\")\n\n  // activate layout handler.\n  // (calc the positions of nodes whose positions are not specified)\n  configs.view.layoutHandler.activate(activateParams())\n\n  // Wait for applying network/layout changes such as nodes, layouts, etc.\n  // by onBeforeInitialDisplay/LayoutHandler\n  await asyncNextTick()\n\n  const autoPanAndZoom = configs.view.autoPanAndZoomOnLoad\n  if (configs.view.fit || autoPanAndZoom !== false) {\n    const nodesEmpty = Object.keys(props.nodes).length == 0\n    const pan1 = svg.getPan()\n    if (nodesEmpty || autoPanAndZoom === \"center-zero\") {\n      await updateBorderBox()\n      // Pan (0, 0) to the center.\n      const sizes = svg.getSizes()\n      svg.pan({\n        x: sizes.width / 2,\n        y: sizes.height / 2,\n      })\n    } else if (autoPanAndZoom === \"fit-content\" || configs.view.fit) {\n      await fitToContents()\n    } else if (autoPanAndZoom === \"center-content\") {\n      await panToCenter()\n    } else {\n      await updateBorderBox()\n    }\n\n    // If the pan position does not change, the onPan event of svg-pan-zoom\n    // is not fired, but v-network-graph always fires the `view:pan` event\n    // when initialized.\n    nextTick(() => {\n      const pan2 = svg.getPan()\n      if (pan1.x === pan2.x && pan1.y === pan2.y) {\n        emitter.emit(\"view:pan\", pan2)\n      }\n    })\n  } else {\n    await updateBorderBox()\n  }\n\n  emitter.emit(\"view:load\")\n\n  // start displaying the svg\n  state.value = State.LOADED\n})\n\nonSvgPanZoomUnmounted(() => {\n  state.value = State.UNLOADED\n  emitter.emit(\"view:unload\")\n  configs.view.layoutHandler.deactivate()\n})\n\n/**\n * Zoom in\n */\nfunction zoomIn() {\n  svgPanZoom.value?.zoomIn()\n}\n\n/**\n * Zoom out\n */\nfunction zoomOut() {\n  svgPanZoom.value?.zoomOut()\n}\n\n/**\n * Pan to a rendered position\n * @return {Point} point to pan\n */\nfunction panTo(point: Point) {\n  svgPanZoom.value?.pan(point)\n}\n\n/**\n * Relatively pan the graph by a specified rendered position vector\n * @return {Point} relative point to pan\n */\nfunction panBy(point: Point) {\n  svgPanZoom.value?.panBy(point)\n}\n\n/**\n * Get pan vector\n * @return {Point} pan vector\n */\nfunction getPan(): Point {\n  return nonNull(svgPanZoom.value).getPan()\n}\n\n/**\n * Get all calculate svg dimensions\n */\nfunction getSizes(): Sizes {\n  const sizes = nonNull(svgPanZoom.value).getSizes()\n  return {\n    width: sizes.width,\n    height: sizes.height,\n    viewBox: sizes.viewBox,\n  }\n}\n\n/**\n * Translate from DOM to SVG coordinates\n * @return {Point} coordinates in the SVG\n */\nfunction translateFromDomToSvgCoordinates(coordinates: Point): Point {\n  return svgUtils.translateFromDomToSvgCoordinates(\n    nonNull(svg.value, \"svg\"),\n    nonNull(viewport.value, \"viewport\"),\n    coordinates\n  )\n}\n\n/**\n * Translate from SVG to DOM coordinates\n * @return {Point} coordinates in the DOM\n */\nfunction translateFromSvgToDomCoordinates(coordinates: Point): Point {\n  return svgUtils.translateFromSvgToDomCoordinates(\n    nonNull(svg.value, \"svg\"),\n    nonNull(viewport.value, \"viewport\"),\n    coordinates\n  )\n}\n\n/**\n * Get graph as SVG text.\n * @return {string} SVG text\n * @deprecated\n */\nfunction getAsSvg(): string {\n  const target = exportSvgElement(\n    nonNull(svg.value, \"svg\"),\n    nonNull(viewport.value, \"viewport\"),\n    scale.value\n  )\n  return target.outerHTML\n}\n\n/**\n * Export graph as SVG text.\n * @return {string} SVG text\n */\nasync function exportAsSvgText(options: Partial<ExportOptions> = {}): Promise<string> {\n  const target = exportAsSvgElement(options)\n  return (await target).outerHTML\n}\n\n/**\n * Export graph as SVG element.\n * @return {SVGElement} SVG element\n */\nasync function exportAsSvgElement(options: Partial<ExportOptions> = {}): Promise<SVGElement> {\n  return exportSvgElementWithOptions(\n    nonNull(svg.value, \"svg\"),\n    nonNull(viewport.value, \"viewport\"),\n    scale.value,\n    options\n  )\n}\n\ndefineExpose({\n  // methods\n  fitToContents,\n  panToCenter,\n  getViewBox,\n  setViewBox,\n  transitionWhile,\n  startBoxSelection,\n  stopBoxSelection,\n  zoomIn,\n  zoomOut,\n  panTo,\n  panBy,\n  getPan,\n  getSizes,\n  translateFromDomToSvgCoordinates,\n  translateFromSvgToDomCoordinates,\n  getAsSvg,\n  exportAsSvgText,\n  exportAsSvgElement,\n})\n\n// local functions\n\nfunction applyZoomEnabled(\n  svgPanZoom: SvgPanZoomInstance,\n  enable: boolean,\n  enableDblClick: boolean,\n  enableMouseWheel: boolean\n): void {\n  svgPanZoom.setZoomEnabled(enable)\n  if (enable && enableDblClick) {\n    svgPanZoom.enableDblClickZoom()\n  } else {\n    svgPanZoom.disableDblClickZoom()\n  }\n  if (enable && enableMouseWheel) {\n    svgPanZoom.enableMouseWheelZoom()\n  } else {\n    svgPanZoom.disableMouseWheelZoom()\n  }\n}\n\nfunction isDoubleClickZoomEnabled(view: ViewConfig): boolean {\n  return view.zoomEnabled && view.doubleClickZoomEnabled\n}\n\nfunction isMouseWheelZoomEnabled(view: ViewConfig): boolean {\n  return view.zoomEnabled && view.mouseWheelZoomEnabled\n}\n\nfunction stopEventPropagation(event: Event) {\n  event.stopPropagation()\n}\n</script>\n\n<template>\n  <div ref=\"container\" class=\"v-network-graph v-ng-container\">\n    <svg\n      ref=\"svg\"\n      class=\"v-ng-canvas\"\n      :class=\"{ show, dragging, touches, 'box-selection-mode': isBoxSelectionMode }\"\n      width=\"100%\"\n      height=\"100%\"\n    >\n      <!-- outside of viewport -->\n      <slot\n        v-for=\"layerName in layerDefs['root']\"\n        :key=\"layerName\"\n        :name=\"layerName\"\n        :scale=\"scale\"\n      />\n\n      <defs v-if=\"Object.keys(markerState.markers).length > 0\">\n        <v-marker-head\n          v-for=\"(marker, id) in markerState.markers\"\n          :id=\"id\"\n          :key=\"id\"\n          :marker=\"marker\"\n          :scale=\"scale\"\n        />\n      </defs>\n\n      <!-- background-viewport:\n           area outside the scope of SVG text retrieval but targeted by pan/zoom. -->\n      <v-background-viewport v-if=\"isShowBackgroundViewport\">\n        <g v-for=\"layerName in layerDefs['background']\" :key=\"layerName\" class=\"v-ng-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n\n        <!-- grid -->\n        <v-background-grid v-if=\"isShowGrid\" />\n\n        <g v-for=\"layerName in layerDefs['grid']\" :key=\"layerName\" class=\"v-ng-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n      </v-background-viewport>\n\n      <!-- viewport: pan/zoom target and within the range of SVG text retrieval. -->\n      <g\n        ref=\"viewport\"\n        class=\"v-ng-viewport\"\n        :class=\"{ 'v-ng-transition': transitionOption.enabled }\"\n        :style=\"transitionStyles\"\n      >\n        <g v-for=\"layerName in layerDefs['base']\" :key=\"layerName\" class=\"v-ng-layer\">\n          <slot :name=\"layerName\" :scale=\"scale\" />\n        </g>\n\n        <!-- Sortable built-in layers -->\n        <template v-for=\"layerName in builtInLayerOrder\" :key=\"layerName\">\n          <!-- Edges -->\n          <template v-if=\"layerName === 'edges'\">\n            <v-edges-layer>\n              <template v-if=\"'edge-overlay' in slots\" #edge-overlay=\"slotProps\">\n                <slot name=\"edge-overlay\" v-bind=\"slotProps\" />\n              </template>\n            </v-edges-layer>\n          </template>\n\n          <!-- Edge labels -->\n          <template v-else-if=\"layerName === 'edge-labels'\">\n            <v-edge-labels-layer\n              :enable-edge-label=\"'edge-label' in slots\"\n              :enable-edges-label=\"'edges-label' in slots\"\n            >\n              <template #edge-label=\"slotProps\">\n                <slot name=\"edge-label\" v-bind=\"slotProps\" />\n              </template>\n              <template #edges-label=\"slotProps\">\n                <slot name=\"edges-label\" v-bind=\"slotProps\" />\n              </template>\n            </v-edge-labels-layer>\n          </template>\n\n          <!-- Node focusring -->\n          <template v-else-if=\"layerName === 'focusring'\">\n            <v-focusring-layer />\n          </template>\n\n          <!-- Nodes -->\n          <template v-else-if=\"layerName === 'nodes'\">\n            <v-nodes-layer>\n              <template #override-node=\"slotProps\">\n                <slot name=\"override-node\" v-bind=\"slotProps\" />\n              </template>\n            </v-nodes-layer>\n          </template>\n\n          <!-- Node labels -->\n          <template v-else-if=\"layerName === 'node-labels'\">\n            <v-node-labels-layer>\n              <template #override-node-label=\"slotProps\">\n                <slot name=\"override-node-label\" v-bind=\"slotProps\" />\n              </template>\n            </v-node-labels-layer>\n          </template>\n\n          <!-- Paths -->\n          <template v-else-if=\"layerName === 'paths'\">\n            <v-paths-layer />\n          </template>\n\n          <!-- User defined layer -->\n          <template v-for=\"customLayerName in layerDefs[layerName]\" :key=\"customLayerName\">\n            <g class=\"v-ng-layer\">\n              <slot :name=\"customLayerName\" :scale=\"scale\" />\n            </g>\n          </template>\n        </template>\n      </g>\n\n      <!-- selection box -->\n      <v-selection-box\n        v-if=\"selectionBox\"\n        :box=\"selectionBox\"\n        :config=\"configs.view.selection.box\"\n      />\n    </svg>\n  </div>\n</template>\n\n<style lang=\"scss\">\n:where(.v-ng-container) {\n  width: 100%;\n  height: 100%;\n}\n\n.v-ng-container {\n  padding: 0;\n  position: relative;\n  user-select: none;\n}\n\n.v-ng-canvas {\n  -webkit-tap-highlight-color: transparent;\n  width: 100%;\n  height: 100%;\n  // Respond to disorder until the svgPanZoom library is activated\n  opacity: 0;\n  &.show {\n    opacity: 1;\n    transition: opacity 0.5s linear;\n  }\n}\n\n.v-ng-canvas.dragging {\n  * {\n    cursor: grabbing !important;\n  }\n  .v-ng-line {\n    transition: d 0s;\n  }\n}\n\n.v-ng-canvas.touches {\n  // prevent to perform browser's default action\n  touch-action: none;\n}\n\n.v-ng-canvas.box-selection-mode {\n  cursor: crosshair !important;\n  * {\n    cursor: crosshair !important;\n  }\n}\n\n// Disable transitions before initialization is completed\n.v-ng-canvas:not(.show) {\n  .v-ng-node,\n  .v-ng-node-label,\n  .v-ng-node-focusring,\n  .v-ng-edge,\n  .v-ng-edge-label,\n  .v-ng-path {\n    transition: none;\n    > * {\n      transition: none;\n    }\n  }\n}\n\n// transition options for #transitionWhile()\n.v-ng-viewport.v-ng-transition {\n  --transition-duration: 300ms;\n  --transition-function: linear;\n  .v-ng-node,\n  .v-ng-node-label,\n  .v-ng-node-focusring,\n  .v-ng-edge,\n  .v-ng-edge-label,\n  .v-ng-path {\n    transition: all var(--transition-duration) var(--transition-function);\n    > * {\n      transition: all var(--transition-duration) var(--transition-function);\n    }\n  }\n}\n\n.v-ng-line.animate,\n.v-ng-path.animate {\n  --animation-speed: 100;\n  animation: v-ng-dash 10s linear infinite;\n  stroke-dashoffset: var(--animation-speed);\n}\n@keyframes v-ng-dash {\n  to {\n    stroke-dashoffset: 0;\n  }\n}\n</style>\n","<template>\n  <defs>\n    <component :is=\"'style'\">\n      <slot />\n    </component>\n  </defs>\n</template>\n","<script setup lang=\"ts\">\nimport { computed, Ref, ref, watchEffect } from \"vue\"\nimport { EdgeLabelStyle } from \"@/common/configs\"\nimport { Edge, EdgeLabelArea } from \"@/common/types\"\nimport { VectorLine } from \"@/modules/calculation/line\"\nimport VText from \"@/components/base/VLabelText.vue\"\n\ninterface Props {\n  area: EdgeLabelArea\n  config: EdgeLabelStyle\n  text?: string\n  align?: \"center\" | \"source\" | \"target\"\n  verticalAlign?: \"center\" | \"above\" | \"below\"\n  // The followings are the definitions to avoid passing unwanted\n  // items to <text> when they are specified in v-bind.\n  edge?: Edge\n  hovered?: boolean\n  selected?: boolean\n  scale?: number\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  text: \"\",\n  align: \"center\",\n  verticalAlign: \"center\",\n  edge: undefined,\n  hovered: undefined,\n  selected: undefined,\n  scale: undefined,\n})\n\nconst x = ref(0)\nconst y = ref(0)\nconst textAnchor: Ref<\"middle\" | \"start\" | \"end\"> = ref(\"middle\")\nconst dominantBaseline: Ref<\"text-top\" | \"hanging\" | \"central\"> = ref(\"central\")\nconst angle = ref(0)\n\nwatchEffect(() => {\n  const s = props.area.source\n  const t = props.area.target\n  if (props.align === \"source\") {\n    if (s.above.x == t.above.x) {\n      textAnchor.value = s.above.y > t.above.y ? \"start\" : \"end\"\n    } else {\n      textAnchor.value = s.above.x < t.above.x ? \"start\" : \"end\"\n    }\n    if (props.verticalAlign === \"above\") {\n      x.value = s.above.x\n      y.value = s.above.y\n      dominantBaseline.value = \"text-top\"\n    } else if (props.verticalAlign === \"below\") {\n      x.value = s.below.x\n      y.value = s.below.y\n      dominantBaseline.value = \"hanging\"\n    } else {\n      // center\n      x.value = (s.above.x + s.below.x) / 2\n      y.value = (s.above.y + s.below.y) / 2\n      dominantBaseline.value = \"central\"\n    }\n  } else if (props.align === \"target\") {\n    if (s.above.x == t.above.x) {\n      textAnchor.value = s.above.y < t.above.y ? \"start\" : \"end\"\n    } else {\n      textAnchor.value = s.above.x > t.above.x ? \"start\" : \"end\"\n    }\n    if (props.verticalAlign === \"above\") {\n      x.value = t.above.x\n      y.value = t.above.y\n      dominantBaseline.value = \"text-top\"\n    } else if (props.verticalAlign === \"below\") {\n      x.value = t.below.x\n      y.value = t.below.y\n      dominantBaseline.value = \"hanging\"\n    } else {\n      // center\n      x.value = (t.above.x + t.below.x) / 2\n      y.value = (t.above.y + t.below.y) / 2\n      dominantBaseline.value = \"central\"\n    }\n  } else {\n    // center\n    textAnchor.value = \"middle\"\n    if (props.verticalAlign === \"above\") {\n      x.value = (s.above.x + t.above.x) / 2\n      y.value = (s.above.y + t.above.y) / 2\n      dominantBaseline.value = \"text-top\"\n    } else if (props.verticalAlign === \"below\") {\n      x.value = (s.below.x + t.below.x) / 2\n      y.value = (s.below.y + t.below.y) / 2\n      dominantBaseline.value = \"hanging\"\n    } else {\n      // center\n      x.value = (s.above.x + t.below.x) / 2\n      y.value = (s.above.y + t.below.y) / 2\n      dominantBaseline.value = \"central\"\n    }\n  }\n  let degree = VectorLine.fromPositions(s.above, t.above).v.angleDegree()\n  if (degree < -90 || degree >= 90) {\n    degree = degree + 180\n    if (degree > 180) {\n      degree -= 360\n    }\n  }\n  angle.value = degree\n})\n\n// If there is no background config and text overlaps the line,\n// automatically set the background.\nconst updatedConfig = computed(() => {\n  if (dominantBaseline.value === \"central\" && !props.config.background) {\n    return {\n      ...props.config,\n      background: {\n        visible: true,\n        color: \"#ffffff\",\n        padding: {\n          vertical: 1,\n          horizontal: 4,\n        },\n        borderRadius: 2,\n      },\n    }\n  } else {\n    return props.config\n  }\n})\n</script>\n\n<template>\n  <v-text\n    class=\"v-ng-edge-label\"\n    :text=\"text\"\n    :x=\"x\"\n    :y=\"y\"\n    :config=\"updatedConfig\"\n    :text-anchor=\"textAnchor\"\n    :dominant-baseline=\"dominantBaseline\"\n    :transform=\"`rotate(${angle} ${x} ${y})`\"\n  />\n  <!-- <g>\n    <circle\n      :cx=\"area.source.above.x\"\n      :cy=\"area.source.above.y\"\n      r=\"3\"\n      fill=\"red\"\n    />\n    <circle\n      :cx=\"area.target.above.x\"\n      :cy=\"area.target.above.y\"\n      r=\"3\"\n      fill=\"green\"\n    />\n    <circle\n      :cx=\"area.source.below.x\"\n      :cy=\"area.source.below.y\"\n      r=\"3\"\n      fill=\"blue\"\n    />\n    <circle\n      :cx=\"area.target.below.x\"\n      :cy=\"area.target.below.y\"\n      r=\"3\"\n      fill=\"orange\"\n    />\n  </g> -->\n</template>\n","import { Ref } from \"vue\"\nimport { Position } from \"@/common/types\"\nimport { SimpleLayout } from \"./simple\"\n\nconst DEFAULT_GRID = 10\n\nexport type GridLayoutParameters = {\n  grid?: number\n}\n\nexport class GridLayout extends SimpleLayout {\n  constructor(private options: GridLayoutParameters = {}) {\n    super()\n  }\n\n  protected setNodePosition(nodeLayout: Ref<Position>, pos: Position) {\n    const grid = this.options.grid || DEFAULT_GRID\n    nodeLayout.value.x = Math.floor(pos.x / grid) * grid\n    nodeLayout.value.y = Math.floor(pos.y / grid) * grid\n  }\n}\n","import { App, Plugin } from \"vue\"\n\n// Import vue components\nimport * as components from \"./components/index\"\n\n// install function executed by Vue.use()\nconst install: Exclude<Plugin[\"install\"], undefined> = function (app: App) {\n  Object.entries(components).forEach(([componentName, component]) => {\n    app.component(componentName, component)\n  })\n}\n\n// Create module definition for Vue.use()\nexport default install\n\nexport type VNetworkGraphInstance = InstanceType<typeof components.VNetworkGraph>\nexport type Instance = InstanceType<typeof components.VNetworkGraph>\n\n// To allow individual component use, export components\n// each can be registered via Vue.component()\nexport * from \"./components/index\"\n\nexport { getFullConfigs } from \"./common/config-defaults\"\n\nexport { SimpleLayout } from \"./layouts/simple\"\nexport { GridLayout } from \"./layouts/grid\"\n// export { ForceLayout } from \"./layouts/force\"\nexport type { LayoutHandler } from \"./layouts/handler\"\n\nexport * from \"./common/types\"\nexport * from \"./common/configs\"\nexport { Vector2D } from \"./modules/vector2d\"\n\n// Export for more advanced visualization. However, be aware of the\n// possibility of destructive specification changes in the future.\nexport { useStates } from \"./composables/state\"\n\nexport type { Box } from \"./modules/svg-pan-zoom-ex\"\n"],"names":["LayerPositions","Reactive","value","isReactive","reactive","nonNull","val","name","containersKey","provideContainers","containers","provide","useContainers","inject","Config","target","v","k","NodeLabelDirection","withSelf","callback","self","configsWithType","configs","defineConfigs","getNodeSize","node","style","scale","shape","areNodesCollision","nodePos","nodeSize","targetNodePos","targetNodeSize","collisionX","collisionY","applyScaleToDasharray","dasharray","result","getDasharrayUnit","array","s","n","NEW_NODE_POSITION_MARGIN","SimpleLayout","parameters","nodePositions","nodes","emitter","svgPanZoom","onDrag","positions","id","pos","layout","setNewNodePositions","nodeIds","newNodes","area","nodeId","candidate","__spreadValues","collision","targetNode","stopNodeWatch","watch","isEqual","equality","nodeLayout","round","toRef","getConfigDefaults","event","detect","_a","edge","w","_edges","p","list","hash","a","b","path","getFullConfigs","config","merge","injectionKey","merger","destination","source","isPlainObject","provideConfigs","results","styleKeys","key","mergeWith","injectConfig","useViewConfig","useNodeConfig","useEdgeConfig","usePathConfig","nextId","useId","entriesOf","obj","updateObjectDiff","from","keys","isPromise","makeEdgeGroupStates","edges","state","watchEffect","edgeLayoutPoints","edgeGroups","calculateEdgeGroupAndPositions","summarizedEdges","groupWidth","summarize","defaultCheckSummarize","calculateEdgeShiftedPosition","isSummarized","keepOrder","calculateEdgePositionInner","map","values","calcGap","_e","_c","edgeLen","gap","edgeId","pointInGroup","lineHalfWidths","width","points","i","minWidth","e","x1","y1","x2","y2","calculateLinePosition","_b","_d","_f","_g","_h","dx","dy","diff","radian","perpendicular","sign","moveSlope","diffX","add","v1","v2","subtract","multiply","multiplyScalar","scalar","divide","dot","cross","lengthSquared","length","distanceSquared","distance","normalize","len","rotate","angle","newX","newY","DEGREES","rad2deg","rad","angleDegree","Vector2D","x","y","V","VectorLine","line","toLineVector","sourcePos","targetPos","toVectorsFromLinePosition","getCenterOfLinePosition","toLinePosition","p1","p2","applyMargin","linePos","sourceMargin","targetMargin","applyMarginInner","normalized","sv","tv","check","c1","c2","inverseLine","calculatePerpendicularLine","n1","getNearestPoint","lp","getIntersectionOfLineTargetAndCircle","center","radius","h","hpLen","t","__pow","getIntersectionOfLineTargetAndCircle2","nearBy","ip1","ip2","d1","d2","getIntersectionPointOfLines","line1","line2","t2","getIntersectionOfCircles","center1","radius1","center2","radius2","near","vC1C2","sumR","subR","isLarge","c","cos","rc","rs","n2","tn1","sn2","result1","result2","calculateDistanceToAvoidOverlapsWithRect","rect","centerLine","halfWidth","halfHeight","borderRadius","angleVRad","angleHRad","isCrossedVLine","isCrossedHLine","left","top","right","bottom","vertexes","index","centerOfNearestCircle","point","PointUtils.getIntersectionOfLineTargetAndCircle","PointUtils.getNearestPoint","LineUtils.toLineVector","calculateEdgeLabelArea","edgeStyle","margin","padding","labelMargin","vMargin","sourceAbove","sourceBelow","targetAbove","targetBelow","calculateDistancesFromCenterOfNodeToEndOfNode","sourceNodePos","sourceNodeShape","targetNodeShape","distance1","distance2","moveOnCircumference","reverseAngleRadian","theta","calculateBezierCurveControlPoint","theta0","control","centerToSource","centerToTarget","calculateRelativeAngleRadian","middle","centerToMp","mpTangent","LineUtils.calculatePerpendicularLine","theta1","tangent","cp","PointUtils.getIntersectionPointOfLines","mp","tangent2","cp1","cp2","theta2","calculateCircleCenterAndRadiusBy3Points","p3","x3","y3","x12","y12","x32","y32","getNodeRadius","findFirstNonNull","EPSILON","calculatePathPoints","nodeStates","nodeLayouts","edgeStates","curveInNode","pathEndType","directions","edgePos","_getEdgeLine","isMarginOverRunStart","isMarginOverRunEnd","firstEdge","nodeRadius","NodeUtils.getNodeRadius","lineMargin","nextPoint","_calculateEdgeOfNode","prev","next","crossPoint","_getIntersectionOfLines","nodeCoreRadius","isForwardPrev","_isForward","isForwardNext","prevCoreIp","_getIntersectionOfLineAndNode","nextCoreIp","prevNodeIp","nextNodeIp","d","lastPoints","lastPoint","v2d.calculateBezierCurveControlPoint","arc","_makeArcString","lastEdge","_","calculateDirectionsOfPathEdges","lastNode","isForward","joint","_getJointNode","edgeObject0","edgeObject1","currentEdge","nextEdge","direction","curve","moveRad","v2d.moveOnCircumference","PointUtils.getIntersectionOfCircles","PointUtils.getIntersectionOfLineTargetAndCircle2","prevSlope","_getSlope","nextSlope","nodeCenter","targetSide","position","loop","LineUtils.inverseLine","__spreadProps","rx","ry","ends","end1","end2","isClockwise","a1","largeArc","useObjectState","objects","selected","hovered","createState","terminateState","entriesForZOrder","states","idSet","createNewState","append","removed","zOrderedList","computed","makeZOrderedList","stateObject","unref","zOrder","hover1","hover2","selected1","selected2","convertToAscii","makeMarkerState","useMarker","markerState","markers","referenceCount","addMarker","marker","m","removeMarker","clearMarker","makeMarker","isSource","previousId","strokeColor","instanceId","headMarker","toHeadMarker","buildKey","u","makeStateInput","statesKey","NONE_MARKER","provideStates","paths","layouts","makerState","summarizedEdgeStates","opposingNodes","_nodes","nodeZOrderedList","newState","createNewNodeState","_state","edgeGroupStates","EdgeGroup.makeEdgeGroupStates","edgeEntries","ref","edgeZOrderedList","createNewEdgeState","_edgeId","createEdgeEntries","createSummarizedEdgeStates","pathStates","pathZOrderedList","toEdgeObjects","isSummarizedEdges","item","useStates","getNodeShape","getNodeStaticShape","oppositeNodeIds","entry","getEdgeStroke","toEdgeMarker","stroke","normalWidth","edgeLayoutPoint","isEdgeSummarized","stopCalcHandle","sourceShape","targetShape","shiftedPosition","EdgeGroup.calculateEdgeShiftedPosition","sourceShapeMargin","targetShapeMargin","v2d.calculateDistancesFromCenterOfNodeToEndOfNode","LineUtils.applyMargin","l","isStartEdgeOfNode","LineUtils.toLinePosition","selfLoopStyle","calculateArcPositionAndState","shift","calculateCurvePositionAndState","stopUpdateMarkerHandle","group","z","originPosition","origin","shifted","shiftedCenter","LineUtils.getCenterOfLinePosition","v2d.calculateCircleCenterAndRadiusBy3Points","centerToTop","v2d.calculateRelativeAngleRadian","sourceMoveRad","targetMoveRad","v2d.reverseAngleRadian","LineUtils.toVectorsFromLinePosition","nodeShape","intersects","radiusLine","V2D.rotate","isLargeArc","groups","MapUtil","MOUSE_MOVE_DETECTION_THRESHOLD","TOUCH_MOVE_DETECTION_THRESHOLD","DOUBLE_CLICK_THRESHOLD","getPointerMoveDetectionThreshold","type","detectClicks","clickStates","pointerId","clickState","idAndState","oldPointerId","clickEvent","doubleClickEvent","createClickEvents","now","initDict","cleanClickState","makeNodeInteractionHandlers","modes","hoveredNodes","selectedNodes","zoomLevel","nodePointerHandlers","handleNodePointerMoveEvent","handleNodePointerUpEvent","handleNodePointerCancelEvent","_updateFollowNodes","pointerState","isFollowed","isSelectedNode","followed","userGrabs","_unwrapNodePosition","mode","_calculateNodeNewPosition","handleNodeClickEvent","selectable","isTouchAnySelectedNode","handleNodeDoubleClickEvent","threshold","draggingNodes","ev","handler","isMoved","handleNodePointerDownEvent","handleNodePointerOverEvent","handleNodePointerOutEvent","handleNodeContextMenu","makeEdgeInteractionHandlers","hoveredEdges","selectedEdges","edgePointerHandlers","handleEdgePointerUpEvent","handleEdgePointerCancelEvent","handleEdgePointerDownEvent","_makeEdgeEventObject","handleEdgeClickEvent","isTouchAnySelectedEdge","handleEdgeDoubleClickEvent","handleEdgePointerOverEvent","handleEdgePointerOutEvent","handleEdgeContextMenu","handleEdgesPointerDownEvent","handleEdgesPointerOverEvent","handleEdgesPointerOutEvent","handleEdgesClickEvent","handleEdgesDoubleClickEvent","handleEdgesContextMenu","setupContainerInteractionHandlers","container","isSvgWheelZoomEnabled","containerPointerHandlers","handleContainerPointerMoveEvent","handleContainerPointerUpEvent","handleContainerPointerDownEvent","handleContainerClickEvent","handleContainerDoubleClickEvent","handleContainerContextMenuEvent","preventDefault","onMounted","onUnmounted","enabled","old","makePathInteractionHandlers","hoveredPaths","selectedPaths","isInCompatibilityModeForPath","_makePathEventObject","pathPointerHandlers","handlePathPointerUpEvent","handlePathPointerCancelEvent","handlePathPointerDownEvent","handlePathPointerOverEvent","handlePathPointerOutEvent","handlePathClickEvent","isTouchAnySelectedPath","handlePathDoubleClickEvent","handlePathContextMenu","urlContentToDataUrl","url","__async","blob","onSuccess","onError","reader","translateFromDomToSvgCoordinates","svg","viewport","coordinates","svgPoint","translateFromSvgToDomCoordinates","domPoint","exportSvgElement","element","svgViewport","box","svgRect","iter","commentNode","replaceImageSourceToDataUrl","image","useNS","href","dataUrl","exportSvgElementWithOptions","_0","_1","_2","options","promises","img","makeBoxSelectionMethods","isBoxSelectionEnabled","isBoxSelectionMode","selectionBox","updateNodesSelection","debounce","_updateNodesSelection","pointerEventHandler","PointerEventRegistrar","handlePointerDownEvent","handlePointerUpEvent","handlePointerMoveEvent","handleClickEvent","handleKeyDownEvent","stopBoxSelection","updateRectangle","pos1","pos2","pointerArray","first","last","keyEventRegistrar","KeyEventRegistrar","startBoxSelection","selectedNodesAtSelectStarted","selectionType","enclosedNodes","temporary","handleKeyUpEvent","mouseEventHandlersKey","provideMouseOperation","provides","useMouseOperation","mitt","eventEmitterKey","provideEventEmitter","useEventEmitter","utilities","global","prop","o","elementOrSelector","fn","context","evt","touch","prevEvt","timeStampDiff","touchesDistance","func","wait","that","args","timeout","previous","later","remaining","refreshRate","requestTimeout","point1","point2","Utils","require$$0","uniwheel","prefix","_addEventListener","_removeEventListener","support","fns","passiveTrueOption","passiveFalseOption","getSupport","createCallback","originalEvent","getCallback","removeCallback","_addWheelListener","elem","eventName","isPassiveListener","cb","_removeWheelListener","addWheelListener","removeWheelListener","_browser","svgUtilities","selector","childNodes","el","viewportId","svgChildren","classNames","allDefs","allDefsCount","thisDefs","this","matrix","defs","height","SvgUtils","controlIcons","instance","styleEl","zoomGroup","zoomIn","zoomInBackground","zoomInShape","resetPanZoomControl","resetPanZoomControlBackground","resetPanZoomControlShape1","resetPanZoomControlShape2","zoomOut","zoomOutBackground","zoomOutShape","require$$1","ShadowViewport","newCTM","svgViewBox","viewBoxValues","zoom","bBox","newScale","offsetX","offsetY","safeCTM","willZoom","willPan","preventPan","preventPanX","preventPanY","ctm","shadowViewport","Wheel","ControlIcons","require$$2","require$$3","require$$4","SvgPanZoom","optionsDefaults","passiveListenerTrueOption","passiveListenerFalseOption","boundingClientRectNormalized","oldScale","oldPoint","newPoint","publicInstance","haltEventListeners","delta","timeDelta","divider","inversedScreenCTM","relativeMousePoint","zoomScale","zoomAbsolute","originalState","oldCTM","relativePoint","modifier","absolute","targetClass","zoomFactor","viewportCTM","touch1","touch2","relativeTouchPoint","viewBox","instancesStore","svgPanZoom_1","methods","sizes","pan","sizeWidth","sizeHeight","ratio","currentRatio","newWidth","newHeight","absoluteZoom","realZoom","relativeZoom","originalZoom","minZoomLevel","maxZoomLevel","min","max","constructor","createSvgPanZoomEx","userInit","userDestroy","useSvgPanZoom","mountedCallbacks","unmountedCallbacks","instanceMounted","instanceUnmounted","initialize","zoomLevelKey","provideZoomLevel","viewStyle","useZoomLevel","useTransitionWhile","timerId","transitionOption","transitionWhile","duration","timingFunction","nextTick","promise","useTranslatePathsToObject","input","idStore","containKeys","bindProp","props","emit","filter","update","filtered","bindPropKeySet","sourceObject","bound","provideSelections","useSelections","provideLayouts","useLayouts","pairwise","arr","removeItem","insertAfter","base","useBuiltInLayerOrder","slots","builtInLayers","request","uniq","layer","defined","order","lower","higher","asyncNextTick","resolve","arrowPoints","angleStroke","anglePoints","types","VMarkerHeadArrow","VMarkerHeadAngle","VMarkerHeadCircle","refX","refYOffset","offset","basePoint","thickVerticals","thickHorizontals","normalVerticals","normalHorizontals","thickH","thickV","normalH","normalV","gi","maxWidth","maxHeight","inc","normalDasharray","thickDasharray","thickAttrs","normalAttrs","background","updateAttributes","attrs","bgLayer","vpLayer","attr","observer","records","r","pathD","f1","f2","chunk","strokeWidth","strokeDasharray","animationSpeed","speed","useAttrs","texts","fontSize","lineHeight","topDeltaY","dominantBaseline","transform","backgroundRectPos","paddingVertical","paddingHorizontal","updateObserver","enableMutationObserver","updateBackgroundPosition","bbox","centerPos","edgeIds","labelConfig","shapeConfig","strokeConfig","edgeConfig","getStrokeConfig","toEdgePosition","calculateCenterPoint","getPathTotalLength","calculatePointAtLength","useSlots","hasEdgeOverlaySlot","v2d.calculateEdgeLabelArea","individual","summarized","getRepresentativeEdgeKey","shapeStyle","hasOverrideNodeSlot","labelDirections","denyAngles","inRange","handleNodeLabelAutoAdjustment","currentPos","oppositeNodes","getLoopCenter","defaultDirection","angles","oppositeNode","isSelfLoop","directionIndex","directionToIndex","azimuth","indexToDirection","amount","defaultValue","labelShiftV","labelShiftH","labelDiagonalShiftV","labelDiagonalShiftH","labelDirection","autoAdjustment","textAnchor","labelX","labelY","diagonalMargin","eventHandlers","groupClasses","handleEvents","labelClasses","hasOverrideNodeLabelSlot","onlyHasDisplayLabel","pathConfig","calcPathPoints","calcPathD","move","SYSTEM_SLOTS","nodesRef","edgesRef","pathsRef","layerDefs","definedSlots","layers","accum","isShowGrid","isShowBackgroundViewport","builtInLayerOrder","show","onSvgPanZoomMounted","onSvgPanZoomUnmounted","isDoubleClickZoomEnabled","isMouseWheelZoomEnabled","rectSize","resizeObserver","stopEventPropagation","applyAbsoluteZoomLevel","absoluteZoomLevel","svgPanZoomInstance","applyZoomEnabled","initialZoomLevel","updateBorderBox","fitToContents","panToCenter","getViewBox","setViewBox","currentSelectedNodes","currentSelectedEdges","currentSelectedPaths","currentLayouts","dragging","touches","readonly","activateParams","newHandler","oldHandler","transitionStyles","autoPanAndZoom","nodesEmpty","pan1","pan2","panTo","panBy","getPan","getSizes","svgUtils.translateFromDomToSvgCoordinates","svgUtils.translateFromSvgToDomCoordinates","getAsSvg","exportAsSvgText","exportAsSvgElement","expose","enable","enableDblClick","enableMouseWheel","view","_cache","_openBlock","_createElementBlock","_resolveDynamicComponent","_withCtx","degree","updatedConfig","DEFAULT_GRID","GridLayout","grid","install","app","components","componentName","component"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4DO,MAAMA,KAA2C;AAAA,EACtD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AC5CO,SAASC,GAA2BC,GAAuB;AAC5D,SAAAC,GAAWD,CAAK,IACXA,IAEAE,GAASF,CAAK;AAEzB;AAMgB,SAAAG,EAAWC,GAAgBC,IAAO,aAAgB;AAC5D,MAAqBD,KAAQ;AAC/B,UAAM,IAAI,MAAM,GAAGC,CAAI,UAAU;AAE5B,SAAAD;AACT;AC1BA,MAAME,KAAgB,OAAO,YAAY;AAElC,SAASC,GAAkBC,GAA8B;AAC9D,EAAAC,GAAQH,IAAeE,CAAU;AACnC;AAEO,SAASE,KAAmC;AACjD,QAAMF,IAAaL,EAAQQ,GAAOL,EAAa,GAAG,YAAY;AACvD,SAAA;AAAA,IACL,WAAWE,EAAW;AAAA,IACtB,KAAKA,EAAW;AAAA,IAChB,UAAUA,EAAW;AAAA,IACrB,YAAYA,EAAW;AAAA,EAAA;AAE3B;ACrBO,MAAMI,EAAO;AAAA,EAClB,OAAO,MAAYZ,GAA4Ba,GAAc;AAC3D,WAAOb,aAAiB,WAAWA,EAAMa,CAAM,IAAIb;AAAA,EACrD;AAAA,EAEA,OAAO,OAAaA,GAA6Ba,GAAc;AACzD,WAAA,OAAO,OAAOb,CAAK,EAAE,OAAO,OAAKc,aAAa,QAAQ,EAAE,WAAW,IAC9Dd,IAEF,OAAO;AAAA,MACZ,OAAO,QAAQA,CAAK,EAAE,IAAI,CAAC,CAACe,GAAGD,CAAC,MAAM,CAACC,GAAGD,aAAa,WAAWA,EAAED,CAAM,IAAIC,CAAC,CAAC;AAAA,IAAA;AAAA,EAEpF;AACF;AAsHY,IAAAE,sBAAAA,OACVA,EAAA,SAAS,UACTA,EAAA,QAAQ,SACRA,EAAA,aAAa,cACbA,EAAA,OAAO,QACPA,EAAA,aAAa,cACbA,EAAA,QAAQ,SACRA,EAAA,aAAa,cACbA,EAAA,OAAO,QACPA,EAAA,aAAa,cATHA,IAAAA,KAAA,CAAA,CAAA;AAuLL,SAASC,GAA4CC,GAA6B;AACvF,QAAMC,IAAO,CAAA;AACb,SAAO,OAAO,OAAOA,GAAMD,EAASC,CAAI,CAAC;AAC3C;AAGO,SAASC,GAKdC,GAAsC;AAC/B,SAAAA;AACT;AAGO,SAASC,GAKdD,GAAsC;AAC/B,SAAAA;AACT;ACzVgB,SAAAE,GAAYC,GAAYC,GAAmBC,GAAqB;AAC9E,QAAMC,IAAQf,EAAO,OAAOa,EAAM,QAAQD,CAAI;AAC1C,SAAAG,EAAM,QAAQ,WACT;AAAA,IACL,OAAOA,EAAM,SAAS,IAAID;AAAA,IAC1B,QAAQC,EAAM,SAAS,IAAID;AAAA,EAAA,IAGtB;AAAA,IACL,OAAOC,EAAM,QAAQD;AAAA,IACrB,QAAQC,EAAM,SAASD;AAAA,EAAA;AAG7B;AAEO,SAASE,GACdC,GACAC,GACAC,GACAC,GACS;AAGT,QAAMC,IADY,KAAK,IAAIJ,EAAQ,IAAIE,EAAc,CAAC,IACvBD,EAAS,QAAQ,IAAIE,EAAe,QAAQ,GAIrEE,IADY,KAAK,IAAIL,EAAQ,IAAIE,EAAc,CAAC,IACvBD,EAAS,SAAS,IAAIE,EAAe,SAAS;AAC7E,SAAOC,KAAcC;AACvB;AAEgB,SAAAC,GAAsBC,GAAwCV,GAAe;AAC3F,MAAIW,IAA0B;AAC9B,SAAIX,MAAU,KAAKU,MAAc,UAAaA,MAAc,SAC1DC,IAASD,KAAA,OAAAA,IAAa,IACb,OAAOA,KAAc,WAC9BC,IAASD,EACN,MAAM,KAAK,EACX,IAAI,CAAAtB,MAAK,SAASA,CAAC,IAAIY,CAAK,EAC5B,OAAO,OAAK,CAAC,MAAMZ,CAAC,CAAC,EACrB,KAAK,GAAG,IAEXuB,IAASD,IAAYV,GAEhBW,KAAUA,MAAW,MAAMA,IAAS;AAC7C;AAEO,SAASC,GAAiBF,GAAwC;AACvE,MAAIC,IAA0B;AAC1B,MAAAD,MAAc,UAAaA,MAAc;AAClC,IAAAC,IAAA;AAAA,WACA,OAAOD,KAAc,UAAU;AACxC,UAAMG,IAAQH,EACX,MAAM,KAAK,EACX,IAAI,CAAKtB,MAAA,SAASA,CAAC,CAAC,EACpB,OAAO,CAAAA,MAAK,CAAC,MAAMA,CAAC,CAAC;AACpB,IAAAyB,EAAM,SAAS,MAAM,IAEvBF,IAASE,EAAM,OAAO,CAACC,GAAGC,MAAMD,IAAIC,GAAG,CAAC,IAG/BJ,IAAAE,EAAM,OAAO,CAACC,GAAGC,MAAMD,IAAIC,GAAG,CAAC,IAAI;AAAA,EAC9C;AAEA,IAAAJ,IAASD,IAAY;AAEhB,SAAAC;AACT;AChEA,MAAMK,KAA2B;AAE1B,MAAMC,GAAsC;AAAA,EAGjD,SAASC,GAA4C;AACnD,UAAM,EAAE,eAAAC,GAAe,OAAAC,GAAO,SAAAzB,GAAS,SAAA0B,GAAS,OAAArB,GAAO,YAAAsB,EAAe,IAAAJ,GAChEK,IAAwB,CAAaC,MAAA;AACzC,iBAAW,CAACC,GAAIC,CAAG,KAAK,OAAO,QAAQF,CAAS,GAAG;AACjD,cAAMG,IAAS,KAAK,wBAAwBR,GAAeM,CAAE;AACxD,aAAA,gBAAgBE,GAAQD,CAAG;AAAA,MAClC;AAAA,IAAA,GAGIE,IAAsB,CAACC,MAAsB;AAEjD,YAAMC,IAAWD,EAAQ,OAAO,OAAK,EAAEd,KAAKI,EAAc,MAAM,GAC1DY,IAAOT,EAAW,eAClBR,IAAId,EAAM;AAChB,iBAAWgC,KAAUF,GAAU;AACvB,cAAAhC,IAAOsB,EAAM,MAAMY,CAAM,GACzB5B,IAAWP,GAAYC,GAAMH,EAAQ,MAAMmB,CAAC,GAC5CmB,IAAYC,GAAA,IAAKH,EAAK;AACnB,mBAAA;AACP,cAAII,IAAY;AACL,qBAAA,CAACV,GAAIC,CAAG,KAAK,OAAO,QAAQP,EAAc,KAAK,GAAG;AAC3D,gBAAIa,MAAWP;AAAI;AACb,kBAAAW,IAAahB,EAAM,MAAMK,CAAE;AACjC,gBAAI,CAACW;AAAY;AACjB,kBAAM9B,IAAiBT,GAAYuC,GAAYzC,EAAQ,MAAMmB,CAAC;AAE9D,gBADAqB,IAAYjC,GAAkB+B,GAAW7B,GAAUsB,GAAKpB,CAAc,GAClE6B;AACF;AAAA,UAEJ;AACA,cAAIA;AAGQ,YAAAF,EAAA,KAAK7B,EAAS,QAAQY,KAA2BF,GACvDmB,EAAU,IAAI7B,EAAS,QAAQ,IAAI2B,EAAK,IAAI,UACpCE,EAAA,IAAIF,EAAK,OAAO,GAChBE,EAAA,KAAK7B,EAAS,SAASY,KAA2BF;AAAA;AAG9D;AAAA,QAEJ;AACA,cAAMa,IAAS,KAAK,wBAAwBR,GAAea,CAAM;AAC5D,aAAA,gBAAgBL,GAAQM,CAAS;AAAA,MACxC;AAAA,IAAA;AAGF,IAAAL,EAAoB,OAAO,KAAKR,EAAM,KAAK,CAAC;AAC5C,UAAMiB,IAAgBC;AAAA,MACpB,MAAMC,GAAQ,IAAI,IAAI,OAAO,KAAKnB,EAAM,KAAK,CAAC,GAAG,IAAI,IAAI,OAAO,KAAKD,EAAc,KAAK,CAAC,CAAC;AAAA,MAC1F,CAACqB,MAAsB;AACrB,QAAKA,KAAUZ,EAAoB,OAAO,KAAKR,EAAM,KAAK,CAAC;AAAA,MAC7D;AAAA,IAAA;AAGM,IAAAC,EAAA,GAAG,kBAAkBE,CAAM,GAC3BF,EAAA,GAAG,oBAAoBE,CAAM,GAC7BF,EAAA,GAAG,gBAAgBE,CAAM,GAEjC,KAAK,eAAe,MAAM;AACV,MAAAc,KACNhB,EAAA,IAAI,kBAAkBE,CAAM,GAC5BF,EAAA,IAAI,oBAAoBE,CAAM,GAC9BF,EAAA,IAAI,gBAAgBE,CAAM;AAAA,IAAA;AAAA,EAEtC;AAAA,EAEA,aAAmB;AACjB,IAAI,KAAK,gBACP,KAAK,aAAa;AAAA,EAEtB;AAAA,EAEU,gBAAgBkB,GAA2Bf,GAAe;AAClE,IAAAe,EAAW,MAAM,IAAIC,GAAMhB,EAAI,GAAG,CAAC,GACnCe,EAAW,MAAM,IAAIC,GAAMhB,EAAI,GAAG,CAAC;AAAA,EACrC;AAAA,EAEQ,wBAAwBP,GAAmCrB,GAAc;AAC/E,UAAM6B,IAASgB,GAAMxB,EAAc,OAAOrB,CAAI;AAC1C,WAAC6B,EAAO,UACVA,EAAO,QAAQ,EAAE,GAAG,GAAG,GAAG,MAErBA;AAAA,EACT;AACF;ACtFO,SAASiB,KAA6B;AACpC,SAAA;AAAA,IACL,MAAM;AAAA,MACJ,gBAAgB;AAAA,MAChB,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,cAAc;AAAA,MACd,cAAc;AAAA,MACd,wBAAwB;AAAA,MACxB,uBAAuB;AAAA,MACvB,qBAAqB;AAAA,MACrB,sBAAsB;AAAA,MACtB,iBAAiB;AAAA,MACjB,eAAe,IAAI3B,GAAa;AAAA,MAChC,yBAAyB;AAAA,MACzB,MAAM;AAAA,QACJ,SAAS;AAAA,QACT,UAAU;AAAA,QACV,iBAAiB;AAAA,QACjB,MAAM;AAAA,UACJ,OAAO;AAAA,UACP,OAAO;AAAA,UACP,WAAW;AAAA,QACb;AAAA,QACA,OAAO;AAAA,UACL,OAAO;AAAA,UACP,OAAO;AAAA,UACP,WAAW;AAAA,QACb;AAAA,MACF;AAAA,MACA,WAAW;AAAA,QACT,KAAK;AAAA,UACH,OAAO;AAAA,UACP,aAAa;AAAA,UACb,aAAa;AAAA,UACb,iBAAiB;AAAA,QACnB;AAAA,QACA,UAAU,CAAC4B,MAAyB;AAC5B,gBAAAC,IAAS,SAAS,KAAK,UAAU,SAAS,IAAID,EAAM,UAAUA,EAAM;AAC1E,iBAAOA,EAAM,SAAS,YAAYC,IAAS,CAACA;AAAA,QAC9C;AAAA,MACF;AAAA,MACA,mBAAmB,CAAC;AAAA,MACpB,wBAAwB;AAAA,IAC1B;AAAA,IACA,MAAMvD,GAAS,CAASE,OAAA;AAAA,MACtB,QAAQ;AAAA,QACN,MAAM;AAAA,QACN,QAAQ;AAAA;AAAA,QAER,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,cAAc;AAAA;AAAA,QAEd,OAAO;AAAA,QACP,aAAa;AAAA,QACb,aAAa;AAAA,QACb,iBAAiB;AAAA,MACnB;AAAA,MACA,OAAO;AAAA,QACL,MAAM,CAAQK,MAAAZ,EAAO,MAAMO,EAAK,OAAO,MAAMK,CAAI;AAAA,QACjD,QAAQ;;AAAS,mBAAAiD,IAAA7D,EAAO,MAAMO,EAAK,OAAO,QAAQK,CAAI,MAArC,OAAAiD,IAA0C,KAAK;AAAA;AAAA,QAChE,OAAO;;AAAS,mBAAAA,IAAA7D,EAAO,MAAMO,EAAK,OAAO,OAAOK,CAAI,MAApC,OAAAiD,IAAyC,KAAK;AAAA;AAAA,QAC9D,QAAQ;;AAAS,mBAAAA,IAAA7D,EAAO,MAAMO,EAAK,OAAO,QAAQK,CAAI,MAArC,OAAAiD,IAA0C,KAAK;AAAA;AAAA,QAChE,cAAc,OAAQ;;AAAA,kBAAAA,IAAA7D,EAAO,MAAMO,EAAK,OAAO,cAAcK,CAAI,MAA3C,OAAAiD,IAAgD;AAAA;AAAA,QACtE,aAAa,CAAQjD,MAAAZ,EAAO,MAAMO,EAAK,OAAO,aAAaK,CAAI;AAAA,QAC/D,aAAa,CAAQA,MAAAZ,EAAO,MAAMO,EAAK,OAAO,aAAaK,CAAI;AAAA,QAC/D,iBAAiB,CAAQA,MAAAZ,EAAO,MAAMO,EAAK,OAAO,iBAAiBK,CAAI;AAAA,QACvE,OAAO;AAAA,MACT;AAAA,MACA,UAAU;AAAA,MACV,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,OAAO;AAAA,QACL,SAAS;AAAA,QACT,YAAY;AAAA,QACZ,UAAU;AAAA,QACV,YAAY;AAAA,QACZ,OAAO;AAAA,QACP,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAUZ,QAAQ;AAAA,QACR,WAAWR,EAAmB;AAAA,QAC9B,yBAAyB;AAAA,QACzB,MAAM;AAAA,QACN,kBAAkB;AAAA,MACpB;AAAA,MACA,WAAW;AAAA,QACT,SAAS;AAAA,QACT,OAAO;AAAA,QACP,SAAS;AAAA,QACT,OAAO;AAAA,MACT;AAAA,MACA,QAAQ;AAAA,QACN,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,qBAAqB;AAAA,QACrB,wBAAwB;AAAA,MAC1B;AAAA,MACA,YAAY;AAAA,IAAA,EACZ;AAAA,IACF,MAAMC,GAAS,CAASE,OAAA;AAAA,MACtB,QAAQ;AAAA,QACN,OAAO;AAAA,QACP,OAAO;AAAA,QACP,WAAW;AAAA,QACX,SAAS;AAAA,QACT,SAAS;AAAA,QACT,gBAAgB;AAAA,MAClB;AAAA,MACA,OAAO;AAAA,QACL,OAAO,OAAQP,EAAO,MAAMO,EAAK,OAAO,OAAOuD,CAAI,IAAI;AAAA,QACvD,OAAO;AAAA,QACP,WAAW,CAAQA,MAAA9D,EAAO,MAAMO,EAAK,OAAO,WAAWuD,CAAI;AAAA,QAC3D,SAAS,CAAQA,MAAA9D,EAAO,MAAMO,EAAK,OAAO,SAASuD,CAAI;AAAA,QACvD,SAAS,CAAQA,MAAA9D,EAAO,MAAMO,EAAK,OAAO,SAASuD,CAAI;AAAA,QACvD,gBAAgB,CAAQA,MAAA9D,EAAO,MAAMO,EAAK,OAAO,gBAAgBuD,CAAI;AAAA,MACvE;AAAA,MACA,UAAU;AAAA,QACR,OAAO,OAAQ9D,EAAO,MAAMO,EAAK,OAAO,OAAOuD,CAAI,IAAI;AAAA,QACvD,OAAO;AAAA,QACP,WAAW,CAAQA,MAAA;AACjB,gBAAMC,IAAI/D,EAAO,MAAMO,EAAK,OAAO,OAAOuD,CAAI;AAC9C,iBAAO,GAAGC,IAAI,GAAG,IAAIA,IAAI,CAAC;AAAA,QAC5B;AAAA,QACA,SAAS,CAAQD,MAAA9D,EAAO,MAAMO,EAAK,OAAO,SAASuD,CAAI;AAAA,QACvD,SAAS,CAAQA,MAAA9D,EAAO,MAAMO,EAAK,OAAO,SAASuD,CAAI;AAAA,QACvD,gBAAgB,CAAQA,MAAA9D,EAAO,MAAMO,EAAK,OAAO,gBAAgBuD,CAAI;AAAA,MACvE;AAAA,MACA,YAAY;AAAA,MACZ,KAAK;AAAA,MACL,MAAM;AAAA,MACN,QAAQ;AAAA,QACN,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,QAAQ;AAAA,UACR,QAAQ;AAAA,UACR,OAAO;AAAA,UACP,OAAO;AAAA,QACT;AAAA,QACA,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,QAAQ;AAAA,UACR,QAAQ;AAAA,UACR,OAAO;AAAA,UACP,OAAO;AAAA,QACT;AAAA,MACF;AAAA,MACA,QAAQ;AAAA,MACR,WAAW,CAACE,GAAevD,MAClBA,EAAQ,KAAK,QAAQ,UAAU,KAAQ;AAAA,MAEhD,YAAY;AAAA,QACV,OAAO;AAAA,UACL,UAAU;AAAA,UACV,YAAY;AAAA,UACZ,OAAO;AAAA,QACT;AAAA,QACA,OAAO;AAAA,UACL,MAAM;AAAA;AAAA,UAEN,QAAQ;AAAA;AAAA,UAER,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,cAAc;AAAA,UACd,OAAO;AAAA,UACP,aAAa;AAAA,UACb,aAAa;AAAA,UACb,iBAAiB;AAAA,QACnB;AAAA,QACA,QAAQ;AAAA,UACN,OAAO;AAAA,UACP,OAAO;AAAA,UACP,WAAW;AAAA,UACX,SAAS;AAAA,UACT,SAAS;AAAA,UACT,gBAAgB;AAAA,QAClB;AAAA,MACF;AAAA,MACA,UAAU;AAAA,QACR,QAAQ;AAAA,QACR,aAAa;AAAA,QACb,QAAQ;AAAA,QACR,OAAO;AAAA,MACT;AAAA,MACA,WAAW;AAAA,MACX,OAAO;AAAA,QACL,YAAY;AAAA,QACZ,UAAU;AAAA,QACV,YAAY;AAAA,QACZ,OAAO;AAAA,QACP,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAUZ,QAAQ;AAAA,QACR,SAAS;AAAA,MACX;AAAA,MACA,QAAQ;AAAA,QACN,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,qBAAqB;AAAA,QACrB,wBAAwB;AAAA,MAC1B;AAAA,IAAA,EACA;AAAA,IACF,MAAMJ,GAAS,CAASE,OAAA;AAAA,MACtB,SAAS;AAAA,MACT,WAAW;AAAA,MACX,WAAW;AAAA,MACX,aAAa;AAAA,MACb,KAAK;AAAA,MACL,QAAQ;AAAA;AAAA,MAER,MAAMjB,GAAS;AAAA,QACb,OAAO;AAAA,QACP,OAAO,CAAK2E,MAAA;AACV,gBAAMC,IAAO;AAAA,YACX;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UAAA,GAEIC,IAAOF,EAAE,MACZ;AAAA,YAAI,CAAArC,MACHA,EAAE,MAAM,EAAE,EAAE,OAAO,CAACwC,GAAGC,OACrBD,KAAKA,KAAK,KAAKA,IAAIC,EAAE,WAAW,CAAC,GAC1BD,IAAIA,IACV,CAAC;AAAA,UAAA,EAEL,OAAO,CAACA,GAAGC,MAAMD,IAAIC,GAAG,CAAC;AAC5B,iBAAOH,EAAK,KAAK,IAAIC,CAAI,IAAID,EAAK,MAAM;AAAA,QAC1C;AAAA,QACA,WAAW;AAAA,QACX,SAAS;AAAA,QACT,UAAU;AAAA,QACV,SAAS;AAAA,QACT,gBAAgB;AAAA,MAAA,CACjB;AAAA,MACD,QAAQ;AAAA,QACN,OAAO,CAAQI,MAAAtE,EAAO,MAAMO,EAAK,KAAK,OAAO+D,CAAI;AAAA,QACjD,OAAO,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,KAAK,OAAO+D,CAAI;AAAA,QACjD,WAAW,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,KAAK,WAAW+D,CAAI;AAAA,QACzD,SAAS,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,KAAK,SAAS+D,CAAI;AAAA,QACrD,UAAU,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,KAAK,UAAU+D,CAAI;AAAA,QACvD,SAAS,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,KAAK,SAAS+D,CAAI;AAAA,QACrD,gBAAgB,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,KAAK,gBAAgB+D,CAAI;AAAA,MACrE;AAAA,MACA,OAAO;AAAA,QACL,OAAO,OAAQtE,EAAO,MAAMO,EAAK,OAAO,OAAO+D,CAAI,IAAI;AAAA,QACvD,OAAO,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,OAAO,OAAO+D,CAAI;AAAA,QACnD,WAAW,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,OAAO,WAAW+D,CAAI;AAAA,QAC3D,SAAS,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,OAAO,SAAS+D,CAAI;AAAA,QACvD,UAAU,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,OAAO,UAAU+D,CAAI;AAAA,QACzD,SAAS,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,OAAO,SAAS+D,CAAI;AAAA,QACvD,gBAAgB,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,OAAO,gBAAgB+D,CAAI;AAAA,MACvE;AAAA,MACA,UAAU;AAAA,QACR,OAAO,OAAQtE,EAAO,MAAMO,EAAK,OAAO,OAAO+D,CAAI,IAAI;AAAA,QACvD,OAAO,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,OAAO,OAAO+D,CAAI;AAAA,QACnD,WAAW;AAAA,QACX,SAAS,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,OAAO,SAAS+D,CAAI;AAAA,QACvD,UAAU,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,OAAO,UAAU+D,CAAI;AAAA,QACzD,SAAS,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,OAAO,SAAS+D,CAAI;AAAA,QACvD,gBAAgB,CAAQA,MAAAtE,EAAO,MAAMO,EAAK,OAAO,gBAAgB+D,CAAI;AAAA,MACvE;AAAA,MACA,YAAY;AAAA,MACZ,QAAQ;AAAA,QACN,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,qBAAqB;AAAA,QACrB,wBAAwB;AAAA,MAC1B;AAAA,MACA,YAAY;AAAA,IAAA,EACZ;AAAA,EAAA;AAEN;AAEO,SAASC,GACdC,GACS;AACT,QAAM/D,IAAUiD;AAChB,SAAIc,KACFC,GAAMhE,GAAS+D,CAAM,GAEhB/D;AACT;AChUA,MAAMiE,KAAe,OAAO,OAAO;AAEnC,SAASC,GAAOC,GAAkBC,GAAa;AACzC,SAAAC,GAAcF,CAAW,IACpBH,GAAMG,GAAaC,CAAM,IAEzBA;AAEX;AAEO,SAASE,GAAetE,GAA2B;AAClD,QAAAuE,IAAmB1F,GAASoE,GAAA,CAAmB,GAC/CuB,IAAY,OAAO,KAAKD,CAAO;AACrC,aAAWE,KAAOD;AAChB,IAAA7B,EAAM,MAAM3C,EAAQ,MAAMyE,CAAG,GAAG,MAAM;AAC1B,MAAAC,GAAAH,EAAQE,CAAG,GAAGzE,EAAQ,MAAMyE,CAAG,KAAK,IAAIP,EAAM;AAAA,OACvD,EAAE,WAAW,IAAM,MAAM,GAAM,CAAA;AAGpC,SAAA9E,GAAQ6E,IAAcM,CAAO,GACtBA;AACT;AAEA,SAASI,GAAsCF,GAAQ;AAC9C,SAAA3F,EAAQQ,GAAO2E,EAAY,GAAG,WAAWQ,CAAG,GAAG,EAAEA,CAAG;AAC7D;AAMO,SAASG,KAAgB;AAC9B,SAAOD,GAAa,MAAM;AAC5B;AAEO,SAASE,KAAgB;AAC9B,SAAOF,GAAa,MAAM;AAC5B;AAEO,SAASG,KAAgB;AAC9B,SAAOH,GAAa,MAAM;AAC5B;AAEO,SAASI,KAAgB;AAC9B,SAAOJ,GAAa,MAAM;AAC5B;ACnDA,IAAIK,KAAS;AAGN,SAASC,KAAgB;AACvB,SAAAD;AACT;ACCO,SAASE,GAA+CC,GAAqB;AAC3E,SAAA,OAAO,QAAQA,CAAG;AAC3B;AAEgB,SAAAC,GAAgD5F,GAAW6F,GAAS;AAClF,QAAMC,IAAO,IAAI,IAAa,OAAO,KAAK9F,CAAM,CAAC;AACjD,EAAA0F,GAAUG,CAAI,EAAE,QAAQ,CAAC,CAACZ,GAAK9F,CAAK,MAAM;AACxC,IAAKiE,GAAQpD,EAAOiF,CAAG,GAAG9F,CAAK,MAC7Ba,EAAOiF,CAAG,IAAI9F,IAEhB2G,EAAK,OAAOb,CAAG;AAAA,EAAA,CAChB,GACDa,EAAK,QAAQ,CAAA5F,MAAK,OAAOF,EAAOE,CAAC,CAAC;AACpC;AAEO,SAAS6F,GAAUJ,GAAmB;AAC3C,SAAOA,aAAe,WAAYA,KAAO,OAAOA,EAAI,QAAS;AAC/D;ACDgB,SAAAK,GACd/D,GACAgE,GACAzF,GAC2B;AAE3B,QAAM0F,IAAQhH,GAA0B;AAAA,IACtC,kBAAkB,CAAC;AAAA,IACnB,YAAY,CAAC;AAAA,IACb,iBAAiB,CAAC;AAAA,EAAA,CACnB;AAED,SAAAiH,GAAY,MAAM;AACV,UAAA,EAAE,kBAAAC,GAAkB,YAAAC,EAAA,IAAeC;AAAA,MACvC9F;AAAA,MACAyB,EAAM;AAAA,MACNgE,EAAM;AAAA,IAAA;AAES,IAAAL,GAAAM,EAAM,kBAAkBE,CAAgB,GACxCR,GAAAM,EAAM,YAAYG,CAAU;AAAA,EAAA,CAC9C,GAGDF,GAAY,MAAM;AAChB,UAAMI,IAAwC,CAAA;AAC9C,eAAW,CAACjE,GAAI,EAAE,OAAA2D,GAAO,YAAAO,GAAY,KAAK,OAAO,QAAQN,EAAM,UAAU,GAAG;AAC1E,UAAIO,IAAY;AAChB,UAAID,KAAc;AACJ,QAAAC,IAAA;AAAA,eACHjG,EAAQ,KAAK,qBAAqB,UAAU;AACrD,cAAMmB,IAAInB,EAAQ,KAAK,UAAUyF,GAAOzF,CAAO;AAC/C,QAAImB,MAAM,OACR8E,IAAYC,GAAsBzE,EAAM,OAAOgE,GAAOzF,GAASgG,CAAU,IAE7DC,IAAA9E;AAAA,MACd;AACF,QAAWnB,EAAQ,KAAK,YACtBiG,IAAYC,GAAsBzE,EAAM,OAAOgE,GAAOzF,GAASgG,CAAU,IAE7DC,IAAA;AAER,MAAAP,EAAA,WAAW5D,CAAE,EAAE,YAAYmE,GAC7BA,KACK,OAAA,KAAKR,CAAK,EAAE,QAAQ,CAAA3D,MAAOiE,EAAgBjE,CAAE,IAAI,EAAK;AAAA,IAEjE;AACiB,IAAAsD,GAAAM,EAAM,iBAAiBK,CAAe;AAAA,EAAA,CACxD,GAEML;AACT;AAYO,SAASS,GACd3C,GACA4C,GACAhC,GACA5E,GACAa,GACAgG,GACc;AACd,SAAK7C,IAGD4C,IAEKE,GAA2B9C,EAAE,MAAMY,GAAQ5E,GAAQa,GAAO,GAAG,GAAGgG,CAAS,IAEzEC;AAAA,IACL9C,EAAE;AAAA,IACFY;AAAA,IACA5E;AAAA,IACAa;AAAA,IACAmD,EAAE;AAAA,IACFA,EAAE;AAAA,IACF6C;AAAA,EAAA,IAbK,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG,EAAA,GAAK,IAAI,EAAE,GAAG,GAAG,GAAG,EAAI,EAAA;AAgBpD;AAMA,SAASP,GAA+B9F,GAAkByB,GAAcgE,GAAc;AACpF,QAAMG,IAAoD,CAAA,GACpDC,IAAwC,CAAA,GAMxCU,IAA6B,CAAA;AAEnC,aAAW,CAACzE,GAAIuB,CAAI,KAAK,OAAO,QAAQoC,CAAK,GAAG;AAC9C,QAAI,EAAEpC,EAAK,UAAU5B,KAAS4B,EAAK,UAAU5B;AAE3C;AAEI,UAAAgD,IAAM,CAACpB,EAAK,QAAQA,EAAK,MAAM,EAAE,KAAO,EAAA,KAAK,KAAK,GAClDmD,IAASD,EAAI9B,CAAG,KAAK,CAAA;AAC3B,IAAA+B,EAAO1E,CAAE,IAAIuB,GACbkD,EAAI9B,CAAG,IAAI+B;AAAA,EAMb;AAMA,QAAMC,IACJzG,EAAQ,KAAK,eAAe,WACxBA,EAAQ,KAAK,MACb,CAAC0G,GAAWC,MAAgB3G,EAAQ,KAAK;AAC/C,aAAW,CAACyE,GAAKgB,CAAK,KAAK,OAAO,QAAQc,CAAG,GAAG;AAC9C,UAAMK,IAAU,OAAO,KAAKnB,CAAK,EAAE;AACnC,QAAImB,KAAW;AAAG;AAEZ,UAAAC,IAAMJ,EAAQhB,GAAOzF,CAAO,GAC5B,CAAC8G,GAAQzD,CAAI,IAAI,OAAO,QAAQoC,CAAK,EAAE,CAAC;AAC9C,QAAImB,MAAY;AACd,MAAAhB,EAAiBkB,CAAM,IAAI,EAAE,MAAAzD,GAAM,cAAc,GAAG,YAAY,KACrDwC,EAAApB,CAAG,IAAI,EAAE,OAAAgB,GAAO,YAAY,GAAG,WAAW;SAChD;AACL,UAAIsB,IAAe;AACb,YAAAC,IAAiB,OAAO,QAAQvB,CAAK,EAAE,IAAI,CAAC,CAAC3D,GAAIuB,CAAI,MAAM;AAC/D,YAAI4D,IAAQ1H,EAAO,MAAMS,EAAQ,KAAK,OAAO,OAAOqD,CAAI;AACpD,eAAA,MAAM,CAAC4D,CAAK,MACN,QAAA;AAAA,UACN;AAAA,UACAnF;AAAA,UACAmF;AAAA,QAAA,GAEMA,IAAA,IAEHA,IAAQ;AAAA,MAAA,CAChB,GACKC,IAAS,OAAO,QAAQzB,CAAK,EAAE,IAAI,CAAC,CAACqB,GAAQzD,CAAI,GAAG8D,OACpDA,IAAI,MACNJ,KAAgBC,EAAeG,IAAI,CAAC,IAAIN,IAAMG,EAAeG,CAAC,IAEzD,CAACL,GAAQzD,GAAM0D,CAAY,EACnC,GACKf,IAAae;AACnB,MAAAG,EAAO,QAAQ,CAAC,CAACJ,GAAQzD,GAAM0D,CAAY,MAAM;AAC/C,QAAAnB,EAAiBkB,CAAM,IAAI,EAAE,MAAAzD,GAAM,cAAA0D,GAAc,YAAAf;MAAW,CAC7D,GACDH,EAAWpB,CAAG,IAAI,EAAE,OAAAgB,GAAO,YAAAO,GAAY,WAAW;IACpD;AAAA,EACF;AAEO,SAAA,EAAE,kBAAAJ,GAAkB,YAAAC;AAC7B;AAEA,SAASK,GAAsBzE,GAAcgE,GAAczF,GAAkBiH,GAAe;AAG1F,MADkB,OAAO,QAAQxB,CAAK,EAAE,WACtB;AAAU,WAAA;AAQ5B,QAAM2B,IAAW,KAAK;AAAA,IACpB,GAAG,OAAO,OAAO3B,CAAK,EACnB,QAAQ,CAAA4B,MAAK,CAAC5F,EAAM4F,EAAE,MAAM,GAAG5F,EAAM4F,EAAE,MAAM,CAAC,CAAC,EAC/C,OAAO,CAAK5H,MAAAA,CAAC,EACb,IAAI,CAAQU,MAAA;AACX,YAAMG,IAAQf,EAAO,OAAOS,EAAQ,KAAK,QAAQG,CAAI;AACjD,aAAAG,EAAM,SAAS,WACVA,EAAM,SAAS,IAEf,KAAK,IAAIA,EAAM,OAAOA,EAAM,MAAM;AAAA,IAC3C,CACD;AAAA,EAAA;AAEL,SAAO2G,IAAQG;AACjB;AAEA,SAASd,GACPjD,GACAe,GACA5E,GACAa,GACA2F,GACAe,GACAV,GACc;;AACV,MAAAiB,GAAIC,GAAIC,GAAIC;AACZ,SAAApE,EAAK,SAASA,EAAK,SACpB,CAACiE,GAAIC,GAAIC,GAAIC,CAAE,IAAIC;AAAA,KAClBtE,IAAAgB,KAAA,gBAAAA,EAAQ,MAAR,OAAAhB,IAAa;AAAA,KACbuE,IAAAvD,KAAA,gBAAAA,EAAQ,MAAR,OAAAuD,IAAa;AAAA,KACbhB,IAAAnH,KAAA,gBAAAA,EAAQ,MAAR,OAAAmH,IAAa;AAAA,KACbiB,IAAApI,KAAA,gBAAAA,EAAQ,MAAR,OAAAoI,IAAa;AAAA,IACbvH;AAAA,IACA2F;AAAA,IACAe;AAAA,IACAV;AAAA,EAAA,IAGD,CAACmB,GAAIC,GAAIH,GAAIC,CAAE,IAAIG;AAAA,KAClBhB,IAAAlH,KAAA,gBAAAA,EAAQ,MAAR,OAAAkH,IAAa;AAAA,KACbmB,IAAArI,KAAA,gBAAAA,EAAQ,MAAR,OAAAqI,IAAa;AAAA,KACbC,IAAA1D,KAAA,gBAAAA,EAAQ,MAAR,OAAA0D,IAAa;AAAA,KACbC,IAAA3D,KAAA,gBAAAA,EAAQ,MAAR,OAAA2D,IAAa;AAAA,IACb1H;AAAA,IACA2F;AAAA,IACAe;AAAA,IACAV;AAAA,EAAA,GAGG,EAAE,IAAI,EAAE,GAAGiB,GAAI,GAAGC,EAAA,GAAM,IAAI,EAAE,GAAGC,GAAI,GAAGC,EAAK,EAAA;AACtD;AAEA,SAASC,GACPJ,GACAC,GACAC,GACAC,GACApH,GACA2F,GACAe,GACAV,GACkC;AAClC,QAAM2B,IAAKR,IAAKF,GACVW,IAAKR,IAAKF;AAGZ,MAAAW,KAAQlC,IAAa,IAAIe,KAAgB1G;AAGzC,MAAA6H,MAAS,KAAK7B,MAAc,SAAS;AACvC,UAAM8B,IAAS,KAAK,MAAMV,IAAKF,GAAIC,IAAKF,CAAE;AAC1C,QAAIjB,MAAc,YAAY;AAEtB,YAAA+B,IAAgB,KAAK,KAAK;AAChC,OAAID,IAAS,CAACC,KAAiBD,KAAUC,OAC/BF,KAAA;AAAA,IACV;AACF,MAAW7B,MAAc,gBAEnB8B,IAAS,MACHD,KAAA;AAAA,EAGd;AAEA,MAAIF,MAAO,GAAG;AACN,UAAAK,IAAOJ,IAAK,IAAI,KAAK;AACpB,WAAA,CAACX,IAAKY,IAAOG,GAAMd,GAAIC,IAAKU,IAAOG,GAAMZ,CAAE;AAAA,EAAA,WACzCQ,MAAO,GAAG;AACb,UAAAI,IAAOL,IAAK,IAAI,IAAI;AACnB,WAAA,CAACV,GAAIC,IAAKW,IAAOG,GAAMb,GAAIC,IAAKS,IAAOG,CAAI;AAAA,EAAA,OAC7C;AAEL,UAAMC,IAAY,MADJL,IAAKD;AAEnB,IAAIC,IAAK,MACPC,IAAO,CAACA;AAEJ,UAAAK,IAAQL,IAAO,KAAK,KAAK,IAAI,KAAK,IAAII,GAAW,CAAC,CAAC;AAClD,WAAA,CAAChB,IAAKiB,GAAOhB,IAAKgB,IAAQD,GAAWd,IAAKe,GAAOd,IAAKc,IAAQD,CAAS;AAAA,EAChF;AACF;ACxSgB,SAAAE,GAAIC,GAAaC,GAAalJ,GAA2B;AACvE,SAAKA,MACHA,IAAS,EAAE,GAAG,GAAG,GAAG,EAAE,IAEjBA,EAAA,IAAIiJ,EAAG,IAAIC,EAAG,GACdlJ,EAAA,IAAIiJ,EAAG,IAAIC,EAAG,GACdlJ;AACT;AAIgB,SAAAmJ,GAASF,GAAaC,GAAalJ,GAA2B;AAC5E,SAAKA,MACHA,IAAS,EAAE,GAAG,GAAG,GAAG,EAAE,IAEjBA,EAAA,IAAIiJ,EAAG,IAAIC,EAAG,GACdlJ,EAAA,IAAIiJ,EAAG,IAAIC,EAAG,GACdlJ;AACT;AAIgB,SAAAoJ,GAASH,GAAaC,GAAalJ,GAA2B;AAC5E,SAAKA,MACHA,IAAS,EAAE,GAAG,GAAG,GAAG,EAAE,IAEjBA,EAAA,IAAIiJ,EAAG,IAAIC,EAAG,GACdlJ,EAAA,IAAIiJ,EAAG,IAAIC,EAAG,GACdlJ;AACT;AAIgB,SAAAqJ,GAAepJ,GAAYqJ,GAAgBtJ,GAA2B;AACpF,SAAKA,MACHA,IAAS,EAAE,GAAG,GAAG,GAAG,EAAE,IAEjBA,EAAA,IAAIC,EAAE,IAAIqJ,GACVtJ,EAAA,IAAIC,EAAE,IAAIqJ,GACVtJ;AACT;AAIgB,SAAAuJ,GAAON,GAAaC,GAAalJ,GAA2B;AAC1E,SAAKA,MACHA,IAAS,EAAE,GAAG,GAAG,GAAG,EAAE,IAEjBA,EAAA,IAAIiJ,EAAG,IAAIC,EAAG,GACdlJ,EAAA,IAAIiJ,EAAG,IAAIC,EAAG,GACdlJ;AACT;AAEgB,SAAAwJ,GAAIP,GAAaC,GAAqB;AACpD,SAAOD,EAAG,IAAIC,EAAG,IAAID,EAAG,IAAIC,EAAG;AACjC;AAEgB,SAAAO,GAAMR,GAAaC,GAAqB;AACtD,SAAOD,EAAG,IAAIC,EAAG,IAAID,EAAG,IAAIC,EAAG;AACjC;AAEO,SAASQ,GAAczJ,GAAoB;AAChD,SAAOA,EAAE,IAAIA,EAAE,IAAIA,EAAE,IAAIA,EAAE;AAC7B;AAEO,SAAS0J,GAAO1J,GAAoB;AACzC,SAAO,KAAK,KAAKyJ,GAAczJ,CAAC,CAAC;AACnC;AAEgB,SAAA2J,GAAgBX,GAAaC,GAAqB;AAC1D,QAAAV,IAAKS,EAAG,IAAIC,EAAG,GACfT,IAAKQ,EAAG,IAAIC,EAAG;AACd,SAAAV,IAAKA,IAAKC,IAAKA;AACxB;AAEgB,SAAAoB,GAASZ,GAAaC,GAAqB;AACzD,SAAO,KAAK,KAAKU,GAAgBX,GAAIC,CAAE,CAAC;AAC1C;AAIgB,SAAAY,GAAU7J,GAAYD,GAA2B;AAC/D,EAAKA,MACHA,IAAS,EAAE,GAAG,GAAG,GAAG,EAAE;AAElB,QAAA+J,IAAMJ,GAAO1J,CAAC;AACpB,SAAI8J,MAAQ,KACV/J,EAAO,IAAI,GACXA,EAAO,IAAI,KAEXuJ,GAAOtJ,GAAG,EAAE,GAAG8J,GAAK,GAAGA,EAAA,GAAO/J,CAAM,GAE/BA;AACT;AAIgB,SAAAgK,GAAO/J,GAAYgK,GAAejK,GAA2B;AAC3E,EAAKA,MACHA,IAAS,EAAE,GAAG,GAAG,GAAG,EAAE;AAGlB,QAAAkK,IAAOjK,EAAE,IAAI,KAAK,IAAIgK,CAAK,IAAIhK,EAAE,IAAI,KAAK,IAAIgK,CAAK,GACnDE,IAAOlK,EAAE,IAAI,KAAK,IAAIgK,CAAK,IAAIhK,EAAE,IAAI,KAAK,IAAIgK,CAAK;AACzD,SAAAjK,EAAO,IAAIkK,GACXlK,EAAO,IAAImK,GACJnK;AACT;AAEA,MAAMoK,KAAU,MAAM,KAAK;AAE3B,SAASC,GAAQC,GAAa;AAC5B,SAAOA,IAAMF;AACf;AAEO,SAASH,GAAMhK,GAAY;AAChC,SAAO,KAAK,MAAMA,EAAE,GAAGA,EAAE,CAAC;AAC5B;AAEO,SAASsK,GAAYtK,GAAY;AAC/B,SAAAoK,GAAQJ,GAAMhK,CAAC,CAAC;AACzB;;;;;;;;;;;;;;;;;;;ACxHO,MAAMuK,EAA4B;AAAA,EAIvC,OAAO,UAAU9I,GAAiB;AACzB,WAAA,IAAI8I,EAAS9I,EAAM,CAAC,KAAK,GAAGA,EAAM,CAAC,KAAK,CAAC;AAAA,EAClD;AAAA,EAEA,OAAO,WAAWiE,GAAc;AAC9B,WAAO,IAAI6E,EAAS7E,EAAI,GAAGA,EAAI,CAAC;AAAA,EAClC;AAAA,EAEA,YAAY8E,GAAWC,GAAW;AAChC,SAAK,IAAID,GACT,KAAK,IAAIC;AAAA,EACX;AAAA;AAAA,EAGA,IAAIzK,GAAsB;AACjB,WAAA+I,GAAI,MAAM/I,GAAG,IAAI;AAAA,EAC1B;AAAA,EAEA,SAASA,GAAsB;AACtB,WAAAkJ,GAAS,MAAMlJ,GAAG,IAAI;AAAA,EAC/B;AAAA,EAEA,SAASA,GAAsB;AACtB,WAAAmJ,GAAS,MAAMnJ,GAAG,IAAI;AAAA,EAC/B;AAAA,EAEA,eAAeqJ,GAA0B;AAChC,WAAAD,GAAe,MAAMC,GAAQ,IAAI;AAAA,EAC1C;AAAA,EAEA,OAAOrJ,GAAsB;AACpB,WAAAsJ,GAAO,MAAMtJ,GAAG,IAAI;AAAA,EAC7B;AAAA,EAEA,IAAIA,GAAoB;AACf,WAAAuJ,GAAI,MAAMvJ,CAAC;AAAA,EACpB;AAAA,EAEA,MAAMA,GAAoB;AACjB,WAAAwJ,GAAM,MAAMxJ,CAAC;AAAA,EACtB;AAAA,EAEA,gBAAwB;AACtB,WAAOyJ,GAAc,IAAI;AAAA,EAC3B;AAAA,EAEA,SAAiB;AACf,WAAOC,GAAO,IAAI;AAAA,EACpB;AAAA,EAEA,gBAAgB1J,GAAoB;AAC3B,WAAA2J,GAAgB,MAAM3J,CAAC;AAAA,EAChC;AAAA,EAEA,SAASA,GAAoB;AACpB,WAAA4J,GAAS,MAAM5J,CAAC;AAAA,EACzB;AAAA,EAEA,YAAsB;AACb,WAAA6J,GAAU,MAAM,IAAI;AAAA,EAC7B;AAAA,EAEA,QAAgB;AACd,WAAOG,GAAM,IAAI;AAAA,EACnB;AAAA,EAEA,cAAsB;AACpB,WAAOM,GAAY,IAAI;AAAA,EACzB;AAAA,EAEA,OAAON,GAAyB;AACvB,WAAAD,GAAO,MAAMC,GAAO,IAAI;AAAA,EACjC;AAAA,EAEA,UAAUhK,GAAqB;AAC7B,WAAO,KAAK,MAAMA,EAAE,KAAK,KAAK,MAAMA,EAAE;AAAA,EACxC;AAAA,EAEA,QAAkB;AAChB,WAAO,IAAIuK,EAAS,KAAK,GAAG,KAAK,CAAC;AAAA,EACpC;AAAA,EAEA,WAAoB;AAClB,WAAO,EAAE,GAAG,KAAK,GAAG,GAAG,KAAK;EAC9B;AAAA,EAEA,UAA4B;AAC1B,WAAO,CAAC,KAAK,GAAG,KAAK,CAAC;AAAA,EACxB;AACF;AC5FA,MAAeG,KAAA5H,GAAA;AAAA,EACb,UAAAyH;AAAAA,GACGG;ACDE,MAAMC,EAAW;AAAA,EAKtB,YAAYhG,GAAkB5E,GAAkBC,GAAa;AAC3D,SAAK,SAAS2E,GACd,KAAK,SAAS5E,GACd,KAAK,IAAIC;AAAA,EACX;AAAA,EAEA,OAAO,iBAAiB4K,GAAgC;AACtD,UAAMjG,IAAS4F,EAAS,WAAWK,EAAK,EAAE,GACpC7K,IAASwK,EAAS,WAAWK,EAAK,EAAE;AAC1C,WAAO,IAAID,EAAWhG,GAAQ5E,GAAQ8K,GAAalG,GAAQ5E,CAAM,CAAC;AAAA,EACpE;AAAA,EAEA,OAAO,cAAc+K,GAAqBC,GAAiC;AACnE,UAAApG,IAAS4F,EAAS,WAAWO,CAAS,GACtC/K,IAASwK,EAAS,WAAWQ,CAAS;AAC5C,WAAO,IAAIJ,EAAWhG,GAAQ5E,GAAQ8K,GAAalG,GAAQ5E,CAAM,CAAC;AAAA,EACpE;AAAA,EAEA,OAAO,YAAY4E,GAAkB5E,GAA8B;AACjE,WAAO,IAAI4K,EAAWhG,GAAQ5E,GAAQ8K,GAAalG,GAAQ5E,CAAM,CAAC;AAAA,EACpE;AACF;AAEgB,SAAA8K,GAAalG,GAAkB5E,GAA4B;AACzE,SAAOA,EAAO,MAAA,EAAQ,SAAS4E,CAAM;AACvC;AAEO,SAASqG,GAA0BJ,GAA0C;AAC3E,SAAA,CAACL,EAAS,WAAWK,EAAK,EAAE,GAAGL,EAAS,WAAWK,EAAK,EAAE,CAAC;AACpE;AAEO,SAASK,GAAwBL,GAA8B;AACpE,SAAO,IAAIL,GAAUK,EAAK,GAAG,IAAIA,EAAK,GAAG,KAAK,IAAIA,EAAK,GAAG,IAAIA,EAAK,GAAG,KAAK,CAAC;AAC9E;AAYiB,SAAAM,GAAeC,GAAcC,GAA4B;AACjE,SAAA,EAAE,IAAAD,GAAI,IAAAC;AACf;AASiB,SAAAC,GACfC,GACAC,GACAC,GACc;AACR,QAAAZ,IAAOD,EAAW,iBAAiBW,CAAO;AACzC,SAAAG,GAAiBb,GAAMW,GAAcC,CAAY;AAC1D;AAEA,SAASC,GACPb,GACAW,GACAC,GACc;AACd,QAAME,IAAad,EAAK,EAAE,QAAQ,UAAU,GAEtCe,IAAKf,EAAK,OAAO,MAAM,EAAE,IAAIc,EAAW,MAAM,EAAE,eAAeH,CAAY,CAAC,GAE5EK,IAAKhB,EAAK,OAAO,MAAM,EAAE,SAASc,EAAW,MAAM,EAAE,eAAeF,CAAY,CAAC;AAEnF,MAAAL,IAAKQ,EAAG,YACRP,IAAKQ,EAAG;AAEN,QAAAC,IAAQhB,GAAac,GAAIC,CAAE;AACjC,MAAIhB,EAAK,EAAE,MAAA,IAAUiB,EAAM,UAAU,GAAG;AAEtC,UAAMC,IAAK,IAAIvB,GAAUY,EAAG,IAAIC,EAAG,KAAK,IAAID,EAAG,IAAIC,EAAG,KAAK,CAAC,GACtDW,IAAKD,EAAG,MAAM,EAAE,IAAIJ,EAAW,eAAe,GAAG,CAAC;AACxD,IAAAP,IAAKW,EAAG,YACRV,IAAKW,EAAG;EACV;AAEO,SAAA,EAAE,IAAAZ,GAAI,IAAAC;AACf;AAEO,SAASY,GAAYpB,GAAkC;AAC5D,SAAO,EAAE,IAAIA,EAAK,IAAI,IAAIA,EAAK;AACjC;AAEO,SAASqB,GAA2BrB,GAAkB;AACrD,QAAAsB,IAAKtB,EAAK,EACb,MAAM,EACN,UACA,EAAA,OAAO,KAAK,KAAK,CAAC;AACd,SAAAD,EAAW,YAAYC,EAAK,QAAQA,EAAK,OAAO,MAAM,EAAE,IAAIsB,CAAE,CAAC;AACxE;ACxGgB,SAAAC,GAAgBpI,GAAa6G,GAA4B;AACvE,QAAM,IAAIA,EAAK,EAAE,QAAQ,UAAU,GAG7BwB,IAAKxB,EAAK,QACV1G,IAAIwG,GAAE,SAAS3G,GAAGqI,CAAE,GAGpB7C,IAAM,EAAE,IAAIrF,CAAC;AAMZ,SAFMkI,EAAG,MAAM,EAAE,IAAI,EAAE,eAAe7C,CAAG,CAAC;AAGnD;AAsBO,SAAS8C,GACd1H,GACA5E,GACAuM,GACAC,GACiB;AAKjB,MAAI,EAHW7B,GAAE,cAAcA,GAAE,SAAS3K,GAAQuM,CAAM,CAAC,IAC/BC,IAASA,KAAU,KAAK,IAAI,GAAG,GAAG;AAEtC,WAAA;AAKtB,QAAM3B,IAAOD,EAAW,YAAYhG,GAAQ5E,CAAM,GAC5CyM,IAAIL,GAAgBG,GAAQ1B,CAAI,GAGhC6B,IAAQ/B,GAAE,OAAOA,GAAE,SAAS8B,GAAGF,CAAM,CAAC;AAI5C,MAAIC,IAASE;AAAc,WAAA;AAK3B,MAAIF,MAAWE;AAAc,WAAAD;AAI7B,QAAME,IAAI,KAAK,KAAKC,GAAAJ,GAAU,KAAII,GAAAF,GAAS,EAAC,GAMtCb,IAAKhB,EAAK,EAAE,UAAU,EAAE,eAAe8B,CAAC;AAIvC,SAAAF,EAAE,SAASZ,CAAE;AACtB;AAEO,SAASgB,GACdjI,GACA5E,GACAuM,GACAC,GACAM,GACiB;AAKjB,MAAI,EAHWnC,GAAE,cAAcA,GAAE,SAAS3K,GAAQuM,CAAM,CAAC,IAC/BC,IAASA,KAAU,KAAK,IAAI,GAAG,GAAG;AAEtC,WAAA;AAKtB,QAAM3B,IAAOD,EAAW,YAAYhG,GAAQ5E,CAAM,GAC5CyM,IAAIL,GAAgBG,GAAQ1B,CAAI,GAGhC6B,IAAQ/B,GAAE,OAAOA,GAAE,SAAS8B,GAAGF,CAAM,CAAC;AAI5C,MAAIC,IAASE;AAAc,WAAA;AAK3B,MAAIF,MAAWE;AAAc,WAAAD;AAI7B,QAAME,IAAI,KAAK,KAAKC,GAAAJ,GAAU,KAAII,GAAAF,GAAS,EAAC,GAMtCb,IAAKhB,EAAK,EAAE,UAAU,EAAE,eAAe8B,CAAC,GACxCI,IAAMN,EAAE,MAAM,EAAE,IAAIZ,CAAE,GACtBmB,IAAMP,EAAE,MAAM,EAAE,SAASZ,CAAE,GAE3BoB,IAAKH,EAAO,SAASC,CAAG,GACxBG,IAAKJ,EAAO,SAASE,CAAG;AAE9B,SAAI,KAAK,IAAIC,IAAKC,CAAE,IAAI,IAGfF,IAGFC,IAAKC,IAAKH,IAAMC;AACzB;AAQgB,SAAAG,GAA4BC,GAAmBC,GAA6B;AAC1F,QAAMpN,IAAI0K,GAAE,SAAS0C,EAAM,QAAQD,EAAM,MAAM,GAEzCnE,IAAKmE,EAAM,GACXlE,IAAKmE,EAAM,GAEXC,IAAK3C,GAAE,MAAM1K,GAAGgJ,CAAE,IAAI0B,GAAE,MAAM1B,GAAIC,CAAE;AAEnC,SAAAmE,EAAM,OAAO,MAAA,EAAQ,IAAInE,EAAG,QAAQ,eAAeoE,CAAE,CAAC;AAC/D;AAeO,SAASC,GACdC,GACAC,GACAC,GACAC,GACAC,GACwC;AACxC,QAAM7B,IAAKyB,GAILK,IAHKH,EAGM,MAAM,EAAE,SAAS3B,CAAE,GAG9B5H,IAAI0J,EAAM,UAEVC,IAAOL,IAAUE;AACvB,MAAIG,IAAO3J;AAAU,WAAA;AAGrB,QAAM4J,IAAO,KAAK,IAAIN,IAAUE,CAAO;AACvC,MAAIxJ,IAAI4J;AAAa,WAAA;AAKrB,MAAI5J,MAAM2J,GAAM;AACd,UAAMlM,IAAIiM,EAAM,MAAM,EAAE,UAAU,GAC5B7J,IAAIwJ,EAAQ,MAAM,EAAE,IAAI5L,EAAE,eAAe6L,CAAO,CAAC;AACvD,WAAOG,IAAO5J,IAAI,CAACA,GAAIA,CAAC;AAAA,EAC1B;AAKA,MAAIG,MAAM4J,GAAM;AACd,UAAMnM,IAAIiM,EAAM,MAAM,EAAE,UAAU,GAC5BG,IAAUP,IAAUE,GAIpB3J,IAAIwJ,EAAQ,MAAA,EAAQ,IAAI5L,EAAE,eAAeoM,IAAUP,IAAU,CAACA,CAAO,CAAC;AAC5E,WAAOG,IAAO5J,IAAI,CAACA,GAAIA,CAAC;AAAA,EAC1B;AAKA,QAAMI,IAAIqJ,GACJQ,IAAIN,GAGJO,KAAOtB,GAAAzI,GAAK,KAAIyI,GAAAxI,GAAK,KAAIwI,GAAAqB,GAAK,OAAM,IAAI9J,IAAIC,IAI5C+J,IAAK/J,IAAI8J,GAGTE,IAAK,KAAK,KAAKxB,GAAAxI,GAAK,KAAIwI,GAAAuB,GAAM,EAAC,GAG/BhC,IAAK0B,EAAM,MAAM,EAAE,UAAU,GAG7BQ,IAAK,IAAI7D,EAAS,CAAC2B,EAAG,GAAGA,EAAG,CAAC,GAK7BmC,IAAMnC,EAAG,MAAM,EAAE,eAAegC,CAAE,GAClCI,IAAMF,EAAG,MAAM,EAAE,eAAeD,CAAE,GAElCI,IAAUhB,EAAQ,MAAM,EAAE,IAAIc,CAAG,EAAE,IAAIC,CAAG,GAC1CE,IAAUjB,EAAQ,MAAM,EAAE,IAAIc,CAAG,EAAE,SAASC,CAAG;AAErD,MAAIX,GAAM;AACF,UAAAX,IAAKuB,EAAQ,SAASZ,CAAI,GAC1BV,IAAKuB,EAAQ,SAASb,CAAI;AACzB,WAAAX,IAAKC,IAAKsB,IAAUC;AAAA,EAAA;AAEpB,WAAA,CAACD,GAASC,CAAO;AAE5B;ACxNA,SAASC,GACP3D,GACAC,GACA2D,GACA9N,GACA;AACA,QAAM+N,IAAahE,EAAW,cAAcG,GAAWC,CAAS,GAC1D6D,KAAcF,EAAK,QAAQA,EAAK,eAAe,IAAK9N,GACpDiO,KAAeH,EAAK,SAASA,EAAK,eAAe,IAAK9N,GAEtDkO,IACJJ,EAAK,eAAe,KAAKA,EAAK,eAAeA,EAAK,cAAc,KAAK9N,IAAQ,GAGzEmO,KAAaJ,EAAW,EAAE,MAAA,IAAU,KAAK,KAAK,KAAK,KAAK,IACxDK,IAAY,KAAK,KAAK,IAAKD,IAAY,KAAK,IAC5ClL,IAAIgL,IAAa,KAAK,IAAI,KAAK,IAAIE,CAAS,CAAC,GAC7C,IAAIH,IAAY,KAAK,IAAI,KAAK,IAAII,CAAS,CAAC,GAC5CC,IAAiBpL,KAAK+K,IAAYE,GAClCI,IAAiB,KAAKL,IAAaC;AACrC,MAAAG,KAAkBC,KAAkBJ,MAAiB;AACvD,WACS,KAAK,KADVG,IACetC,GAAAkC,GAAc,KAAIlC,GAAA9I,GAAK,KAEvB8I,GAAAiC,GAAa,KAAIjC,GAAA,GAAK,EAFE;AAItC;AAEC,UAAAwC,IAAOpE,EAAU,IAAI6D,IAAYE,GACjCM,IAAMrE,EAAU,IAAI8D,IAAaC,GACjCO,IAAQtE,EAAU,IAAI6D,IAAYE,GAClCQ,IAASvE,EAAU,IAAI8D,IAAaC,GACpCS,IAAW;AAAA,MACf,IAAIhF,EAAS4E,GAAMC,CAAG;AAAA,MACtB,IAAI7E,EAAS8E,GAAOD,CAAG;AAAA,MACvB,IAAI7E,EAAS8E,GAAOC,CAAM;AAAA,MAC1B,IAAI/E,EAAS4E,GAAMG,CAAM;AAAA,IAAA,GAErBE,IAAQ,KAAK,OAAQb,EAAW,EAAE,gBAAgB,OAAO,MAAO,EAAE,GAClEc,IAAwBF,EAASC,CAAK,GACtCE,IAAQC;AAAAA,MACZhB,EAAW;AAAA,MACXiB,GAA2BH,GAAuBd,CAAU;AAAA,MAC5Dc;AAAA,MACAX;AAAA,IAAA;AAEF,WAAOY,IACHG,GAAuBH,GAAOf,EAAW,MAAM,EAAE,OAAA,IACjDkB,GAAuBJ,GAAuBd,EAAW,MAAM,EAAE,WAAWG;AAAA,EAClF;AACF;AAYO,SAASgB,GACdxE,GACAyE,GACAC,GACAC,GACArP,GACe;AAET,QAAAgK,IAAOD,EAAW,iBAAiBW,CAAO,GAC1CI,IAAad,EAAK,EAAE,QAAQ,UAAU,GAGtCe,IACJsE,MAAY,IACRrF,EAAK,SACLA,EAAK,OAAO,MAAQ,EAAA,IAAIc,EAAW,MAAM,EAAE,eAAeuE,IAAUrP,CAAK,CAAC,GAG1EgL,IACJqE,MAAY,IACRrF,EAAK,SACLA,EAAK,OAAO,MAAQ,EAAA,SAASc,EAAW,MAAM,EAAE,eAAeuE,IAAUrP,CAAK,CAAC,GAG/EsP,KAAeH,EAAU,QAAQ,IAAIC,KAAUpP,GAC/CuP,IAAU,IAAI5F,EAAS,CAACmB,EAAW,GAAGA,EAAW,CAAC,EAAE,eAAewE,CAAW;AACpF,MAAIE,IAAc1F,GAAE,SAASiB,GAAIwE,CAAO,GACpCE,IAAc3F,GAAE,IAAIiB,GAAIwE,CAAO,GAC/BG,IAAc5F,GAAE,SAASkB,GAAIuE,CAAO,GACpCI,IAAc7F,GAAE,IAAIkB,GAAIuE,CAAO;AAE7B,QAAAnG,IAAQY,EAAK,EAAE,YAAY;AAC7B,UAAAZ,IAAQ,OAAOA,KAAS,QAEzB,CAACoG,GAAaC,CAAW,IAAI,CAACA,GAAaD,CAAW,GACtD,CAACE,GAAaC,CAAW,IAAI,CAACA,GAAaD,CAAW,IAElD;AAAA,IACL,QAAQ,EAAE,OAAOF,GAAa,OAAOC,EAAY;AAAA,IACjD,QAAQ,EAAE,OAAOC,GAAa,OAAOC,EAAY;AAAA,EAAA;AAErD;AAUO,SAASC,GACdC,GACAxP,GACAyP,GACAC,GACkB;AAEd,MAAAC;AACA,EAAAF,EAAgB,SAAS,WACfE,IAAAF,EAAgB,SAAUA,EAAgB,cAAc,IAExDE,IAAAnC;AAAA,IACVxN;AAAA,IACAwP;AAAA,IACAC;AAAA,IACA;AAAA;AAAA,EAAA;AAKA,MAAAG;AACA,SAAAF,EAAgB,SAAS,WACfE,IAAAF,EAAgB,SAAUA,EAAgB,cAAc,IAExDE,IAAApC;AAAA,IACVgC;AAAA,IACAxP;AAAA,IACA0P;AAAA,IACA;AAAA;AAAA,EAAA,GAIG,CAACC,GAAWC,CAAS;AAC9B;AASgB,SAAAC,GAAoBxO,GAAegK,GAAkB5D,GAAgB;AAC7E,QAAA,EAAE,GAAA8B,GAAG,GAAAC,EAAM,IAAAnI,GACXiG,IAAKiC,IAAI8B,EAAO,GAChB9D,IAAKiC,IAAI6B,EAAO;AAEf,SAAA;AAAA,IACL,GAAG/D,IAAK,KAAK,IAAIG,CAAM,IAAIF,IAAK,KAAK,IAAIE,CAAM,IAAI4D,EAAO;AAAA,IAC1D,GAAG/D,IAAK,KAAK,IAAIG,CAAM,IAAIF,IAAK,KAAK,IAAIE,CAAM,IAAI4D,EAAO;AAAA,EAAA;AAE9D;AAOO,SAASyE,GAAmBC,GAAuB;AACxD,SAAIA,IAAQ,IACH,EAAE,KAAK,KAAK,IAAIA,KAEhB,KAAK,KAAK,IAAIA;AAEzB;AAEO,SAASC,GACd9F,GACAmB,GACAlB,GACA8F,GACY;AACZ,QAAMC,IAAsB,CAAA,GACtBC,IAAiBzG,EAAW,YAAY2B,GAAQnB,CAAE,GAClDkG,IAAiB1G,EAAW,YAAY2B,GAAQlB,CAAE;AAEpD,MAAA4F,IAAQM,GAA6BF,GAAgBC,CAAc;AACnE,EAAAH,IAASF,IAAQ,MACnBA,IAAQD,GAAmBC,CAAK;AAE5B,QAAAO,IAAShH,EAAS,WAAWuG,GAAoB3F,GAAImB,GAAQ,CAAC0E,IAAQ,CAAC,CAAC,GACxEQ,IAAa7G,EAAW,YAAY2B,GAAQiF,CAAM,GAClDE,IAAYC,GAAqCF,CAAU,GAE3DG,IAASL,GAA6BF,GAAgBI,CAAU;AAClE,MAAAI,IAAUF,GAAqCN,CAAc;AACjE,MAAI,KAAK,IAAIO,CAAM,IAAI,KAAK,KAAK,GAAG;AAClC,UAAME,IAAKC,GAAuCF,GAASH,CAAS;AACpE,IAAAN,EAAQ,KAAKU,CAAE;AAAA,EAAA,OACV;AAEC,UAAAE,IAAKxH,EAAS,WAAWuG,GAAoBS,GAAQjF,GAAQqF,IAAS,CAAC,CAAC,GACxEK,IAAWN;AAAAA,MACf/G,EAAW,YAAY2B,GAAQ/B,EAAS,WAAWwH,CAAE,CAAC;AAAA,IAAA,GAElDE,IAAMH,GAAuCF,GAASI,CAAQ,GAC9DE,IAAMJ,GAAuCE,GAAUP,CAAS;AAC9D,IAAAN,EAAA,KAAKc,GAAKF,GAAIG,CAAG;AAAA,EAC3B;AAEA,EAAAf,EAAQ,KAAKI,CAAM;AAEb,QAAAY,IAASb,GAA6BD,GAAgBG,CAAU;AAEtE,MADUI,IAAAF,GAAqCL,CAAc,GACzD,KAAK,IAAIc,CAAM,IAAI,KAAK,KAAK,GAAG;AAClC,UAAMN,IAAKC,GAAuCF,GAASH,CAAS;AACpE,IAAAN,EAAQ,KAAKU,CAAE;AAAA,EAAA,OACV;AAEC,UAAAE,IAAKxH,EAAS,WAAWuG,GAAoBS,GAAQjF,GAAQ6F,IAAS,CAAC,CAAC,GACxEH,IAAWN;AAAAA,MACf/G,EAAW,YAAY2B,GAAQ/B,EAAS,WAAWwH,CAAE,CAAC;AAAA,IAAA,GAElDE,IAAMH,GAAuCL,GAAWO,CAAQ,GAChEE,IAAMJ,GAAuCE,GAAUJ,CAAO;AAC5D,IAAAT,EAAA,KAAKc,GAAKF,GAAIG,CAAG;AAAA,EAC3B;AAEO,SAAAf;AACT;AAEgB,SAAAG,GAA6BnE,GAAmBC,GAAmB;AACjF,SAAO,KAAK;AAAA,IACVD,EAAM,EAAE,IAAIC,EAAM,EAAE,IAAID,EAAM,EAAE,IAAIC,EAAM,EAAE;AAAA,IAC5CD,EAAM,EAAE,IAAIC,EAAM,EAAE,IAAID,EAAM,EAAE,IAAIC,EAAM,EAAE;AAAA,EAAA;AAEhD;AAEgB,SAAAgF,GACdjH,GACAC,GACAiH,GACoB;AACpB,QAAMxK,IAAKsD,EAAG,GACRrD,IAAKqD,EAAG,GACRpD,IAAKqD,EAAG,GACRpD,IAAKoD,EAAG,GACRkH,IAAKD,EAAG,GACRE,IAAKF,EAAG,GACRG,IAAM3K,IAAKE,GACX0K,IAAM3K,IAAKE,GACX0K,IAAMJ,IAAKvK,GACX4K,IAAMJ,IAAKvK;AAEjB,MAAKwK,MAAQ,KAAKC,MAAQ,KAAOC,MAAQ,KAAKC,MAAQ;AAE7C,WAAA,CAACxH,GAAI,CAAC;AAGf,QAAMX,KACHmI,KAAOH,KAAO3K,IAAKE,KAAM0K,KAAO3K,IAAKE,MAAOyK,KAAOC,KAAOJ,IAAKvK,KAAM4K,KAAOJ,IAAKvK,QACjF,IAAIwK,IAAMG,IAAM,IAAIF,IAAMC,IACvBjI,KACH,CAACiI,KAAOF,KAAO3K,IAAKE,KAAM0K,KAAO3K,IAAKE,MAAOwK,KAAOE,KAAOJ,IAAKvK,KAAM4K,KAAOJ,IAAKvK,QAClF,IAAIwK,IAAMG,IAAM,IAAIF,IAAMC,IAEvBnG,IAAS,KAAK,KAAK,KAAK,IAAI1E,IAAK2C,GAAG,CAAC,IAAI,KAAK,IAAI1C,IAAK2C,GAAG,CAAC,CAAC;AAE3D,SAAA,CADQ,IAAIF,EAASC,GAAGC,CAAC,GAChB8B,CAAM;AACxB;ACzTO,SAASqG,GAAc/R,GAAsB;AAC9C,SAAAA,EAAM,QAAQ,WACTA,EAAM,SAEN,KAAK,IAAIA,EAAM,OAAOA,EAAM,MAAM,IAAI;AAEjD;ACLO,SAASgS,MAAuB9L,GAAoB;AACzD,SAAOA,EAAO,KAAK,CAAK/G,MAAA,CAAC,CAACA,CAAC;AAC7B;ACSA,MAAM8S,KAAU,OAAO,UAAU;AAEjB,SAAAC,GACd3O,GACA4O,GACAC,GACAC,GACAtS,GACAuS,GACAC,GACApD,GACmB;;AAInB,QAAMhK,IAAQ5B,EAAK,OAGbiP,IAAajP,EAAK,YAClBkP,IAAUtN,EAAM,IAAI,CAACpC,GAAM8D,MAAM6L,GAAa3P,GAAMyP,EAAW3L,CAAC,GAAGwL,EAAWtP,EAAK,MAAM,CAAC,CAAC,GAG3F6D,IAAoC,CAAA;AAE1C,MAAI+L,IAAuB,IACvBC,IAAqB;AAKzB;AACQ,UAAAC,IAAYJ,EAAQ,CAAC;AACvB,QAAAK,IAAaC,GAAwBZ,EAAWU,EAAU,MAAM,EAAE,KAAK,IAAI9S;AAC/E,UAAMiT,IAAa7D,KAAUoD,MAAgB,eAAeO,IAAa,IACnEG,IACJD,KAAc,IACVH,EAAU,KAAK,SACfK,GAAqBL,GAAWG,GAAYZ,GAAa,EAAI;AACnE,IAAAxL,EAAO,KAAKqM,CAAS,GACrBH,IAAaC,GAAwBZ,EAAWU,EAAU,MAAM,EAAE,KAAK,IAAI9S,GACvEoP,IAAS,KACMtF,GAAE,SAASgJ,EAAU,KAAK,QAAQA,EAAU,KAAK,MAAM,KACxDG,IAAaF,MACJH,IAAA;AAAA,EAG7B;AAKA,QAAM9J,IAAS1D,EAAM;AACrB,WAAS0B,IAAI,GAAGA,IAAIgC,GAAQhC,KAAK;AACzB,UAAAsM,IAAOV,EAAQ5L,IAAI,CAAC,GACpBuM,IAAOX,EAAQ5L,CAAC,GAEhB9E,IAASqR,EAAK,QACdlT,IAAUwJ,EAAS,YAAW5G,IAAAsP,EAAYrQ,CAAM,MAAlB,OAAAe,IAAuB,EAAE,GAAG,GAAG,GAAG,EAAG,CAAA,GAGnEuQ,IAAaC,GAAwBH,GAAMC,GAAMlT,CAAO,GAMxD4S,IAAaC,GAAwBZ,EAAWpQ,CAAM,EAAE,KAAK,IAAIhC,GACjEwT,IAAiB,KAAK,IAAIT,KAAc,IAAI,IAAIA,IAAa,IAAI/S,CAAK,GACtEyT,IAAgBC,GAAWN,CAAI,GAC/BO,IAAgBD,GAAWL,CAAI,GAC/BO,IAAaC,GAA8BT,GAAMjT,GAASqT,GAAgBC,CAAa,GACvFK,IAAaD,GAA8BR,GAAMlT,GAASqT,GAAgB,CAACG,CAAa,GACxFI,IAAaF,GAA8BT,GAAMjT,GAAS4S,GAAYU,CAAa,GACnFO,IAAaH,GAA8BR,GAAMlT,GAAS4S,GAAY,CAACY,CAAa;AAKtF,QAAAjS;AACJ,QAAI4R,GAAY;AACd,YAAMW,IAAInK,GAAE,SAASwJ,GAAYnT,CAAO;AACxC,UAAI8T,IAAIT;AAIA,QAAA9R,IAAA;AAAA,UACJuQ,GAAiB2B,GAAYG,GAAYX,EAAK,KAAK,MAAM;AAAA,UACzDE;AAAA,UACArB,GAAiB6B,GAAYE,GAAYX,EAAK,KAAK,MAAM;AAAA,QAAA;AAAA,eAElDY,KAAKlB,GAAY;AAG1B,YAAIxI,IAAcC;AAClB,QAAIuJ,KAAcH,IAIdrJ,KAAAT,GAAE,SAASwJ,GAAYM,CAAU,IAAI9J,GAAE,SAASwJ,GAAYS,CAAU,IAClEH,IACAG,IAIDxJ,KAAAwJ,KAAcX,EAAK,KAAK,QAE3BY,KAAcF,IAIdtJ,KAAAV,GAAE,SAASwJ,GAAYQ,CAAU,IAAIhK,GAAE,SAASwJ,GAAYU,CAAU,IAClEF,IACAE,IAIDxJ,KAAAwJ,KAAcX,EAAK,KAAK,QAEzB3R,IAAA,CAAC6I,IAAI+I,GAAY9I,EAAE;AAAA,MAAA;AAGzB,QAAIoJ,KAAcE,IAIVpS,IAAA,CAACkS,GAAYzT,GAAS2T,CAAU,IAC7BC,KAAcC,IAIjBtS,IAAA,CAACqS,GAAY5T,GAAS6T,CAAU,IAMhCtS,IAAA;AAAA,UACJuQ,GAAiB2B,GAAYG,GAAYX,EAAK,KAAK,MAAM;AAAA,UACzDjT;AAAA,UACA8R,GAAiB6B,GAAYE,GAAYX,EAAK,KAAK,MAAM;AAAA,QAAA;AAAA,IAG/D;AAIA,MAAIO,KAAcE,IAGVpS,IAAA,CAACkS,GAAYzT,GAAS2T,CAAU,IAC7BC,KAAcC,IAGjBtS,IAAA,CAACqS,GAAY5T,GAAS6T,CAAU,IAItCtS,IAAM,CAAC0R,EAAK,KAAK,QAAQjT,GAASkT,EAAK,KAAK,MAAM;AAItD,QAAID,EAAK,OAAO;AAKd,YAAMc,IAAarN,EAAOA,EAAO,SAAS,CAAC;AAC3C,UAAIqN,GAAY;AACd,cAAMC,KACJD,aAAsB,QAAQA,EAAWA,EAAW,SAAS,CAAC,IAAIA;AAChE,YAAAhB;AACJ,QAAIxR,aAAe,QAGjBwR,KAAYX,IAAc7Q,EAAI,CAAC,IAAIA,EAAI,CAAC,IAE5BwR,KAAAxR;AAEd,cAAM6O,KAAU6D;AAAAA,UACdD;AAAA,UACAf,EAAK,MAAM,OAAO;AAAA,UAClBF;AAAA,UACAE,EAAK,MAAM;AAAA,QAAA;AAET,QAAA1R,aAAe,SAAS6Q,IAC1B1L,EAAO,KAAK,CAAC,GAAG0J,IAAS,GAAG7O,CAAG,CAAC,IAEhCmF,EAAO,KAAK,CAAC,GAAG0J,IAAS2C,EAAS,CAAC;AAAA,MAEvC;AAAA,IAAA,WACSE,EAAK,MAAM;AACd,YAAA,CAAC7I,GAAIC,IAAI6J,EAAG,IAAIC,GAAenU,GAASiT,GAAML,CAAU;AAC9D,MAAAlM,EAAO,KAAK0D,CAAE,GACd1D,EAAO,KAAKwN,EAAG,GACX3S,aAAe,SAAS6Q,IACnB1L,EAAA,KAAK,CAAC2D,IAAI9I,EAAI,CAAC,GAAGA,EAAI,CAAC,CAAC,CAAC,IAEzBmF,EAAA,KAAKnF,EAAI,CAAC,CAAC;AAAA,IACpB;AAEI,MAAA6Q,KAAe,EAAE7Q,aAAe,SAClCmF,EAAO,KAAKnF,CAAG,IAEX2R,EAAK,QACAxM,EAAA,KAAKnF,EAAI,CAAC,CAAC,IACT2R,EAAK,OACPxM,EAAA,KAAKnF,EAAI,CAAC,CAAC,IAElBmF,EAAO,KAAKnF,EAAI,CAAC,GAAGA,EAAI,CAAC,CAAC;AAAA,EAIlC;AAKA;AACE,UAAM6S,IAAW7B,EAAQA,EAAQ,SAAS,CAAC;AACvC,QAAAK,IAAaC,GAAwBZ,EAAWmC,EAAS,MAAM,EAAE,KAAK,IAAIvU;AAC9E,UAAMiT,IAAa7D,KAAUoD,MAAgB,eAAeO,IAAa,IACnEG,IACJD,KAAc,IACVsB,EAAS,KAAK,SACdpB,GAAqBoB,GAAUtB,GAAYZ,GAAa,EAAK;AAEnE,QADAU,IAAaC,GAAwBZ,EAAWmC,EAAS,MAAM,EAAE,KAAK,IAAIvU,GACtEuU,EAAS,MAAM;AACjB,YAAMpU,IAAUwJ,EAAS,YAAWrC,IAAA+K,EAAYkC,EAAS,MAAM,MAA3B,OAAAjN,IAAgC,EAAE,GAAG,GAAG,GAAG,EAAG,CAAA,GAC5E,CAACiD,GAAIiK,GAAGH,CAAG,IAAIC,GAAenU,GAASoU,GAAUxB,CAAU;AACjE,MAAAlM,EAAO,KAAK0D,CAAE,GACd1D,EAAO,KAAKwN,CAAG;AAAA,IAAA,WACNE,EAAS,OAAO;AAEzB,YAAM7S,IAAMmF,EAAOA,EAAO,SAAS,CAAC,GAC9BsN,IAAYzS,aAAe,QAAQA,EAAIA,EAAI,SAAS,CAAC,IAAIA,GACzD6O,IAAU6D;AAAAA,QACdD;AAAA,QACAI,EAAS,MAAM,OAAO;AAAA,QACtBrB;AAAA,QACAqB,EAAS,MAAM;AAAA,MAAA;AAEjB,MAAA1N,EAAO,KAAK,CAAC,GAAG0J,GAAS2C,CAAS,CAAC;AAAA,IAAA;AAGnC,MAAArM,EAAO,KAAKqM,CAAS;AAEvB,IAAI9D,IAAS,KACMtF,GAAE,SAASyK,EAAS,KAAK,QAAQA,EAAS,KAAK,MAAM,KACtDtB,IAAaF,MACNF,IAAA;AAAA,EAG3B;AAEA,SAAID,MACF/L,EAAO,MAAM,GACTA,EAAO,CAAC,aAAa,SACvBA,EAAO,QAAQA,EAAO,CAAC,EAAE,CAAC,CAAC,IAG3BgM,KACFhM,EAAO,IAAI,GAGNA;AACT;AAEO,SAAS4N,GAA+BrP,GAAgC;AAC7E,QAAM0D,IAAS1D,EAAM;AACrB,MAAI0D,MAAW;AAAG,WAAO;AACzB,MAAIA,KAAU;AAAG,WAAO,CAAC,EAAI;AAE7B,QAAM2J,IAAwB,CAAA;AAC9B,MAAIiC,IAA0B,MAC1BC,IAAY;AAChB,WAAS7N,IAAI,GAAGA,IAAIgC,GAAQhC,KAAK;AAC/B,UAAM/C,IAASqB,EAAM0B,CAAC,EAAE,KAAK,QACvB3H,IAASiG,EAAM0B,CAAC,EAAE,KAAK;AAC7B,QAAIA,MAAM;AACR,UAAIgC,IAAS,GAAG;AAGR,cAAA8L,IAAQC,GAAczP,GAAO,CAAC;AACpC,QAAIwP,MAAU,OACAD,IAAA,KAEZA,IAAYC,MAAUzV;AAAA,MACxB;AAEA,QAAAwV,IAAY,CAACvP,EAAM,CAAC,EAAE,KAAK,QAAQA,EAAM,CAAC,EAAE,KAAK,MAAM,EAAE,SAASjG,CAAM;AAAA;AAE5E,MAAW4E,MAAW5E,IACRwV,IAAA,KAEZA,IAAYD,MAAa3Q;AAE3B,IAAA0O,EAAW,KAAKkC,CAAS,GACzBD,IAAWC,IAAYxV,IAAS4E;AAAA,EAClC;AAEO,SAAA0O;AACT;AAEA,SAASoC,GAAczP,GAAqBwJ,GAA8B;AAClE,QAAAkG,IAAc1P,EAAMwJ,CAAK,GACzBmG,IAAc3P,EAAMwJ,IAAQ,CAAC,GAC7BoG,IAAc,CAACF,EAAY,KAAK,QAAQA,EAAY,KAAK,MAAM,EAAE,QACjEG,IAAW,CAACF,EAAY,KAAK,QAAQA,EAAY,KAAK,MAAM,EAAE;AAEpE,MAAIC,EAAY,CAAC,MAAMA,EAAY,CAAC;AAElC,WAAOA,EAAY,CAAC;AAGtB,MAAIC,EAAS,CAAC,MAAMA,EAAS,CAAC;AAE5B,WAAOA,EAAS,CAAC;AAGnB,MAAIH,EAAY,WAAWC,EAAY,UAAWC,EAAY,CAAC,MAAMC,EAAS,CAAC,KAAKD,EAAY,CAAC,MAAMC,EAAS,CAAC,GAAI;AAE/G,QAAArG,KAASxJ,EAAM,SAAS;AAEnB,aAAA;AACF;AAEL,YAAMwP,IAAQC,GAAczP,GAAOwJ,IAAQ,CAAC;AAC5C,aAAIgG,MAAU,OACL,OAEAA,MAAUI,EAAY,CAAC,IAAIA,EAAY,CAAC,IAAIA,EAAY,CAAC;AAAA,IAEpE;AAAA,EAAA;AAEO,WAAAC,EAAS,SAASD,EAAY,CAAC,CAAC,IAAIA,EAAY,CAAC,IAAIA,EAAY,CAAC;AAE7E;AAEA,SAAS7B,GACPnQ,GACA+P,GACAV,GACA6C,GACA;AACA,QAAMlT,IAASkT,IAAYlS,EAAK,SAASA,EAAK,QACxCmS,IAAQnS,EAAK;AACnB,MAAImS,GAAO;AACL,QAAAC,IAAUrC,IAAaoC,EAAM,OAAO;AACpC,WAAAA,EAAM,QAAQ,MACLC,KAAA,KAERF,MACQE,KAAA,KAENzL,EAAS;AAAA,MACd0L;AAAAA,QACEH,IAAYlS,EAAK,KAAK,SAASA,EAAK,KAAK;AAAA,QACzCmS,EAAM,OAAO;AAAA,QACbC;AAAA,MACF;AAAA,IAAA;AAAA,EACF,OACK;AACL,QAAIrR,GAAkB5E;AASlB,QARA+V,KACFnR,IAASf,EAAK,KAAK,QACnB7D,IAAS6D,EAAK,KAAK,WAEnBe,IAASf,EAAK,KAAK,QACnB7D,IAAS6D,EAAK,KAAK,SAGjBqP,EAAYrQ,CAAM,GAAG;AACvB,YAAMmB,IAAI4L;AAAAA,QACRhL;AAAA,QACA5E;AAAA,QACAwK,EAAS,WAAW0I,EAAYrQ,CAAM,CAAC;AAAA,QACvC+Q;AAAA,MAAA;AAEK,aAAA5P,MAAM,OAAOY,IAASZ;AAAA,IAAA;AAEtB,aAAAY;AAAA,EAEX;AACF;AAEA,SAASwP,GACPH,GACAC,GACAlT,GACiB;AACjB,MAAImT,IAA8B;AAC9B,MAAAF,EAAK,QAAQC,EAAK;AACP,IAAAC,IAAA;AAAA,WACJF,EAAK;AACd,QAAIC,EAAK,OAAO;AACd,UAAID,EAAK,KAAK,OAAO,UAAUC,EAAK,KAAK,MAAM;AACtC,eAAAD,EAAK,KAAK,OAAO,MAAM;AAGhC,MAAAE,IAAagC;AAAAA,QACXlC,EAAK,MAAM,OAAO;AAAA,QAClBA,EAAK,MAAM,OAAO;AAAA,QAClBC,EAAK,MAAM,OAAO;AAAA,QAClBA,EAAK,MAAM,OAAO;AAAA,QAClBD,EAAK,MAAM;AAAA,MAAA;AAAA,IACb;AAGA,MAAAE,IAAaiC;AAAAA,QACXlC,EAAK,KAAK;AAAA,QACVA,EAAK,KAAK;AAAA,QACVD,EAAK,MAAM,OAAO;AAAA,QAClBA,EAAK,MAAM,OAAO;AAAA,QAClBjT;AAAA,MAAA;AAAA,WAIAkT,EAAK;AAEP,IAAAC,IAAavE;AAAAA,MACXqE,EAAK,KAAK;AAAA,MACVA,EAAK,KAAK;AAAA,MACVC,EAAK,MAAM,OAAO;AAAA,MAClBA,EAAK,MAAM,OAAO;AAAA,IAAA;AAAA,OAEf;AAEC,UAAAmC,IAAYC,GAAUrC,EAAK,IAAI,GAC/BsC,IAAYD,GAAUpC,EAAK,IAAI;AAGrC,IADG,CAAC,SAASmC,CAAS,KAAK,CAAC,SAASE,CAAS,KAAM,KAAK,IAAIF,IAAYE,CAAS,IAAIxD,KAEvEoB,IAAA,OAEbA,IAAapC,GAAuCkC,EAAK,MAAMC,EAAK,IAAI;AAAA,EAE5E;AAEK,SAAAC;AACT;AAEA,SAASO,GACP7Q,GACA2S,GACA5C,GACA6C,GACiB;AACjB,MAAI5S,EAAK,MAAM;AACb,UAAM6D,IAASyO;AAAAA,MACbK;AAAA,MACA5C;AAAA,MACA/P,EAAK,KAAK;AAAA,MACVA,EAAK,KAAK,OAAO,CAAC;AAAA,IAAA;AAEpB,WAAO6D,IAAU+O,IAAa/O,EAAO,CAAC,IAAIA,EAAO,CAAC,IAAK;AAAA,EAAA;AACzD,WAAW7D,EAAK,QACPsS;AAAAA,MACLK;AAAA,MACA5C;AAAA,MACA/P,EAAK,MAAM,OAAO;AAAA,MAClBA,EAAK,MAAM,OAAO;AAAA,MAClB2G,EAAS,WAAW3G,EAAK,MAAM,MAAM;AAAA,IAAA,IAGhC+L;AAAAA,MACL6G,IAAa5S,EAAK,KAAK,SAASA,EAAK,KAAK;AAAA,MAC1C4S,IAAa5S,EAAK,KAAK,SAASA,EAAK,KAAK;AAAA,MAC1C2S;AAAA,MACA5C;AAAA,IAAA;AAGN;AAEA,SAASJ,GAAa3P,GAAkBkS,GAAoB7P,GAA4B;AACtF,MAAIwQ,IAAWxQ,EAAM,QACjBtB,IAASf,EAAK,KAAK,QACnB7D,IAAS6D,EAAK,KAAK,QACnBmS,IAAQ9P,EAAM;AAClB,QAAMyQ,IAAOzQ,EAAM;AACnB,EAAIyQ,IACFD,IAAWxQ,EAAM,WACP6P,MACCW,IAAAE,GAAsBF,CAAQ,GACzC9R,IAASf,EAAK,KAAK,QACnB7D,IAAS6D,EAAK,KAAK,QACfmS,MACFA,IAAQa,GAAA9T,GAAA,IAAKiT,IAAL,EAAY,OAAO,CAACA,EAAM;AAGhC,QAAAnL,IAAOD,EAAW,iBAAiB8L,CAAQ;AAU1C,SATkB;AAAA,IACvB,QAAQ7S,EAAK;AAAA,IACb,QAAAe;AAAA,IACA,QAAA5E;AAAA,IACA,MAAA6K;AAAA,IACA,WAAAkL;AAAA,IACA,OAAAC;AAAA,IACA,MAAAW;AAAA,EAAA;AAGJ;AAEA,SAASL,GAAU/T,GAAiB;AAC1B,UAAAA,EAAI,OAAO,IAAIA,EAAI,OAAO,MAAMA,EAAI,OAAO,IAAIA,EAAI,OAAO;AACpE;AAEA,SAAS4S,GACPnU,GACA6C,GACA+P,GAC2B;AAC3B,QAAM,EAAE,QAAApH,GAAQ,QAAAD,MAAWjN,EAAQuE,EAAK,MAAM,wBAAwB,GAChE,CAACiT,GAAIC,CAAE,IAAIvK,GACXwK,IAAOb,GAAoCnV,GAAS4S,GAAYrH,GAAQC,EAAO,CAAC,CAAC;AACvF,MAAI,CAACyK,GAAMC,CAAI,IAAIF,IAAOA,EAAK,QAAA,IAAY,CAACnT,EAAK,KAAK,QAAQA,EAAK,KAAK,MAAM;AACxE,QAAAsT,IAAc5C,GAAW1Q,CAAI;AACnC,EAAKsT,MACH,CAACF,GAAMC,CAAI,IAAI,CAACA,GAAMD,CAAI;AAE5B,QAAM7L,IAAK6L,GACL5L,IAAK6L,GAELE,IAAK5M,EAAS,WAAWY,CAAE,EAAE,SAASmB,CAAM,EAAE;AAGhD,MAAA8K,KAFO7M,EAAS,WAAWa,CAAE,EAAE,SAASkB,CAAM,EAAE,gBAChC,MAAM6K,KAAM,OACR;AACb,SAAAC,IAAAF,IAAcE,IAAW,CAACA,GAI9B,CAACjM,GAAIC,GAAI,KAAKyL,CAAE,IAAIC,CAAE,MAHlBM,IAAW,IAAI,CAGW,IAF1BF,IAAc,IAAI,CAEc,IAAI9L,EAAG,CAAC,IAAIA,EAAG,CAAC,EAAE;AAC/D;AAEA,SAASkJ,GAAW1Q,GAAgB;AAClC,SAAIA,EAAK,OACAA,EAAK,YAAYA,EAAK,KAAK,cAAc,CAACA,EAAK,KAAK,cAEpD;AAEX;ACrhBO,SAASyT,GAKdC,GACAhT,GACAiT,GACAC,GACAC,GACAC,GACAC,GAIA;AAEM,QAAAC,IAAyCxY,GAAS,CAAA,CAAE;AAG1D,EAAA8D;AAAA,IACE,MAAM,IAAI,IAAI,OAAO,KAAKoU,EAAQ,KAAK,CAAC;AAAA,IACxC,CAACO,GAAO7D,MAAS;AACf,MAAKA,MAAaA,IAAA,oBAAI,IAAI,CAAA,CAAE;AAC5B,iBAAW3R,KAAMwV;AACX,QAAA7D,EAAK,IAAI3R,CAAE,KAEfyV,GAAeR,GAASM,GAAQvV,GAAI,IAAOiC,GAAQmT,CAAW;AAIhE,iBAAWpV,KAAM2R;AACX,QAAA6D,EAAM,IAAIxV,CAAE,MAEhBkV,EAAS,OAAOlV,CAAE,GAClBmV,EAAQ,OAAOnV,CAAE,GACAqV,KAAA,QAAAA,EAAArV,GAAIuV,EAAOvV,CAAE,IAC9B,OAAOuV,EAAOvV,CAAE;AAAA,IAEpB;AAAA,IACA,EAAE,WAAW,GAAK;AAAA,EAAA,GAKpBa;AAAA,IACE,MAAM,CAAC,GAAGqU,CAAQ;AAAA,IAClB,CAACD,GAAStD,MAAS;AACX,YAAA+D,IAAS/D,IAAOsD,EAAQ,OAAO,CAAA3V,MAAK,CAACqS,EAAK,SAASrS,CAAC,CAAC,IAAI2V,GACzDU,IAAUhE,IAAOA,EAAK,OAAO,CAAArS,MAAK,CAAC2V,EAAQ,SAAS3V,CAAC,CAAC,IAAI,CAAA;AAChE,MAAAoW,EAAO,QAAQ,CAAM1V,MAAA;AACb,cAAA4D,IAAQ2R,EAAOvV,CAAE;AACnB,QAAA4D,KAAS,CAACA,EAAM,aAAUA,EAAM,WAAW;AAAA,MAAA,CAChD,GACD+R,EAAQ,QAAQ,CAAM3V,MAAA;AACd,cAAA4D,IAAQ2R,EAAOvV,CAAE;AACvB,QAAI4D,KAASA,EAAM,aAAUA,EAAM,WAAW;AAAA,MAAA,CAC/C;AAAA,IACH;AAAA,IACA,EAAE,WAAW,GAAK;AAAA;AAAA,EAAA,GAIpB/C;AAAA,IACE,MAAM,CAAC,GAAGsU,CAAO;AAAA,IACjB,CAACxV,GAAOgS,MAAS;AACT,YAAA+D,IAAS/V,EAAM,OAAO,CAAAL,MAAK,CAACqS,EAAK,SAASrS,CAAC,CAAC,GAC5CqW,IAAUhE,EAAK,OAAO,CAAArS,MAAK,CAACK,EAAM,SAASL,CAAC,CAAC;AACnD,MAAAoW,EAAO,QAAQ,CAAM1V,MAAA;AACb,cAAA4D,IAAQ2R,EAAOvV,CAAE;AACnB,QAAA4D,KAAS,CAACA,EAAM,YAASA,EAAM,UAAU;AAAA,MAAA,CAC9C,GACD+R,EAAQ,QAAQ,CAAM3V,MAAA;AACd,cAAA4D,IAAQ2R,EAAOvV,CAAE;AACvB,QAAI4D,KAASA,EAAM,YAASA,EAAM,UAAU;AAAA,MAAA,CAC7C;AAAA,IACH;AAAA,EAAA;AAKI,QAAAgS,IAAeC,EAAS,MAAM;AAClC,UAAMlU,IAAY2T,IAAmBA,EAAA,IAAsB,OAAO,OAAOC,CAAM;AAC3E,WAAAtT,EAAO,OAAO,UACT6T,GAAiBnU,GAAMM,EAAO,QAAQkT,GAASD,CAAQ,IAEvDvT;AAAA,EACT,CACD;AAEM,SAAA,EAAE,QAAA4T,GAAQ,cAAAK;AACnB;AAEA,SAASH,GACPR,GACAM,GACAvV,GACAkV,GACAjT,GACAmT,GACA;AACA,QAAMW,IAAgC;AAAA,IACpC,IAAA/V;AAAA,IACA,UAAAkV;AAAA,IACA,SAAS;AAAA,IACT,YAAYW,EAAS,MACdZ,EAAQ,MAAMjV,CAAE,IACdvC,EAAO,MAAMwE,EAAO,YAAYgT,EAAQ,MAAMjV,CAAE,CAAC,IADzBgW,EAAMD,EAAY,UAAU,CAE5D;AAAA,IACD,QAAQF,EAAS,MACVZ,EAAQ,MAAMjV,CAAE,IACdvC,EAAO,MAAMwE,EAAO,OAAO,QAAQgT,EAAQ,MAAMjV,CAAE,CAAC,IAD5BgW,EAAMD,EAAY,MAAM,CAExD;AAAA,EAAA;AAEH,EAAAR,EAAOvV,CAAE,IAAI+V,GACbX;AAAA,IAAYH;AAAA,IAASjV;AAAA,IAAIuV,EAAOvV,CAAE;AAAA;AAAA,EAAA;AACpC;AAEA,SAAS8V,GACPP,GACAU,GACAd,GACAD,GACA;AACI,SAAAe,EAAO,uBAAuBA,EAAO,yBAChCV,EAAO,KAAK,CAAC1T,GAAGC,MAAM;AAC3B,UAAMoU,IAASf,EAAQ,IAAItT,EAAE,EAAE,GACzBsU,IAAShB,EAAQ,IAAIrT,EAAE,EAAE;AAC/B,QAAIoU,KAAUC;AACZ,aAAOD,IAAS,IAAI;AAEtB,UAAME,IAAYlB,EAAS,IAAIrT,EAAE,EAAE,GAC7BwU,IAAYnB,EAAS,IAAIpT,EAAE,EAAE;AACnC,WAAIsU,KAAaC,IACRD,IAAY,IAAI,KAElBvU,EAAE,SAASC,EAAE;AAAA,EAAA,CACrB,IACQmU,EAAO,sBACTV,EAAO,KAAK,CAAC1T,GAAGC,MAAM;AAC3B,UAAMoU,IAASf,EAAQ,IAAItT,EAAE,EAAE,GACzBsU,IAAShB,EAAQ,IAAIrT,EAAE,EAAE;AAC/B,WAAIoU,KAAUC,IACLD,IAAS,IAAI,KAEfrU,EAAE,SAASC,EAAE;AAAA,EAAA,CACrB,IACQmU,EAAO,yBACTV,EAAO,KAAK,CAAC1T,GAAGC,MAAM;AAC3B,UAAMsU,IAAYlB,EAAS,IAAIrT,EAAE,EAAE,GAC7BwU,IAAYnB,EAAS,IAAIpT,EAAE,EAAE;AACnC,WAAIsU,KAAaC,IACRD,IAAY,IAAI,KAElBvU,EAAE,SAASC,EAAE;AAAA,EAAA,CACrB,IAEMyT,EAAO,KAAK,CAAC1T,GAAGC,MACdD,EAAE,SAASC,EAAE,MACrB;AAEL;ACpLO,SAASwU,GAAehU,GAAwB;AACjD,SAAA,OAAO,SAAS,SACX,OAAO,KAAKA,CAAM,EAAE,SAAS,QAAQ,EAAE,WAAW,KAAK,EAAE,IAEzD,KAAKA,CAAM,EAAE,WAAW,KAAK,EAAE;AAE1C;ACSO,SAASiU,KAA+B;AAGtC,SAAA,EAAE,SAFmCxZ,GAAS,CAAA,CAAE,GAErC,gBAD6B,CAAA;AAEjD;AAEO,SAASyZ,GAAUC,GAA0B;AAC5C,QAAA,EAAE,SAAAC,GAAS,gBAAAC,EAAmB,IAAAF;AAE3B,WAAAG,EAAUjU,GAAakU,GAAoB;;AAC5C,UAAAC,KAAIxV,IAAAqV,EAAehU,CAAG,MAAlB,OAAArB,IAAuB;AAClB,IAAAqV,EAAAhU,CAAG,IAAImU,IAAI,GACrBA,MACHJ,EAAQ/T,CAAG,IAAIkU;AAAA,EAEnB;AAEA,WAASE,EAAapU,GAAa;;AAC3B,UAAAmU,KAAIxV,IAAAqV,EAAehU,CAAG,MAAlB,OAAArB,IAAuB;AACjC,IAAIwV,MACEA,IAAI,MAAM,KACZ,OAAOJ,EAAQ/T,CAAG,GAClB,OAAOgU,EAAehU,CAAG,KAEVgU,EAAAhU,CAAG,IAAImU,IAAI;AAAA,EAGhC;AAEA,WAASE,EAAYhX,GAAwB;AAC3C,IAAIA,KACF+W,EAAa/W,CAAE;AAAA,EAEnB;AAEA,WAASiX,EACPJ,GACAK,GACAC,GACAC,GACAC,GACA;AACI,QAAAR,EAAO,SAAS,QAAQ;AAC1B,MAAAG,EAAYG,CAAU;AACf;AAAA,IACT;AAEI,QAAAN,EAAO,SAAS;AAClB,aAAAG,EAAYG,CAAU,GACfN,EAAO;AAGhB,UAAMS,IAAaC,GAAaV,GAAQK,GAAUE,CAAW,GACvDpX,IAAKwX,GAASF,GAAYD,CAAU;AAC1C,WAAIrX,MAAOmX,MAGXH,EAAYG,CAAU,GACtBP,EAAU5W,GAAIsX,CAAU,IACjBtX;AAAA,EACT;AAEO,SAAA;AAAA,IACL,YAAAiX;AAAA,IACA,aAAAD;AAAA,EAAA;AAEJ;AAEA,SAASO,GAAaV,GAAqBK,GAAmBE,GAAqB;;AAC1E,SAAA7C,GAAA9T,GAAA,IACFoW,IADE;AAAA,IAEL,QAAOvV,IAAAuV,EAAO,UAAP,OAAAvV,IAAgB8V;AAAA,IACvB,UAAAF;AAAA,EAAA;AAEJ;AAEA,SAASM,GAASV,GAAeO,GAAoB;AAI7C,QAAA1L,IAAI2K,GAAeQ,EAAE,KAAK,GAC1BtE,IAAIsE,EAAE,WAAW,MAAM,KACvBW,IAAIX,EAAE,UAAU,gBAAgB,QAAQ;AACvC,SAAA,UAAUO,CAAU,IAAIP,EAAE,IAAI,IAAIA,EAAE,KAAK,IAAIA,EAAE,MAAM,IAAIA,EAAE,MAAM,IAAIA,EAAE,MAAM,IAAInL,CAAC,IAAI6G,CAAC,IAAIiF,CAAC;AACrG;ACnCgB,SAAAC,GACdzC,GACAC,GACAC,GACA;AACO,SAAA;AAAA,IACL,SAAAF;AAAA,IACA,UAAAC;AAAA,IACA,SAAAC;AAAA,EAAA;AAEJ;AAMA,MAAMwC,KAAY,OAAO,QAAQ,GAE3BC,KAA2B;AAAA,EAC/B,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,OAAO;AACT;AAMO,SAASC,GACdlY,GACAgE,GACAmU,GACA5Z,GACA6Z,GACAC,GACAzZ,GACA;AACM,QAAA0Z,IAAuDlb,GAAS,CAAA,CAAE,GAOlEmb,IAAgBtb,GAAiD,CAAA,CAAE;AACzE,EAAAiH,GAAY,MAAM;AAChB,UAAMsU,IAAS,OAAO;AAAA,MACpB,OAAO,KAAKxY,EAAM,QAAQ,KAAK,EAAE,IAAI,CAAA/B,MAAK,CAACA,GAAG,CAA4B,CAAA,CAAC;AAAA,IAAA;AAEtE,WAAA,QAAQ+F,EAAM,QAAQ,KAAK,EAAE,QAAQ,CAAC,CAAC3D,GAAIuF,CAAC,MAAM;AACnD,MAAC4S,KAAA,QAAAA,EAAS5S,EAAE,YAAgB4S,EAAA5S,EAAE,MAAM,IAAI,KACvC4S,KAAA,QAAAA,EAAS5S,EAAE,YAAgB4S,EAAA5S,EAAE,MAAM,IAAI,KAC5C4S,EAAO5S,EAAE,MAAM,EAAEvF,CAAE,IAAIuF,EAAE,QACzB4S,EAAO5S,EAAE,MAAM,EAAEvF,CAAE,IAAIuF,EAAE;AAAA,IAAA,CAC1B,GACDjC,GAAiB4U,GAAeC,CAAM;AAAA,EAAA,CACvC;AAEK,QAAA;AAAA,IACJ,QAAQxH;AAAA,IACR,cAAcyH;AAAA;AAAA,EAAA,IACZpD;AAAA,IACFrV,EAAM;AAAA,IACNzB,EAAQ;AAAA,IACRyB,EAAM;AAAA,IACNA,EAAM;AAAA,IACN,CAACA,GAAOK,GAAIqY,MAAa;AACvB,MAAAC;AAAA,QACE3Y;AAAAA,QACAK;AAAA,QACAqY;AAAA,QACAna,EAAQ;AAAA,QACRga;AAAA,QACAH;AAAA,MAAA;AAAA,IAEJ;AAAA,IACA,CAACxX,GAAQgY,MAAW;AAClB,YAAMxY,IAAYgY,EAAQ;AAC1B,aAAOhY,EAAUQ,CAAM;AAAA,IACzB;AAAA,EAAA,GAWI8W,IAAalU,MAGbqV,IAAkBC,GAA8B9Y,EAAM,SAASgE,EAAM,SAASzF,CAAO,GAGrFwa,IAAcC,EAA2B,CAAA,CAAE,GAE3C;AAAA,IACJ,QAAQ9H;AAAA,IACR,cAAc+H;AAAA;AAAA,EAAA,IACZ5D;AAAA,IACFrR,EAAM;AAAA,IACNzF,EAAQ;AAAA,IACRyF,EAAM;AAAA,IACNA,EAAM;AAAA,IACN,CAACA,GAAO3D,GAAIqY,MAAa;AACvB,MAAAQ;AAAA,QACElV;AAAAA,QACA3D;AAAA,QACAqY;AAAA,QACAna,EAAQ;AAAA,QACR8Z;AAAA,QACArH;AAAA,QACA6H;AAAA,QACAT;AAAA,QACAxZ;AAAA,QACA8Y;AAAA,MAAA;AAAA,IAEJ;AAAA,IACA,CAACyB,GAASlV,MAAU;;AAClB,OAAAtC,IAAAsC,EAAM,oBAAN,QAAAtC,EAAA,KAAAsC;AAAA,IACF;AAAA,IACA,MAAM8U,EAAY;AAAA,EAAA;AAIpB,EAAA7U,GAAY,MAAM;AAChB,IAAA6U,EAAY,QAAQK,GAAkBP,EAAgB,YAAY3H,CAAU;AAAA,EAAA,CAC7E,GAEDhQ;AAAA,IACE2X,EAAgB;AAAA,IAChB,CAAKzF,MAAAiG,GAA2Bf,GAAsBO,GAAiBta,CAAO;AAAA,IAC9E,EAAE,WAAW,GAAK;AAAA,EAAA;AAOd,QAAA;AAAA,IACJ,QAAQ+a;AAAA,IACR,cAAcC;AAAA;AAAA,EAAA,IACZlE;AAAA,IACF8C,EAAM;AAAA,IACN5Z,EAAQ;AAAA,IACR4Z,EAAM;AAAA,IACNA,EAAM;AAAA,IACN,CAACA,GAAO9X,GAAIqY,MAAa;AACvB,YAAMzU,IAAQyU;AAER,MAAAzU,EAAA,YAAYiS,EAAS,MACpBiC,EAAM,MAAM9X,CAAE,IACZvC,EAAO,MAAMS,EAAQ,KAAK,WAAW4Z,EAAM,MAAM9X,CAAE,CAAC,IAD9B,EAE9B,GACK4D,EAAA,YAAYiS,EAAS,MACpBiC,EAAM,MAAM9X,CAAE,IACZvC,EAAO,MAAMS,EAAQ,KAAK,WAAW4Z,EAAM,MAAM9X,CAAE,CAAC,IAD9B,EAE9B,GAEK4D,EAAA,OAAOkU,EAAM,MAAM9X,CAAE,GAC3B4D,EAAM,QAAQuV,GAAcvV,EAAM,MAAMD,CAAK,GACvCC,EAAA,aAAaoP,GAA+BpP,EAAM,KAAK,GAE7DA,EAAM,kBAAkB/C;AAAA,QACtB,MAAMiX,EAAM,MAAM9X,CAAE,EAAE;AAAA,QACtB,MAAM;AACJ,UAAA4D,EAAM,QAAQuV,GAAcvV,EAAM,MAAMD,CAAK,GACvCC,EAAA,aAAaoP,GAA+BpP,EAAM,KAAK;AAAA,QAC/D;AAAA,MAAA;AAAA,IAEJ;AAAA,IACA,CAACmP,GAAGnP,MAAU;;AACZ,OAAAtC,IAAAsC,EAAM,oBAAN,QAAAtC,EAAA,KAAAsC;AAAA,IACF;AAAA,EAAA,GAGI2R,IAAiB;AAAA,IACrB,YAAA5E;AAAA,IACA,YAAAE;AAAA,IACA,iBAAA2H;AAAA,IACA,sBAAAP;AAAA,IACA,YAAAgB;AAAA,IACA,SAAAlB;AAAA,IACA,kBAAAK;AAAA,IACA,kBAAAQ;AAAA,IACA,kBAAAM;AAAA,EAAA;AAEF,SAAA5b,GAAQqa,IAAWpC,CAAM,GAClBA;AACT;AAEO,SAAS6D,GAAkBC,GAAgE;AAChG,SAAOA,EAAK;AACd;AAEO,SAASC,KAAY;AAC1B,SAAOtc,EAAQQ,GAAOma,EAAS,GAAG,QAAQ;AAC5C;AAMA,SAAS4B,GAAalb,GAAY6W,GAAmBC,GAAkBlT,GAAoB;AACrF,SAAAkT,KAAWlT,EAAO,QACbxE,EAAO,OAAOwE,EAAO,OAAO5D,CAAI,IAEhCmb,GAAmBnb,GAAM6W,GAAUjT,CAAM;AAEpD;AAEA,SAASuX,GAAmBnb,GAAY6W,GAAmBjT,GAAoB;AAEzE,SAAAiT,KAAYjT,EAAO,WACdxE,EAAO,OAAOwE,EAAO,UAAU5D,CAAI,IAEnCZ,EAAO,OAAOwE,EAAO,QAAQ5D,CAAI;AAE5C;AAEA,SAASia,GACP3Y,GACAK,GACA4D,GACA3B,GACAwX,GACA1B,GACA;AACM,EAAAnU,EAAA,QAAQiS,EAAS,MAChBlW,EAAM,MAAMK,CAAE,IACZuZ,GAAa5Z,EAAM,MAAMK,CAAE,GAAG4D,EAAM,UAAUA,EAAM,SAAS3B,CAAM,IAD7C+T,EAAMpS,EAAM,KAAK,CAE/C,GAEKA,EAAA,cAAciS,EAAS,MACtBlW,EAAM,MAAMK,CAAE,IACZwZ,GAAmB7Z,EAAM,MAAMK,CAAE,GAAG4D,EAAM,UAAU3B,CAAM,IADpC+T,EAAMpS,EAAM,WAAW,CAErD,GAEKA,EAAA,QAAQiS,EAAS,MAChBlW,EAAM,MAAMK,CAAE,IACZvC,EAAO,OAAOwE,EAAO,OAAOtC,EAAM,MAAMK,CAAE,CAAC,IADrBgW,EAAMpS,EAAM,KAAK,CAE/C,GAEKA,EAAA,YAAYiS,EAAS,MAAM;;AAC3B,WAAA5T,EAAO,MAAM,gBAAgB,WACxB+T,EAAMpS,EAAM,KAAK,EAAE,OAErBjE,EAAM,MAAMK,CAAE,KACZ6F,KAAAvE,IAAA3B,EAAM,MAAMK,CAAE,MAAd,gBAAAsB,EAAkB0U,EAAMpS,EAAM,KAAK,EAAE,UAArC,OAAAiC,IAA8C,KADxBmQ,EAAMpS,EAAM,SAAS;AAAA,EAEpD,CACD,GAEKA,EAAA,YAAYiS,EAAS,MACpBlW,EAAM,MAAMK,CAAE,IACZvC,EAAO,MAAMwE,EAAO,WAAWtC,EAAM,MAAMK,CAAE,CAAC,IADxBgW,EAAMpS,EAAM,SAAS,CAEnD,GAEKA,EAAA,kBAAkB1C,GAAMuY,GAAiBzZ,CAAE,GAE3C4D,EAAA,gBAAgBiS,EAAuC,MACpD,OAAO,QAAQjS,EAAM,eAAe,EAAE;AAAA,IAC3C,CAACjE,GAAO+Z,MAAU;AACV,YAAA,CAAC1U,GAAQzE,CAAM,IAAImZ,GACnBzZ,IAAM8X,EAAQ,MAAMxX,CAAM;AAC5B,aAAAN,MAAKN,EAAMqF,CAAM,IAAI,EAAE,QAAAzE,GAAQ,KAAKE,GAAA,IAAKR,OACtCN;AAAAA,IACT;AAAA,IACA,CAAC;AAAA,EAAA,CAEJ;AACH;AAEA,SAASga,GAAcpY,GAAY2T,GAAmBC,GAAkBlT,GAAoB;AAC1F,SAAIiT,IACKzX,EAAO,OAAOwE,EAAO,UAAUV,CAAI,IACjC4T,KAAWlT,EAAO,QACpBxE,EAAO,OAAOwE,EAAO,OAAOV,CAAI,IAEhC9D,EAAO,OAAOwE,EAAO,QAAQV,CAAI;AAE5C;AAEA,SAASqY,GAAa/C,GAAkC;AAClD,SAAAA,EAAO,SAAS,SACXe,KAEAf;AAEX;AAEA,SAASgC,GACPlV,GACA3D,GACA4D,GACA3B,GACA+V,GACArH,GACA6H,GACAT,GACAxZ,GACA8Y,GACA;AACA,QAAM,EAAE,YAAAJ,GAAY,aAAAD,EAAY,IAAIR,GAAUwB,CAAU;AAExD,SAAO,OAAOpU,GAAO;AAAA,IACnB,QAAQ,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG,KAAK,IAAI,EAAE,GAAG,GAAG,GAAG,IAAI;AAAA,IACjD,eAAe,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG,KAAK,IAAI,EAAE,GAAG,GAAG,GAAG,IAAI;AAAA,IACxD,UAAU,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG,KAAK,IAAI,EAAE,GAAG,GAAG,GAAG,IAAI;AAAA,EAAA,CACpD,GAEKA,EAAA,QAAQiS,EAAS,MAChBlS,EAAM,MAAM3D,CAAE,IACZvC,EAAO,OAAOwE,EAAO,OAAO0B,EAAM,MAAM3D,CAAE,CAAC,IADrBgW,EAAMpS,EAAM,KAAK,CAE/C;AAEK,QAAA2E,IAAOsN,EAAyB,MAAM;AACpC,UAAAtU,IAAOoC,EAAM,MAAM3D,CAAE,GACrB6Z,IAASF,GAAcpY,GAAMqC,EAAM,UAAUA,EAAM,SAAS3B,CAAM;AAExE,IAAI,MAAM,CAAC4X,EAAO,KAAK,MACb,QAAA;AAAA,MACN;AAAA,MACA7Z;AAAA,MACA6Z,EAAO;AAAA,IAAA,GAETA,EAAO,QAAQ,KAEbA,EAAO,UAAU,UAAaA,EAAO,UAAU,UACzC,QAAA;AAAA,MACN;AAAA,MACA7Z;AAAA,MACA6Z,EAAO;AAAA,IAAA,GAETA,EAAO,QAAQ;AAEjB,QAAIC,IAAcrc,EAAO,MAAMwE,EAAO,OAAO,OAAOV,CAAI;AACpD,IAAA,MAAM,CAACuY,CAAW,MACNA,IAAA;AAEV,UAAAxX,IAASsX,GAAanc,EAAO,OAAOwE,EAAO,OAAO,QAAQ,CAACV,GAAMsY,CAAM,CAAC,CAAC,GACzEnc,IAASkc,GAAanc,EAAO,OAAOwE,EAAO,OAAO,QAAQ,CAACV,GAAMsY,CAAM,CAAC,CAAC;AAC/E,WAAO,EAAE,QAAAA,GAAQ,aAAAC,GAAa,QAAAxX,GAAQ,QAAA5E,EAAO;AAAA,EAAA,CAC9C;AACD,EAAAkG,EAAM,OAAO2E;AACb,QAAMwR,IAA8D7Y;AAAA,IAClEsX,EAAgB;AAAA,IAChBxY;AAAA,EAAA,GAEIga,IAA0C9Y,GAAMsX,EAAgB,iBAAiBxY,CAAE,GAEnFia,IAAiBpW,GAAY,MAAM;;AACjC,UAAAtC,IAAOoC,EAAM,MAAM3D,CAAE;AAC3B,QAAI,CAACuB;AAAM;AAEX,UAAM2Y,KAAc5Y,IAAAqP,EAAWpP,EAAK,MAAM,MAAtB,gBAAAD,EAAyB,aACvC6Y,KAActU,IAAA8K,EAAWpP,EAAK,MAAM,MAAtB,gBAAAsE,EAAyB;AACzC,QAAA,CAACqU,KAAe,CAACC;AACnB;AAGI,UAAA7X,KAASuC,KAAAkT,EAAQ,MAAMxW,KAAA,gBAAAA,EAAM,MAAM,MAA1B,OAAAsD,KAA+B,EAAE,GAAG,GAAG,GAAG,EAAE,GACrDnH,KAASoI,KAAAiS,EAAQ,MAAMxW,KAAA,gBAAAA,EAAM,MAAM,MAA1B,OAAAuE,KAA+B,EAAE,GAAG,GAAG,GAAG,EAAE,GAGrDsU,IAAkBC;AAAAA,MACtBN,EAAgB;AAAA,OAChBnV,KAAAoV,EAAiB,UAAjB,OAAApV,KAA0B;AAAA,MAC1BtC;AAAA,MACA5E;AAAA,MACAa,EAAM;AAAA,MACN0D,EAAO;AAAA,IAAA,GAGH,CAACqY,GAAmBC,CAAiB,IACzCC,GAAkDlY,GAAQ5E,GAAQwc,GAAaC,CAAW,GAEtF9a,IAAId,EAAM;AAGhB,IAAAqF,EAAM,gBAAgB6W;AAAAA,MACpBL;AAAA,MACAE,IAAoBjb;AAAA,MACpBkb,IAAoBlb;AAAA,IAAA;AAItB,QAAI6J,IAAe,GACfC,IAAe;AACnB,UAAMuR,IAAInS,EAAK;AACX,QAAAmS,EAAE,OAAO,SAAS,QAAQ;AAC5B,YAAM7D,KAAS6D,EAAE;AACF,MAAAxR,IAAA2N,GAAO,SAASA,GAAO,OAClCA,GAAO,UAAU,kBACnB3N,KAAgBwR,EAAE;AAAA,IAEtB;AACI,QAAAA,EAAE,OAAO,SAAS,QAAQ;AAC5B,YAAM7D,KAAS6D,EAAE;AACF,MAAAvR,IAAA0N,GAAO,SAASA,GAAO,OAClCA,GAAO,UAAU,kBACnB1N,KAAgBuR,EAAE;AAAA,IAEtB;AAEA,IAAIzY,EAAO,WACTiH,KAAgBjH,EAAO,QACvBkH,KAAgBlH,EAAO;AAGnB,UAAA0Y,IACJ,CAAC,CAAC1Y,EAAO,UAAUyY,EAAE,OAAO,SAAS,UAAUA,EAAE,OAAO,SAAS;AAG/D,QAAAnZ,EAAK,WAAWA,EAAK,QAAQ;AAC/B,MAAAqC,EAAM,SAASgX,GAAyBtY,GAAQ5E,CAAM;AAEtD,YAAMmd,KAAgBpd,EAAO,OAAOwE,EAAO,UAAUV,CAAI,GACnD,CAAC6S,IAAUxB,EAAG,IAAIkI;AAAA,QACtBxY;AAAA,QACA4X;AAAA,QACAW;AAAA,QACAF;AAAA,QACAzR;AAAA,QACAC;AAAA,SACAnD,MAAAD,KAAAgU,EAAgB,UAAhB,gBAAAhU,GAAuB,iBAAvB,OAAAC,KAAuC;AAAA,QACvC3G;AAAA,MAAA;AAEF,MAAAuE,EAAM,WAAWwQ,IACjBxQ,EAAM,OAAOgP,IACbhP,EAAM,QAAQ;AACd;AAAA,IAAA;AAEA,MAAAA,EAAM,OAAO;AAUX,QAPA+W,MACczR,KAAAoR,GACAnR,KAAAoR,IAILtY,EAAO,SACP,cAAc+X,EAAiB;AAC1C,MAAApW,EAAM,SAASwW,GACfxW,EAAM,QAAQ,QACVsF,MAAiB,KAAKC,MAAiB,IACzCvF,EAAM,WAAWA,EAAM,SAEjBA,EAAA,WAAW6W,GAAsB7W,EAAM,QAAQsF,IAAe7J,GAAG8J,IAAe9J,CAAC;AAAA,SAEpF;AAEL,MAAAuE,EAAM,SAASgX,GAAyBtY,GAAQ5E,CAAM;AAEhD,YAAAqd,KAAQhB,EAAgB,QAC1BA,EAAgB,MAAM,aAAa,IAAIA,EAAgB,MAAM,eAC7D,GAEE,CAAC3F,IAAUV,EAAK,IAAIsH;AAAA,QACxBpX,EAAM;AAAA,QACNwW;AAAA,QACAW;AAAA,QACA7R,IAAe7J;AAAA,QACf8J,IAAe9J;AAAA,MAAA;AAEjB,MAAAuE,EAAM,WAAWwQ,IACjBxQ,EAAM,QAAQ8P;AAAA,IAChB;AAAA,EAAA,CACD,GAEKuH,IAAyBpX,GAAY,MAAM;AAC3C,IAACF,EAAM,MAAM3D,CAAE,MACnB4D,EAAM,iBAAiBqT;AAAA,MACrB1O,EAAK,MAAM;AAAA,MACX;AAAA,MACA3E,EAAM;AAAA,MACN2E,EAAK,MAAM,OAAO;AAAA,MAClB8O;AAAA,IAAA,GAEFzT,EAAM,iBAAiBqT;AAAA,MACrB1O,EAAK,MAAM;AAAA,MACX;AAAA,MACA3E,EAAM;AAAA,MACN2E,EAAK,MAAM,OAAO;AAAA,MAClB8O;AAAA,IAAA;AAAA,EACF,CACD;AAED,EAAAzT,EAAM,kBAAkB,MAAM;AACb,IAAAqW,KACQgB,KACvBjE,EAAYpT,EAAM,cAAc,GAChCoT,EAAYpT,EAAM,cAAc;AAAA,EAAA;AAEpC;AAEA,SAASmV,GACPhV,GACA8M,GACA;AACO,SAAA,OAAO,QAAQ9M,CAAU,EAC7B,IAAI,CAAC,CAACpB,GAAKuY,CAAK,MAAM;;AACrB,WAAIA,EAAM,YAC6B;AAAA,MACnC,KAAI5Z,IAAA,OAAO,KAAK4Z,EAAM,KAAK,EAAE,CAAC,MAA1B,OAAA5Z,IAA+BqB;AAAA,MACnC,YAAY;AAAA,MACZ,KAAAA;AAAA,MACA,OAAAuY;AAAA,MACA,QAAQ,OAAO,KAAKA,EAAM,KAAK,EAC5B,IAAI,CAAMlb,MAAA;;AAAA,gBAAA6F,KAAAvE,IAAAuP,EAAW7Q,CAAE,MAAb,gBAAAsB,EAAgB,WAAhB,OAAAuE,IAA0B;AAAA,OAAC,EACrC,OAAO,CAAC,GAAGsV,MAAM,KAAK,IAAI,GAAGA,CAAC,CAAC;AAAA,IAAA,IAG7B,OAAO,QAAQD,EAAM,KAAK,EAAE;AAAA,MACjC,CAAC,CAAClb,GAAIuB,CAAI,MACkB;;AAAA;AAAA,UACxB,IAAAvB;AAAA,UACA,YAAY;AAAA,UACZ,KAAKA;AAAA,UACL,MAAAuB;AAAA,UACA,SAAQsE,KAAAvE,IAAAuP,EAAW7Q,CAAE,MAAb,gBAAAsB,EAAgB,WAAhB,OAAAuE,IAA0B;AAAA,QAAA;AAAA;AAAA,IACpC;AAAA,EAEN,CACD,EACA,KAAK;AACV;AAEA,SAASmV,GACPI,GACAhB,GACAW,GACA7R,GACAC,GAC6C;AAIvC,QAAAkS,IAAS/S,EAAW,iBAAiB8S,CAAc,GACnDE,IAAUhT,EAAW,iBAAiB8R,CAAe,GACrDmB,IAAgBC,GAAkCpB,CAAe,GAGjE,CAACnQ,GAAQC,CAAM,IAAIuR;AAAAA,IACvBJ,EAAO;AAAA,IACPA,EAAO;AAAA,IACPE;AAAA,EAAA;AAGE,MAAAnH,GACAV;AAEJ,MAAIxJ,MAAW;AACN,WAAA,CAACkR,GAAgB1H,CAAK;AAC/B,MAAWqH,MAAU;AAEf,WAAA7R,MAAiB,KAAKC,MAAiB,IAC9BiL,IAAAgH,IAEXhH,IAAWqG,GAAsBW,GAAgBlS,GAAcC,CAAY,GAEtE,CAACiL,GAAUV,CAAK;AAIzB,QAAMgI,IAAcpT,EAAW,YAAY2B,GAAQsR,CAAa,GAG1D1M,IAAS8M;AAAAA,IACbrT,EAAW,YAAY2B,GAAQoR,EAAO,MAAM;AAAA,IAC5CK;AAAA,EAAA;AAGE,MAAAxS,MAAiB,KAAKC,MAAiB;AAC9B,IAAAiL,IAAAgH;AAAA,OACN;AAGL,QAAIQ,IAAgB1S,IAAegB,GAC/B2R,IAAgB1S,IAAee;AAGnC,IAAI2E,IAAS,MACM+M,KAAA,IACAC,KAAA,KAEnBzH,IAAWwG;AAAAA,MACThH,GAAwByH,EAAO,QAAQpR,GAAQ2R,CAAa;AAAA,MAC5DhI,GAAwByH,EAAO,QAAQpR,GAAQ,CAAC4R,CAAa;AAAA,IAAA;AAK/D,QAAIvM,IAASqM;AAAAA,MACXrT,EAAW,YAAY2B,GAAQoR,EAAO,MAAM;AAAA,MAC5C/S,EAAW,YAAY2B,GAAQoR,EAAO,MAAM;AAAA,IAAA,GAE1CvL,IAAS6L;AAAAA,MACXrT,EAAW,cAAc2B,GAAQmK,EAAS,EAAE;AAAA,MAC5C9L,EAAW,cAAc2B,GAAQmK,EAAS,EAAE;AAAA,IAAA;AAQ1C,QANAvF,IAASS,IAAS,MACXA,IAAAwM,GAAuBxM,CAAM,GAClCT,IAASiB,IAAS,MACXA,IAAAgM,GAAuBhM,CAAM,KAGtCR,IAASQ,IAAS,GAAG;AAEjB,YAAAnE,IAAI4P,EAAc,MAAA,EAAQ,IAAID,EAAQ,EAAE,UAAU,EAAE,eAAe,GAAG,CAAC;AAClE,aAAAlH,IAAAwG,GAAyBW,GAAe5P,CAAC,GAC7C,CAACyI,GAAUV,CAAK;AAAA,IACzB;AAAA,EACF;AAGA,QAAM,CAAC5K,GAAIC,CAAE,IAAIgT,GAAoC3H,CAAQ,GACvDtF,IAAU6D,GACoB7J,GAAImB,GAAQlB,GAAI8F,CAAM,EACvD,IAAI,CAAA,MAAK,EAAE,SAAU,CAAA;AAEhB,SAAA6E,IAAA;AAAA,IACN,QAAQ6H;AAAA,IACR,OAAO1M;AAAA,IACP,QAAQ,EAAE,QAAA5E,GAAQ,QAAAC,EAAO;AAAA,IACzB,SAAA4E;AAAA,EAAA,GAEK,CAACsF,GAAUV,CAAK;AACzB;AAEA,SAASoH,GACPpc,GACAsd,GACAnB,GACAF,GACAzR,GACAC,GACAlE,GACA1G,GAC+B;AAC/B,QAAMc,IAAId,GAGJ2L,KAAU2Q,EAAc,SAAS5V,IAAe,KAAK5F,GACrDmT,IAAIqI,EAAc,SAASxb,IAAI6K,GAC/BlC,KAAO6S,EAAc,QAAQ,OAAO,KAAK,KAAK,MAC9C5Q,IAAS/B,EAAS,WAAW;AAAA,IACjC,GAAGxJ,EAAQ,IAAI8T,IAAI,KAAK,IAAIxK,CAAG;AAAA,IAC/B,GAAGtJ,EAAQ,IAAI8T,IAAI,KAAK,IAAIxK,CAAG;AAAA,EAAA,CAChC,GAEK6M,IAAcgG,EAAc;AAElC,MAAI/R,GAAyBC;AAC7B,MAAI4R,GAAmB;AACrB,UAAMsB,IAAapI;AAAAA,MACjB5J;AAAA,MACAC;AAAA,MACAhC,EAAS,WAAWxJ,CAAO;AAAA,MAC3B6S,GAAwByK,CAAS,IAAI3c;AAAA,IAAA;AAEvC,QAAI4c,GAAY;AACb,OAAAnT,GAAIC,CAAE,IAAIkT;AACX,UAAIxI,IAAY;AAKZ,UAJCoB,MACH,CAAC/L,GAAIC,CAAE,IAAI,CAACA,GAAID,CAAE,GACN2K,IAAA,KAEVvK,MAAiB,KAAKC,MAAiB,GAAG;AACtC,cAAAyS,IAAkB1S,IAAe7J,IAAK6K,IAAUuJ,GAChDoI,IAAkB1S,IAAe9J,IAAK6K,IAAUuJ;AACtD,QAAA3K,IAAK8K,GAAwB9K,GAAImB,GAAQ2R,CAAa,GACtD7S,IAAK6K,GAAwB7K,GAAIkB,GAAQ,CAAC4R,CAAa;AAAA,MACzD;AAAA,IACF;AAAA,EACF;AACI,MAAA/S,MAAO,UAAaC,MAAO,QAAW;AAClC,UAAAmT,IAAahU,EAAS,WAAWxJ,CAAO,EAC3C,SAASuL,CAAM,EACf,UAAA,EACA,eAAeC,CAAM;AACpBlC,QAAAA,IAAM,KAAK,KAAK,KAAK;AACzB,IAAK6M,MAAa7M,KAAO,KACpBc,IAAAmB,EAAO,QAAQ,IAAIkS,GAAWD,GAAYlU,CAAG,CAAC,GAC9Ce,IAAAkB,EAAO,QAAQ,IAAIkS,GAAWD,GAAY,CAAClU,CAAG,CAAC;AAAA,EACtD;AACM,QAAA8M,IAAK5M,EAAS,WAAWY,CAAE,EAAE,SAASmB,CAAM,EAAE,eAI9CmS,KAHKlU,EAAS,WAAWa,CAAE,EAAE,SAASkB,CAAM,EAAE,gBAChC,MAAM6K,KAAM,OAEJ;AACrB,SAAA;AAAA,IACL,EAAE,IAAAhM,GAAI,IAAAC,EAAG;AAAA,IACT;AAAA,MACE,QAAAkB;AAAA,MACA,QAAQ,CAACC,GAAQA,CAAM;AAAA,MACvB,YAAY2K,IAAcuH,IAAa,CAACA;AAAA,MACxC,aAAAvH;AAAA,IACF;AAAA,EAAA;AAEJ;AAEA,SAASmE,GACPf,GACAO,GACAta,GACA;AACA,QAAMme,IAAS7D,EAAgB;AACxB,SAAA,QAAQ6D,CAAM,EAClB,OAAO,CAAC,CAACrc,GAAIkb,CAAK,MAAMA,EAAM,aAAa,EAAElb,KAAMiY,EAAqB,EACxE,QAAQ,CAAC,CAACjY,GAAIkb,CAAK,MAAM;AAClB,UAAAtX,IAAQ,EAAE,QAAQ,OAAiB;AACzC,IAAAA,EAAM,SAASiS;AAAA,MAAsB,MACnCpY,EAAO,OAAOS,EAAQ,KAAK,WAAW,QAAQgd,EAAM,KAAK;AAAA,IAAA,GAE3DjD,EAAqBjY,CAAE,IAAI4D;AAAA,EAAA,CAC5B,GACH,OAAO,KAAKqU,CAAoB,EAAE,QAAQ,CAAMjY,MAAA;;AAC9C,KAAKsB,IAAAkX,EAAgB,WAAWxY,CAAE,MAA7B,QAAAsB,EAAgC,aACnC,OAAO2W,EAAqBjY,CAAE;AAAA,EAChC,CACD;AACH;AAEA,SAASmZ,GAAcpX,GAAY4B,GAA4B;AAC7D,SAAO5B,EAAK,MACT,IAAI,CAAWiD,OAAA,EAAE,QAAAA,GAAQ,MAAMrB,EAAM,QAAQ,MAAMqB,CAAM,EAAE,EAAE,EAC7D,OAAO,CAAAO,MAAKA,EAAE,IAAI;AACvB;AC9xBO,MAAM+W,GAAQ;AAAA,EACnB,OAAO,QAAc7X,GAAgB;AACnC,WAAO,MAAM,KAAKA,EAAI,OAAQ,CAAA;AAAA,EAChC;AACF;ACFA,MAAM8X,KAAiC,GACjCC,KAAiC,GAC1BC,KAAyB;AAsC/B,SAASC,GAAiCC,GAAsB;AAC9D,SAAAA,MAAS,UAAUH,KAAiCD;AAC7D;AAEO,SAASK,GACdC,GACAC,GACA9c,GACAoB,GACsC;AAElC,MAAA2b,IAAaF,EAAY,IAAIC,CAAS;AAC1C,MAAIC;AACE,IAAAA,EAAW,OAAO/c,MAEP+c,IAAA;AAAA,OAEV;AACL,UAAMC,IAAa,MAAM,KAAKH,EAAY,QAAS,CAAA,EAAE,KAAK,CAAC,CAAC9J,GAAGnP,CAAK,MAAMA,EAAM,OAAO5D,CAAE;AACzF,QAAIgd,GAAY;AACR,YAAA,CAACC,GAAcrZ,CAAK,IAAIoZ;AAC9B,MAAAH,EAAY,OAAOI,CAAY,GAClBF,IAAAnZ;AAAA,IACf;AAAA,EACF;AAEA,MAAIsZ,GAAwBC;AAC5B,UAACJ,GAAYG,GAAYC,CAAgB,IAAIC,GAAkBL,GAAY3b,GAAOpB,CAAE,GAGxE6c,EAAA,IAAIC,GAAWC,CAAU,GAE9B,CAAEG,GAAYC,CAAiB;AACxC;AAEgB,SAAAC,GACdL,GACA3b,GACApB,GACkD;AAC5C,QAAAqd,IAAM,KAAK;AACjB,EAAIN,KAAcM,IAAMN,EAAW,YAAYN,MAElCM,EAAA,SACXA,EAAW,WAAWM,KAGtBN,IAAa,EAAE,OAAO,GAAG,UAAUM,GAAK,IAAArd;AAG1C,QAAMsd,IAAW;AAAA,IACf,MAAM;AAAA,IACN,SAASlc,EAAM;AAAA,IACf,SAASA,EAAM;AAAA,IACf,SAASA,EAAM;AAAA,IACf,SAASA,EAAM;AAAA,IACf,SAASA,EAAM;AAAA,IACf,UAAUA,EAAM;AAAA,IAChB,QAAQA,EAAM;AAAA,IACd,SAASA,EAAM;AAAA,IACf,QAAQA,EAAM;AAAA,IACd,SAASA,EAAM;AAAA,IACf,QAAQ2b,EAAW;AAAA,EAAA;AAGjB,MAAAG,GACAC;AACJ,SAAI/b,aAAiB,gBACnB,OAAO,OAAOkc,GAAU;AAAA,IACtB,WAAWlc,EAAM;AAAA,IACjB,OAAOA,EAAM;AAAA,IACb,QAAQA,EAAM;AAAA,IACd,UAAUA,EAAM;AAAA,IAChB,oBAAoBA,EAAM;AAAA,IAC1B,OAAOA,EAAM;AAAA,IACb,OAAOA,EAAM;AAAA,IACb,OAAOA,EAAM;AAAA,IACb,aAAaA,EAAM;AAAA,IACnB,WAAWA,EAAM;AAAA,EAAA,CAClB,GACY8b,IAAA,IAAI,aAAa,SAASI,CAAQ,GAC3CP,EAAW,UAAU,MACJI,IAAA,IAAI,aAAa,YAAYG,CAAQ,OAG7CJ,IAAA,IAAI,WAAW,SAASI,CAAQ,GACzCP,EAAW,UAAU,MACJI,IAAA,IAAI,WAAW,YAAYG,CAAQ,KAInD,CAACP,GAAYG,GAAYC,CAAgB;AAClD;AAEO,SAASI,GAAgBhI,GAAiC;AACzD,QAAA8H,IAAM,KAAK;AACX,QAAA,KAAK9H,EAAO,SAAS,EACxB,OAAO,CAAC,CAACxC,GAAGnP,CAAK,MAAMyZ,IAAMzZ,EAAM,WAAW6Y,EAAsB,EACpE,IAAI,CAAC,CAACK,GAAW/J,CAAC,MAAMwC,EAAO,OAAOuH,CAAS,CAAC;AACrD;AClHO,SAASU,GACd7M,GACAoH,GACA0F,GACAC,GACAC,GACAC,GACAhe,GACA;AACA,QAAMgE,IAA8B;AAAA,IAClC,8BAAc,IAAI;AAAA,IAClB,QAAQ;AAAA,MACN,mBAAmB;AAAA,MACnB,mBAAmB,CAAC;AAAA,IACtB;AAAA,IACA,qCAAqB,IAAI;AAAA,IACzB,4BAAY,IAAI;AAAA,EAAA,GAGZia,IAAsB;AAAA,IAC1B,aAAaC;AAAA,IACb,WAAWC;AAAA,IACX,eAAeC;AAAA,EAAA;AAGjB,WAASC,EAAmBC,GAAgC;AAC1D,UAAMC,IAAava,EAAM,OAAO,sBAAsBsa,EAAa,WAC7DE,IAAiBT,EAAc,IAAIO,EAAa,MAAM,GAEtDvI,IAAU,EAAEuI,EAAa,aAAata,EAAM;AAClD,QAAKua,KAAcxI,KAAawI,KAAc,CAACC,GAAiB;AAE9D,YAAM5d,IAAY8b,GAAQ,QAAQ1Y,EAAM,QAAQ,EAAE,KAAK,CAAAlC,MAAKic,EAAc,IAAIjc,EAAE,MAAM,CAAC;AACvF,UAAI,CAAClB,GAAW;AACd,QAAAoD,EAAM,SAAS,EAAE,mBAAmB,IAAI,mBAAmB,CAAA;AAC3D;AAAA,MACF;AACe,MAAAsa,IAAA1d,GACToD,EAAA,OAAO,oBAAoBsa,EAAa;AAAA,IAAA,OACzC;AACL,YAAMG,IAAWza,EAAM,SAAS,IAAIA,EAAM,OAAO,iBAAiB;AAClE,UAAI,CAACya,GAAU;AACb,QAAAza,EAAM,SAAS,EAAE,mBAAmB,IAAI,mBAAmB,CAAA;AAC3D;AAAA,MACF;AACe,MAAAsa,IAAAG;AAAA,IACjB;AAEA,QAAIF,KAAcC,GAAgB;AAG1B,YAAAE,IAAYhC,GAAQ,QAAQ1Y,EAAM,QAAQ,EAAE,IAAI,CAAKtE,MAAAA,EAAE,MAAM;AAC7D,MAAAsE,EAAA,OAAO,oBAAoB,OAAO;AAAA,QACtC,MAAM,KAAK+Z,CAAa,EACrB,OAAO,CAAAre,MAAK,CAACgf,EAAU,SAAShf,CAAC,CAAC,EAClC,OAAO,CAAAA;;AAAK,kBAAAgC,IAAAqP,EAAWrR,CAAC,MAAZ,gBAAAgC,EAAe;AAAA,SAAS,EACpC,IAAI,CAAKhC,MAAA,CAACA,GAAGif,GAAoBxG,EAAQ,OAAOzY,CAAC,CAAC,CAAC;AAAA,MAAA,GAExD4e,EAAa,mBAAmBzd,GAAA,IAAKyd,EAAa,iBAClDA,EAAa,mBAAmBK,GAAoBxG,EAAQ,OAAOmG,EAAa,MAAM;AAAA,IACxF;AAAA,EACF;AAEA,EAAArd,EAAM8c,GAAe,CAAYzI,MAAA;AAC/B,UAAMgJ,IAAeta,EAAM,SAAS,IAAIA,EAAM,OAAO,iBAAiB;AACtE,IAAIsa,KACFD,EAAmBC,CAAY,GAE7BhJ,EAAS,OAAO,KAAKuI,EAAM,cAAc,UAAU,SACrDA,EAAM,cAAc,QAAQ,SACnBvI,EAAS,SAAS,KAAKuI,EAAM,cAAc,UAAU,WAC9DA,EAAM,cAAc,QAAQ;AAAA,EAC9B,CACD,GAEK5c,EAAA4c,EAAM,eAAe,CAAQe,MAAA;AACjC,IAAIA,MAAS,UACXb,EAAc,MAAM;AAAA,EACtB,CACD;AAEQ,WAAAc,EAA0BP,GAAgC9c,GAAwB;AACzF,UAAM8E,IAAKgY,EAAa,iBAAiB,IAAI9c,EAAM,OAC7C+E,IAAK+X,EAAa,iBAAiB,IAAI9c,EAAM,OAC7CrB,IACJ6D,EAAM,OAAO,qBAAqBsa,EAAa,YAC3Czd,GAAA;AAAA,MACE,CAACyd,EAAa,MAAM,GAAGA,EAAa;AAAA,OACjCta,EAAM,OAAO,qBAElB,EAAE,CAACsa,EAAa,MAAM,GAAGA,EAAa,iBAAiB,GACvD/C,IAAIyC,EAAU;AAEpB,WAAO,OAAO;AAAA,MACZ,OAAO,QAAQ7d,CAAS,EAAE,IAAI,CAAC,CAAC1B,GAAM4B,CAAG,MAAM;AAAA,QAC7C5B;AAAA,QACA;AAAA,UACE,GAAG4B,EAAI,IAAIiG,IAAKiV;AAAA,UAChB,GAAGlb,EAAI,IAAIkG,IAAKgV;AAAA,QAClB;AAAA,MAAA,CACD;AAAA,IAAA;AAAA,EAEL;AAES,WAAAuD,EAAqBrgB,GAAc+C,GAAmB;;AAMzD,QALAA,EAAM,aAKNA,EAAM,YAAY,CAAC,CAAC,aAAa,MAAM,EAAE,SAASqc,EAAM,cAAc,KAAK;AAC7E;AAEF,IAAAA,EAAM,cAAc,QAAQ;AAE5B,UAAMkB,KAAa9Y,KAAAvE,IAAAqP,EAAWtS,CAAI,MAAf,gBAAAiD,EAAkB,eAAlB,OAAAuE,IAAgC;AACnD,QAAI8Y,GAAY;AACd,YAAMC,IACJtC,GAAQ,QAAQ1Y,EAAM,QAAQ,EAAE,OAAO,CAAKlC,MAAAic,EAAc,IAAIjc,EAAE,MAAM,CAAC,EAAE,SAAS;AAChF,MAAAN,EAAM,YAAYwd,IAEhBjB,EAAc,IAAItf,CAAI,IACxBsf,EAAc,OAAOtf,CAAI,IACd,OAAOsgB,KAAe,YAAYhB,EAAc,QAAQgB,KACnEhB,EAAc,IAAItf,CAAI,IAEdsf,EAAc,IAAItf,CAAI,MAEhCsf,EAAc,MAAM,GACpBA,EAAc,IAAItf,CAAI;AAAA,IAE1B;AACA,IAAAuB,EAAQ,KAAK,cAAc,EAAE,MAAAvB,GAAM,OAAA+C,EAAO,CAAA;AAAA,EAC5C;AAES,WAAAyd,EAA2BxgB,GAAc+C,GAAmB;AACnE,IAAIA,EAAM,aACVxB,EAAQ,KAAK,iBAAiB,EAAE,MAAAvB,GAAM,OAAA+C,EAAO,CAAA;AAAA,EAC/C;AAEA,WAAS0c,EAA2B1c,GAAqB;;AACvD,IAAAA,EAAM,gBAAgB;AAEtB,UAAM8c,IAAeta,EAAM,SAAS,IAAIxC,EAAM,SAAS;AACvD,QAAI,CAAC8c;AACH;AAEF,IAAAA,EAAa,iBAAiB,EAAE,GAAG9c,EAAM,OAAO,GAAGA,EAAM,SAC5C8c,EAAA;AAEP,UAAAY,IAAYpC,GAAiCtb,EAAM,WAAW;AAKpE,QAJI8c,EAAa,eAAeY,KAI5B,GAACxd,IAAAqP,EAAWuN,EAAa,MAAM,MAA9B,QAAA5c,EAAiC;AACpC;AAGE,QAAA4c,EAAa,gBAAgBY,IAAY,GAAG;AACxCC,YAAAA,IAAgBN,EAA0BP,GAAc;AAAA,QAC5D,WAAWA,EAAa;AAAA,QACxB,OAAOA,EAAa,iBAAiB;AAAA,QACrC,OAAOA,EAAa,iBAAiB;AAAA,MAAA,CACtC;AACO,MAAAte,EAAA,KAAK,kBAAkBmf,CAAa;AAAA,IAC9C;AACM,UAAAA,IAAgBN,EAA0BP,GAAc9c,CAAK;AAC3D,IAAAxB,EAAA,KAAK,oBAAoBmf,CAAa;AAAA,EAChD;AAEA,WAASf,EAA6B5c,GAAqB;AACzD,IAAAA,EAAM,gBAAgB;AAEtB,QAAI8c,IAAeta,EAAM,SAAS,IAAIxC,EAAM,SAAS;AACrD,QAAK8c,GAIL;AAAA,WAAKA,KAAgBta,EAAM,SAAS,OAAA,GAAU;AAC5C,cAAMvF,IAAO6f,EAAa,QAEpBY,IAAYpC,GAAiCtb,EAAM,WAAW;AAEpE,YADgB8c,EAAa,cAAcY,GAC9B;AAEL,gBAAAC,IAAgBN,EAA0BP,GAAc;AAAA,YAC5D,WAAWA,EAAa;AAAA,YACxB,OAAOA,EAAa,eAAe;AAAA,YACnC,OAAOA,EAAa,eAAe;AAAA,UAAA,CACpC;AACO,UAAAte,EAAA,KAAK,gBAAgBmf,CAAa;AAAA,QAC5C;AACA,QAAAnf,EAAQ,KAAK,kBAAkB,EAAE,MAAAvB,GAAM,OAAA+C,EAAO,CAAA;AAAA,MAChD;AAGA,MAAAwC,EAAM,SAAS,SACfA,EAAM,SAAS,EAAE,mBAAmB,IAAI,mBAAmB,CAAA,KAC3DR,GAAUya,CAAmB,EAAE,QAAQ,CAAC,CAACmB,GAAIC,CAAO,MAAM;AAC/C,iBAAA,oBAAoBD,GAAIC,CAAO;AAAA,MAAA,CACzC,GACDxB,EAAM,SAAS,QAAQ;AAAA;AAAA,EACzB;AAEA,WAASM,EAAyB3c,GAAqB;;AACrD,IAAAA,EAAM,gBAAgB;AAEtB,UAAM8c,IAAeta,EAAM,SAAS,IAAIxC,EAAM,SAAS;AACvD,QAAI,CAAC8c;AACH;AAGI,IAAAta,EAAA,SAAS,OAAOxC,EAAM,SAAS;AAErC,UAAM/C,IAAO6f,EAAa,QAEpBY,IAAYpC,GAAiCtb,EAAM,WAAW,GAC9D8d,IAAUhB,EAAa,cAAcY;AAC3C,QAAII;AACF,WAAI5d,IAAAqP,EAAWuN,EAAa,MAAM,MAA9B,QAAA5c,EAAiC,WAAW;AACxC,cAAAyd,IAAgBN,EAA0BP,GAAc9c,CAAK;AAC3D,QAAAxB,EAAA,KAAK,gBAAgBmf,CAAa,GAC1Cnf,EAAQ,KAAK,kBAAkB,EAAE,MAAAvB,GAAM,OAAA+C,EAAO,CAAA;AAAA,MAChD;AAAA;AAEA,MAAAxB,EAAQ,KAAK,kBAAkB,EAAE,MAAAvB,GAAM,OAAA+C,EAAO,CAAA;AAGhD,QAAI,CAAC8d,GAAuE;AAEpE,YAAA,CAAChC,GAAYC,CAAgB,IAAIP;AAAA,QACrChZ,EAAM;AAAA,QACNsa,EAAa;AAAA,QACb7f;AAAA,QACA+C;AAAA,MAAA;AAEW,OAAAyE,IAAAqY,EAAA,gBAAA,QAAArY,EAAa,cAAcqX,IACpCC,OACWtY,IAAAqZ,EAAA,gBAAA,QAAArZ,EAAa,cAAcsY;AAAA,IAE5C;AAEI,IAAAvZ,EAAM,SAAS,SAAS,KAE1BA,EAAM,SAAS,EAAE,mBAAmB,IAAI,mBAAmB,CAAA,KAC3DR,GAAUya,CAAmB,EAAE,QAAQ,CAAC,CAACmB,GAAIC,CAAO,MAAM;AAC/C,eAAA,oBAAoBD,GAAIC,CAAO;AAAA,IAAA,CACzC,GACD1B,GAAgB3Z,EAAM,MAAM,GAC5B6Z,EAAM,SAAS,QAAQ,aAEvBQ,EAAmBC,CAAY,GAIjCR,EAAa,MAAM,GACnB9Z,EAAM,gBAAgB,QAAQ8Z,EAAa,KAAKA,CAAY;AAAA,EAC9D;AAES,WAAAyB,EAA2B9gB,GAAc+C,GAAqB;AAMjE,QALAA,EAAM,UAAU,MAGpBA,EAAM,gBAAgB,GAElB,CAAC,CAAC,WAAW,MAAM,EAAE,SAASqc,EAAM,SAAS,KAAK;AACpD;AAGE,IAAA7Z,EAAM,SAAS,QAAQ,MAEzB6Z,EAAM,SAAS,QAAQ,QACvBra,GAAUya,CAAmB,EAAE,QAAQ,CAAC,CAACmB,GAAIC,CAAO,MAAM;AAC/C,eAAA,iBAAiBD,GAAIC,CAAO;AAAA,IAAA,CACtC;AAIH,UAAMf,IAAiC;AAAA,MACrC,WAAW9c,EAAM;AAAA,MACjB,QAAQ/C;AAAA,MACR,aAAa;AAAA,MACb,kBAAkBkgB,GAAoBxG,EAAQ,OAAO1Z,CAAI;AAAA,MACzD,kBAAkB,EAAE,GAAG+C,EAAM,OAAO,GAAGA,EAAM,MAAM;AAAA,MACnD,gBAAgB,EAAE,GAAGA,EAAM,OAAO,GAAGA,EAAM,MAAM;AAAA,MACjD,aAAaA,EAAM;AAAA,IAAA;AAErB,IAAAwC,EAAM,SAAS,IAAIxC,EAAM,WAAW8c,CAAY,GAE5CP,EAAc,IAAItf,CAAI,MACpBuF,EAAM,OAAO,oBAAoB,KAE7BA,EAAA,OAAO,oBAAoBxC,EAAM,WACvC6c,EAAmBC,CAAY,KAI/B,OAAOta,EAAM,OAAO,kBAAkBsa,EAAa,MAAM,IAI7Dte,EAAQ,KAAK,oBAAoB,EAAE,MAAAvB,GAAM,OAAA+C,EAAO,CAAA;AAAA,EAClD;AAES,WAAAge,EAA2B/gB,GAAc+C,GAAqB;AAEjE,IADEwC,EAAA,gBAAgB,IAAIvF,CAAI,GAC1B,EAAAuF,EAAM,SAAS,OAAO,OAG1B8Z,EAAa,IAAIrf,CAAI,GACrBuB,EAAQ,KAAK,oBAAoB,EAAE,MAAAvB,GAAM,OAAA+C,EAAO,CAAA;AAAA,EAClD;AAES,WAAAie,EAA0BhhB,GAAc+C,GAAqB;AAEhE,IADEwC,EAAA,gBAAgB,OAAOvF,CAAI,GAC7B,EAAAuF,EAAM,SAAS,OAAO,OAG1B8Z,EAAa,OAAOrf,CAAI,GACxBuB,EAAQ,KAAK,mBAAmB,EAAE,MAAAvB,GAAM,OAAA+C,EAAO,CAAA;AAAA,EACjD;AAES,WAAAke,EAAsBjhB,GAAc+C,GAAmB;AAC9D,IAAAA,EAAM,gBAAgB,GACtBxB,EAAQ,KAAK,oBAAoB,EAAE,MAAAvB,GAAM,OAAA+C,EAAO,CAAA;AAAA,EAClD;AAEO,SAAA;AAAA,IACL,4BAAA+d;AAAA,IACA,4BAAAC;AAAA,IACA,2BAAAC;AAAA,IACA,sBAAAX;AAAA,IACA,4BAAAG;AAAA,IACA,uBAAAS;AAAA,EAAA;AAEJ;AAEA,SAASf,GAAoB5e,GAAgCtB,GAAc;;AACnE,QAAA4B,KAAMqB,IAAA3B,EAAMtB,CAAI,MAAV,OAAAiD,IAAe,EAAE,GAAG,GAAG,GAAG;AAC/B,SAAAb,GAAA,IAAKR;AACd;AClWO,SAASsf,GACd1O,GACA4M,GACA+B,GACAC,GACA7f,GACA;AACA,QAAMgE,IAAQ;AAAA,IACZ,8BAAc,IAA8B;AAAA;AAAA,IAC5C,kBAAkB;AAAA,IAClB,4BAAY,IAAwB;AAAA,EAAA,GAGhC8b,IAAsB;AAAA,IAC1B,WAAWC;AAAA,IACX,eAAeC;AAAA,EAAA;AAGjB,EAAA/e,EAAM4e,GAAe,CAAYvK,MAAA;AAC/B,IAAIA,EAAS,OAAO,KAAKuI,EAAM,cAAc,UAAU,SACrDA,EAAM,cAAc,QAAQ,SACnBvI,EAAS,SAAS,KAAKuI,EAAM,cAAc,UAAU,WAC9DA,EAAM,cAAc,QAAQ;AAAA,EAC9B,CACD,GAEK5c,EAAA4c,EAAM,eAAe,CAAQe,MAAA;AACjC,IAAIA,MAAS,UACXiB,EAAc,MAAM;AAAA,EACtB,CACD;AAEQ,WAAAI,EAA2Bte,GAAcH,GAAqB;AAMjE,QALAA,EAAM,UAAU,MAGpBA,EAAM,gBAAgB,GAElB,CAAC,CAAC,WAAW,MAAM,EAAE,SAASqc,EAAM,SAAS,KAAK;AACpD;AAGE,IAAA7Z,EAAM,SAAS,QAAQ,MAEzB6Z,EAAM,SAAS,QAAQ,QACvBra,GAAUsc,CAAmB,EAAE,QAAQ,CAAC,CAACV,GAAIC,CAAO,MAAM;AAC/C,eAAA,iBAAiBD,GAAIC,CAAO;AAAA,IAAA,CACtC,GACDrb,EAAM,mBAAmB,IAGrBA,EAAA;AAGN,UAAMsa,IAAiC;AAAA,MACrC,WAAW9c,EAAM;AAAA,MACjB,IAAIG;AAAA,MACJ,aAAaH,EAAM;AAAA,IAAA;AAErB,IAAAwC,EAAM,SAAS,IAAIxC,EAAM,WAAW8c,CAAY,GAEhDte,EAAQ,KAAK,oBAAoBkgB,GAAqBve,GAAMH,CAAK,CAAC;AAAA,EACpE;AAEA,WAASue,EAAyBve,GAAqB;;AACrD,IAAAA,EAAM,gBAAgB;AAEtB,UAAM8c,IAAeta,EAAM,SAAS,IAAIxC,EAAM,SAAS;AACvD,QAAI,CAAC8c;AACH;AAGI,IAAAta,EAAA,SAAS,OAAOxC,EAAM,SAAS;AAErC,UAAMG,IAAO2c,EAAa;AAC1B,IAAAte,EAAQ,KAAK,kBAAkBkgB,GAAqBve,GAAMH,CAAK,CAAC;AAG1D,UAAA,CAAC8b,GAAYC,CAAgB,IAAIP;AAAA,MACrChZ,EAAM;AAAA,MACNsa,EAAa;AAAA,MACb3c,aAAgB,QAAQA,EAAK,KAAK,GAAG,IAAIA;AAAA,MACzCH;AAAA,IAAA;AAEW,KAAAE,IAAA4c,EAAA,gBAAA,QAAA5c,EAAa,cAAc4b,IACpCC,OACWtX,IAAAqY,EAAA,gBAAA,QAAArY,EAAa,cAAcsX,KAGtCvZ,EAAM,SAAS,SAAS,MAE1BA,EAAM,mBAAmB,GACzBR,GAAUsc,CAAmB,EAAE,QAAQ,CAAC,CAACV,GAAIC,CAAO,MAAM;AAC/C,eAAA,oBAAoBD,GAAIC,CAAO;AAAA,IAAA,CACzC,GACD1B,GAAgB3Z,EAAM,MAAM,GAC5B6Z,EAAM,SAAS,QAAQ;AAAA,EAE3B;AAEA,WAASmC,EAA6Bxe,GAAqB;AAIzD,QAHAA,EAAM,gBAAgB,GAGlB,EADiBwC,EAAM,SAAS,IAAIxC,EAAM,SAAS,GAKvD;AAAA,iBAAW8c,KAAgBta,EAAM,SAAS,OAAA,GAAU;AAClD,cAAMrC,IAAO2c,EAAa;AAC1B,QAAAte,EAAQ,KAAK,kBAAkBkgB,GAAqBve,GAAMH,CAAK,CAAC;AAAA,MAClE;AAGA,MAAAwC,EAAM,SAAS,SACfA,EAAM,mBAAmB,GACzBR,GAAUsc,CAAmB,EAAE,QAAQ,CAAC,CAACV,GAAIC,CAAO,MAAM;AAC/C,iBAAA,oBAAoBD,GAAIC,CAAO;AAAA,MAAA,CACzC,GACOrf,EAAA,KAAK,aAAa,SAAS;AAAA;AAAA,EACrC;AAES,WAAAmgB,EAAqBxe,GAAyBH,GAAmB;;AAMpE,QALAA,EAAM,aAKNA,EAAM,YAAY,CAAC,CAAC,aAAa,MAAM,EAAE,SAASqc,EAAM,cAAc,KAAK;AAC7E;AAEF,IAAAA,EAAM,cAAc,QAAQ;AAE5B,UAAM9Z,IAAQpC,aAAgB,QAAQA,IAAO,CAACA,CAAI,GAE5Cye,IACJ1D,GAAQ,QAAQ1Y,EAAM,QAAQ,EAAE,OAAO,CAAKlC,OAC5BA,EAAE,cAAc,QAAQA,EAAE,KAAK,CAACA,EAAE,EAAE,GACrC,MAAM,CAAAH,MAAQke,EAAc,IAAIle,CAAI,CAAC,CACnD,EAAE,SAAS;AAEd,QAAIA,aAAgB;AAGlB,MADwBoC,EAAM,KAAK,CAAApC;;AAAQ,gBAAAD,IAAAuP,EAAWtP,CAAI,MAAf,gBAAAD,EAAkB;AAAA,OAAU,MAEjEF,EAAM,YAAY4e,IAChBrc,EAAM,KAAK,CAAApC,MAAQke,EAAc,IAAIle,CAAI,CAAC,IAC5CoC,EAAM,QAAQ,CAAApC,MAAQke,EAAc,OAAOle,CAAI,CAAC,IAE1CoC,EAAA,QAAQ,CAAApC,MAAQ;;AACd,cAAAod,KAAard,IAAAuP,EAAWtP,CAAI,MAAf,gBAAAD,EAAkB;AACrC,QAAM,OAAOqd,KAAe,YAAYc,EAAc,QAAQd,KAC5Dc,EAAc,IAAIle,CAAI;AAAA,MACxB,CACD,KAIHke,EAAc,MAAM,GACpB9b,EAAM,QAAQ,CAAApC,MAAQke,EAAc,IAAIle,CAAI,CAAC;AAAA,SAG5C;AACC,YAAAod,KAAard,IAAAuP,EAAWtP,CAAI,MAAf,gBAAAD,EAAkB;AACrC,MAAIqd,MACEvd,EAAM,YAAY4e,IAChBP,EAAc,IAAIle,CAAI,IACxBke,EAAc,OAAOle,CAAI,IACd,OAAOod,KAAe,YAAYc,EAAc,QAAQd,KACnEc,EAAc,IAAIle,CAAI,IAEdke,EAAc,IAAIle,CAAI,MAEhCke,EAAc,MAAM,GACpBA,EAAc,IAAIle,CAAI;AAAA,IAG5B;AACA,IAAA3B,EAAQ,KAAK,cAAckgB,GAAqBve,GAAMH,CAAK,CAAC;AAAA,EAC9D;AAES,WAAA6e,EAA2B1e,GAAyBH,GAAmB;AAC9E,IAAIA,EAAM,aACVxB,EAAQ,KAAK,iBAAiBkgB,GAAqBve,GAAMH,CAAK,CAAC;AAAA,EACjE;AAES,WAAA8e,EAA2B3e,GAAcH,GAAqB;AACrE,IAAAoe,EAAa,IAAIje,CAAI,GACrB3B,EAAQ,KAAK,oBAAoBkgB,GAAqBve,GAAMH,CAAK,CAAC;AAAA,EACpE;AAES,WAAA+e,EAA0B5e,GAAcH,GAAqB;AACpE,IAAAoe,EAAa,OAAOje,CAAI,GACxB3B,EAAQ,KAAK,mBAAmBkgB,GAAqBve,GAAMH,CAAK,CAAC;AAAA,EACnE;AAES,WAAAgf,EAAsB7e,GAAcH,GAAmB;AAC9D,IAAAA,EAAM,gBAAgB,GACtBxB,EAAQ,KAAK,oBAAoBkgB,GAAqBve,GAAMH,CAAK,CAAC;AAAA,EACpE;AAES,WAAAif,EAA4B1c,GAAiBvC,GAAqB;AAMrE,QALAA,EAAM,UAAU,MAGpBA,EAAM,gBAAgB,GAElB,CAAC,CAAC,WAAW,MAAM,EAAE,SAASqc,EAAM,SAAS,KAAK;AACpD;AAGE,IAAA7Z,EAAM,SAAS,QAAQ,MAEzB6Z,EAAM,SAAS,QAAQ,QACvBra,GAAUsc,CAAmB,EAAE,QAAQ,CAAC,CAACV,GAAIC,CAAO,MAAM;AAC/C,eAAA,iBAAiBD,GAAIC,CAAO;AAAA,IAAA,CACtC,GACDrb,EAAM,mBAAmB,IAGrBA,EAAA;AAGN,UAAMsa,IAAiC;AAAA,MACrC,WAAW9c,EAAM;AAAA,MACjB,IAAIuC;AAAA,MACJ,aAAavC,EAAM;AAAA,IAAA;AAErB,IAAAwC,EAAM,SAAS,IAAIxC,EAAM,WAAW8c,CAAY,GAChDte,EAAQ,KAAK,oBAAoBkgB,GAAqBnc,GAAOvC,CAAK,CAAC;AAAA,EACrE;AAES,WAAAkf,EAA4B3c,GAAiBvC,GAAqB;AACzE,IAAAuC,EAAM,QAAQ,CAAApC,MAAQie,EAAa,IAAIje,CAAI,CAAC,GAC5C3B,EAAQ,KAAK,oBAAoBkgB,GAAqBnc,GAAOvC,CAAK,CAAC;AAAA,EACrE;AAES,WAAAmf,EAA2B5c,GAAiBvC,GAAqB;AACxE,IAAAuC,EAAM,QAAQ,CAAApC,MAAQie,EAAa,OAAOje,CAAI,CAAC,GAC/C3B,EAAQ,KAAK,mBAAmBkgB,GAAqBnc,GAAOvC,CAAK,CAAC;AAAA,EACpE;AAES,WAAAof,EAAsB7c,GAAiBvC,GAAmB;AACjE,IAAA2e,EAAqBpc,GAAOvC,CAAK;AAAA,EACnC;AAES,WAAAqf,EAA4B9c,GAAiBvC,GAAmB;AACvE,IAAA6e,EAA2Btc,GAAOvC,CAAK;AAAA,EACzC;AAES,WAAAsf,EAAuB/c,GAAiBvC,GAAmB;AAClE,IAAAA,EAAM,gBAAgB,GACtBxB,EAAQ,KAAK,oBAAoBkgB,GAAqBnc,GAAOvC,CAAK,CAAC;AAAA,EACrE;AAEO,SAAA;AAAA,IACL,4BAAAye;AAAA,IACA,4BAAAK;AAAA,IACA,2BAAAC;AAAA,IACA,sBAAAJ;AAAA,IACA,4BAAAE;AAAA,IACA,uBAAAG;AAAA,IACA,6BAAAC;AAAA,IACA,6BAAAC;AAAA,IACA,4BAAAC;AAAA,IACA,uBAAAC;AAAA,IACA,6BAAAC;AAAA,IACA,wBAAAC;AAAA,EAAA;AAEJ;AAEA,SAASZ,GAAsCve,GAAyBH,GAAwB;AAC9F,SAAIG,aAAgB,QACX;AAAA,IACL,OAAOA;AAAA,IACP,OAAAH;AAAA,IACA,YAAY;AAAA,EAAA,IAGP;AAAA,IACL,MAAAG;AAAA,IACA,OAAO,CAACA,CAAI;AAAA,IACZ,OAAAH;AAAA,IACA,YAAY;AAAA,EAAA;AAGlB;AClSO,SAASuf,GACdC,GACAnD,GACAoD,GACAjhB,GACA;AACA,QAAMgE,IAAQ;AAAA,IACZ,aAAa;AAAA,IACb,gBAAgB;AAAA,IAChB,YAAY;AAAA,EAAA,GAKRkd,IAA2B;AAAA,IAC/B,aAAaC;AAAA,IACb,WAAWC;AAAA,IACX,eAAeA;AAAA,EAAA;AAGjB,WAASC,EAAgClO,GAAiB;AACxD,IAAAnP,EAAM,cAAc,GAChBA,EAAM,mBAAmB,KAE3BR,GAAU0d,CAAwB,EAAE,QAAQ,CAAC,CAAC9B,GAAIC,CAAO,MAAM;AAC7D,eAAS,iBAAiBD,GAAIC,GAAS,EAAE,SAAS,IAAM;AAAA,IAAA,CACzD,GAEGrb,EAAA;AAAA,EACR;AAEA,WAASmd,EAAgChO,GAAiB;AAClD,IAAAnP,EAAA;AAAA,EACR;AAEA,WAASod,EAA8B5f,GAAqB;AAEtD,QADEwC,EAAA,kBACFA,EAAM,kBAAkB,GAAG;AAC7B,MAAAA,EAAM,iBAAiB,GAEvBR,GAAU0d,CAAwB,EAAE,QAAQ,CAAC,CAAC9B,GAAIC,CAAO,MAAM;AACpD,iBAAA,oBAAoBD,GAAIC,CAAO;AAAA,MAAA,CACzC;AACK,YAAAH,IAAYpC,GAAiCtb,EAAM,WAAW;AAChE,UAAAwC,EAAM,eAAekb,GAAW;AAElC,YAAI1d,EAAM,YAAYqc,EAAM,cAAc,UAAU;AAClD;AAEF,QAAAA,EAAM,cAAc,QAAQ;AAG5B,cAAM,CAACV,GAAYG,GAAYC,CAAgB,IAAIC;AAAA,UACjDxZ,EAAM;AAAA,UACNxC;AAAA,UACA;AAAA,QAAA;AAEF,QAAAwC,EAAM,aAAamZ,GACT6D,EAAA,MAAO,cAAc1D,CAAU,GACrCC,KACQyD,EAAA,MAAO,cAAczD,CAAgB;AAAA,MAEnD;AAAA,IACF;AAAA,EACF;AAEA,WAAS+D,EAA0B9f,GAAmB;AACpD,IAAIA,EAAM,cAIVA,EAAM,gBAAgB,GACtBxB,EAAQ,KAAK,cAAc,EAAE,OAAAwB,EAAO,CAAA;AAAA,EACtC;AAEA,WAAS+f,EAAgC/f,GAAmB;AAC1D,IAAIA,EAAM,cACVA,EAAM,gBAAgB,GACtBxB,EAAQ,KAAK,iBAAiB,EAAE,OAAAwB,EAAO,CAAA;AAAA,EACzC;AAEA,WAASggB,EAAgChgB,GAAmB;AAC1D,IAAAxB,EAAQ,KAAK,oBAAoB,EAAE,OAAAwB,EAAO,CAAA,GAEtCwC,EAAM,iBAAiB,MAEzBA,EAAM,iBAAiB,GAEvBR,GAAU0d,CAAwB,EAAE,QAAQ,CAAC,CAAC9B,GAAIC,CAAO,MAAM;;AACnD,OAAA3d,IAAAsf,EAAA,UAAA,QAAAtf,EAAO,oBAAoB0d,GAAIC;AAAA,IAAO,CACjD;AAAA,EAEL;AAEM,QAAAoC,IAAiB,CAAC9b,MAAkB;AACxC,IAAAA,EAAE,eAAe;AAAA,EAAA;AAGnB,EAAA+b,GAAU,MAAM;AACd,UAAM3V,IAAIiV,EAAU;AACpB,IAAKjV,MACLA,EAAE,iBAAiB,eAAesV,GAAiC,EAAE,SAAS,IAAM,GACpFtV,EAAE,iBAAiB,SAASuV,GAA2B,EAAE,SAAS,IAAO,GACzEvV,EAAE,iBAAiB,YAAYwV,GAAiC,EAAE,SAAS,IAAO,GAClFxV,EAAE,iBAAiB,eAAeyV,GAAiC,EAAE,SAAS,IAAO,GACjFP,EAAsB,SACxBlV,EAAE,iBAAiB,SAAS0V,GAAgB,EAAE,SAAS,IAAO;AAAA,EAChE,CACD,GAEDE,GAAY,MAAM;AAChB,UAAM5V,IAAIiV,EAAU;AACpB,IAAKjV,MACHA,EAAA,oBAAoB,eAAesV,CAA+B,GAClEtV,EAAA,oBAAoB,SAASuV,CAAyB,GACtDvV,EAAA,oBAAoB,YAAYwV,CAA+B,GAC/DxV,EAAA,oBAAoB,eAAeyV,CAA+B,GAChEP,EAAsB,SACtBlV,EAAA,oBAAoB,SAAS0V,CAAc;AAAA,EAC/C,CACD,GAEKxgB,EAAAggB,GAAuB,CAACW,GAASC,MAAQ;AAC7C,UAAM9V,IAAIiV,EAAU;AAChB,IAAA,CAACjV,KAAK6V,MAAYC,MAElBD,IACF7V,EAAE,iBAAiB,SAAS0V,GAAgB,EAAE,SAAS,IAAO,IAE5D1V,EAAA,oBAAoB,SAAS0V,CAAc;AAAA,EAC/C,CACD;AACH;AChIO,SAASK,GACdzI,GACAwE,GACAkE,GACAC,GACAC,GACAjiB,GACA;AACA,QAAMgE,IAAQ;AAAA,IACZ,8BAAc,IAA8B;AAAA;AAAA,IAC5C,kBAAkB;AAAA,IAClB,4BAAY,IAAwB;AAAA,EAAA;AAG7B,WAAAke,EAAsC/f,GAAcX,GAAwB;;AACnF,WAAIygB,EAA6B,QACxB,EAAE,OAAOhc,KAAAvE,IAAA2X,EAAWlX,CAAI,MAAf,gBAAAT,EAAkB,SAAlB,OAAAuE,IAA0B9D,GAAc,OAAAX,MAEjD,EAAE,MAAAW,GAAM,OAAAX;EAEnB;AAEA,QAAM2gB,IAAsB;AAAA,IAC1B,WAAWC;AAAA,IACX,eAAeC;AAAA,EAAA;AAGjB,EAAAphB,EAAM+gB,GAAe,CAAY1M,MAAA;AAC/B,IAAIA,EAAS,OAAO,KAAKuI,EAAM,cAAc,UAAU,SACrDA,EAAM,cAAc,QAAQ,SACnBvI,EAAS,SAAS,KAAKuI,EAAM,cAAc,UAAU,WAC9DA,EAAM,cAAc,QAAQ;AAAA,EAC9B,CACD,GAEK5c,EAAA4c,EAAM,eAAe,CAAQe,MAAA;AACjC,IAAIA,MAAS,UACXoD,EAAc,MAAM;AAAA,EACtB,CACD;AAEQ,WAAAM,EAA2BngB,GAAcX,GAAqB;;AAUjE,QATA,GAACE,IAAA2X,EAAWlX,CAAI,MAAf,QAAAT,EAAkB,cAInBF,EAAM,UAAU,MAGpBA,EAAM,gBAAgB,GAElB,CAAC,CAAC,WAAW,MAAM,EAAE,SAASqc,EAAM,SAAS,KAAK;AACpD;AAGE,IAAA7Z,EAAM,SAAS,QAAQ,MAEzB6Z,EAAM,SAAS,QAAQ,QACvBra,GAAU2e,CAAmB,EAAE,QAAQ,CAAC,CAAC/C,GAAIC,CAAO,MAAM;AAC/C,eAAA,iBAAiBD,GAAIC,CAAO;AAAA,IAAA,CACtC,GACDrb,EAAM,mBAAmB,IAGrBA,EAAA;AAGN,UAAMsa,IAAiC;AAAA,MACrC,WAAW9c,EAAM;AAAA,MACjB,IAAIW;AAAA,MACJ,aAAaX,EAAM;AAAA,IAAA;AAErB,IAAAwC,EAAM,SAAS,IAAIxC,EAAM,WAAW8c,CAAY,GAEhDte,EAAQ,KAAK,oBAAoBkiB,EAAqB/f,GAAMX,CAAK,CAAC;AAAA,EACpE;AAEA,WAAS4gB,EAAyB5gB,GAAqB;;AACrD,UAAM8c,IAAeta,EAAM,SAAS,IAAIxC,EAAM,SAAS;AACvD,QAAI,CAAC8c;AACH;AAGF,IAAA9c,EAAM,gBAAgB,GAEhBwC,EAAA,SAAS,OAAOxC,EAAM,SAAS;AAErC,UAAMW,IAAOmc,EAAa;AAC1B,IAAAte,EAAQ,KAAK,kBAAkBkiB,EAAqB/f,GAAMX,CAAK,CAAC;AAG1D,UAAA,CAAC8b,GAAYC,CAAgB,IAAIP;AAAA,MACrChZ,EAAM;AAAA,MACNsa,EAAa;AAAA,MACbnc;AAAA,MACAX;AAAA,IAAA;AAEW,KAAAE,IAAA4c,EAAA,gBAAA,QAAA5c,EAAa,cAAc4b,IACpCC,OACWtX,IAAAqY,EAAA,gBAAA,QAAArY,EAAa,cAAcsX,KAGtCvZ,EAAM,SAAS,SAAS,MAE1BA,EAAM,mBAAmB,GACzBR,GAAU2e,CAAmB,EAAE,QAAQ,CAAC,CAAC/C,GAAIC,CAAO,MAAM;AAC/C,eAAA,oBAAoBD,GAAIC,CAAO;AAAA,IAAA,CACzC,GACD1B,GAAgB3Z,EAAM,MAAM,GAC5B6Z,EAAM,SAAS,QAAQ;AAAA,EAE3B;AAEA,WAASwE,EAA6B7gB,GAAqB;AAEzD,QADqBwC,EAAM,SAAS,IAAIxC,EAAM,SAAS,GAKvD;AAAA,MAAAA,EAAM,gBAAgB;AAEtB,iBAAW8c,KAAgBta,EAAM,SAAS,OAAA,GAAU;AAClD,cAAM7B,IAAOmc,EAAa;AAC1B,QAAAte,EAAQ,KAAK,kBAAkBkiB,EAAqB/f,GAAMX,CAAK,CAAC;AAAA,MAClE;AAGA,MAAAwC,EAAM,SAAS,SACfA,EAAM,mBAAmB,GACzBR,GAAU2e,CAAmB,EAAE,QAAQ,CAAC,CAAC/C,GAAIC,CAAO,MAAM;AAC/C,iBAAA,oBAAoBD,GAAIC,CAAO;AAAA,MAAA,CACzC,GACOrf,EAAA,KAAK,aAAa,SAAS;AAAA;AAAA,EACrC;AAES,WAAAuiB,EAA2BpgB,GAAcX,GAAqB;;AACrE,KAAKE,IAAA2X,EAAWlX,CAAI,MAAf,QAAAT,EAAkB,cAGvBqgB,EAAa,IAAI5f,CAAI,GACrBnC,EAAQ,KAAK,oBAAoBkiB,EAAqB/f,GAAMX,CAAK,CAAC;AAAA,EACpE;AAES,WAAAghB,EAA0BrgB,GAAcX,GAAqB;;AACpE,KAAKE,IAAA2X,EAAWlX,CAAI,MAAf,QAAAT,EAAkB,cAGvBqgB,EAAa,OAAO5f,CAAI,GACxBnC,EAAQ,KAAK,mBAAmBkiB,EAAqB/f,GAAMX,CAAK,CAAC;AAAA,EACnE;AAES,WAAAihB,EAAqBtgB,GAAcX,GAAmB;;AAUzD,QATAA,EAAM,aAKN,GAACE,IAAA2X,EAAWlX,CAAI,MAAf,QAAAT,EAAkB,cAInBF,EAAM,YAAY,CAAC,CAAC,aAAa,MAAM,EAAE,SAASqc,EAAM,cAAc,KAAK;AAC7E;AAEF,IAAAA,EAAM,cAAc,QAAQ;AAE5B,UAAMkB,KAAa9Z,KAAAgB,IAAAoT,EAAWlX,CAAI,MAAf,gBAAA8D,EAAkB,eAAlB,OAAAhB,IAAgC;AACnD,QAAI8Z,GAAY;AACd,YAAM2D,IACJhG,GAAQ,QAAQ1Y,EAAM,QAAQ,EAAE,OAAO,CAAKlC,MAAAkgB,EAAc,IAAIlgB,EAAE,EAAE,CAAC,EAAE,SAAS;AAC5E,MAAAN,EAAM,YAAYkhB,IAEhBV,EAAc,IAAI7f,CAAI,IACxB6f,EAAc,OAAO7f,CAAI,IACd,OAAO4c,KAAe,YAAYiD,EAAc,QAAQjD,KACnEiD,EAAc,IAAI7f,CAAI,IAEd6f,EAAc,IAAI7f,CAAI,MAEhC6f,EAAc,MAAM,GACpBA,EAAc,IAAI7f,CAAI;AAAA,IAE1B;AACA,IAAAnC,EAAQ,KAAK,cAAckiB,EAAqB/f,GAAMX,CAAK,CAAC;AAAA,EAC9D;AAES,WAAAmhB,EAA2BxgB,GAAcX,GAAmB;;AACnE,IAAIA,EAAM,cACLE,IAAA2X,EAAWlX,CAAI,MAAf,QAAAT,EAAkB,aAGvB1B,EAAQ,KAAK,iBAAiBkiB,EAAqB/f,GAAMX,CAAK,CAAC;AAAA,EACjE;AAES,WAAAohB,EAAsBzgB,GAAcX,GAAmB;;AAC9D,KAAKE,IAAA2X,EAAWlX,CAAI,MAAf,QAAAT,EAAkB,cAGvBF,EAAM,gBAAgB,GACtBxB,EAAQ,KAAK,oBAAoBkiB,EAAqB/f,GAAMX,CAAK,CAAC;AAAA,EACpE;AAEO,SAAA;AAAA,IACL,4BAAA8gB;AAAA,IACA,4BAAAC;AAAA,IACA,2BAAAC;AAAA,IACA,sBAAAC;AAAA,IACA,4BAAAE;AAAA,IACA,uBAAAC;AAAA,EAAA;AAEJ;AChOA,SAAsBC,GAAoBC,GAAa;AAAA,SAAAC,GAAA;AAE/C,UAAAC,IAAO,OADI,MAAM,MAAMF,CAAG,GACJ;AAC5B,WAAO,IAAI,QAAgB,CAACG,GAAWC,MAAY;AAC7C,UAAA;AACI,cAAAC,IAAS,IAAI;AACnB,QAAAA,EAAO,SAAS,WAAW;AAAE,UAAAF,EAAU,KAAK,MAAgB;AAAA,QAAA,GAC5DE,EAAO,cAAcH,CAAI;AAAA,eAClBrd,GAAG;AACV,QAAAud,EAAQvd,CAAC;AAAA,MACX;AAAA,IAAA,CACD;AAAA,EACH;AAAA;ACNgB,SAAAyd,GACdC,GACAC,GACAC,GACO;;AACD,QAAA9V,IAAQ4V,EAAI;AAClB,EAAA5V,EAAM,IAAI8V,EAAY,GACtB9V,EAAM,IAAI8V,EAAY;AACtB,QAAMC,IAAW/V,EAAM,iBAAgB/L,IAAA4hB,EAAS,OAAO,MAAhB,gBAAA5hB,EAAmB,SAAS;AACnE,SAAO,EAAE,GAAG8hB,EAAS,GAAG,GAAGA,EAAS;AACtC;AAEgB,SAAAC,GACdJ,GACAC,GACAC,GACO;AACD,QAAA9V,IAAQ4V,EAAI;AAClB,EAAA5V,EAAM,IAAI8V,EAAY,GACtB9V,EAAM,IAAI8V,EAAY;AACtB,QAAMG,IAAWjW,EAAM,gBAAgB6V,EAAS,OAAyB,CAAA;AACzE,SAAO,EAAE,GAAGI,EAAS,GAAG,GAAGA,EAAS;AACtC;AAEgB,SAAAC,GACdC,GACAC,GACAllB,GACY;;AACN,QAAAb,IAAS8lB,EAAQ,UAAU,EAAI,GAE/BE,IAAMD,EAAY,WAClBtI,IAAI,IAAI5c,GACRolB,IAAU;AAAA,IACd,GAAG,KAAK,OAAOD,EAAI,IAAI,MAAMvI,CAAC;AAAA,IAC9B,GAAG,KAAK,OAAOuI,EAAI,IAAI,MAAMvI,CAAC;AAAA,IAC9B,OAAO,KAAK,MAAMuI,EAAI,QAAQ,MAAMvI,CAAC;AAAA,IACrC,QAAQ,KAAK,MAAMuI,EAAI,SAAS,MAAMvI,CAAC;AAAA,EAAA;AAEzC,EAAAzd,EAAO,aAAa,SAASimB,EAAQ,MAAM,UAAU,GACrDjmB,EAAO,aAAa,UAAUimB,EAAQ,OAAO,UAAU;AAEjD,QAAAhmB,IAAID,EAAO,cAAc,gBAAgB;AAC/C,EAAAC,EAAE,aAAa,aAAa,aAAa,CAACgmB,EAAQ,CAAC,IAAI,CAACA,EAAQ,CAAC,YAAYxI,CAAC,GAAG,GACjFxd,EAAE,gBAAgB,OAAO,GAElBD,EAAA,aAAa,WAAW,OAAOimB,EAAQ,KAAK,IAAIA,EAAQ,MAAM,EAAE,GACvEjmB,EAAO,gBAAgB,OAAO;AAG9B,QAAMkmB,IAAO,SAAS,mBAAmBlmB,GAAQ,WAAW,YAAY;AACjE,SAAAkmB,EAAK,cAAY;AACtB,UAAMC,IAAcD,EAAK;AACb,KAAAtiB,IAAAuiB,EAAA,eAAA,QAAAviB,EAAY,YAAYuiB;AAAA,EACtC;AACO,SAAAnmB;AACT;AAEA,SAAeomB,GAA4BC,GAAwB;AAAA,SAAApB,GAAA;AACjE,QAAIqB,IAAQ,IACRC,IAAOF,EAAM,aAAa,MAAM;AAKpC,QAJKE,MACKD,IAAA,IACDC,IAAAF,EAAM,aAAa,YAAY,IAEpC,GAACE,KAAQA,EAAK,WAAW,OAAO;AAEhC,UAAA;AACI,cAAAC,IAAU,MAAMzB,GAAoBwB,CAAI;AAC9C,QAAAF,EAAM,aAAaC,IAAQ,eAAe,QAAQE,CAAO;AAAA,eAClD3e,GAAG;AAEF,gBAAA,KAAK,0BAA0B0e,CAAI;AAC3C;AAAA,MACF;AAAA,EACF;AAAA;AAEA,SAAsBE,GACpBC,GACAC,GACAC,GAEqB;AAAA,SAAA3B,GAAA,4BAJrBa,GACAC,GACAllB,GACAgmB,IAAkC,CAAA,GACb;AACrB,UAAM7mB,IAAS6lB,GAAiBC,GAASC,GAAallB,CAAK;AAE3D,QAAIgmB,EAAQ,aAAa;AAGvB,YAAMC,IADS,MAAM,KAAK9mB,EAAO,iBAAiB,OAAO,CAAC,EAClC,IAAI,CAAO+mB,MAAAX,GAA4BW,CAAG,CAAC;AAC7D,YAAA,QAAQ,IAAID,CAAQ;AAAA,IAC5B;AAEO,WAAA9mB;AAAA,EACT;AAAA;ACzEO,SAASgnB,GACd9D,GACAnD,GACA1F,GACApH,GACAgN,GACAzf,GACA;AACA,QAAMymB,IAAwB9O;AAAA,IAC5B,MAAM,CAAC,CAAC3X,EAAQ,KAAK,cAAcA,EAAQ,KAAK;AAAA,EAAA,GAE5C0mB,IAAqB/O,EAAS,MAAM4H,EAAM,SAAS,UAAU,eAAe,GAK5EyF,IAAWvK,KACXkM,IAAelM,KACfpD,IAAS;AAAA,IACb,8BAAc,IAAY;AAAA;AAAA,IAC1B,4BAAY,IAAmB;AAAA;AAAA,IAC/B,YAAY;AAAA;AAAA,IACZ,kDAAkC,IAAY;AAAA;AAAA,IAC9C,eAAe;AAAA;AAAA,IACf,SAAS;AAAA;AAAA,MAEP,aAAa;AAAA,MACb,eAAe;AAAA,MACf,2BAA2B;AAAA,IAC7B;AAAA,EAAA,GAOIuP,IAAuBC;AAAA,IAC3B,MAAM;AACJ,MAAAC;AAAA,QACEhoB,EAAQ4jB,EAAU,OAAO,WAAW;AAAA,QACpC5jB,EAAQkmB,EAAS,OAAO,UAAU;AAAA,QAClC2B;AAAA,QACA9M,EAAQ;AAAA,QACRpH;AAAA,QACAgN;AAAA,QACApI,EAAO;AAAA,QACPA,EAAO;AAAA,MAAA;AAAA,IAEX;AAAA,IACA;AAAA,IACA,EAAE,SAAS,IAAI;AAAA,EAAA,GAMX0P,IAAsB,IAAIC;AAAA,IAC9BtE;AAAA,IACAuE;AAAA,IACAC;AAAA,IACAC;AAAA,IACAC;AAAA,IACAC;AAAA,EAAA;AAGF,WAASD,EAAiBlkB,GAAmB;AAEvC,QADAmU,EAAO,QAAQ,gBAAgB,WAC/BA,EAAO,SAAS,OAAO;AAAG;AAE9B,UAAMlI,IAAQ,EAAE,GAAGjM,EAAM,SAAS,GAAGA,EAAM;AACvC,IAAAmU,EAAO,cAAcrN,EAAS,WAAWqN,EAAO,UAAU,EAAE,SAASlI,CAAK,IAAI,MAGjEmY;EACnB;AAEA,WAASL,EAAuB/jB,GAAqB;AACnD,IAAAA,EAAM,gBAAgB;AAEtB,UAAMiM,IAAQ,EAAE,GAAGjM,EAAM,SAAS,GAAGA,EAAM;AACvC,IAAAmU,EAAO,SAAS,SAAS,MAC3BA,EAAO,aAAalI,GAEpB4X,EAAoB,SAAS,GAE7B1P,EAAO,6BAA6B,SACpCoI,EAAc,QAAQ,CAAUpd,MAAAgV,EAAO,6BAA6B,IAAIhV,CAAM,CAAC,GAC3EgV,EAAO,QAAQ,8BAA8B,SACxCA,EAAA,gBAAgBA,EAAO,QAAQ,gBAEtCA,EAAO,gBAAgBnU,EAAM,WACzBmU,EAAO,QAAQ,4BACfA,EAAO,QAAQ,gBAGlBA,EAAO,SAAS,IAAInU,EAAM,SAAS,KAC/BmU,EAAA,SAAS,IAAInU,EAAM,SAAS,GAErCmU,EAAO,OAAO,IAAInU,EAAM,WAAWiM,CAAK,GACxBoY;EAClB;AAEA,WAASL,EAAqBhkB,GAAqB;AAE7C,QADGmU,EAAA,SAAS,OAAOnU,EAAM,SAAS,GAClCmU,EAAO,SAAS,SAAS,GAAG;AAC9B,YAAMlJ,IAAOrP,EAAQ4jB,EAAU,KAAK,EAAE,sBAAsB,GACtDvT,IAAQ,EAAE,GAAGjM,EAAM,IAAIiL,EAAK,GAAG,GAAGjL,EAAM,IAAIiL,EAAK,EAAE;AACzD,MAAAkJ,EAAO,aAAalI;AAAA,IACX;AAAA,MAAAkI,EAAO,SAAS,SAAS,MAClC0P,EAAoB,WAAW,GAC3B1P,EAAO,QAAQ,gBAAgB,eAChBiQ,KAEnBjQ,EAAO,6BAA6B;AAEtB,IAAAkQ;EAClB;AAEA,WAASJ,EAAuBjkB,GAAqB;AACnD,UAAMiL,IAAOrP,EAAQ4jB,EAAU,KAAK,EAAE,sBAAsB,GACtDvT,IAAQ,EAAE,GAAGjM,EAAM,IAAIiL,EAAK,GAAG,GAAGjL,EAAM,IAAIiL,EAAK,EAAE;AACzD,IAAAkJ,EAAO,OAAO,IAAInU,EAAM,WAAWiM,CAAK,GACxBoY,KACKX;EACvB;AAEA,WAASS,EAAmBnkB,GAAsB;AAChD,IAAIA,EAAM,QAAQ,YAAYmU,EAAO,QAAQ,gBAAgB,aAC3DnU,EAAM,gBAAgB,GACLokB;EAErB;AAEA,WAASC,IAAkB;AACrB,QAAAC,GACAC;AACJ,UAAMC,IAAe,MAAM,KAAKrQ,EAAO,QAAQ;AAC3C,QAAAqQ,EAAa,UAAU,GAAG;AACtB,YAAAC,IAAQD,EAAa,CAAC,GACtBE,IAAOF,EAAaA,EAAa,SAAS,CAAC;AAC1C,MAAAF,IAAAnQ,EAAO,OAAO,IAAIsQ,CAAK,GACvBF,IAAApQ,EAAO,OAAO,IAAIuQ,CAAI;AAAA,IACpB,WAAAvQ,EAAO,cAAcqQ,EAAa,WAAW,GAAG;AACnD,YAAAC,IAAQD,EAAa,CAAC;AAC5B,MAAAF,IAAOnQ,EAAO,YACPoQ,IAAApQ,EAAO,OAAO,IAAIsQ,CAAK;AAAA,IAAA;AAEvB,MAAAH,IAAA,QACAC,IAAA;AAET,IAAID,KAAQC,KAEVd,EAAa,QAAQ;AAAA,MACnB,KAAK;AAAA,QACH,GAAG,KAAK,IAAIa,EAAK,GAAGC,EAAK,CAAC;AAAA,QAC1B,GAAG,KAAK,IAAID,EAAK,GAAGC,EAAK,CAAC;AAAA,MAC5B;AAAA,MACA,MAAM;AAAA,QACJ,OAAO,KAAK,IAAIA,EAAK,IAAID,EAAK,CAAC;AAAA,QAC/B,QAAQ,KAAK,IAAIC,EAAK,IAAID,EAAK,CAAC;AAAA,MAClC;AAAA,IAAA,GAEEb,EAAa,MAAM,KAAK,UAAU,MACvBA,EAAA,MAAM,KAAK,QAAQ,IAE9BA,EAAa,MAAM,KAAK,WAAW,MACxBA,EAAA,MAAM,KAAK,SAAS,MAE1BA,EAAa,UACtBA,EAAa,QAAQ;AAAA,EAEzB;AAKA,QAAMkB,IAAoB,IAAIC;AAAA,IAC5BpF;AAAA;AAAA,IAEA,CAACxf,MAAyB;AACxB,MAAKujB,EAAsB,SACvBzmB,EAAQ,KAAK,UAAU,SAASkD,CAAK,MACrB6kB,EAAA;AAAA,QAChB,MAAM;AAAA,QACN,MAAM;AAAA,QACN,cAAc;AAAA,MAAA,CACf,GACDF,EAAkB,SAAS;AAAA,IAE/B;AAAA;AAAA,IAEA,CAAC3kB,MAAyB;AACxB,MAAKujB,EAAsB,SACvBzmB,EAAQ,KAAK,UAAU,SAASkD,CAAK,MACnCmU,EAAO,SAAS,SAAS,IACViQ,MAEjBjQ,EAAO,QAAQ,cAAc,aAE/BwQ,EAAkB,WAAW;AAAA,IAEjC;AAAA,EAAA;AAGF,EAAAllB,EAAM8jB,GAAuB,CAAS9nB,MAAA;AACpC,IAAIA,IACFkpB,EAAkB,SAAS,IAE3BA,EAAkB,WAAW;AAAA,EAC/B,CACD,GAMDzE,GAAU,MAAM;;AACd,IAAA4B,EAAS,SAAQ5hB,IAAAsf,EAAU,UAAV,gBAAAtf,EAAiB,cAAc,mBAC5CqjB,EAAsB,SACxBoB,EAAkB,SAAS;AAAA,EAC7B,CACD,GAEDxE,GAAY,MAAM;AACC,IAAAiE,KACbb,EAAsB,SACxBoB,EAAkB,WAAW;AAAA,EAC/B,CACD;AAMQ,WAAAE,EAAkB1B,IAAuC,IAAI;;AAQhE,IANJhP,EAAO,UAAU;AAAA,MACf,cAAajU,IAAAijB,EAAQ,SAAR,OAAAjjB,IAAgB;AAAA,MAC7B,gBAAeuE,IAAA0e,EAAQ,SAAR,OAAA1e,IAAgB;AAAA,MAC/B,4BAA2BhB,IAAA0f,EAAQ,iBAAR,OAAA1f,IAAwB;AAAA,IAAA,GAGjD4Y,EAAM,SAAS,UAAU,oBAC7BA,EAAM,SAAS,QAAQ,iBAEvBlI,EAAO,SAAS,SAChB0P,EAAoB,SAAS;AAAA,EAC/B;AAEA,WAASO,IAAmB;AACtB,IAAA/H,EAAM,SAAS,UAAU,oBAC7BA,EAAM,SAAS,QAAQ,WACvBwH,EAAoB,WAAW;AAAA,EACjC;AAEA,SAAO,EAAE,oBAAAL,GAAoB,cAAAC,GAAc,mBAAAoB,GAAmB,kBAAAT,EAAiB;AACjF;AAMA,SAASR,GACP/B,GACAC,GACA2B,GACAnlB,GACAiR,GACAgN,GACAuI,GACAC,GACA;AACA,MAAI,CAACtB,EAAa;AAAO;AACzB,QAAMnB,IAAMmB,EAAa,OACnBa,IAAO1C,GAAiCC,GAAKC,GAAUQ,EAAI,GAAG,GAC9DiC,IAAO3C,GAAiCC,GAAKC,GAAU;AAAA,IAC3D,GAAGQ,EAAI,IAAI,IAAIA,EAAI,KAAK;AAAA,IACxB,GAAGA,EAAI,IAAI,IAAIA,EAAI,KAAK;AAAA,EAAA,CACzB,GAGK0C,IAAgB,IAAI;AAAA,IACxB,OAAO,QAAQ1mB,CAAa,EACzB,OAAO,CAAC,CAACqT,GAAG9S,CAAG,MACPylB,EAAK,KAAKzlB,EAAI,KAAKA,EAAI,KAAK0lB,EAAK,KAAKD,EAAK,KAAKzlB,EAAI,KAAKA,EAAI,KAAK0lB,EAAK,CAC/E,EACA,IAAI,CAAC,CAACplB,GAAQwS,CAAC,MAAMxS,CAAM;AAAA,EAAA;AAGhC,MAAI4lB,MAAkB;AACpB,IAAAxI,EAAc,QAAQ,CAAUpd,MAAA;AAC9B,MAAK6lB,EAAc,IAAI7lB,CAAM,KAC3Bod,EAAc,OAAOpd,CAAM;AAAA,IAC7B,CACD,GACD6lB,EAAc,QAAQ,CAAU7lB,MAAA;;AAC9B,YAAMoe,KAAa9Y,KAAAvE,IAAAqP,EAAWpQ,CAAM,MAAjB,gBAAAe,EAAoB,eAApB,OAAAuE,IAAkC;AACrD,OACE8Y,MAAe,MACd,OAAOA,KAAe,YAAYhB,EAAc,OAAOgB,MAExDhB,EAAc,IAAIpd,CAAM;AAAA,IAC1B,CACD;AAAA,OACI;AAEC,UAAA8lB,IAAY,IAAI,IAAYH,CAA4B;AAC9D,IAAAG,EAAU,QAAQ,CAAU9lB,MAAA;AACtB,MAAA6lB,EAAc,IAAI7lB,CAAM,KAC1B8lB,EAAU,OAAO9lB,CAAM;AAAA,IACzB,CACD,GACD6lB,EAAc,QAAQ,CAAU7lB,MAAA;;AAC9B,UAAI,CAAC2lB,EAA6B,IAAI3lB,CAAM,GAAG;AAC7C,cAAMoe,KAAa9Y,KAAAvE,IAAAqP,EAAWpQ,CAAM,MAAjB,gBAAAe,EAAoB,eAApB,OAAAuE,IAAkC;AACrD,SACE8Y,MAAe,MACd,OAAOA,KAAe,YAAY0H,EAAU,OAAO1H,MAEpD0H,EAAU,IAAI9lB,CAAM;AAAA,MAExB;AAAA,IAAA,CACD,GAEDod,EAAc,MAAM,GACpB0I,EAAU,QAAQ,CAAA9lB,MAAUod,EAAc,IAAIpd,CAAM,CAAC;AAAA,EACvD;AACF;AAUA,MAAM2kB,GAAsB;AAAA,EAS1B,YACEtE,GACAuE,GACAC,GACAC,GACAC,GACAC,GACA;AACA,SAAK,aAAa3E,GAClB,KAAK,0BAA0BuE,GAC/B,KAAK,wBAAwBC,GAC7B,KAAK,0BAA0BC,GAC/B,KAAK,oBAAoBC,GACzB,KAAK,sBAAsBC,GAC3B,KAAK,eAAe,CAACnkB,MAAwBA,EAAM,gBAAgB;AAAA,EACrE;AAAA,EAEA,WAAW;AACT,UAAMmjB,IAAU,EAAE,SAAS,IAAM,SAAS,GAAM,GAC1C3D,IAAY5jB,EAAQ,KAAK,WAAW,OAAO,WAAW;AAC5D,IAAA4jB,EAAU,iBAAiB,eAAe,KAAK,yBAAyB2D,CAAO,GAC/E3D,EAAU,iBAAiB,SAAS,KAAK,mBAAmB2D,CAAO,GACnE3D,EAAU,iBAAiB,gBAAgB,KAAK,cAAc2D,CAAO,GACrE3D,EAAU,iBAAiB,gBAAgB,KAAK,cAAc2D,CAAO,GACrE,SAAS,iBAAiB,WAAW,KAAK,qBAAqBA,CAAO;AAAA,EACxE;AAAA,EAEA,WAAW;AACT,UAAMA,IAAU,EAAE,SAAS,IAAM,SAAS,GAAM;AAChD,aAAS,iBAAiB,eAAe,KAAK,yBAAyBA,CAAO,GAC9E,SAAS,iBAAiB,aAAa,KAAK,uBAAuBA,CAAO;AAAA,EAC5E;AAAA,EAEA,aAAa;AACL,UAAAA,IAAU,EAAE,SAAS;AAC3B,aAAS,oBAAoB,eAAe,KAAK,yBAAyBA,CAAO,GACjF,SAAS,oBAAoB,aAAa,KAAK,uBAAuBA,CAAO;AAAA,EAC/E;AAAA,EAEA,aAAa;AACX,SAAK,WAAW;AACV,UAAAA,IAAU,EAAE,SAAS;AACvB,QAAA,KAAK,WAAW,OAAO;AACnB,YAAA3D,IAAY,KAAK,WAAW;AAClC,MAAAA,EAAU,oBAAoB,eAAe,KAAK,yBAAyB2D,CAAO,GAClF3D,EAAU,oBAAoB,SAAS,KAAK,mBAAmB2D,CAAO,GACtE3D,EAAU,oBAAoB,gBAAgB,KAAK,cAAc2D,CAAO,GACxE3D,EAAU,oBAAoB,gBAAgB,KAAK,cAAc2D,CAAO,GACxE,SAAS,oBAAoB,WAAW,KAAK,qBAAqBA,CAAO;AAAA,IAC3E;AAAA,EACF;AACF;AAEA,MAAMyB,GAAkB;AAAA,EAMtB,YACEpF,GACA2E,GACAe,GACA;AACA,SAAK,aAAa1F,GAClB,KAAK,sBAAsB2E,GAC3B,KAAK,oBAAoBe,GACpB,KAAA,kBAAkB,CAACllB,MAAsB;AAC5C,MAAAA,EAAM,gBAAgB,GACtBA,EAAM,eAAe;AAAA,IAAA;AAAA,EAEzB;AAAA,EAEA,WAAW;AACA,aAAA,iBAAiB,WAAW,KAAK,qBAAqB,EAAE,SAAS,IAAM,SAAS,GAAA,CAAM;AAAA,EACjG;AAAA,EAEA,WAAW;AACA,aAAA,iBAAiB,SAAS,KAAK,mBAAmB,EAAE,SAAS,IAAM,SAAS,GAAA,CAAM,GACzEpE,EAAQ,KAAK,WAAW,OAAO,WAAW,EAClD,iBAAiB,eAAe,KAAK,iBAAiB,EAAE,SAAS,IAAO;AAAA,EACpF;AAAA,EAEA,aAAa;AACX,aAAS,oBAAoB,SAAS,KAAK,mBAAmB,EAAE,SAAS,IAAM,GAC3E,KAAK,WAAW,SACA,KAAK,WAAW,MACxB,oBAAoB,eAAe,KAAK,eAAe;AAAA,EAErE;AAAA,EAEA,aAAa;AACX,SAAK,WAAW,GAChB,SAAS,oBAAoB,WAAW,KAAK,qBAAqB,EAAE,SAAS,IAAM;AAAA,EACrF;AACF;AClZA,MAAMupB,KAAwB,OAAO,oBAAoB;AAElD,SAASC,GACd5F,GACA7I,GACA6F,GACAjN,GACAE,GACAoI,GACA0E,GACA8B,GACAmC,GACAlE,GACA8B,GACAmC,GACAE,GACAhB,GACA3iB,GACA0B,GACoB;AACpB,QAAM6d,IAA0B;AAAA,IAC9B,eAAe9E,EAAI,WAAW;AAAA,IAC9B,UAAUA,EAAI,SAAS;AAAA,EAAA;AAGrB,EAAAgF,EAAc,OAAO,IACvBF,EAAM,cAAc,QAAQ,SACnBgC,EAAc,OAAO,IAC9BhC,EAAM,cAAc,QAAQ,SACnBmE,EAAc,OAAO,MAC9BnE,EAAM,cAAc,QAAQ,SAGxB5c,EAAA4c,EAAM,UAAU,CAAQe,MAAA;AACpB,IAAA5e,EAAA,KAAK,aAAa4e,CAAI;AAAA,EAAA,CAC/B,GAEiCmC,GAAAC,GAAWnD,GAAOoD,GAAuBjhB,CAAO;AAElF,QAAM6mB,IAA+BhmB,YAAA;AAAA,IACnC,eAAAkd;AAAA,IACA,cAAAD;AAAA,IACA,eAAA+B;AAAA,IACA,cAAAD;AAAA,IACA,eAAAoC;AAAA,IACA,cAAAD;AAAA,KACGnE;AAAA,IACD7M;AAAA,IACAoH;AAAA,IACA0F;AAAA,IACAC;AAAA,IACAC;AAAA,IACAC;AAAA,IACAhe;AAAA,EACF,IACG2f,GAA4B1O,GAAY4M,GAAO+B,GAAcC,GAAe7f,CAAO,IACnF8hB;AAAA,IACDzI;AAAA,IACAwE;AAAA,IACAkE;AAAA,IACAC;AAAA,IACAC;AAAA,IACAjiB;AAAA,EACF,IACG8kB;AAAA,IACD9D;AAAA,IACAnD;AAAA,IACA1F;AAAA,IACApH;AAAA,IACAgN;AAAA,IACAzf;AAAA,EACF;AAEF,SAAAZ,GAAQipB,IAAuBE,CAAQ,GAChCA;AACT;AAEO,SAASC,KAAwC;AACtD,SAAO1pB,EAAQQ,GAAO+oB,EAAqB,GAAG,oBAAoB;AACpE;ACjJe,SAAAI,GAASrnB,GAAE;AAAC,SAAM,EAAC,KAAIA,IAAEA,KAAG,oBAAI,OAAI,IAAG,SAAS,GAAEiG,GAAE;AAAC,QAAIF,IAAE/F,EAAE,IAAI,CAAC;AAAE,IAAA+F,IAAEA,EAAE,KAAKE,CAAC,IAAEjG,EAAE,IAAI,GAAE,CAACiG,CAAC,CAAC;AAAA,EAAC,GAAE,KAAI,SAAS,GAAEA,GAAE;AAAC,QAAIF,IAAE/F,EAAE,IAAI,CAAC;AAAE,IAAA+F,MAAIE,IAAEF,EAAE,OAAOA,EAAE,QAAQE,CAAC,MAAI,GAAE,CAAC,IAAEjG,EAAE,IAAI,GAAE,EAAE;AAAA,EAAE,GAAE,MAAK,SAAS,GAAEiG,GAAE;AAAC,QAAIF,IAAE/F,EAAE,IAAI,CAAC;AAAE,IAAA+F,KAAGA,EAAE,QAAQ,IAAI,SAAS/F,GAAE;AAAC,MAAAA,EAAEiG,CAAC;AAAA,IAAC,CAAC,IAAGF,IAAE/F,EAAE,IAAI,GAAG,MAAI+F,EAAE,MAAO,EAAC,IAAI,SAAS/F,GAAE;AAAC,MAAAA,EAAE,GAAEiG,CAAC;AAAA,IAAC,CAAC;AAAA,EAAC,EAAC;AAAC;ACKzT,MAAMqhB,KAAkB,OAAO,SAAS;AAEjC,SAASC,KAAuC;AAErD,QAAMjnB,IAAU+mB;AAChB,SAAArpB,GAAQspB,IAAiBhnB,CAAO,GACzBA;AACT;AAEO,SAASknB,KAAmC;AACjD,SAAO9pB,EAAQQ,GAAOopB,EAAe,GAAG,eAAe;AACzD;;;;;AChBA,IAAAG,KAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMf,eAAe,WAAY;AACzB,QAAI,OAAO,cAAe;AAAa,aAAO;AAC9C,QAAI,OAAO,QAAS;AAAa,aAAO;AACxC,QAAI,OAAO,UAAW;AAAa,aAAO;AAC1C,QAAI,OAAOC,MAAW;AAAa,aAAOA;AAE1C,QAAI,OAAO,QAAS;AAAa,aAAO;AACxC,UAAM,IAAI,MAAM,gCAAgC;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,QAAQ,SAAUtpB,GAAQ4E,GAAQ;AAChC,IAAA5E,IAASA,KAAU;AACnB,aAASupB,KAAQ3kB;AAEf,MAAI,KAAK,SAASA,EAAO2kB,CAAI,CAAC,IAC5BvpB,EAAOupB,CAAI,IAAI,KAAK,OAAOvpB,EAAOupB,CAAI,GAAG3kB,EAAO2kB,CAAI,CAAC,IAErDvpB,EAAOupB,CAAI,IAAI3kB,EAAO2kB,CAAI;AAG9B,WAAOvpB;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,WAAW,SAAUwpB,GAAG;AACtB,WACEA,aAAa,eACbA,aAAa,cACbA,aAAa;AAAA,IACZA,KACC,OAAOA,KAAM,YACbA,MAAM,QACNA,EAAE,aAAa,KACf,OAAOA,EAAE,YAAa;AAAA,EAE3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,UAAU,SAAUA,GAAG;AACrB,WAAO,OAAO,UAAU,SAAS,KAAKA,CAAC,MAAM;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,UAAU,SAAU5nB,GAAG;AACrB,WAAO,CAAC,MAAM,WAAWA,CAAC,CAAC,KAAK,SAASA,CAAC;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,QAAQ,SAAU6nB,GAAmB;AACnC,QAAI3D,GAASP;AAEb,QAAK,KAAK,UAAUkE,CAAiB;AAqBnC,MAAA3D,IAAU2D;AAAA,aAlBR,OAAOA,KAAsB,YAC7BA,aAA6B;AAK7B,UAFA3D,IAAU,SAAS,cAAc2D,CAAiB,GAE9C,CAAC3D;AACH,cAAM,IAAI;AAAA,UACR,4DACE2D;AAAA,QACd;AAAA;AAIQ,YAAM,IAAI,MAAM,oDAAoD;AAOxE,QAAI3D,EAAQ,QAAQ,YAAW,MAAO;AACpC,MAAAP,IAAMO;AAAA,aAEFA,EAAQ,QAAQ,YAAW,MAAO;AACpC,MAAAP,IAAMO,EAAQ,gBAAgB;AAAA,aAE1BA,EAAQ,QAAQ,YAAW,MAAO;AACpC,MAAAP,IAAMO,EAAQ,eAAgB,EAAC;AAAA;AAE/B,YAAIA,EAAQ,QAAQ,YAAW,MAAO,QAC9B,IAAI;AAAA,QACR;AAAA,MACd,IAEkB,IAAI,MAAM,iBAAiB;AAOzC,WAAOP;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,OAAO,SAAUmE,GAAIC,GAAS;AAC5B,WAAO,WAAY;AACjB,aAAOD,EAAG,MAAMC,GAAS,SAAS;AAAA,IACxC;AAAA,EACG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,SAAS,SAAUH,GAAG;AACpB,WAAO,OAAO,UAAU,SACrB,MAAMA,CAAC,EACP,QAAQ,eAAe,EAAE,EACzB,QAAQ,OAAO,EAAE;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,wBAAwB,SAAUI,GAAKrE,GAAK;AAE1C,QAAIqE,EAAI,YAAY,UAAUA,EAAI,YAAY;AAM5C,UAJAA,EAAI,UAAU,GACdA,EAAI,UAAU,GAGVA,EAAI,YAAY,UAAUA,EAAI,QAAQ;AACxC,YAAIA,EAAI,QAAQ,CAAC,EAAE,YAAY;AAC7B,UAAAA,EAAI,UAAUA,EAAI,QAAQ,CAAC,EAAE,SAC7BA,EAAI,UAAUA,EAAI,QAAQ,CAAC,EAAE;AAAA,iBACpBA,EAAI,QAAQ,CAAC,EAAE,UAAU,QAAQ;AAC1C,cAAIjb,IAAO4W,EAAI;AAEf,UAAAqE,EAAI,UAAUA,EAAI,QAAQ,CAAC,EAAE,QAAQjb,EAAK,MAC1Cib,EAAI,UAAUA,EAAI,QAAQ,CAAC,EAAE,QAAQjb,EAAK;AAAA,QAC3C;AAAA;AAEI,QAAIib,EAAI,kBAAkB,UAC3BA,EAAI,cAAc,YAAY,WAChCA,EAAI,UAAUA,EAAI,cAAc,SAChCA,EAAI,UAAUA,EAAI,cAAc;AAAA,EAIvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,gBAAgB,SAAUA,GAAKrE,GAAKsE,GAAO;AAEzC,QAAID,EAAI,YAAY,UAAUA,EAAI,QAAQ;AACxC,UAAIA,EAAI,QAAQC,CAAK,EAAE,YAAY;AACjC,QAAAD,EAAI,UAAUA,EAAI,QAAQC,CAAK,EAAE,SACjCD,EAAI,UAAUA,EAAI,QAAQC,CAAK,EAAE;AAAA,eACxBD,EAAI,QAAQC,CAAK,EAAE,UAAU,QAAQ;AAC9C,YAAIlb,IAAO4W,EAAI;AAEf,QAAAqE,EAAI,UAAUA,EAAI,QAAQC,CAAK,EAAE,QAAQlb,EAAK,MAC9Cib,EAAI,UAAUA,EAAI,QAAQC,CAAK,EAAE,QAAQlb,EAAK;AAAA,MAC/C;AAAA;AAID,OAAIib,EAAI,YAAY,UAAUA,EAAI,YAAY,UAE5CA,EAAI,UAAU,GACdA,EAAI,UAAU,GACVA,EAAI,kBAAkB,UACpBA,EAAI,cAAc,YAAY,WAChCA,EAAI,UAAUA,EAAI,cAAc,SAChCA,EAAI,UAAUA,EAAI,cAAc;AAAA,EAKzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWD,YAAY,SAAUA,GAAKE,GAAS;AAElC,QAAIF,EAAI,WAAW;AACjB,aAAO;AAGJ,QAA0BE,KAAY,MAAM;AAC/C,UAAIC,IAAgBH,EAAI,YAAYE,EAAQ,WAC1CE,IAAkB,KAAK;AAAA,QACrB,KAAK,IAAIJ,EAAI,UAAUE,EAAQ,SAAS,CAAC,IACvC,KAAK,IAAIF,EAAI,UAAUE,EAAQ,SAAS,CAAC;AAAA,MACrD;AAEM,aAAOC,IAAgB,OAAOC,IAAkB;AAAA,IACjD;AAGD,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,KACE,KAAK,OACL,WAAY;AACV,YAAO,oBAAI,QAAO;EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQH,UAAU,SAAUC,GAAMC,GAAMrD,GAAS;AACvC,QAAIsD,IAAO,MACPR,GAASS,GAAM5oB,GACf6oB,IAAU,MACVC,IAAW;AACf,IAAKzD,MACHA,IAAU,CAAA;AAEZ,QAAI0D,IAAQ,WAAY;AACtB,MAAAD,IAAWzD,EAAQ,YAAY,KAAQ,IAAIsD,EAAK,OAChDE,IAAU,MACV7oB,IAASyoB,EAAK,MAAMN,GAASS,CAAI,GAC5BC,MACHV,IAAUS,IAAO;AAAA,IAEzB;AACI,WAAO,WAAY;AACjB,UAAIzK,IAAMwK,EAAK;AACf,MAAI,CAACG,KAAYzD,EAAQ,YAAY,OACnCyD,IAAW3K;AAEb,UAAI6K,IAAYN,KAAQvK,IAAM2K;AAC9B,aAAAX,IAAU,MACVS,IAAO,WACHI,KAAa,KAAKA,IAAYN,KAChC,aAAaG,CAAO,GACpBA,IAAU,MACVC,IAAW3K,GACXne,IAASyoB,EAAK,MAAMN,GAASS,CAAI,GAC5BC,MACHV,IAAUS,IAAO,SAEV,CAACC,KAAWxD,EAAQ,aAAa,OAC1CwD,IAAU,WAAWE,GAAOC,CAAS,IAEhChpB;AAAA,IACb;AAAA,EACG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,6BAA6B,SAAUipB,GAAa;AAClD,QAAIJ,IAAU;AAOd,WAJII,MAAgB,UAAUA,IAAc,MAAMA,IAAc,MAC9DJ,IAAU,KAAK,MAAM,MAAOI,CAAW,IAGrCJ,MAAY,OACP,OAAO,yBAAyBK,GAAe,EAAE,IAEjDA,GAAeL,CAAO;AAAA,EAEhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,mBAAmB,SAAUM,GAAQC,GAAQ;AAC3C,QAAIpiB,IAAKmiB,EAAO,IAAIC,EAAO,GACvBniB,IAAKkiB,EAAO,IAAIC,EAAO;AAC3B,WAAO,KAAK,KAAKpiB,IAAKA,IAAKC,IAAKA,CAAE;AAAA,EACnC;AACH;AAQA,SAASiiB,GAAeL,GAAS;AAC/B,SAAO,SAAUhqB,GAAU;AACzB,WAAO,WAAWA,GAAUgqB,CAAO;AAAA,EACvC;AACA;ACnWA,IAAIQ,KAAQC,IAEZC,KAAkB,WAAW;AAG3B,MAAIC,IAAS,IACXC,GACAC,GACAC,GACAC,IAAM,CAAA,GACJC,IAAoB,EAAE,SAAS,MAC/BC,IAAqB,EAAE,SAAS;AAGpC,EAAIT,GAAM,cAAe,EAAC,oBACxBI,IAAoB,oBACpBC,IAAuB,0BAEvBD,IAAoB,eACpBC,IAAuB,eACvBF,IAAS;AAGX,WAASO,IAAa;AACpB,WAAKJ,MACHA,IACE,aAAa,SAAS,cAAc,KAAK,IACrC,UACA,SAAS,iBAAiB,SAC1B,eACA,mBAEDA;AAAA,EACR;AAED,WAASK,EAAe1F,GAASzlB,GAAU;AAGzC,QAAIqpB,IAAK,SAAS+B,GAAe;AAC/B,OAACA,MAAkBA,IAAgB,OAAO;AAG1C,UAAI/nB,IAAQ;AAAA;AAAA,QAEV,eAAe+nB;AAAA,QACf,QAAQA,EAAc,UAAUA,EAAc;AAAA,QAC9C,MAAM;AAAA,QACN,WAAWA,EAAc,QAAQ,wBAAwB,IAAI;AAAA,QAC7D,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,gBAAgB,WAAW;AACzB,UAAAA,EAAc,iBACVA,EAAc,eAAgB,IAC7BA,EAAc,cAAc;AAAA,QAClC;AAAA,MACT;AAGM,aAAIF,EAAY,KAAI,gBAClB7nB,EAAM,SAAU,SAAW+nB,EAAc,YAEzCA,EAAc,gBACX/nB,EAAM,SAAU,SAAW+nB,EAAc,gBAE5C/nB,EAAM,SAAS+nB,EAAc,QAIxBprB,EAASqD,CAAK;AAAA,IAC3B;AAEI,WAAA0nB,EAAI,KAAK;AAAA,MACP,SAAStF;AAAA,MACT,IAAI4D;AAAA,IACV,CAAK,GAEMA;AAAA,EACR;AAED,WAASgC,EAAY5F,GAAS;AAC5B,aAASne,IAAI,GAAGA,IAAIyjB,EAAI,QAAQzjB;AAC9B,UAAIyjB,EAAIzjB,CAAC,EAAE,YAAYme;AACrB,eAAOsF,EAAIzjB,CAAC,EAAE;AAGlB,WAAO,WAAW;AAAA,IAAA;AAAA,EACnB;AAED,WAASgkB,EAAe7F,GAAS;AAC/B,aAASne,IAAI,GAAGA,IAAIyjB,EAAI,QAAQzjB;AAC9B,UAAIyjB,EAAIzjB,CAAC,EAAE,YAAYme;AACrB,eAAOsF,EAAI,OAAOzjB,GAAG,CAAC;AAAA,EAG3B;AAED,WAASikB,EAAkBC,GAAMC,GAAWzrB,GAAU0rB,GAAmB;AACvE,QAAIC;AAEJ,IAAIT,EAAY,MAAK,UACnBS,IAAK3rB,IAEL2rB,IAAKR,EAAeK,GAAMxrB,CAAQ,GAGpCwrB,EAAKZ,CAAiB;AAAA,MACpBD,IAASc;AAAA,MACTE;AAAA,MACAD,IAAoBV,IAAoBC;AAAA,IAC9C;AAAA,EACG;AAED,WAASW,EAAqBJ,GAAMC,GAAWzrB,GAAU0rB,GAAmB;AAC1E,QAAIC;AAEJ,IAAIT,EAAY,MAAK,UACnBS,IAAK3rB,IAEL2rB,IAAKN,EAAYG,CAAI,GAGvBA,EAAKX,CAAoB;AAAA,MACvBF,IAASc;AAAA,MACTE;AAAA,MACAD,IAAoBV,IAAoBC;AAAA,IAC9C,GAEIK,EAAeE,CAAI;AAAA,EACpB;AAED,WAASK,EAAiBL,GAAMxrB,GAAU0rB,GAAmB;AAC3D,IAAAH,EAAkBC,GAAMN,EAAY,GAAElrB,GAAU0rB,CAAiB,GAG7DR,EAAY,KAAI,oBAClBK;AAAA,MACEC;AAAA,MACA;AAAA,MACAxrB;AAAA,MACA0rB;AAAA,IACR;AAAA,EAEG;AAED,WAASI,EAAoBN,GAAMxrB,GAAU0rB,GAAmB;AAC9D,IAAAE,EAAqBJ,GAAMN,EAAY,GAAElrB,GAAU0rB,CAAiB,GAGhER,EAAY,KAAI,oBAClBU;AAAA,MACEJ;AAAA,MACA;AAAA,MACAxrB;AAAA,MACA0rB;AAAA,IACR;AAAA,EAEG;AAED,SAAO;AAAA,IACL,IAAIG;AAAA,IACJ,KAAKC;AAAA,EACT;AACA,EAAI,GCtKAtB,KAAQC,IACVsB,KAAW;AAAA;AAKV,OAAO,YAAY,eAAiB,SAAS,iBAG9CA,KAAW;AAGb,IAAAC,KAAiB;AAAA,EACf,OAAO;AAAA,EACP,OAAO;AAAA,EACP,SAAS;AAAA,EACT,SAAS;AAAA,EACT,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQN,iCAAiC,SAAU9G,GAAK;AAC9C,QAAIA,EAAI,eAAeA,EAAI;AACzB,aAAO,EAAE,OAAOA,EAAI,aAAa,QAAQA,EAAI;AACxC,QAAMA,EAAI;AACf,aAAOA,EAAI;AAEX,UAAM,IAAI,MAAM,wCAAwC;AAAA,EAE3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,qBAAqB,SAAUA,GAAK+G,GAAU;AAC5C,QAAI9G,IAAW;AASf,QAPIqF,GAAM,UAAUyB,CAAQ,IAC1B9G,IAAW8G,IAEX9G,IAAWD,EAAI,cAAc+G,CAAQ,GAInC,CAAC9G,GAAU;AACb,UAAI+G,IAAa,MAAM,UAAU,MAC9B,KAAKhH,EAAI,cAAcA,EAAI,QAAQ,EACnC,OAAO,SAAUiH,GAAI;AACpB,eAAOA,EAAG,aAAa,UAAUA,EAAG,aAAa;AAAA,MAC3D,CAAS;AAIH,MACED,EAAW,WAAW,KACtBA,EAAW,CAAC,EAAE,aAAa,OAC3BA,EAAW,CAAC,EAAE,aAAa,WAAW,MAAM,SAE5C/G,IAAW+G,EAAW,CAAC;AAAA,IAE1B;AAGD,QAAI,CAAC/G,GAAU;AACb,UAAIiH,IACF,eAAc,oBAAI,QAAO,YAAa,EAAC,QAAQ,OAAO,EAAE;AAC1D,MAAAjH,IAAW,SAAS,gBAAgB,KAAK,OAAO,GAAG,GACnDA,EAAS,aAAa,MAAMiH,CAAU;AAGtC,UAAIC,IAAcnH,EAAI,cAAcA,EAAI;AACxC,UAAMmH,KAAeA,EAAY,SAAS;AACxC,iBAAS/kB,IAAI+kB,EAAY,QAAQ/kB,IAAI,GAAGA;AAEtC,UAAI+kB,EAAYA,EAAY,SAAS/kB,CAAC,EAAE,aAAa,UACnD6d,EAAS,YAAYkH,EAAYA,EAAY,SAAS/kB,CAAC,CAAC;AAI9D,MAAA4d,EAAI,YAAYC,CAAQ;AAAA,IACzB;AAGD,QAAImH,IAAa,CAAA;AACjB,WAAInH,EAAS,aAAa,OAAO,MAC/BmH,IAAanH,EAAS,aAAa,OAAO,EAAE,MAAM,GAAG,IAIlD,CAACmH,EAAW,QAAQ,uBAAuB,MAC9CA,EAAW,KAAK,uBAAuB,GACvCnH,EAAS,aAAa,SAASmH,EAAW,KAAK,GAAG,CAAC,IAG9CnH;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,oBAAoB,SAAUD,GAAK;AAOjC,QALAA,EAAI,aAAa,SAAS,KAAK,KAAK,GACpCA,EAAI,eAAe,KAAK,SAAS,eAAe,KAAK,OAAO,GAC5DA,EAAI,eAAe,KAAK,SAAS,YAAY,KAAK,IAAI,GAGlDA,EAAI,eAAe,MAAM;AAC3B,UAAI3kB,IAAQ2kB,EAAI,aAAa,OAAO,KAAK;AACzC,MAAI3kB,EAAM,YAAa,EAAC,QAAQ,UAAU,MAAM,MAC9C2kB,EAAI,aAAa,SAAS,uBAAuB3kB,CAAK;AAAA,IAEzD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKD,mCAAmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAanC,mBAAmBiqB,GAAM;AAAA,IACvB,WAAY;AAGV,eAFI+B,IAAU,SAAS,iBAAiB,MAAM,GAC1CC,IAAeD,EAAQ,QAClBjlB,IAAI,GAAGA,IAAIklB,GAAcllB,KAAK;AACrC,YAAImlB,IAAWF,EAAQjlB,CAAC;AACxB,QAAAmlB,EAAS,WAAW,aAAaA,GAAUA,CAAQ;AAAA,MACpD;AAAA,IACF;AAAA,IACDC,KAAOA,GAAK,oCAAoC;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,QAAQ,SAAUjH,GAASkH,GAAQC,GAAM;AACvC,QAAI9C,IAAO,MACTxoB,IACE,YACAqrB,EAAO,IACP,MACAA,EAAO,IACP,MACAA,EAAO,IACP,MACAA,EAAO,IACP,MACAA,EAAO,IACP,MACAA,EAAO,IACP;AAEJ,IAAAlH,EAAQ,eAAe,MAAM,aAAankB,CAAC,GACvC,eAAemkB,EAAQ,QACzBA,EAAQ,MAAM,YAAYnkB,IACjB,mBAAmBmkB,EAAQ,QACpCA,EAAQ,MAAM,eAAe,IAAInkB,IACxB,uBAAuBmkB,EAAQ,UACxCA,EAAQ,MAAM,mBAAmB,IAAInkB,IAMnCyqB,OAAa,QAAUa,MAEzBA,EAAK,WAAW,aAAaA,GAAMA,CAAI,GAIvC,OAAO,WAAW,WAAY;AAC5B,MAAA9C,EAAK,kBAAiB;AAAA,IAC9B,GAASA,EAAK,iCAAiC;AAAA,EAE5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,eAAe,SAAUP,GAAKrE,GAAK;AACjC,QAAI5V,IAAQ4V,EAAI;AAEhBsF,WAAAA,GAAM,uBAAuBjB,GAAKrE,CAAG,GAErC5V,EAAM,IAAIia,EAAI,SACdja,EAAM,IAAIia,EAAI,SAEPja;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,eAAe,SAAUia,GAAKrE,GAAKsE,GAAO;AACxC,QAAIla,IAAQ4V,EAAI;AAEhBsF,WAAAA,GAAM,eAAejB,GAAKrE,GAAKsE,CAAK,GAEpCla,EAAM,IAAIia,EAAI,SACdja,EAAM,IAAIia,EAAI,SAEPja;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,mBAAmB,SAAU4V,GAAK9d,GAAOylB,GAAQ;AAC/C,WAAO,KAAK,eAAe3H,GAAK9d,IAAQ,GAAGylB,IAAS,CAAC;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,gBAAgB,SAAU3H,GAAK9a,GAAGC,GAAG;AACnC,QAAIiF,IAAQ4V,EAAI;AAChB,WAAA5V,EAAM,IAAIlF,GACVkF,EAAM,IAAIjF,GAEHiF;AAAA,EACR;AACH,GCtQIwd,KAAWrC,IAEfsC,KAAiB;AAAA,EACf,QAAQ,SAAUC,GAAU;AAE1B,QAAIJ,IAAOI,EAAS,IAAI,cAAc,MAAM;AAC5C,IAAKJ,MACHA,IAAO,SAAS,gBAAgBE,GAAS,OAAO,MAAM,GACtDE,EAAS,IAAI,YAAYJ,CAAI;AAI/B,QAAIK,IAAUL,EAAK,cAAc,oCAAoC;AACrE,QAAI,CAACK,GAAS;AACZ,UAAI1sB,IAAQ,SAAS,gBAAgBusB,GAAS,OAAO,OAAO;AAC5D,MAAAvsB,EAAM,aAAa,MAAM,8BAA8B,GACvDA,EAAM,aAAa,QAAQ,UAAU,GACrCA,EAAM,cACJ,gQACFqsB,EAAK,YAAYrsB,CAAK;AAAA,IACvB;AAGD,QAAI2sB,IAAY,SAAS,gBAAgBJ,GAAS,OAAO,GAAG;AAC5D,IAAAI,EAAU,aAAa,MAAM,uBAAuB,GACpDA,EAAU;AAAA,MACR;AAAA,MACA,gBACGF,EAAS,QAAQ,MAClB,OACCA,EAAS,SAAS,MACnB;AAAA,IACR,GACIE,EAAU,aAAa,SAAS,sBAAsB,GAGtDA,EAAU,YAAY,KAAK,cAAcF,CAAQ,CAAC,GAClDE,EAAU,YAAY,KAAK,iBAAiBF,CAAQ,CAAC,GACrDE,EAAU,YAAY,KAAK,eAAeF,CAAQ,CAAC,GAGnDA,EAAS,IAAI,YAAYE,CAAS,GAGlCF,EAAS,eAAeE;AAAA,EACzB;AAAA,EAED,eAAe,SAAUF,GAAU;AACjC,QAAIG,IAAS,SAAS,gBAAgBL,GAAS,OAAO,GAAG;AACzD,IAAAK,EAAO,aAAa,MAAM,sBAAsB,GAChDA,EAAO,aAAa,aAAa,gCAAgC,GACjEA,EAAO,aAAa,SAAS,sBAAsB,GACnDA,EAAO;AAAA,MACL;AAAA,MACA,WAAY;AACV,QAAAH,EAAS,oBAAoB;MAC9B;AAAA,MACD;AAAA,IACN,GACIG,EAAO;AAAA,MACL;AAAA,MACA,WAAY;AACV,QAAAH,EAAS,oBAAoB;MAC9B;AAAA,MACD;AAAA,IACN;AAEI,QAAII,IAAmB,SAAS,gBAAgBN,GAAS,OAAO,MAAM;AACtE,IAAAM,EAAiB,aAAa,KAAK,GAAG,GACtCA,EAAiB,aAAa,KAAK,GAAG,GACtCA,EAAiB,aAAa,SAAS,MAAM,GAC7CA,EAAiB,aAAa,UAAU,MAAM,GAC9CA,EAAiB,aAAa,SAAS,iCAAiC,GACxED,EAAO,YAAYC,CAAgB;AAEnC,QAAIC,IAAc,SAAS,gBAAgBP,GAAS,OAAO,MAAM;AACjE,WAAAO,EAAY;AAAA,MACV;AAAA,MACA;AAAA,IACN,GACIA,EAAY,aAAa,SAAS,8BAA8B,GAChEF,EAAO,YAAYE,CAAW,GAEvBF;AAAA,EACR;AAAA,EAED,kBAAkB,SAAUH,GAAU;AAEpC,QAAIM,IAAsB,SAAS,gBAAgBR,GAAS,OAAO,GAAG;AACtE,IAAAQ,EAAoB,aAAa,MAAM,6BAA6B,GACpEA,EAAoB,aAAa,aAAa,4BAA4B,GAC1EA,EAAoB,aAAa,SAAS,sBAAsB,GAChEA,EAAoB;AAAA,MAClB;AAAA,MACA,WAAY;AACV,QAAAN,EAAS,oBAAoB;MAC9B;AAAA,MACD;AAAA,IACN,GACIM,EAAoB;AAAA,MAClB;AAAA,MACA,WAAY;AACV,QAAAN,EAAS,oBAAoB;MAC9B;AAAA,MACD;AAAA,IACN;AAEI,QAAIO,IAAgC,SAAS;AAAA,MAC3CT,GAAS;AAAA,MACT;AAAA,IACN;AACI,IAAAS,EAA8B,aAAa,KAAK,GAAG,GACnDA,EAA8B,aAAa,KAAK,GAAG,GACnDA,EAA8B,aAAa,SAAS,KAAK,GACzDA,EAA8B,aAAa,UAAU,IAAI,GACzDA,EAA8B;AAAA,MAC5B;AAAA,MACA;AAAA,IACN,GACID,EAAoB,YAAYC,CAA6B;AAE7D,QAAIC,IAA4B,SAAS;AAAA,MACvCV,GAAS;AAAA,MACT;AAAA,IACN;AACI,IAAAU,EAA0B;AAAA,MACxB;AAAA,MACA;AAAA,IACN,GACIA,EAA0B;AAAA,MACxB;AAAA,MACA;AAAA,IACN,GACIF,EAAoB,YAAYE,CAAyB;AAEzD,QAAIC,IAA4B,SAAS;AAAA,MACvCX,GAAS;AAAA,MACT;AAAA,IACN;AACI,WAAAW,EAA0B;AAAA,MACxB;AAAA,MACA;AAAA,IACN,GACIA,EAA0B;AAAA,MACxB;AAAA,MACA;AAAA,IACN,GACIH,EAAoB,YAAYG,CAAyB,GAElDH;AAAA,EACR;AAAA,EAED,gBAAgB,SAAUN,GAAU;AAElC,QAAIU,IAAU,SAAS,gBAAgBZ,GAAS,OAAO,GAAG;AAC1D,IAAAY,EAAQ,aAAa,MAAM,uBAAuB,GAClDA,EAAQ,aAAa,aAAa,iCAAiC,GACnEA,EAAQ,aAAa,SAAS,sBAAsB,GACpDA,EAAQ;AAAA,MACN;AAAA,MACA,WAAY;AACV,QAAAV,EAAS,oBAAoB;MAC9B;AAAA,MACD;AAAA,IACN,GACIU,EAAQ;AAAA,MACN;AAAA,MACA,WAAY;AACV,QAAAV,EAAS,oBAAoB;MAC9B;AAAA,MACD;AAAA,IACN;AAEI,QAAIW,IAAoB,SAAS,gBAAgBb,GAAS,OAAO,MAAM;AACvE,IAAAa,EAAkB,aAAa,KAAK,GAAG,GACvCA,EAAkB,aAAa,KAAK,GAAG,GACvCA,EAAkB,aAAa,SAAS,MAAM,GAC9CA,EAAkB,aAAa,UAAU,MAAM,GAC/CA,EAAkB,aAAa,SAAS,iCAAiC,GACzED,EAAQ,YAAYC,CAAiB;AAErC,QAAIC,IAAe,SAAS,gBAAgBd,GAAS,OAAO,MAAM;AAClE,WAAAc,EAAa;AAAA,MACX;AAAA,MACA;AAAA,IACN,GACIA,EAAa,aAAa,SAAS,8BAA8B,GACjEF,EAAQ,YAAYE,CAAY,GAEzBF;AAAA,EACR;AAAA,EAED,SAAS,SAAUV,GAAU;AAC3B,IAAIA,EAAS,iBACXA,EAAS,aAAa,WAAW,YAAYA,EAAS,YAAY,GAClEA,EAAS,eAAe;AAAA,EAE3B;AACH,GCtMIF,KAAWrC,IACbD,KAAQqD,IAENC,KAAiB,SAAU3I,GAAUqB,GAAS;AAChD,OAAK,KAAKrB,GAAUqB,CAAO;AAC7B;AAQAsH,GAAe,UAAU,OAAO,SAAU3I,GAAUqB,GAAS;AAE3D,OAAK,WAAWrB,GAChB,KAAK,UAAUqB,GAGf,KAAK,gBAAgB,EAAE,MAAM,GAAG,GAAG,GAAG,GAAG,KACzC,KAAK,cAAc,EAAE,MAAM,GAAG,GAAG,GAAG,GAAG,KAEvC,KAAK,kBAAkBgE,GAAM,MAAM,KAAK,WAAW,IAAI,GAGvD,KAAK,wBAAwBA,GAAM;AAAA,IACjC,KAAK,QAAQ;AAAA,EACjB,GAGE,KAAK,UAAU,EAAE,GAAG,GAAG,GAAG,GAAG,OAAO,GAAG,QAAQ,EAAC,GAChD,KAAK,aAAY;AAGjB,MAAIuD,IAAS,KAAK;AAGlB,OAAK,OAAOA,CAAM,GAGlB,KAAK,UAAS;AAChB;AAMAD,GAAe,UAAU,eAAe,WAAY;AAClD,MAAIE,IAAa,KAAK,QAAQ,IAAI,aAAa,SAAS;AAExD,MAAIA,GAAY;AACd,QAAIC,IAAgBD,EACjB,MAAM,QAAQ,EACd,OAAO,SAAUpuB,GAAG;AACnB,aAAOA;AAAA,IACf,CAAO,EACA,IAAI,UAAU;AAGjB,SAAK,QAAQ,IAAIquB,EAAc,CAAC,GAChC,KAAK,QAAQ,IAAIA,EAAc,CAAC,GAChC,KAAK,QAAQ,QAAQA,EAAc,CAAC,GACpC,KAAK,QAAQ,SAASA,EAAc,CAAC;AAErC,QAAIC,IAAO,KAAK;AAAA,MACd,KAAK,QAAQ,QAAQ,KAAK,QAAQ;AAAA,MAClC,KAAK,QAAQ,SAAS,KAAK,QAAQ;AAAA,IACzC;AAGI,SAAK,YAAY,OAAO,SAASA,CAAI,IAAIA,IAAO,GAChD,KAAK,YAAY,KAAK,KAAK,QAAQ,QAAQ,KAAK,QAAQ,QAAQA,KAAQ,GACxE,KAAK,YAAY,KAAK,KAAK,QAAQ,SAAS,KAAK,QAAQ,SAASA,KAAQ,GAG1E,KAAK,qBAAoB,GAEzB,KAAK,QAAQ,IAAI,gBAAgB,SAAS;AAAA,EAC9C;AACI,SAAK,mBAAkB;AAE3B;AAKAJ,GAAe,UAAU,qBAAqB,WAAY;AACxD,MAAIK,IAAO,KAAK,SAAS,QAAO;AAEhC,OAAK,QAAQ,IAAIA,EAAK,GACtB,KAAK,QAAQ,IAAIA,EAAK,GACtB,KAAK,QAAQ,QAAQA,EAAK,OAC1B,KAAK,QAAQ,SAASA,EAAK;AAC7B;AAOAL,GAAe,UAAU,aAAa,WAAY;AAChD,SAAOtD,GAAM,OAAO,CAAE,GAAE,KAAK,OAAO;AACtC;AAQAsD,GAAe,UAAU,aAAa,WAAY;AAChD,MAAIC,IAAS,KAAK;AAElB,MAAI,KAAK,QAAQ,OAAO,KAAK,QAAQ,SAAS;AAC5C,QAAIK;AACJ,IAAI,KAAK,QAAQ,MACfA,IAAW,KAAK;AAAA,MACd,KAAK,QAAQ,QAAQ,KAAK,QAAQ;AAAA,MAClC,KAAK,QAAQ,SAAS,KAAK,QAAQ;AAAA,IAC3C,IAEMA,IAAW,KAAK;AAAA,MACd,KAAK,QAAQ,QAAQ,KAAK,QAAQ;AAAA,MAClC,KAAK,QAAQ,SAAS,KAAK,QAAQ;AAAA,IAC3C,GAGIA,IAAW,SAASA,CAAQ,IAAIA,IAAW,GAE3CL,EAAO,IAAIK,GACXL,EAAO,IAAIK,GACXL,EAAO,IAAI,CAAC,KAAK,QAAQ,IAAIK,GAC7BL,EAAO,IAAI,CAAC,KAAK,QAAQ,IAAIK;AAAA,EAC9B;AAED,MAAI,KAAK,QAAQ,QAAQ;AACvB,QAAIC,KACC,KAAK,QAAQ,SACX,KAAK,QAAQ,QAAQ,KAAK,QAAQ,IAAI,KAAKN,EAAO,KACrD,KACFO,KACG,KAAK,QAAQ,UACX,KAAK,QAAQ,SAAS,KAAK,QAAQ,IAAI,KAAKP,EAAO,KACtD;AAEJ,IAAAA,EAAO,IAAIM,GACXN,EAAO,IAAIO;AAAA,EACZ;AAGD,cAAK,cAAc,OAAOP,EAAO,GACjC,KAAK,cAAc,IAAIA,EAAO,GAC9B,KAAK,cAAc,IAAIA,EAAO,GAEvBA;AACT;AAOAD,GAAe,UAAU,mBAAmB,WAAY;AACtD,SAAOtD,GAAM,OAAO,CAAE,GAAE,KAAK,aAAa;AAC5C;AAOAsD,GAAe,UAAU,WAAW,WAAY;AAC9C,SAAOtD,GAAM,OAAO,CAAE,GAAE,KAAK,WAAW;AAC1C;AAOAsD,GAAe,UAAU,UAAU,WAAY;AAC7C,SAAO,KAAK,YAAY;AAC1B;AAOAA,GAAe,UAAU,kBAAkB,WAAY;AACrD,SAAO,KAAK,YAAY,OAAO,KAAK,cAAc;AACpD;AAOAA,GAAe,UAAU,sBAAsB,SAAUttB,GAAO;AAC9D,SAAOA,IAAQ,KAAK,cAAc;AACpC;AAOAstB,GAAe,UAAU,SAAS,WAAY;AAC5C,SAAO,EAAE,GAAG,KAAK,YAAY,GAAG,GAAG,KAAK,YAAY;AACtD;AAOAA,GAAe,UAAU,SAAS,WAAY;AAC5C,MAAIS,IAAU,KAAK,QAAQ,IAAI,gBAAe;AAG9C,SAAAA,EAAQ,IAAI,KAAK,YAAY,MAC7BA,EAAQ,IAAI,GACZA,EAAQ,IAAI,GACZA,EAAQ,IAAI,KAAK,YAAY,MAC7BA,EAAQ,IAAI,KAAK,YAAY,GAC7BA,EAAQ,IAAI,KAAK,YAAY,GAEtBA;AACT;AAOAT,GAAe,UAAU,SAAS,SAAUC,GAAQ;AAClD,MAAIS,IAAW,KAAK,gBAAgBT,CAAM,GACxCU,IAAU,KAAK,eAAeV,CAAM;AAEtC,MAAIS,KAAYC,GAAS;AAmBvB,QAjBID,MAGA,KAAK,QAAQ;AAAA,MACX,KAAK,gBAAiB;AAAA,MACtB,KAAK,oBAAoBT,EAAO,CAAC;AAAA,IAC3C,MAAc,MAENA,EAAO,IAAIA,EAAO,IAAI,KAAK,YAAY,MACvCS,IAAW,OAEX,KAAK,YAAYT,CAAM,GACvB,KAAK,QAAQ,OAAO,KAAK,gBAAiB,CAAA,KAK1CU,GAAS;AACX,UAAIC,IAAa,KAAK,QAAQ,UAAU,KAAK,UAAU;AAAA,QACnD,GAAGX,EAAO;AAAA,QACV,GAAGA,EAAO;AAAA,MACpB,CAAS,GAEDY,IAAc,IACdC,IAAc;AAGhB,MAAIF,MAAe,MAEjBX,EAAO,IAAI,KAAK,OAAM,EAAG,GACzBA,EAAO,IAAI,KAAK,OAAM,EAAG,GAEzBY,IAAcC,IAAc,MACnBpE,GAAM,SAASkE,CAAU,MAE9BA,EAAW,MAAM,MAEnBX,EAAO,IAAI,KAAK,OAAM,EAAG,GACzBY,IAAc,MACLnE,GAAM,SAASkE,EAAW,CAAC,MAEpCX,EAAO,IAAIW,EAAW,IAIpBA,EAAW,MAAM,MAEnBX,EAAO,IAAI,KAAK,OAAM,EAAG,GACzBa,IAAc,MACLpE,GAAM,SAASkE,EAAW,CAAC,MAEpCX,EAAO,IAAIW,EAAW,KAMrBC,KAAeC,KAAgB,CAAC,KAAK,eAAeb,CAAM,IAC7DU,IAAU,MAEV,KAAK,YAAYV,CAAM,GACvB,KAAK,QAAQ,MAAM,KAAK,OAAQ,CAAA;AAAA,IAEnC;AAGD,KAAIS,KAAYC,MACd,KAAK,qBAAoB;AAAA,EAE5B;AACH;AAEAX,GAAe,UAAU,kBAAkB,SAAUC,GAAQ;AAC3D,SAAO,KAAK,YAAY,SAASA,EAAO;AAC1C;AAEAD,GAAe,UAAU,iBAAiB,SAAUC,GAAQ;AAC1D,SAAO,KAAK,YAAY,MAAMA,EAAO,KAAK,KAAK,YAAY,MAAMA,EAAO;AAC1E;AAOAD,GAAe,UAAU,cAAc,SAAUC,GAAQ;AACvD,OAAK,YAAY,OAAOA,EAAO,GAC/B,KAAK,YAAY,IAAIA,EAAO,GAC5B,KAAK,YAAY,IAAIA,EAAO;AAC9B;AAEAD,GAAe,UAAU,gBAAgB;AAKzCA,GAAe,UAAU,uBAAuB,WAAY;AAC1D,EAAK,KAAK,kBAER,KAAK,gBAAgB,IAGrB,KAAK,sBAAsB,KAAK,QAAQ,KAAK,eAAe;AAEhE;AAKAA,GAAe,UAAU,YAAY,WAAY;AAC/C,MAAIe,IAAM,KAAK;AAGf/B,EAAAA,GAAS,OAAO,KAAK,UAAU+B,GAAK,KAAK,IAAI,GAG7C,KAAK,gBAAgB,IAGjB,KAAK,QAAQ,gBACf,KAAK,QAAQ,aAAaA,CAAG;AAEjC;AAEA,IAAAC,KAAiB,SAAU3J,GAAUqB,GAAS;AAC5C,SAAO,IAAIsH,GAAe3I,GAAUqB,CAAO;AAC7C,GC/WIuI,KAAQtE,IACVuE,KAAenB,IACfrD,KAAQyE,IACRnC,KAAWoC,IACXpB,KAAiBqB,IAEfC,IAAa,SAAUlK,GAAKsB,GAAS;AACvC,OAAK,KAAKtB,GAAKsB,CAAO;AACxB,GAEI6I,KAAkB;AAAA,EACpB,kBAAkB;AAAA;AAAA,EAClB,YAAY;AAAA;AAAA,EACZ,qBAAqB;AAAA;AAAA,EACrB,aAAa;AAAA;AAAA,EACb,qBAAqB;AAAA;AAAA,EACrB,uBAAuB;AAAA;AAAA,EACvB,2BAA2B;AAAA;AAAA,EAC3B,sBAAsB;AAAA;AAAA,EACtB,SAAS;AAAA;AAAA,EACT,SAAS;AAAA;AAAA,EACT,KAAK;AAAA;AAAA,EACL,SAAS;AAAA;AAAA,EACT,QAAQ;AAAA;AAAA,EACR,aAAa;AAAA;AAAA,EACb,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR,WAAW;AAAA,EACX,OAAO;AAAA,EACP,qBAAqB;AAAA,EACrB,uBAAuB;AAAA,EACvB,cAAc;AAChB,GAEIC,KAA4B,EAAE,SAAS,MACvCC,KAA6B,EAAE,SAAS;AAE5CH,EAAW,UAAU,OAAO,SAAUlK,GAAKsB,GAAS;AAClD,MAAIsD,IAAO;AAEX,OAAK,MAAM5E,GACX,KAAK,OAAOA,EAAI,cAAc,MAAM,GAGpC4H,GAAS,mBAAmB,KAAK,GAAG,GAGpC,KAAK,UAAUtC,GAAM,OAAOA,GAAM,OAAO,IAAI6E,EAAe,GAAG7I,CAAO,GAGtE,KAAK,QAAQ;AAGb,MAAIgJ,IACF1C,GAAS,gCAAgC5H,CAAG;AAC9C,OAAK,QAAQsK,EAA6B,OAC1C,KAAK,SAASA,EAA6B,QAG3C,KAAK,WAAW1B;AAAA,IACdhB,GAAS,oBAAoB,KAAK,KAAK,KAAK,QAAQ,gBAAgB;AAAA,IACpE;AAAA,MACE,KAAK,KAAK;AAAA,MACV,OAAO,KAAK;AAAA,MACZ,QAAQ,KAAK;AAAA,MACb,KAAK,KAAK,QAAQ;AAAA,MAClB,SAAS,KAAK,QAAQ;AAAA,MACtB,QAAQ,KAAK,QAAQ;AAAA,MACrB,aAAa,KAAK,QAAQ;AAAA;AAAA,MAE1B,YAAY,SAAU2C,GAAUrB,GAAU;AACxC,YAAItE,EAAK,YAAYA,EAAK,QAAQ;AAChC,iBAAOA,EAAK,QAAQ,WAAW2F,GAAUrB,CAAQ;AAAA,MAEpD;AAAA,MACD,QAAQ,SAAU5tB,GAAO;AACvB,YAAIspB,EAAK,YAAYA,EAAK,QAAQ;AAChC,iBAAOA,EAAK,QAAQ,OAAOtpB,CAAK;AAAA,MAEnC;AAAA,MACD,WAAW,SAAUkvB,GAAUC,GAAU;AACvC,YAAI7F,EAAK,YAAYA,EAAK,QAAQ;AAChC,iBAAOA,EAAK,QAAQ,UAAU4F,GAAUC,CAAQ;AAAA,MAEnD;AAAA,MACD,OAAO,SAAUrgB,GAAO;AACtB,YAAIwa,EAAK,YAAYA,EAAK,QAAQ;AAChC,iBAAOA,EAAK,QAAQ,MAAMxa,CAAK;AAAA,MAElC;AAAA,MACD,cAAc,SAAUuf,GAAK;AAC3B,YAAI/E,EAAK,YAAYA,EAAK,QAAQ;AAChC,iBAAOA,EAAK,QAAQ,aAAa+E,CAAG;AAAA,MAEvC;AAAA,IACF;AAAA,EACL;AAGE,MAAIe,IAAiB,KAAK;AAC1B,EAAAA,EAAe,cAAc,KAAK,QAAQ,UAAU,GACpDA,EAAe,UAAU,KAAK,QAAQ,MAAM,GAC5CA,EAAe,aAAa,KAAK,QAAQ,SAAS,GAClDA,EAAe,SAAS,KAAK,QAAQ,KAAK,GAC1CA,EAAe,gBAAgB,KAAK,QAAQ,YAAY,GAEpD,KAAK,QAAQ,uBACfZ,GAAa,OAAO,IAAI,GAI1B,KAAK,0BAA0B,KAAK,OACpC,KAAK,cAAa;AACpB;AAKAI,EAAW,UAAU,gBAAgB,WAAY;AAC/C,MAAItF,IAAO,MACTL,IAAU;AAqDZ,MAnDA,KAAK,iBAAiB;AAAA;AAAA,IAEpB,aAAa,SAAUF,GAAK;AAC1B,UAAIA,EAAI,gBAAgB,SACxB;AAAA,YAAIpoB,IAAS2oB,EAAK,gBAAgBP,GAAKE,CAAO;AAC9C,eAAAA,IAAUF,GACHpoB;AAAA;AAAA,IACR;AAAA,IACD,YAAY,SAAUooB,GAAK;AACzB,UAAIpoB,IAAS2oB,EAAK,iBAAiBP,GAAKE,CAAO;AAC/C,aAAAA,IAAUF,GACHpoB;AAAA,IACR;AAAA;AAAA,IAGD,WAAW,SAAUooB,GAAK;AACxB,UAAIA,EAAI,gBAAgB;AACxB,eAAOO,EAAK,cAAcP,CAAG;AAAA,IAC9B;AAAA,IACD,UAAU,SAAUA,GAAK;AACvB,aAAOO,EAAK,eAAeP,CAAG;AAAA,IAC/B;AAAA;AAAA,IAGD,aAAa,SAAUA,GAAK;AAC1B,UAAIA,EAAI,gBAAgB;AACxB,eAAOO,EAAK,gBAAgBP,CAAG;AAAA,IAChC;AAAA,IACD,WAAW,SAAUA,GAAK;AACxB,aAAOO,EAAK,gBAAgBP,CAAG;AAAA,IAChC;AAAA;AAAA,IAGD,cAAc,SAAUA,GAAK;AAC3B,UAAIA,EAAI,gBAAgB;AACxB,eAAOO,EAAK,cAAcP,CAAG;AAAA,IAC9B;AAAA,IACD,eAAe,SAAUA,GAAK;AAC5B,UAAIA,EAAI,gBAAgB;AACxB,eAAOO,EAAK,cAAcP,CAAG;AAAA,IAC9B;AAAA,IACD,YAAY,SAAUA,GAAK;AACzB,aAAOO,EAAK,eAAeP,CAAG;AAAA,IAC/B;AAAA,IACD,aAAa,SAAUA,GAAK;AAC1B,aAAOO,EAAK,eAAeP,CAAG;AAAA,IAC/B;AAAA,EACL,GAIM,KAAK,QAAQ,uBAAuB,MAAM;AAC5C,SAAK,QAAQ,oBAAoB,KAAK;AAAA,MACpC,YAAY,KAAK;AAAA,MACjB,uBAAuB,KAAK,QAAQ;AAAA,MACpC,UAAU,KAAK,kBAAmB;AAAA,IACxC,CAAK;AAGD,QAAIsG,IACF,KAAK,QAAQ,oBAAoB;AACnC,QAAIA,KAAsBA,EAAmB;AAC3C,eAASvoB,IAAIuoB,EAAmB,SAAS,GAAGvoB,KAAK,GAAGA;AAClD,QAAI,KAAK,eAAe,eAAeuoB,EAAmBvoB,CAAC,CAAC,KAC1D,OAAO,KAAK,eAAeuoB,EAAmBvoB,CAAC,CAAC;AAAA,EAIvD;AAGD,WAASjE,KAAS,KAAK;AAErB,KAAC,KAAK,QAAQ,yBAAyB,KAAK,KAAK;AAAA,MAC/CA;AAAA,MACA,KAAK,eAAeA,CAAK;AAAA,MACxB,KAAK,QAAQ,4BAEVksB,KADAD;AAAA,IAEV;AAIE,EAAI,KAAK,QAAQ,0BACf,KAAK,QAAQ,wBAAwB,IACrC,KAAK,qBAAoB;AAE7B;AAKAF,EAAW,UAAU,uBAAuB,WAAY;AACtD,MAAI,CAAC,KAAK,QAAQ,uBAAuB;AACvC,QAAItF,IAAO;AAGX,SAAK,gBAAgB,SAAUP,GAAK;AAClC,aAAOO,EAAK,iBAAiBP,CAAG;AAAA,IACtC;AAGI,QAAImC,IAAoB,CAAC,KAAK,QAAQ;AACtC,IAAAqD,GAAM;AAAA,MACJ,KAAK,QAAQ,yBAAyB,KAAK;AAAA,MAC3C,KAAK;AAAA,MACLrD;AAAA,IACN,GAEI,KAAK,QAAQ,wBAAwB;AAAA,EACtC;AACH;AAKA0D,EAAW,UAAU,wBAAwB,WAAY;AACvD,MAAI,KAAK,QAAQ,uBAAuB;AACtC,QAAI1D,IAAoB,CAAC,KAAK,QAAQ;AACtC,IAAAqD,GAAM;AAAA,MACJ,KAAK,QAAQ,yBAAyB,KAAK;AAAA,MAC3C,KAAK;AAAA,MACLrD;AAAA,IACN,GACI,KAAK,QAAQ,wBAAwB;AAAA,EACtC;AACH;AAOA0D,EAAW,UAAU,mBAAmB,SAAU7F,GAAK;AACrD,MAAI,GAAC,KAAK,QAAQ,eAAe,KAAK,UAAU,SAIhD;AAAA,IAAI,KAAK,QAAQ,8BACXA,EAAI,iBACNA,EAAI,eAAc,IAElBA,EAAI,cAAc;AAKtB,QAAIuG,IAAQvG,EAAI,UAAU,GACxBwG,IAAY,KAAK,IAAK,IAAG,KAAK,yBAC9BC,IAAU,IAAI,KAAK,IAAI,GAAG,KAAKD,CAAS;AAG1C,SAAK,0BAA0B,KAAK,OAGhC,eAAexG,KAAOA,EAAI,cAAc,KAAKA,EAAI,eACnDuG,IAAQvG,EAAI,WAAW,IAAI,IAAI,KAAK,IAAIA,EAAI,UAAU,IAAIA,EAAI,SAGhEuG,IACE,OAAOA,KAASA,IAAQ,MACpBA,KACEA,IAAQ,IAAI,IAAI,MAAM,KAAK,IAAI,KAAK,IAAIA,CAAK,IAAI,EAAE,IAAKE;AAEhE,QAAIC,IAAoB,KAAK,IAAI,aAAY,EAAG,QAAS,GACvDC,IAAqBpD,GAAS,cAAcvD,GAAK,KAAK,GAAG,EAAE;AAAA,MACzD0G;AAAA,IACD,GACD/B,IAAO,KAAK,IAAI,IAAI,KAAK,QAAQ,sBAAsB,KAAK4B,CAAK;AAEnE,SAAK,YAAY5B,GAAMgC,CAAkB;AAAA;AAC3C;AAUAd,EAAW,UAAU,cAAc,SAAUe,GAAW7gB,GAAO8gB,GAAc;AAC3E,MAAIC,IAAgB,KAAK,SAAS,iBAAgB;AAElD,EAAKD,KAeHD,IAAY,KAAK;AAAA,IACf,KAAK,QAAQ,UAAUE,EAAc;AAAA,IACrC,KAAK,IAAI,KAAK,QAAQ,UAAUA,EAAc,MAAMF,CAAS;AAAA,EACnE,GAEIA,IAAYA,IAAY,KAAK,aAjB3B,KAAK,QAAO,IAAKA,IACjB,KAAK,QAAQ,UAAUE,EAAc,OAErCF,IAAa,KAAK,QAAQ,UAAUE,EAAc,OAAQ,KAAK,YAE/D,KAAK,QAAO,IAAKF,IACjB,KAAK,QAAQ,UAAUE,EAAc,SAErCF,IAAa,KAAK,QAAQ,UAAUE,EAAc,OAAQ,KAAK;AAYnE,MAAIC,IAAS,KAAK,SAAS,OAAQ,GACjCC,IAAgBjhB,EAAM,gBAAgBghB,EAAO,QAAO,CAAE,GACtDE,IAAW,KAAK,IACb,gBAAiB,EACjB,UAAUD,EAAc,GAAGA,EAAc,CAAC,EAC1C,MAAMJ,CAAS,EACf,UAAU,CAACI,EAAc,GAAG,CAACA,EAAc,CAAC,GAC/CxC,IAASuC,EAAO,SAASE,CAAQ;AAEnC,EAAIzC,EAAO,MAAMuC,EAAO,KACtB,KAAK,SAAS,OAAOvC,CAAM;AAE/B;AAQAqB,EAAW,UAAU,OAAO,SAAU5uB,GAAOiwB,GAAU;AACrD,OAAK;AAAA,IACHjwB;AAAA,IACAssB,GAAS,kBAAkB,KAAK,KAAK,KAAK,OAAO,KAAK,MAAM;AAAA,IAC5D2D;AAAA,EACJ;AACA;AAQArB,EAAW,UAAU,aAAa,SAAU5uB,GAAOiwB,GAAU;AAC3D,EAAIA,MACFjwB,IAAQ,KAAK,wBAAwBA,CAAK,IAG5C,KAAK,KAAKA,GAAOiwB,CAAQ;AAC3B;AASArB,EAAW,UAAU,oBAAoB,SAAU5uB,GAAO8O,GAAOmhB,GAAU;AAOzE,MANIA,MAEFjwB,IAAQ,KAAK,wBAAwBA,CAAK,IAIxCgqB,GAAM,QAAQlb,CAAK,MAAM;AAC3B,QAAI,OAAOA,KAAS,OAAOA;AACzB,MAAAA,IAAQwd,GAAS,eAAe,KAAK,KAAKxd,EAAM,GAAGA,EAAM,CAAC;AAAA;AAE1D,YAAM,IAAI,MAAM,wBAAwB;AAI5C,OAAK,YAAY9O,GAAO8O,GAAOmhB,CAAQ;AACzC;AAOArB,EAAW,UAAU,UAAU,WAAY;AACzC,SAAO,KAAK,SAAS;AACvB;AAOAA,EAAW,UAAU,kBAAkB,WAAY;AACjD,SAAO,KAAK,SAAS;AACvB;AAQAA,EAAW,UAAU,0BAA0B,SAAUlB,GAAM;AAC7D,SAAOA,IAAO,KAAK,SAAS,iBAAgB,EAAG;AACjD;AAKAkB,EAAW,UAAU,YAAY,WAAY;AAC3C,MAAIiB,IAAgB,KAAK,SAAS,iBAAgB;AAElD,OAAK,KAAKA,EAAc,MAAM,EAAI;AACpC;AAKAjB,EAAW,UAAU,WAAW,WAAY;AAC1C,OAAK,IAAI,KAAK,SAAS,iBAAkB,CAAA;AAC3C;AAKAA,EAAW,UAAU,QAAQ,WAAY;AACvC,OAAK,UAAS,GACd,KAAK,SAAQ;AACf;AAQAA,EAAW,UAAU,iBAAiB,SAAU7F,GAAK;AAUnD,MATI,KAAK,QAAQ,8BACXA,EAAI,iBACNA,EAAI,eAAc,IAElBA,EAAI,cAAc,KAKlB,KAAK,QAAQ,qBAAqB;AACpC,QAAImH,IAAcnH,EAAI,OAAO,aAAa,OAAO,KAAK;AACtD,QAAImH,EAAY,QAAQ,sBAAsB,IAAI;AAChD,aAAO;AAAA,EAEV;AAED,MAAIC;AAEJ,EAAIpH,EAAI,WACNoH,IAAa,MAAM,IAAI,KAAK,QAAQ,wBAAwB,KAE5DA,KAAc,IAAI,KAAK,QAAQ,wBAAwB;AAGzD,MAAIrhB,IAAQwd,GAAS,cAAcvD,GAAK,KAAK,GAAG,EAAE;AAAA,IAChD,KAAK,IAAI,aAAc,EAAC,QAAS;AAAA,EACrC;AACE,OAAK,YAAYoH,GAAYrhB,CAAK;AACpC;AAOA8f,EAAW,UAAU,kBAAkB,SAAU7F,GAAKE,GAAS;AAC7D,EAAI,KAAK,QAAQ,8BACXF,EAAI,iBACNA,EAAI,eAAc,IAElBA,EAAI,cAAc,KAItBiB,GAAM,uBAAuBjB,GAAK,KAAK,GAAG,GAGtC,KAAK,QAAQ,uBAAuBiB,GAAM,WAAWjB,GAAKE,CAAO,IACnE,KAAK,eAAeF,CAAG,KAGvB,KAAK,QAAQ,OACb,KAAK,gBAAgB,KAAK,SAAS,OAAM,GACzC,KAAK,cAAcuD,GAAS,cAAcvD,GAAK,KAAK,GAAG,EAAE;AAAA,IACvD,KAAK,cAAc,QAAS;AAAA,EAClC;AAEA;AAOA6F,EAAW,UAAU,kBAAkB,SAAU7F,GAAK;AASpD,MARI,KAAK,QAAQ,8BACXA,EAAI,iBACNA,EAAI,eAAc,IAElBA,EAAI,cAAc,KAIlB,KAAK,UAAU,SAAS,KAAK,QAAQ,YAAY;AAEnD,QAAIja,IAAQwd,GAAS,cAAcvD,GAAK,KAAK,GAAG,EAAE;AAAA,MAC9C,KAAK,cAAc,QAAS;AAAA,IAC7B,GACDqH,IAAc,KAAK,cAAc;AAAA,MAC/BthB,EAAM,IAAI,KAAK,YAAY;AAAA,MAC3BA,EAAM,IAAI,KAAK,YAAY;AAAA,IACnC;AAEI,SAAK,SAAS,OAAOshB,CAAW;AAAA,EACjC;AACH;AAOAxB,EAAW,UAAU,gBAAgB,SAAU7F,GAAK;AAClD,EAAI,KAAK,QAAQ,8BACXA,EAAI,iBACNA,EAAI,eAAc,IAElBA,EAAI,cAAc,KAIlB,KAAK,UAAU,UAEjB,KAAK,QAAQ;AAEjB;AAOA6F,EAAW,UAAU,mBAAmB,SAAU7F,GAAKE,GAAS;AAC9D,MAAIF,EAAI,QAAQ,UAAU;AACxB,SAAK,gBAAgBA,GAAKE,CAAO;AAAA,OAC5B;AACL,IAAI,KAAK,QAAQ,8BACXF,EAAI,iBACNA,EAAI,eAAc,IAElBA,EAAI,cAAc,KAItB,KAAK,gBAAgB,KAAK,SAAS,OAAM;AACzC,QAAIsH,IAAS/D,GAAS,cAAcvD,GAAK,KAAK,KAAK,CAAC,GAChDuH,IAAShE,GAAS,cAAcvD,GAAK,KAAK,KAAK,CAAC;AACpD,SAAK,gBAAgBiB,GAAM,kBAAkBqG,GAAQC,CAAM,GAC3DD,EAAO,KAAKA,EAAO,IAAIC,EAAO,KAAK,GACnCD,EAAO,KAAKA,EAAO,IAAIC,EAAO,KAAK,GACnC,KAAK,cAAcD,EAAO,gBAAgB,KAAK,cAAc,QAAO,CAAE,GACtE,KAAK,iBAAiB,KAAK;EAC5B;AACH;AAOAzB,EAAW,UAAU,kBAAkB,SAAU7F,GAAK;AACpD,MAAIA,EAAI,QAAQ,UAAU;AACxB,SAAK,gBAAgBA,CAAG;AAAA,OACnB;AASL,QAPI,KAAK,QAAQ,8BACXA,EAAI,iBACNA,EAAI,eAAc,IAElBA,EAAI,cAAc,KAGlB,CAAC,KAAK,QAAQ,cAAc,CAAC,KAAK,QAAQ;AAC5C;AAGF,QAAIsH,IAAS/D,GAAS,cAAcvD,GAAK,KAAK,KAAK,CAAC,GAChDuH,IAAShE,GAAS,cAAcvD,GAAK,KAAK,KAAK,CAAC,GAChDrd,IAAS,KAAK,IAAI,eAAc;AAIpC,QAHAA,EAAO,KAAK2kB,EAAO,IAAIC,EAAO,KAAK,GACnC5kB,EAAO,KAAK2kB,EAAO,IAAIC,EAAO,KAAK,GAE/B,KAAK,UAAU,SAAS,KAAK,QAAQ,YAAY;AAEnD,UAAIxhB,IAAQpD,EAAO,gBAAgB,KAAK,cAAc,QAAO,CAAE,GAC3D0kB,IAAc,KAAK,cAAc;AAAA,QACnCthB,EAAM,IAAI,KAAK,YAAY;AAAA,QAC3BA,EAAM,IAAI,KAAK,YAAY;AAAA,MACnC;AACM,WAAK,SAAS,OAAOshB,CAAW;AAAA,IACjC;AAED,QAAI,KAAK,QAAQ,aAAa;AAE5B,UAAIpnB,IAAWghB,GAAM,kBAAkBqG,GAAQC,CAAM,GACjDtwB,IAAQgJ,IAAW,KAAK,eACxBymB,IAAoB,KAAK,IAAI,aAAc,EAAC,QAAO,GACnDc,IAAqB7kB,EAAO,gBAAgB+jB,CAAiB;AACjE,WAAK,YAAY,KAAK,iBAAiBzvB,GAAOuwB,GAAoB,EAAI;AAAA,IACvE;AAAA,EACF;AACH;AAOA3B,EAAW,UAAU,iBAAiB,SAAU7F,GAAK;AACnD,MAAIA,EAAI,QAAQ,UAAU;AACxB,SAAK,cAAcA,CAAG;AAAA,WAElB,KAAK,QAAQ,8BACXA,EAAI,iBACNA,EAAI,eAAc,IAElBA,EAAI,cAAc,KAItB,KAAK,gBAAgB,KAAK,SAAS,OAAM,GACrCA,EAAI,QAAQ,UAAU;AACxB,SAAK,cAAcuD,GAAS,cAAcvD,GAAK,KAAK,GAAG,EAAE;AAAA,MACvD,KAAK,cAAc,QAAS;AAAA,IACpC;AAAA,OACW;AACL,QAAIsH,IAAS/D,GAAS,cAAcvD,GAAK,KAAK,KAAK,CAAC,GAChDuH,IAAShE,GAAS,cAAcvD,GAAK,KAAK,KAAK,CAAC;AACpD,SAAK,gBAAgBiB,GAAM,kBAAkBqG,GAAQC,CAAM,GAC3DD,EAAO,KAAKA,EAAO,IAAIC,EAAO,KAAK,GACnCD,EAAO,KAAKA,EAAO,IAAIC,EAAO,KAAK,GACnC,KAAK,cAAcD,EAAO,gBAAgB,KAAK,cAAc,QAAO,CAAE;AAAA,EACvE;AAEL;AAMAzB,EAAW,UAAU,MAAM,WAAY;AACrC,MAAI4B,IAAU,KAAK,SAAS,WAAY,GACtC5C,IAAW,KAAK;AAAA,IACd,KAAK,QAAQ4C,EAAQ;AAAA,IACrB,KAAK,SAASA,EAAQ;AAAA,EAC5B;AAEE,OAAK,KAAK5C,GAAU,EAAI;AAC1B;AAMAgB,EAAW,UAAU,UAAU,WAAY;AACzC,MAAI4B,IAAU,KAAK,SAAS,WAAY,GACtC5C,IAAW,KAAK;AAAA,IACd,KAAK,QAAQ4C,EAAQ;AAAA,IACrB,KAAK,SAASA,EAAQ;AAAA,EAC5B;AAEE,OAAK,KAAK5C,GAAU,EAAI;AAC1B;AAMAgB,EAAW,UAAU,SAAS,WAAY;AACxC,MAAI4B,IAAU,KAAK,SAAS,WAAY,GACtC3C,KACG,KAAK,SAAS2C,EAAQ,QAAQA,EAAQ,IAAI,KAAK,KAAK,QAAS,KAAI,KACpE1C,KACG,KAAK,UAAU0C,EAAQ,SAASA,EAAQ,IAAI,KAAK,KAAK,QAAO,KAAM;AAExE,OAAK,kBAAmB,EAAC,IAAI,EAAE,GAAG3C,GAAS,GAAGC,EAAO,CAAE;AACzD;AAMAc,EAAW,UAAU,aAAa,WAAY;AAC5C,OAAK,SAAS;AAChB;AAOAA,EAAW,UAAU,MAAM,SAAU9f,GAAO;AAC1C,MAAIshB,IAAc,KAAK,SAAS,OAAM;AACtC,EAAAA,EAAY,IAAIthB,EAAM,GACtBshB,EAAY,IAAIthB,EAAM,GACtB,KAAK,SAAS,OAAOshB,CAAW;AAClC;AAOAxB,EAAW,UAAU,QAAQ,SAAU9f,GAAO;AAC5C,MAAIshB,IAAc,KAAK,SAAS,OAAM;AACtC,EAAAA,EAAY,KAAKthB,EAAM,GACvBshB,EAAY,KAAKthB,EAAM,GACvB,KAAK,SAAS,OAAOshB,CAAW;AAClC;AAOAxB,EAAW,UAAU,SAAS,WAAY;AACxC,MAAIvpB,IAAQ,KAAK,SAAS,SAAQ;AAElC,SAAO,EAAE,GAAGA,EAAM,GAAG,GAAGA,EAAM;AAChC;AAKAupB,EAAW,UAAU,SAAS,WAAY;AAExC,MAAII,IAA+B1C,GAAS;AAAA,IAC1C,KAAK;AAAA,EACT;AACE,OAAK,QAAQ0C,EAA6B,OAC1C,KAAK,SAASA,EAA6B;AAG3C,MAAIrK,IAAW,KAAK;AACpB,EAAAA,EAAS,QAAQ,QAAQ,KAAK,OAC9BA,EAAS,QAAQ,SAAS,KAAK,QAC/BA,EAAS,WAAU,GAGf,KAAK,QAAQ,wBACf,KAAK,oBAAoB,uBACzB,KAAK,oBAAoB;AAE7B;AAKAiK,EAAW,UAAU,UAAU,WAAY;AACzC,MAAItF,IAAO;AAGX,OAAK,aAAa,MAClB,KAAK,SAAS,MACd,KAAK,YAAY,MACjB,KAAK,QAAQ,MACb,KAAK,eAAe,MAIhB,KAAK,QAAQ,uBAAuB,QACtC,KAAK,QAAQ,oBAAoB,QAAQ;AAAA,IACvC,YAAY,KAAK;AAAA,IACjB,uBAAuB,KAAK,QAAQ;AAAA,IACpC,UAAU,KAAK,kBAAmB;AAAA,EACxC,CAAK;AAIH,WAASzmB,KAAS,KAAK;AACrB,KAAC,KAAK,QAAQ,yBAAyB,KAAK,KAAK;AAAA,MAC/CA;AAAA,MACA,KAAK,eAAeA,CAAK;AAAA,MACxB,KAAK,QAAQ,4BAEVksB,KADAD;AAAA,IAEV;AAIE,OAAK,sBAAqB,GAG1B,KAAK,oBAAoB,uBAGzB2B,KAAiBA,GAAe,OAAO,SAAUjE,GAAU;AACzD,WAAOA,EAAS,QAAQlD,EAAK;AAAA,EACjC,CAAG,GAGD,OAAO,KAAK,SAGZ,OAAO,KAAK,UAGZ,OAAO,KAAK,gBACZ,OAAO,KAAK,IACZ,KAAK,oBAAoB,WAAY;AACnC,WAAO;AAAA,EACX;AACA;AAOAsF,EAAW,UAAU,oBAAoB,WAAY;AACnD,MAAItF,IAAO;AAGX,SAAK,KAAK,mBACR,KAAK,iBAAiB,KAAK,KAAK;AAAA;AAAA,IAE9B,WAAW,WAAY;AACrB,aAAAA,EAAK,QAAQ,aAAa,IACnBA,EAAK;AAAA,IACb;AAAA,IACD,YAAY,WAAY;AACtB,aAAAA,EAAK,QAAQ,aAAa,IACnBA,EAAK;AAAA,IACb;AAAA,IACD,cAAc,WAAY;AACxB,aAAO,CAAC,CAACA,EAAK,QAAQ;AAAA,IACvB;AAAA,IACD,KAAK,SAAUxa,GAAO;AACpB,aAAAwa,EAAK,IAAIxa,CAAK,GACPwa,EAAK;AAAA,IACb;AAAA,IACD,OAAO,SAAUxa,GAAO;AACtB,aAAAwa,EAAK,MAAMxa,CAAK,GACTwa,EAAK;AAAA,IACb;AAAA,IACD,QAAQ,WAAY;AAClB,aAAOA,EAAK;IACb;AAAA;AAAA,IAED,cAAc,SAAUT,GAAI;AAC1B,aAAAS,EAAK,QAAQ,YACXT,MAAO,OAAO,OAAOmB,GAAM,MAAMnB,GAAIS,EAAK,cAAc,GACnDA,EAAK;AAAA,IACb;AAAA,IACD,UAAU,SAAUT,GAAI;AACtB,aAAAS,EAAK,QAAQ,QACXT,MAAO,OAAO,OAAOmB,GAAM,MAAMnB,GAAIS,EAAK,cAAc,GACnDA,EAAK;AAAA,IACb;AAAA;AAAA,IAED,YAAY,WAAY;AACtB,aAAAA,EAAK,QAAQ,cAAc,IACpBA,EAAK;AAAA,IACb;AAAA,IACD,aAAa,WAAY;AACvB,aAAAA,EAAK,QAAQ,cAAc,IACpBA,EAAK;AAAA,IACb;AAAA,IACD,eAAe,WAAY;AACzB,aAAO,CAAC,CAACA,EAAK,QAAQ;AAAA,IACvB;AAAA,IACD,oBAAoB,WAAY;AAC9B,aAAKA,EAAK,QAAQ,wBAChBA,EAAK,QAAQ,sBAAsB,IACnCkF,GAAa,OAAOlF,CAAI,IAEnBA,EAAK;AAAA,IACb;AAAA,IACD,qBAAqB,WAAY;AAC/B,aAAIA,EAAK,QAAQ,wBACfA,EAAK,QAAQ,sBAAsB,IACnCkF,GAAa,QAAQlF,CAAI,IAEpBA,EAAK;AAAA,IACb;AAAA,IACD,uBAAuB,WAAY;AACjC,aAAO,CAAC,CAACA,EAAK,QAAQ;AAAA,IACvB;AAAA;AAAA,IAED,oBAAoB,WAAY;AAC9B,aAAAA,EAAK,QAAQ,sBAAsB,IAC5BA,EAAK;AAAA,IACb;AAAA,IACD,qBAAqB,WAAY;AAC/B,aAAAA,EAAK,QAAQ,sBAAsB,IAC5BA,EAAK;AAAA,IACb;AAAA,IACD,uBAAuB,WAAY;AACjC,aAAO,CAAC,CAACA,EAAK,QAAQ;AAAA,IACvB;AAAA;AAAA,IAED,sBAAsB,WAAY;AAChC,aAAAA,EAAK,qBAAoB,GAClBA,EAAK;AAAA,IACb;AAAA,IACD,uBAAuB,WAAY;AACjC,aAAAA,EAAK,sBAAqB,GACnBA,EAAK;AAAA,IACb;AAAA,IACD,yBAAyB,WAAY;AACnC,aAAO,CAAC,CAACA,EAAK,QAAQ;AAAA,IACvB;AAAA;AAAA,IAED,yBAAyB,SAAUtpB,GAAO;AACxC,aAAAspB,EAAK,QAAQ,uBAAuBtpB,GAC7BspB,EAAK;AAAA,IACb;AAAA,IACD,YAAY,SAAUoE,GAAM;AAC1B,aAAApE,EAAK,QAAQ,UAAUoE,GAChBpE,EAAK;AAAA,IACb;AAAA,IACD,YAAY,SAAUoE,GAAM;AAC1B,aAAApE,EAAK,QAAQ,UAAUoE,GAChBpE,EAAK;AAAA,IACb;AAAA;AAAA,IAED,eAAe,SAAUT,GAAI;AAC3B,aAAAS,EAAK,QAAQ,aACXT,MAAO,OAAO,OAAOmB,GAAM,MAAMnB,GAAIS,EAAK,cAAc,GACnDA,EAAK;AAAA,IACb;AAAA,IACD,WAAW,SAAUT,GAAI;AACvB,aAAAS,EAAK,QAAQ,SACXT,MAAO,OAAO,OAAOmB,GAAM,MAAMnB,GAAIS,EAAK,cAAc,GACnDA,EAAK;AAAA,IACb;AAAA;AAAA,IAED,MAAM,SAAUtpB,GAAO;AACrB,aAAAspB,EAAK,WAAWtpB,GAAO,EAAI,GACpBspB,EAAK;AAAA,IACb;AAAA,IACD,QAAQ,SAAUtpB,GAAO;AACvB,aAAAspB,EAAK,WAAWtpB,GAAO,EAAK,GACrBspB,EAAK;AAAA,IACb;AAAA,IACD,aAAa,SAAUtpB,GAAO8O,GAAO;AACnC,aAAAwa,EAAK,kBAAkBtpB,GAAO8O,GAAO,EAAI,GAClCwa,EAAK;AAAA,IACb;AAAA,IACD,eAAe,SAAUtpB,GAAO8O,GAAO;AACrC,aAAAwa,EAAK,kBAAkBtpB,GAAO8O,GAAO,EAAK,GACnCwa,EAAK;AAAA,IACb;AAAA,IACD,QAAQ,WAAY;AAClB,kBAAK,OAAO,IAAIA,EAAK,QAAQ,oBAAoB,GAC1CA,EAAK;AAAA,IACb;AAAA,IACD,SAAS,WAAY;AACnB,kBAAK,OAAO,KAAK,IAAIA,EAAK,QAAQ,qBAAqB,GAChDA,EAAK;AAAA,IACb;AAAA,IACD,SAAS,WAAY;AACnB,aAAOA,EAAK;IACb;AAAA;AAAA,IAED,iBAAiB,SAAUT,GAAI;AAC7B,aAAAS,EAAK,QAAQ,eACXT,MAAO,OAAO,OAAOmB,GAAM,MAAMnB,GAAIS,EAAK,cAAc,GACnDA,EAAK;AAAA,IACb;AAAA;AAAA,IAED,WAAW,WAAY;AACrB,aAAAA,EAAK,UAAS,GACPA,EAAK;AAAA,IACb;AAAA,IACD,UAAU,WAAY;AACpB,aAAAA,EAAK,SAAQ,GACNA,EAAK;AAAA,IACb;AAAA,IACD,OAAO,WAAY;AACjB,aAAAA,EAAK,MAAK,GACHA,EAAK;AAAA,IACb;AAAA;AAAA,IAED,KAAK,WAAY;AACf,aAAAA,EAAK,IAAG,GACDA,EAAK;AAAA,IACb;AAAA,IACD,SAAS,WAAY;AACnB,aAAAA,EAAK,QAAO,GACLA,EAAK;AAAA,IACb;AAAA,IACD,QAAQ,WAAY;AAClB,aAAAA,EAAK,OAAM,GACJA,EAAK;AAAA,IACb;AAAA;AAAA,IAED,YAAY,WAAY;AACtB,aAAAA,EAAK,WAAU,GACRA,EAAK;AAAA,IACb;AAAA,IACD,QAAQ,WAAY;AAClB,aAAAA,EAAK,OAAM,GACJA,EAAK;AAAA,IACb;AAAA,IACD,UAAU,WAAY;AACpB,aAAO;AAAA,QACL,OAAOA,EAAK;AAAA,QACZ,QAAQA,EAAK;AAAA,QACb,UAAUA,EAAK,QAAS;AAAA,QACxB,SAASA,EAAK,SAAS,WAAY;AAAA,MAC7C;AAAA,IACO;AAAA;AAAA,IAED,SAAS,WAAY;AACnB,aAAAA,EAAK,QAAO,GACLA,EAAK;AAAA,IACb;AAAA,EACP,IAGS,KAAK;AACd;AAQA,IAAImH,KAAiB,CAAA,GAEjBnvB,KAAa,SAAUsnB,GAAmB5C,GAAS;AACrD,MAAItB,IAAMsF,GAAM,OAAOpB,CAAiB;AAExC,MAAIlE,MAAQ;AACV,WAAO;AAGP,WAAS5d,IAAI2pB,GAAe,SAAS,GAAG3pB,KAAK,GAAGA;AAC9C,QAAI2pB,GAAe3pB,CAAC,EAAE,QAAQ4d;AAC5B,aAAO+L,GAAe3pB,CAAC,EAAE,SAAS,kBAAiB;AAKvD,SAAA2pB,GAAe,KAAK;AAAA,IAClB,KAAK/L;AAAA,IACL,UAAU,IAAIkK,EAAWlK,GAAKsB,CAAO;AAAA,EAC3C,CAAK,GAGMyK,GACLA,GAAe,SAAS,CAC9B,EAAM,SAAS;AAEf,GAEAC,KAAiBpvB;mCCxgCXqvB,KAAuC;AAAA,EAC3C,gBAAwC;AACtC,gBAAK,MACF,OACA,EAAA,QAAA,EACA,WACI;AAAA,EACT;AAAA,EACA,cAAsC;AAC9B,UAAAC,IAAQ,KAAK,YACbC,IAAM,KAAK,UACX7wB,IAAQ4wB,EAAM;AACpB,IAAAC,EAAI,KAAK7wB,GACT6wB,EAAI,KAAK7wB;AACT,UAAM2kB,IAAW;AAAA,MACf,OAAOiM,EAAM,QAAQ5wB;AAAA,MACrB,QAAQ4wB,EAAM,SAAS5wB;AAAA,IAAA;AAElB,WAAA;AAAA,MACL,KAAK;AAAA,QACH,KAAK,CAAC6wB,EAAI;AAAA,QACV,QAAQlM,EAAS,SAASkM,EAAI;AAAA,QAC9B,MAAM,CAACA,EAAI;AAAA,QACX,OAAOlM,EAAS,QAAQkM,EAAI;AAAA,MAC9B;AAAA,MACA,QAAQ;AAAA,QACN,GAAGlM,EAAS,QAAQ,IAAIkM,EAAI;AAAA,QAC5B,GAAGlM,EAAS,SAAS,IAAIkM,EAAI;AAAA,MAC/B;AAAA,IAAA;AAAA,EAEJ;AAAA,EACA,aAA0C;AACjC,WAAA,KAAK,YAAc,EAAA;AAAA,EAC5B;AAAA,EACA,WAAqC1L,GAAU;AAIvC,UAAAve,IAAQue,EAAI,QAAQA,EAAI,MACxBkH,IAASlH,EAAI,SAASA,EAAI,KAC1B,EAAE,OAAO2L,GAAW,QAAQC,MAAe,KAAK,YAChDC,IAAQpqB,IAAQylB,GAChB4E,IAAeH,IAAYC,GAC3BG,IAAWF,IAAQC,IAAe5E,IAAS4E,IAAerqB,GAC1DuqB,IAAYH,IAAQC,IAAerqB,IAAQqqB,IAAe5E,GAC1D+E,IAAe,KAAK;AAAA,MACxBN,IAAYI;AAAA,MACZH,IAAaI;AAAA,IAAA,GAETE,IAAW,KAAK,eAChBC,IAAe,KAAK,WACpBC,IAAeF,IAAWC;AAC3B,SAAA,KAAKF,IAAeG,CAAY;AAErC,UAAM7lB,IAAS;AAAA,MACb,IAAIyZ,EAAI,OAAOve,IAAQ,KAAKwqB;AAAA,MAC5B,IAAIjM,EAAI,MAAMkH,IAAS,KAAK+E;AAAA,IAAA;AAE9B,SAAK,IAAI;AAAA,MACP,GAAG,CAAE1lB,EAAO,IAAKwlB,IAAW,IAAIE;AAAA,MAChC,GAAG,CAAE1lB,EAAO,IAAKylB,IAAY,IAAIC;AAAA,IAAA,CAClC;AAAA,EACH;AAAA,EACA,cAAsC;AAC7B,WAAA,KAAK,SAAW,EAAA;AAAA,EACzB;AAAA,EACA,uBAAiD/R,GAAmBmS,GAAsBC,GAAsB;AAE9G,UAAMC,IAAM,KAAK,IAAI,MAAQF,CAAY,GACnCG,IAAM,KAAK,IAAID,GAAKD,CAAY,GAChC/D,IAAO,KAAK,IAAI,KAAK,IAAIiE,GAAKtS,CAAS,GAAGqS,CAAG,GAE7CL,IAAW,KAAK,eAChBC,IAAe,KAAK,WACpBC,IAAeF,IAAWC;AAE3B,SAAA,WAAWI,IAAMH,CAAY,EAC/B,WAAWI,IAAMJ,CAAY,EAC7B,KAAK7D,IAAO6D,CAAY;AAAA,EAC7B;AAAA,EACA,eAAuC;AACrC,WAAO,KAAK;AAAA,EACd;AAAA,EACA,YAAoC;AAClC,gBAAK,gBAAgB,IACrB,KAAK,mBAAmB,GACjB;AAAA,EACT;AAAA,EACA,aAAqC;AACnC,gBAAK,gBAAgB,IACrB,KAAK,oBAAoB,GAClB;AAAA,EACT;AAAA,EACA,gBAAwC;AACtC,WAAO,KAAK;AAAA,EACd;AAAA,EACA,aAAqC;AACnC,gBAAK,iBAAiB,IACtB,KAAK,oBAAoB,GAClB;AAAA,EACT;AAAA,EACA,cAAsC;AACpC,gBAAK,iBAAiB,IACtB,KAAK,qBAAqB,GACnB;AAAA,EACT;AAAA,EACA,cAAwCtO,GAAkB;AACxD,WAAIA,IACF,KAAK,UAAU,IAEf,KAAK,WAAW,GAEX;AAAA,EACT;AAAA,EACA,eAAyCA,GAAkB;AACzD,WAAIA,KACF,KAAK,WAAW,GAChB,KAAK,mBAAmB,MAExB,KAAK,YAAY,GACjB,KAAK,oBAAoB,IAEpB;AAAA,EACT;AACF;AAEA,SAAS2O,GACPtwB,GACA0kB,GACoB;;AACpB,QAAMwG,IAAWlrB;AACR,SAAAkrB,EAAA,iBAAgBzpB,IAAAijB,EAAQ,eAAR,OAAAjjB,IAAsB,IACtCypB,EAAA,kBAAiBllB,IAAA0e,KAAA,gBAAAA,EAAS,gBAAT,OAAA1e,IAAwB,IAClDklB,EAAS,wBAAwBA,EAAS,cAC1CA,EAAS,qBAAqBA,EAAS,WACvCA,EAAS,sBAAsBA,EAAS,YACxCA,EAAS,yBAAyBA,EAAS,eAC3CA,EAAS,sBAAsBA,EAAS,YACxCA,EAAS,uBAAuBA,EAAS,aAClC,OAAA,OAAOlrB,GAAYqvB,EAAO,GAC1BnE;AACT;AAEgB,SAAAqF,GACdnN,GACAsB,GACoB;;AAEpB,QAAM8L,KAAWxqB,KAAAvE,IAAAijB,EAAQ,wBAAR,gBAAAjjB,EAA6B,SAA7B,OAAAuE,IAAsC,CAACkN,MAAW;AAAA,EAAA,GAC7Dud,KAAcxqB,KAAAjB,IAAA0f,EAAQ,wBAAR,gBAAA1f,EAA6B,YAA7B,OAAAiB,IAAyC,CAACiN,MAAW;AAAA,EAAA,GACnE6a,KAAqB7nB,KAAAnB,IAAA2f,EAAQ,wBAAR,gBAAA3f,EAA6B,uBAA7B,OAAAmB,IAAmD,CAAA;AAE1E,SAAAwe,EAAQ,0BAA0B,WACpCA,EAAQ,wBAAwBA,EAAQ,cAG1CA,EAAQ,sBAAsB;AAAA,IAC5B,MAAM,CAAK2C,MAAA;AACG,MAAAiJ,GAAAjJ,EAAE,UAAU3C,CAAO,GAC/B8L,EAASnJ,CAAC;AAAA,IACZ;AAAA,IACA,SAAS,CAAKA,MAAAoJ,EAAYpJ,CAAC;AAAA,IAC3B,oBAAA0G;AAAA,EAAA,GAGK/tB,GAAWojB,GAAKsB,CAA6B;AACtD;AC7MgB,SAAAgM,GAActN,GAAqCsB,GAA4B;AAC7F,QAAMwG,IAAWpS;AACjB,MAAI/U,IAAQ;AACZ,QAAM4sB,IAA+B,CAAA,GAC/BC,IAAiC,CAAA,GAEjCC,IAAkB,MAAM;AACpB,IAAA9sB,IAAA,GACS4sB,EAAA,QAAQ,CAAK7kB,MAAAA,EAAG,CAAA,GACjC6kB,EAAiB,SAAS;AAAA,EAAA,GAGtBG,IAAoB,MAAM;AACtB,IAAA/sB,IAAA,GACW6sB,EAAA,QAAQ,CAAK9kB,MAAAA,EAAG,CAAA,GACnC8kB,EAAmB,SAAS;AAAA,EAAA;AAG9B,SAAAnP,GAAU,MAAM;;AACd,UAAMkC,IAAUxmB,EAAQimB,EAAI,OAAO,OAAO,GAEpCoN,KAAWxqB,KAAAvE,IAAAijB,EAAQ,wBAAR,gBAAAjjB,EAA6B,SAA7B,OAAAuE,IAAsC,CAACkN,MAAW;AAAA,IAAA,GAC7Dud,KAAcxqB,KAAAjB,IAAA0f,EAAQ,wBAAR,gBAAA1f,EAA6B,YAA7B,OAAAiB,IAAyC,CAACiN,MAAW;AAAA,IAAA,GACnE6a,KAAqB7nB,KAAAnB,IAAA2f,EAAQ,wBAAR,gBAAA3f,EAA6B,uBAA7B,OAAAmB,IAAmD,CAAA;AAE9E,IAAAwe,EAAQ,sBAAsB;AAAA,MAC5B,MAAM,CAAK2C,MAAA;AACT,QAAA6D,EAAS,QAAQ7D,EAAE,UACnBmJ,EAASnJ,CAAC,GACMwJ;MAClB;AAAA,MACA,SAAS,CAAKxJ,MAAA;AACM,QAAAyJ,KAClBL,EAAYpJ,CAAC;AAAA,MACf;AAAA,MACA,oBAAA0G;AAAA,IAAA;AAGF,UAAMgD,IAAa,MAAM;AACjB,YAAAvkB,IAAOmX,EAAQ;AAOrB,MAAInX,EAAK,UAAU,KAAKA,EAAK,WAAW,IACtC+jB,GAAmB5M,GAASe,CAAO,IAEnC,WAAWqM,GAAY,GAAG;AAAA,IAC5B;AAES,IAAAA;EAAA,CACZ,GAEDrP,GAAY,MAAM;;AAChB,KAAAjgB,IAAAypB,EAAS,UAAT,QAAAzpB,EAAgB,WAChBypB,EAAS,QAAQ;AAAA,EAAA,CAClB,GAkBM,EAAE,YAAYA,GAAU,qBAhBH,CAAChtB,MAAuB;AAClD,IAAI6F,MAAU,IACZ4sB,EAAiB,KAAKzyB,CAAQ,IACrB6F,MAAU,KACV7F;EACX,GAWkD,uBARtB,CAACA,MAAuB;AAChD,IAAA6F,MAAU,KAAiBA,MAAU,IACvC6sB,EAAmB,KAAK1yB,CAAQ,IAEvBA;EACX,EAGwE;AAC5E;AChFA,MAAM8yB,KAAe,OAAO,WAAW;AAEvB,SAAAC,GAAiBlT,GAAwBmT,GAAuB;AACxE,QAAAxyB,IAAQsX,EAAS,MACdkb,EAAU,iBAAiB,IAAK,IAAInT,EAAU,KACtD;AACD,SAAAtgB,GAAQuzB,IAAc;AAAA,IACpB,WAAAjT;AAAA,IACA,OAAArf;AAAA,EAAA,CACD,GACM,EAAE,OAAAA,EAAM;AACjB;AAEO,SAASyyB,KAA6B;AAC3C,SAAOh0B,EAAQQ,GAAOqzB,EAAY,GAAG,WAAW;AAClD;ACXA,SAASptB,GAAUJ,GAAmB;AACpC,SAAOA,aAAe,WAAYA,KAAO,OAAOA,EAAI,QAAS;AAC/D;AAEO,SAAS4tB,KAAqB;AACnC,MAAIC,IAAyB;AAC7B,QAAMC,IAAmBxY,EAA0B;AAAA,IACjD,SAAS;AAAA,IACT,UAAU;AAAA,IACV,gBAAgB;AAAA,EAAA,CACjB;AAED,WAASyY,EACPzJ,GACA0J,IAAW,KACXC,IAAiC,UACjC;AACA,IAAIJ,MACF,aAAaA,CAAO,GACVA,IAAA,OAEZC,EAAiB,QAAQ;AAAA,MACvB,SAAS;AAAA,MACT,UAAAE;AAAA,MACA,gBAAAC;AAAA,IAAA,GAGFC,GAAS,MAAY5O,GAAA;AACnB,YAAM6O,IAAU7J;AACZ,MAAAlkB,GAAU+tB,CAAO,MACb,MAAAA,IAGJN,KACF,aAAaA,CAAO,GAEZA,IAAA,iCAAQ,WAAW,MAAM;AACjC,QAAAC,EAAiB,MAAM,UAAU,IACvBD,IAAA;AAAA,SACTG;AAAA,IAAQ,EACZ;AAAA,EACH;AAEO,SAAA,EAAE,iBAAAD,GAAiB,kBAAAD;AAC5B;ACtDO,SAASM,GAA0BC,GAAwB;AAC1D,QAAAzc,IAAU0D,EAA0B,CAAA,CAAE,GAEtCkJ,IAA+BlJ,EAAI,EAAK;AAC9C,MAAIzV,IAAS;AACP,QAAAyuB,wBAAc;AAGpB,SAAA9tB,GAAY,MAAM;AACZ,QAAA6tB,EAAM,iBAAiB,OAAO;AAChC,YAAME,IAAc,oBAAI,IAAY,CAAA,CAAE;AAuBtC,UAtBA3c,EAAQ,QAAQ,OAAO;AAAA,QACrByc,EAAM,MAAM,IAAI,CAAQ3vB,MAAA;AACtB,cAAI/B,IAAK+B,EAAK;AACd,iBAAK/B,MACE6hB,EAA6B,UAChCA,EAA6B,QAAQ,IAC7B,QAAA;AAAA,YACN;AAAA,UAAA,IAKC7hB,IAAA2xB,EAAQ,IAAI5vB,CAAI,GAChB/B,MACHA,IAAK,UAAUkD,KACPyuB,EAAA,IAAI5vB,GAAM/B,CAAE,KAGxB4xB,EAAY,IAAI5xB,CAAE,GACX,CAACA,GAAI+B,CAAI;AAAA,QAAA,CACjB;AAAA,MAAA,GAEC8f,EAA6B;AACpB,mBAAA,CAAC9f,GAAM/B,CAAE,KAAK,MAAM,KAAK2xB,EAAQ,QAAQ,CAAC;AACnD,UAAKC,EAAY,IAAI5xB,CAAE,KACrB2xB,EAAQ,OAAO5vB,CAAI;AAAA,IAGzB;AAEA,MAAAkT,EAAQ,QAAQyc,EAAM;AAAA,EACxB,CACD,GAEM,EAAE,SAAAzc,GAAS,8BAAA4M;AACpB;AC7CO,SAASgQ,GACdC,GACA50B,GACA60B,GACAC,GACW;AAMX,MAAIA,GAAQ;AACV,UAAM/K,IAAOtO,EAAUqZ,EAAOF,EAAM50B,CAAI,CAAC,CAAC,GACpC+0B,IAAS,CAACC,MAAmB;AACjC,MAAKpxB,GAAQoxB,GAAUjL,EAAK,KAAK,MAC/BA,EAAK,QAAQiL,IAEVpxB,GAAQoxB,GAAUJ,EAAM50B,CAAI,CAAC,KAC3B60B,EAAA,UAAU70B,CAAkB,IAAIg1B,CAAQ;AAAA,IAC/C;AAEF,WAAArxB,EAAM,MAAMmxB,EAAO/K,EAAK,KAAK,GAAGgL,CAAM,GAChCpxB,EAAA,MAAMixB,EAAM50B,CAAI,GAAE,OAAK+0B,EAAOD,EAAOr0B,CAAC,CAAC,CAAC,GAC1CspB,EAAK,UAAU6K,EAAM50B,CAAI,KAC3B60B,EAAK,UAAU70B,CAAkB,IAAI+pB,EAAK,KAAK,GAE1CA;AAAAA,EACT;AAEA,QAAMA,IAAOtO,EAAUmZ,EAAM50B,CAAI,CAAC;AAClC,SAAA2D;AAAA,IACE,MAAMixB,EAAM50B,CAAI;AAAA,IAChB,CAAKS,MAAA;AACH,MAAKmD,GAAQnD,GAAGspB,EAAK,KAAK,MACxBA,EAAK,QAAQtpB;AAAA,IAEjB;AAAA,EAAA,GAEFkD,EAAMomB,GAAM,CAAKtpB,MAAA;AACf,IAAKmD,GAAQnD,GAAGm0B,EAAM50B,CAAI,CAAC,KACpB60B,EAAA,UAAU70B,CAAkB,IAAIS,CAAC;AAAA,EACxC,CACD,GACMspB;AACT;AAMO,SAASkL,GACdL,GACA50B,GACAk1B,GACAL,GACuB;AAGvB,QAAMM,IAAQt1B,GAA0B,oBAAA,IAAK,CAAA;AAC7C,SAAA8D;AAAA,IACE,MAAMixB,EAAM50B,CAAI;AAAA,IAChB,MAAM;AAIJ,YAAMg1B,IADiBJ,EAAM50B,CAAI,EACX,OAAO,CAAKoC,MAAAA,KAAK8yB,EAAa,KAAK;AACzD,MAAKtxB,GAAQoxB,GAAU,MAAM,KAAKG,CAAK,CAAC,MACtCA,EAAM,MAAM,GACHH,EAAA,QAAQG,EAAM,KAAKA,CAAK;AAAA,IAErC;AAAA,IACA,EAAE,MAAM,IAAM,WAAW,GAAK;AAAA,EAAA,GAEhCxxB,EAAMwxB,GAAO,MAAM;AACX,UAAAjzB,IAAQ,MAAM,KAAKizB,CAAK;AAC9B,IAAKvxB,GAAQgxB,EAAM50B,CAAI,GAAGkC,CAAK,KACxB2yB,EAAA,UAAU70B,CAAI,IAAakC,CAAK;AAAA,EACvC,CACD,GACMxC,GAASy1B,CAAK;AACvB;AC3EA,MAAMlwB,KAAe,OAAO,WAAW;AAEvB,SAAAmwB,GACd3U,GACA8B,GACAmC,GACA;AACA,EAAAtkB,GAAQ6E,IAAc;AAAA,IACpB,eAAAwb;AAAA,IACA,eAAA8B;AAAA,IACA,eAAAmC;AAAA,EAAA,CACD;AACH;AAEO,SAAS2Q,KAA4B;AAC1C,SAAOv1B,EAAQQ,GAAO2E,EAAY,GAAG,YAAY;AACnD;ACrBA,MAAMA,KAAe,OAAO,SAAS;AAE9B,SAASqwB,GAAeza,GAA4B;AACzD,EAAAza,GAAQ6E,IAAc4V,CAAO;AAC/B;AAEO,SAAS0a,KAAsB;AACpC,SAAOz1B,EAAQQ,GAAO2E,EAAY,GAAG,SAAS;AAChD;ACXgB,SAAAuwB,GAAYC,GAAUhL,GAA8B;AAClE,WAAStiB,IAAI,GAAGA,IAAIstB,EAAI,SAAS,GAAGttB;AAClC,IAAAsiB,EAAKgL,EAAIttB,CAAC,GAAGstB,EAAIttB,IAAI,CAAC,CAAC;AAE3B;ACJgB,SAAAutB,GAAsCD,GAAU91B,GAAgB;AACxE,QAAAwI,IAAIstB,EAAI,QAAQ91B,CAAK;AAC3B,EAAIwI,KAAK,KAAOstB,EAAA,OAAOttB,GAAG,CAAC;AAC7B;AAEgB,SAAAwtB,GAAuCF,GAAUG,GAASj2B,GAAgB;AAClF,QAAAwI,IAAIstB,EAAI,QAAQG,CAAI;AAC1B,EAAIztB,IAAI,KACRstB,EAAI,OAAOttB,IAAI,GAAG,GAAGxI,CAAK;AAC5B;ACHgB,SAAAk2B,GACd70B,GACA80B,GAC0B;AAC1B,QAAMC,IAAuC;AAAA,IAC3C;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAGF,SAAOpd,EAAsB,MAAM;AACjC,UAAMqd,IAAUC,GAAKj1B,EAAQ,KAAK,iBAAiB,EAChD,OAAO,CAASk1B,MAAA;AACT,YAAAC,IAAUJ,EAAc,SAASG,CAAK;AAC5C,aAAKC,KACK,QAAA,KAAK,SAASD,CAAK,2BAA2B,GAEjDC;AAAA,IAAA,CACR,EACA,QAAQ,GACLC,IAAQ,CAAC,GAAGL,CAAa;AACtB,WAAAP,GAAAQ,GAAS,CAACK,GAAOC,MAAW;AACnC,MAAAZ,GAAWU,GAAOE,CAAM,GACZX,GAAAS,GAAOC,GAAOC,CAAM;AAAA,IAAA,CACjC,GAGK,gBAAgBR,KAAS,iBAAiBA,KAC9CJ,GAAWU,GAAO,aAAa,GAE5Bp1B,EAAQ,KAAK,UAAU,WAC1B00B,GAAWU,GAAO,WAAW,GAE3Bp1B,EAAQ,KAAK,MAAM,YAAY,MACjC00B,GAAWU,GAAO,aAAa,GAE5Bp1B,EAAQ,KAAK,WAChB00B,GAAWU,GAAO,OAAO,GAGpBA;AAAA,EAAA,CACR;AACH;AClDO,MAAMG,KAAgB,MACpB,IAAI,QAAQ,CAACC,MAAYnC,GAASmC,CAAqB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBCU3DC,IAAc9d,EAAS,MAAM;AACjC,YAAMrU,IAAIswB,EAAM,OACV3nB,IAAI2nB,EAAM;AAChB,aAAIA,EAAM,WACD,GAAGtwB,CAAC,IAAI2I,CAAC,OAAOA,IAAI,CAAC,KAAK3I,CAAC,OAE3B,QAAQA,CAAC,IAAI2I,IAAI,CAAC,OAAOA,CAAC;AAAA,IACnC,CACD;;;;;;;;;;;;;;;;;iBCRKypB,IAAc/d,EAAS,MACpBic,EAAM,UAAU,gBAAgB,IAAI,KAAK,IAAIA,EAAM,OAAOA,EAAM,MAAM,IAAI,CAClF,GAEK+B,IAAche,EAAS,MAAM;AAC3B,YAAAiB,IAAI8c,EAAY,QAAQ,GACxBpyB,IAAIswB,EAAM,OACV3nB,IAAI2nB,EAAM;AAChB,aAAIA,EAAM,WACD,GAAGtwB,IAAIsV,CAAC,IAAI3M,IAAI2M,CAAC,KAAKA,CAAC,IAAI3M,IAAI,CAAC,KAAK3I,IAAIsV,CAAC,IAAIA,CAAC,KAE/C,GAAGA,CAAC,IAAIA,CAAC,KAAKtV,IAAIsV,CAAC,IAAI3M,IAAI,CAAC,KAAK2M,CAAC,IAAI3M,IAAI2M,CAAC;AAAA,IACpD,CACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBChBKgd,IAAiC;AAAA,MACrC,OAAOC;AAAAA,MACP,OAAOC;AAAAA,MACP,QAAQC;AAAAA,IAAA,GASJ9uB,IAAQ0Q;AAAA,MACZ,MAAMic,EAAM,OAAO,SAASA,EAAM,OAAO,UAAU,gBAAgB,IAAIA,EAAM;AAAA,IAAA,GAGzElH,IAAS/U;AAAA,MACb,MAAMic,EAAM,OAAO,UAAUA,EAAM,OAAO,UAAU,gBAAgB,IAAIA,EAAM;AAAA,IAAA,GAG1EoC,IAAOre,EAAS,MAAM;AACpB,YAAAlI,IAASmkB,EAAM,OAAO,UAAUA,EAAM,OAAO,UAAU,gBAAgB,IAAIA,EAAM;AACvF,aAAOA,EAAM,OAAO,WAAW3sB,EAAM,QAAQwI,IAAS,CAACA;AAAA,IAAA,CACxD,GAEKwmB,IAAate,EAAS,MAAM;AAC1B,YAAAue,IAAStC,EAAM,OAAO,UAAUA,EAAM,OAAO,UAAU,gBAAgB,IAAIA,EAAM;AACvF,aAAOA,EAAM,OAAO,WAAWsC,IAAS,CAACA;AAAA,IAAA,CAC1C;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BD,UAAM,EAAE,WAAAxT,GAAW,YAAA/gB,EAAW,IAAItC,GAAc,GAC1C,EAAE,WAAAqgB,MAAcoT,MAChBpxB,IAAUknB,MACV7kB,IAASa,MAGTuxB,IAAY1b,EAAW,EAAE,GAAG,GAAG,GAAG,GAAG,GAGrCuK,IAAWvK,EAAU,EAAE,OAAO,KAAK,QAAQ,KAAK;AAEtD,IAAA2I,GAAU,MAAM;;AACR,YAAA8N,KAAM9tB,IAAAzB,EAAW,UAAX,gBAAAyB,EAAkB;AAC9B,MAAI8tB,MACFiF,EAAU,QAAQ;AAAA,QAChB,GAAG,CAACjF,EAAI;AAAA,QACR,GAAG,CAACA,EAAI;AAAA,MAAA;AAGN,YAAA/iB,IAAOuU,EAAU,MAAM,sBAAsB;AACnD,MAAAsC,EAAS,QAAQ;AAAA,QACf,OAAO7W,EAAK;AAAA,QACZ,QAAQA,EAAK;AAAA,MAAA;AAAA,IACf,CACD,GAEOzM,EAAA,GAAG,eAAe,CAAQyM,MAAA;AAChC,MAAA6W,EAAS,QAAQ,EAAE,OAAO7W,EAAK,OAAO,QAAQA,EAAK;IAAO,CAC3D,GAEOzM,EAAA,GAAG,YAAY,CAAOwvB,MAAA;AAClB,MAAAiF,EAAA,QAAQ,EAAE,GAAG,CAACjF,EAAI,GAAG,GAAG,CAACA,EAAI;IAAE,CAC1C,GAEOxvB,EAAA,GAAG,aAAa,MAAM;;AACtB,YAAAwvB,KAAM9tB,IAAAzB,EAAW,UAAX,gBAAAyB,EAAkB;AAC9B,MAAI8tB,MACQiF,EAAA,QAAQ,EAAE,GAAG,CAACjF,EAAI,GAAG,GAAG,CAACA,EAAI;IACzC,CACD;AAEK,UAAAkF,IAAiB3b,EAAqB,CAAA,CAAE,GACxC4b,IAAmB5b,EAAqB,CAAA,CAAE,GAC1C6b,IAAkB7b,EAAqB,CAAA,CAAE,GACzC8b,IAAoB9b,EAAqB,CAAA,CAAE;AAGjD,WAAA9U,GAAY,MAAM;AAChB,YAAM6wB,IAA0B,CAAA,GAC1BC,IAA0B,CAAA,GAC1BC,IAA2B,CAAA,GAC3BC,IAA2B,CAAA,GAE3Bx1B,IAAI,IAAIue,EAAU,OAClBkX,IAAK7yB,EAAO,KAAK,UACjBkG,IAAIksB,EAAU,MAAM,IAAIh1B,GACxB+I,IAAIisB,EAAU,MAAM,IAAIh1B,GACxB8F,IAAQ,KAAK,MAAM+d,EAAS,MAAM,QAAQ4R,IAAK,CAAC,IAAIA,GACpDlK,IAAS,KAAK,MAAM1H,EAAS,MAAM,SAAS4R,IAAK,CAAC,IAAIA,GACtDC,KAAYV,EAAU,MAAM,IAAIlvB,KAAS9F,GACzC21B,KAAaX,EAAU,MAAM,IAAIzJ,KAAUvrB,GAC3C41B,IAAMhzB,EAAO,KAAK,iBAClBizB,IAAkBjzB,EAAO,KAAK,KAAK,WACnCkzB,IAAiBlzB,EAAO,KAAK,MAAM;AAEzC,UAAImzB,IAAa;AAAA,QACf,QAAQnzB,EAAO,KAAK,MAAM;AAAA,QAC1B,gBAAgBA,EAAO,KAAK,MAAM;AAAA,QAClC,oBAAoBkzB;AAAA,QACpB,qBAAqBA,IAAiBhtB,IAAI9I,IAAI;AAAA,MAAA,GAG5Cg2B,IAAc;AAAA,QAChB,QAAQpzB,EAAO,KAAK,KAAK;AAAA,QACzB,gBAAgBA,EAAO,KAAK,KAAK;AAAA,QACjC,oBAAoBizB;AAAA,QACpB,qBAAqBA,IAAkB/sB,IAAI9I,IAAI;AAAA,MAAA;AAIjD,YAAMmC,KAAK6yB,EAAU,MAAM,IAAIlvB,KAAS9F;AACxC,eAASgG,IAAI+C,GAAG/C,KAAK2vB,GAAW3vB,KAAKyvB,GAAI;AACvC,cAAM3nB,IAAQ,KAAK,MAAM9H,IAAIyvB,CAAE;AAC3B,QAAAG,KAAO9nB,IAAQ8nB,MAAQ,IAClBP,EAAA,KAAK,CAACvnB,GAAOA,IAAQ2nB,GAAI3sB,GAAG3G,GAAG4zB,CAAU,CAAC,IAEzCR,EAAA,KAAK,CAACznB,GAAOA,IAAQ2nB,GAAI3sB,GAAG3G,GAAG6zB,CAAW,CAAC;AAAA,MAEvD;AAEa,MAAAD,IAAA30B,GAAA,IAAK20B,IAClBA,EAAW,mBAAmB,IAAID,IAAiB/sB,IAAI/I,IAAI,QAE7Cg2B,IAAA50B,GAAA,IAAK40B,IACnBA,EAAY,mBAAmB,IAAIH,IAAkB9sB,IAAI/I,IAAI;AAG7D,YAAM8K,KAAKkqB,EAAU,MAAM,IAAIzJ,KAAUvrB;AACzC,eAASgG,IAAI8C,GAAG9C,KAAK0vB,GAAU1vB,KAAKyvB,GAAI;AACtC,cAAM3nB,IAAQ,KAAK,MAAM9H,IAAIyvB,CAAE;AAC3B,QAAAG,KAAO9nB,IAAQ8nB,MAAQ,IAClBN,EAAA,KAAK,CAACxnB,GAAOA,IAAQ2nB,GAAI1sB,GAAG+B,GAAGirB,CAAU,CAAC,IAEzCP,EAAA,KAAK,CAAC1nB,GAAOA,IAAQ2nB,GAAI1sB,GAAG+B,GAAGkrB,CAAW,CAAC;AAAA,MAEvD;AAEA,MAAAd,EAAiB,QAAQG,GACzBJ,EAAe,QAAQK,GACvBF,EAAkB,QAAQG,GAC1BJ,EAAgB,QAAQK;AAAA,IAAA,CACzB;;;;;;;;;;;;;;;;;;;;;;;AClHK,UAAA,EAAE,UAAA3R,MAAa3lB,MAGf+3B,IAAa3c,KAEb4c,IAAmB,CAACC,GAAiBC,GAAsBC,MAAyB;AAClF,MAAAF,EAAA,QAAQ,CAAQG,MAAA;;AAAA,eAAAF,EAAQ,aAAaE,IAAMr0B,IAAAo0B,EAAQ,aAAaC,CAAI,MAAzB,OAAAr0B,IAA8B,EAAE;AAAA,OAAC;AAAA,IAAA,GAG9Es0B,IAAW,IAAI,iBAAiB,CAAWC,MAAA;AAC/C,UAAI,CAACP,EAAW;AAAO;AACjB,YAAAE,IAAQK,EAAQ,IAAI,CAAAC,MAAA;;AAAK,gBAAAx0B,IAAAw0B,EAAE,kBAAF,OAAAx0B,IAAmB;AAAA,OAAE,EAAE,OAAO,OAAO;AACpE,MAAAi0B,EAAiBC,GAAOF,EAAW,OAAOpS,EAAS,KAAK;AAAA,IAAA,CACzD;AAED,WAAA5B,GAAU,MAAM;AACR,YAAAkU,IAAQ,CAAC,aAAa,OAAO;AAKnC,MAJSI,EAAA,QAAQ1S,EAAS,OAAO;AAAA,QAC/B,YAAY;AAAA,QACZ,iBAAiBsS;AAAA,MAAA,CAClB,GACIF,EAAW,SAChBC,EAAiBC,GAAOF,EAAW,OAAOpS,EAAS,KAAK;AAAA,IAAA,CACzD,GAED3B,GAAY,MAAM;AAChB,MAAAqU,EAAS,WAAW;AAAA,IAAA,CACrB;;;;;;;;;;;;;;;;;iBCdK,EAAE,OAAAr3B,MAAUyyB,MAEZ/uB,IAASe,MACT;AAAA,MACJ,4BAAA6c;AAAA,MACA,4BAAAK;AAAA,MACA,2BAAAC;AAAA,MACA,sBAAAJ;AAAA,MACA,4BAAAE;AAAA,MACA,uBAAAG;AAAA,QACEsG,GAAkB,GAEhBqP,IAAQlgB,EAAS,MAAM;AACrB,YAAAnU,IAAIowB,EAAM,MAAM;AAClB,UAAAA,EAAM,MAAM,MAAM;AACpB,cAAM,EAAE,QAAA5nB,GAAQ,YAAAkS,GAAY,aAAAvH,EAAY,IAAIid,EAAM,MAAM,MAClD,CAACtd,GAAIC,CAAE,IAAIvK,GACX8rB,IAAK5Z,IAAa,IAAI,GACtB6Z,IAAKphB,IAAc,IAAI;AACtB,eAAA,KAAKnT,EAAE,GAAG,CAAC,IAAIA,EAAE,GAAG,CAAC,MAAM8S,CAAE,IAAIC,CAAE,MAAMuhB,CAAE,IAAIC,CAAE,IAAIv0B,EAAE,GAAG,CAAC,IAAIA,EAAE,GAAG,CAAC;AAAA,MAAA;YACnEO,EAAO,SAAS,cAAc,CAAC6vB,EAAM,MAAM;AACpD,iBAAO,KAAKpwB,EAAE,GAAG,CAAC,IAAIA,EAAE,GAAG,CAAC,MAAMA,EAAE,GAAG,CAAC,IAAIA,EAAE,GAAG,CAAC;AAC7C;AACL,gBAAM0D,IAAS,CAAC,GAAG0sB,EAAM,MAAM,MAAM,SAAS,EAAE,GAAGpwB,EAAE,GAAG,GAAG,GAAGA,EAAE,GAAG,GAAG,GAChE8Q,IAAc,CAAA;AAClB,iBAAAA,EAAA,KAAK,KAAK9Q,EAAE,GAAG,CAAC,IAAIA,EAAE,GAAG,CAAC,EAAE,GACxBw0B,GAAA9wB,GAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC0D,GAAIC,CAAE,MAAMyJ,EAAE,KAAK,KAAK1J,EAAG,CAAC,IAAIA,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAIA,EAAG,CAAC,EAAE,CAAC,GAC3EyJ,EAAE,KAAK,GAAG;AAAA,QACnB;AAAA;AAAA,IAAA,CACD,GAEK2jB,IAActgB,EAAS,OAAOic,EAAM,MAAM,KAAK,OAAO,QAAQ,MAAMvzB,EAAM,KAAK;;;;;;;;;;;;;;;;;;;AChDrF,UAAM,EAAE,YAAAsS,GAAY,iBAAA2H,GAAiB,SAAAT,MAAYuB,GAAU;;;;;;;;;;;;;;;;;;;iBCSrD,EAAE,OAAA/a,MAAUyyB,MAEZmF,IAActgB,EAAS,MACpBic,EAAM,OAAO,QAAQvzB,EAAM,KACnC,GAEK63B,IAAkBvgB,EAAS,MACxB7W,GAAsB8yB,EAAM,OAAO,WAAWvzB,EAAM,KAAK,CACjE,GAEK83B,IAAiBxgB,EAAS,MAAM;AACpC,YAAMygB,IAAQxE,EAAM,OAAO,UACvB3yB,GAAiB2yB,EAAM,OAAO,SAAS,IAAIA,EAAM,OAAO,iBAAiBvzB,EAAM,QAC/E;AACJ,aAAO+3B,IAAS,EAAE,qBAAqBA,EAA4B,IAAA;AAAA,IAAA,CACpE;;;;;;;;;;;;;;;;;;;;;;iBCZK,EAAE,OAAA/3B,MAAUyyB,MAEZmF,IAActgB,EAAS,MACpBic,EAAM,OAAO,QAAQvzB,EAAM,KACnC,GAEK63B,IAAkBvgB,EAAS,MACxB7W,GAAsB8yB,EAAM,OAAO,WAAWvzB,EAAM,KAAK,CACjE,GAEK83B,IAAiBxgB,EAAS,MAAM;AACpC,YAAMygB,IAAQxE,EAAM,OAAO,UACvB3yB,GAAiB2yB,EAAM,OAAO,SAAS,IAAIA,EAAM,OAAO,iBAAiBvzB,EAAM,QAC/E;AACJ,aAAO+3B,IAAS,EAAE,qBAAqBA,EAA4B,IAAA;AAAA,IAAA,CACpE,GAEKP,IAAQlgB,EAAS,MAAM;AAC3B,YAAM,EAAE,IAAA/M,GAAI,IAAAC,GAAI,QAAAmB,GAAQ,YAAAkS,GAAY,aAAAvH,EAAgB,IAAAid,GAC9C,CAACtd,GAAIC,CAAE,IAAIvK,GACX8rB,IAAK5Z,IAAa,IAAI,GACtB6Z,IAAKphB,IAAc,IAAI;AAC7B,aAAO,KAAK/L,EAAG,CAAC,IAAIA,EAAG,CAAC,MAAM0L,CAAE,IAAIC,CAAE,MAAMuhB,CAAE,IAAIC,CAAE,IAAIltB,EAAG,CAAC,IAAIA,EAAG,CAAC;AAAA,IAAA,CACrE;;;;;;;;;;;;;;;;;;;;;iBCnBK,EAAE,OAAAxK,MAAUyyB,MAEZ+E,IAAQlgB,EAAS,MAAM;;AACrB,YAAAnU,IAAIowB,EAAM,MAAM,UAChB1sB,IAAS,CAAC,IAAIS,KAAAvE,IAAAwwB,EAAM,MAAM,UAAZ,gBAAAxwB,EAAmB,YAAnB,OAAAuE,IAA8B,IAAK,EAAE,GAAGnE,EAAE,GAAG,GAAG,GAAGA,EAAE,GAAG,GAAG,GACzE8Q,IAAc,CAAA;AAClB,aAAAA,EAAA,KAAK,KAAK9Q,EAAE,GAAG,CAAC,IAAIA,EAAE,GAAG,CAAC,EAAE,GACxBw0B,GAAA9wB,GAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC0D,GAAIC,CAAE,MAAMyJ,EAAE,KAAK,KAAK1J,EAAG,CAAC,IAAIA,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAIA,EAAG,CAAC,EAAE,CAAC,GAC3EyJ,EAAE,KAAK,GAAG;AAAA,IAAA,CAClB,GAEK2jB,IAActgB,EAAS,MACpBic,EAAM,OAAO,QAAQvzB,EAAM,KACnC,GAEK63B,IAAkBvgB,EAAS,MACxB7W,GAAsB8yB,EAAM,OAAO,WAAWvzB,EAAM,KAAK,CACjE,GAEK83B,IAAiBxgB,EAAS,MAAM;AACpC,YAAMygB,IAAQxE,EAAM,OAAO,UACvB3yB,GAAiB2yB,EAAM,OAAO,SAAS,IAAIA,EAAM,OAAO,iBAAiBvzB,EAAM,QAC/E;AACJ,aAAO+3B,IAAS,EAAE,qBAAqBA,EAA4B,IAAA;AAAA,IAAA,CACpE;;;;;;;;;;;;;;;;;;;;;;;ACxBD,UAAMr0B,IAASe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBCHT,EAAE,OAAAzE,MAAUyyB,MAEZ7oB,IAAIwQ,EAAImZ,EAAM,KAAK,GACnB1pB,IAAIuQ,EAAImZ,EAAM,KAAK,GACnBqE,IAAcxd,EAAI,CAAC,GACnBvB,IAAcuB,EAAI,SAAS,GAC3Byd,IAAkBzd,EAAiC,MAAS,GAC5DzO,IAASyO,EAAI,CAAC,GACdxT,IAAQwT,EAAI,CAAC,GACbiS,IAASjS,EAAI,CAAC,GACdlM,IAAekM,EAAI,CAAC;AAE1B,WAAA9U,GAAY,MAAM;;AAChB,YAAMxE,IAAId,EAAM;AACJ,MAAA43B,EAAA,QAAQrE,EAAM,OAAO,cAAczyB,GACnC+X,EAAA,SAAQ9V,IAAAwwB,EAAM,OAAO,gBAAb,OAAAxwB,IAA4B,QAChD80B,EAAgB,QAAQp3B,GAAsB8yB,EAAM,OAAO,iBAAiBzyB,CAAC,GAEzEyyB,EAAM,OAAO,SAAS,YACxB3pB,EAAE,QAAQ2pB,EAAM,OAChB1pB,EAAE,QAAQ0pB,EAAM,OACT5nB,EAAA,QAAQ4nB,EAAM,OAAO,SAASzyB,MAE/B8F,EAAA,QAAQ2sB,EAAM,OAAO,QAAQzyB,GAC5BurB,EAAA,QAAQkH,EAAM,OAAO,SAASzyB,GACxBoN,EAAA,QAAQqlB,EAAM,OAAO,eAAezyB,GACjD8I,EAAE,QAAQ2pB,EAAM,QAAQ3sB,EAAM,QAAQ,GACtCiD,EAAE,QAAQ0pB,EAAM,QAAQlH,EAAO,QAAQ;AAAA,IACzC,CACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBCzBK4K,IAAQe,MAER,EAAE,OAAAh4B,MAAUyyB,MAEZwF,IAAQ3gB,EAAS,MAAM;;AAAA,cAAAhQ,KAAAvE,IAAAwwB,EAAM,SAAN,gBAAAxwB,EAAY,WAAW,MAAM,aAA7B,OAAAuE,IAAyC;AAAA,KAAE,GAElE4wB,IAAW5gB,EAAS,MAAM;;AAC9B,cAAQvU,IAAAk0B,EAAM,WAAW,MAAjB,OAAAl0B,IAAiCwwB,EAAM,OAAO,WAAWvzB,EAAM;AAAA,IAAA,CACxE,GAEKm4B,IAAa7gB,EAAS,MAAM4gB,EAAS,QAAQ3E,EAAM,OAAO,UAAU,GAEpE6E,IAAY9gB,EAAS,MAAM;AAC/B,YAAM+gB,IAAmB9E,EAAM;AAC/B,aAAI8E,MAAqB,YAChB,IACEA,MAAqB,YACvB,EAAEF,EAAW,SAASF,EAAM,MAAM,SAAS,MAAM,IAGjD,CAACE,EAAW,SAASF,EAAM,MAAM,SAAS;AAAA,IACnD,CACD,GAEKhT,IAAU7K,KACVke,IAAYle,EAAI,EAAE,GAClB1Y,IAAMlD,GAAe,EAAE,GAAG,GAAG,GAAG,GAAG,OAAO,GAAG,QAAQ,EAAG,CAAA,GACxD+5B,IAAoBjhB,EAAS,MAAM;;AACjC,YAAA5T,IAAS6vB,EAAM,OAAO;AAC5B,UAAI,CAAC7vB;AAAe,eAAAhC;AACpB,UAAI82B,GAAiBC;AACjB,MAAA/0B,EAAO,mBAAmB,UAC5B80B,IAAkB90B,EAAO,QAAQ,UACjC+0B,IAAoB/0B,EAAO,QAAQ,eAEnC80B,KAAkBz1B,IAAAW,EAAO,YAAP,OAAAX,IAAkB,GACpC01B,KAAoBnxB,IAAA5D,EAAO,YAAP,OAAA4D,IAAkB;AAElC,YAAA2L,IAAaklB,EAAW,QAAQD,EAAS;AACxC,aAAA;AAAA,QACL,GAAGx2B,EAAI,IAAI+2B,IAAoBz4B,EAAM;AAAA,QACrC,GAAG0B,EAAI,IAAI82B,IAAkBx4B,EAAM,QAAQiT,IAAa;AAAA,QACxD,OAAOvR,EAAI,QAAQ+2B,IAAoB,IAAIz4B,EAAM;AAAA,QACjD,QAAQ0B,EAAI,SAAS82B,IAAkB,IAAIx4B,EAAM,QAAQiT;AAAA,MAAA;AAAA,IAC3D,CACD;AAEG,QAAAokB;AACJ,UAAMqB,IAAiB,MAAM;AAC3B,MAAInF,EAAM,OAAO,cAAcA,EAAM,OAAO,WAAW,UACjD,CAAC8D,KAAYpS,EAAQ,UACvBoS,IAAWsB,EAAuB1T,EAAQ,OAAOvjB,GAAK42B,CAAS,MAGjEjB,KAAA,QAAAA,EAAU,cACCA,IAAA;AAAA,IACb;AAGQ,IAAAtU,GAAA,MAAM2V,GAAgB,GAChCp2B;AAAA,MACE,MAAMixB,EAAM,OAAO,cAAcA,EAAM,OAAO,WAAW;AAAA,MACzD,CAACn0B,GAAGgU,MAAS;AACX,QAAIhU,KAAKgU,KACMslB;MACjB;AAAA,IAAA,GAEF1V,GAAY,MAAM;AAChB,MAAAqU,KAAA,QAAAA,EAAU,cACCA,IAAA;AAAA,IAAA,CACZ;AAEQ,aAAAuB,EACP3T,GACAvjB,GACA42B,GACA;;AACM,YAAAO,IAAO5T,EAAQ;AACrBvjB,MAAAA,EAAI,IAAIm3B,EAAK,GACbn3B,EAAI,IAAIm3B,EAAK,GACbn3B,EAAI,QAAQm3B,EAAK,OACjBn3B,EAAI,SAASm3B,EAAK,QAClBP,EAAU,SAAQrT,IAAAA,EAAQ,aAAa,WAAW,MAAhCA,OAAAA,IAAqC;AAAA,IACzD;AAES,aAAA0T,EACP1T,GACAvjB,GACA42B,GACA;AACMjB,YAAAA,IAAW,IAAI,iBAAiB,MAAM;AACjBpS,QAAAA,EAAAA,GAASvjB,GAAK42B,CAAS;AAAA,MAAA,CACjD;AACDjB,aAAAA,EAAS,QAAQpS,GAAS;AAAA,QACxB,YAAY;AAAA,QACZ,iBAAiB,CAAC,KAAK,KAAK,aAAa,WAAW;AAAA,MAAA,CACrD,GACwBA,EAAAA,GAASvjB,GAAK42B,CAAS,GACzCjB;AAAAA,IACT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBCxGM3zB,IAASe,MACT;AAAA,MACJ,6BAAAqd;AAAA,MACA,6BAAAC;AAAA,MACA,4BAAAC;AAAA,MACA,uBAAAC;AAAA,MACA,6BAAAC;AAAA,MACA,wBAAAC;AAAA,QACEgG,GAAkB,GAEhB,EAAE,YAAA7V,MAAeyI,MAIjBrZ,IAAM0Y,EAAkB,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,KAAK,GAClE0e,IAAY1e,EAAc,EAAE,GAAG,GAAG,GAAG,GAAG;AAE9C,IAAA9U,GAAY,MAAM;AACV,YAAAmB,IAAS,OAAO,KAAK8sB,EAAM,KAAK,EAAE,KAAK,CAAA9sB,MAAUA,KAAU6L,CAAU;AAC3E,MAAI7L,MACE/E,EAAA,QAAQ4Q,EAAW7L,CAAM,EAAE,UAC/BqyB,EAAU,QAAQ;AAAA,QAChB,IAAIp3B,EAAI,MAAM,GAAG,IAAIA,EAAI,MAAM,GAAG,KAAK;AAAA,QACvC,IAAIA,EAAI,MAAM,GAAG,IAAIA,EAAI,MAAM,GAAG,KAAK;AAAA,MAAA;AAAA,IAE3C,CACD;AAED,UAAMq3B,IAAUzhB,EAAS,MAAM,OAAO,KAAKic,EAAM,KAAK,CAAC,GACjDyF,IAAc1hB,EAAS,MAAMpY,EAAO,OAAOwE,EAAO,WAAW,OAAO6vB,EAAM,KAAK,CAAC,GAChF0F,IAAc3hB,EAAS,MAAMpY,EAAO,OAAOwE,EAAO,WAAW,OAAO6vB,EAAM,KAAK,CAAC,GAChF2F,IAAe5hB,EAAS,MAAMpY,EAAO,OAAOwE,EAAO,WAAW,QAAQ6vB,EAAM,KAAK,CAAC,GAElF3c,IAAUU,EAAS,MAAMyhB,EAAQ,MAAM,KAAK,CAAA/1B,MAAQsP,EAAWtP,CAAI,EAAE,OAAO,CAAC,GAC7Eod,IAAa9I,EAAS,MAAMyhB,EAAQ,MAAM,KAAK,CAAA/1B,MAAQsP,EAAWtP,CAAI,EAAE,UAAU,CAAC,GACnF2T,IAAWW,EAAS,MAAMyhB,EAAQ,MAAM,KAAK,CAAA/1B,MAAQsP,EAAWtP,CAAI,EAAE,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBC7B/E,EAAE,KAAA0hB,MAAQ1lB,MACV,EAAE,OAAAgB,MAAUyyB,MACZ0G,IAAa10B;AAEnB,aAAS20B,IAAkB;AACzB,aAAI7F,EAAM,eACDr0B,EAAO,OAAOi6B,EAAW,WAAW,QAAQ5F,EAAM,KAAK,IAEvDA,EAAM,MAAM,KAAK;AAAA,IAE5B;AAEA,aAAS8F,EAAervB,GAAkC;AACxD,aAAO,EAAE,QAAQA,EAAK,IAAI,QAAQA,EAAK;IACzC;AAEA,aAASsvB,EAAqBj0B,GAAyB;AACrD,UAAIA,EAAM;AACR,eAAOA,EAAM,MAAM;AACd;AACC,cAAAkF,IAAKlF,EAAM,OAAO,IAClBmF,IAAKnF,EAAM,OAAO;AACjB,eAAA;AAAA,UACL,IAAIkF,EAAG,IAAIC,EAAG,KAAK;AAAA,UACnB,IAAID,EAAG,IAAIC,EAAG,KAAK;AAAA,QAAA;AAAA,MAEvB;AAAA,IACF;AAEA,aAAS+uB,IAAqB;;AAC5B,UAAI,CAAC7U,EAAI;AAAc,eAAA;AACjB,YAAAje,KAAS1D,IAAAwwB,EAAM,WAAN,OAAAxwB,IAAgB,OAAO,KAAKwwB,EAAM,KAAK,EAAE,CAAC,GACnD/vB,IAAOkhB,EAAI,MAAM,cAA8B,sBAAsBje,CAAM,IAAI;AACrF,aAAKjD,IACEA,EAAK,mBADM;AAAA,IAEpB;AAEA,aAASg2B,EAAuBxwB,GAAyB;;AACvD,UAAI,CAAC0b,EAAI,SAAS,CAAC,SAAS1b,CAAQ;AAAU,eAAAuqB,EAAM,MAAM,SAAS;AAG7D,MAAAA,EAAA;AAEA,YAAA9sB,KAAS1D,IAAAwwB,EAAM,WAAN,OAAAxwB,IAAgB,OAAO,KAAKwwB,EAAM,KAAK,EAAE,CAAC,GAEnD/vB,IAAOkhB,EAAI,MAAM,cAA8B,sBAAsBje,CAAM,IAAI;AACrF,UAAI,CAACjD;AAAa,eAAA+vB,EAAM,MAAM,SAAS;AAEjC,YAAApwB,IAAIK,EAAK,iBAAiBwF,CAAQ;AACxC,aAAO,EAAE,GAAG7F,EAAE,GAAG,GAAGA,EAAE;IACxB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9DA,UAAM,EAAE,YAAAmP,GAAY,kBAAA+H,GAAkB,SAAAb,MAAYuB,GAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJ5D,UAAM0Z,IAAQgF,MAERC,IAAqBpiB,EAAS,MAAM,kBAAkBmd,CAAK;;;;;;;;;;;;;;;;;;;;;;iBCa3D,EAAE,OAAAz0B,MAAUyyB,MAEZ1wB,IAAOuV,EAAS,MACbqiB;AAAAA,MACLpG,EAAM,MAAM;AAAA,MACZA,EAAM,MAAM,KAAK;AAAA,MACjBA,EAAM,MAAM,MAAM;AAAA,MAClBA,EAAM,MAAM,MAAM;AAAA,MAClBvzB,EAAM;AAAA,IAAA,CAET;;;;;;;;;;;;;;;;;;;;iBCVK,EAAE,OAAAA,MAAUyyB,MAEZ1wB,IAAOuV,EAAS,MAAM;;AAC1B,aAAOqiB;AAAAA,QACLpG,EAAM,MAAM;AAAA,SACZjsB,KAAAvE,IAAAwwB,EAAM,mBAAN,gBAAAxwB,EAAsB,WAAtB,OAAAuE,IAAgCisB,EAAM,MAAM,KAAK;AAAA,QACjDA,EAAM,MAAM,MAAM;AAAA,QAClBA,EAAM,MAAM,MAAM;AAAA,QAClBvzB,EAAM;AAAA,MAAA;AAAA,IACR,CACD;;;;;;;;;;;;;;;;;;ACdD,UAAM,EAAE,YAAAsS,GAAY,iBAAA2H,GAAiB,sBAAAP,MAAyBqB,GAAU,GAElEvV,IAAa8R,EAAS,MAAM;AAChC,YAAMsiB,IAAwC,CAAA,GACxCC,IAAwC,CAAA;AACvC,oBAAA,QAAQ5f,EAAgB,UAAU,EAAE,QAAQ,CAAC,CAACxY,GAAIkb,CAAK,MAAM;AAClE,QAAI,OAAO,KAAKA,EAAM,KAAK,EAAE,SAAS,MAChCA,EAAM,YACRkd,EAAWp4B,CAAE,IAAIkb,IAEjBid,EAAWn4B,CAAE,IAAIkb;AAAA,MAErB,CACD,GACM,EAAE,YAAAid,GAAY,YAAAC;IAAW,CACjC;AAED,aAASC,EAAyBnd,GAAkB;AAClD,aAAO,OAAO,KAAKA,EAAM,KAAK,EAAE,CAAC;AAAA,IACnC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBClBM/S,IAAI0N,EAAS,MAAM;;AAAA,eAAAvU,IAAAwwB,EAAM,QAAN,gBAAAxwB,EAAW,MAAK;AAAA,KAAC,GACpC8G,IAAIyN,EAAS,MAAM;;AAAA,eAAAvU,IAAAwwB,EAAM,QAAN,gBAAAxwB,EAAW,MAAK;AAAA,KAAC,GAEpCW,IAASc,MACTy0B,IAAcz6B,GAAqB,CAAA,CAAS;AAElD,WAAA8G,GAAY,MAAM;;AACV,YAAAy0B,IAAaxG,EAAM,MAAM;AAC3B,UAAAwG,EAAW,SAAS,UAAU;AAChC,cAAM95B,IAA0B;AAAA,UAC9B,MAAM;AAAA,UACN,QACE85B,EAAW,WACVh3B,IAAAg3B,EAAW,gBAAX,OAAAh3B,IAA0B,KAAK,IAChCW,EAAO,UAAU,UACjBA,EAAO,UAAU,QAAQ;AAAA,UAC3B,OAAO;AAAA,UACP,aAAaA,EAAO,UAAU;AAAA,UAC9B,aAAaA,EAAO,UAAU;AAAA,UAC9B,iBAAiBA,EAAO,UAAU;AAAA,QAAA;AAE7B,eAAA,OAAOu1B,GAAah5B,CAAK;AAAA,MAAA,OAC3B;AACL,cAAMA,IAA6B;AAAA,UACjC,MAAM;AAAA,UACN,OACE85B,EAAW,UACVzyB,IAAAyyB,EAAW,gBAAX,OAAAzyB,IAA0B,KAC3B5D,EAAO,UAAU,UAAU,IAC3BA,EAAO,UAAU;AAAA,UACnB,QACEq2B,EAAW,WACVzzB,IAAAyzB,EAAW,gBAAX,OAAAzzB,IAA0B,KAC3B5C,EAAO,UAAU,UAAU,IAC3BA,EAAO,UAAU;AAAA,UACnB,cACEq2B,EAAW,eAAe,IAAIA,EAAW,eAAer2B,EAAO,UAAU,UAAU;AAAA,UACrF,OAAO;AAAA,UACP,aAAaA,EAAO,UAAU;AAAA,UAC9B,aAAaA,EAAO,UAAU;AAAA,UAC9B,iBAAiBA,EAAO,UAAU;AAAA,QAAA;AAE7B,eAAA,OAAOu1B,GAAah5B,CAAK;AAAA,MAClC;AAAA,IAAA,CACD;;;;;;;;;;;ACxDK,UAAA,EAAE,YAAAmS,MAAe2I,MACjB,EAAE,eAAAqE,MAAkB4U,MACpBxa,IAAU0a;;;;;;;;;;;;;;;;;;iBCUVtqB,IAAI0N,EAAS,MAAM;;AAAA,eAAAvU,IAAAwwB,EAAM,QAAN,gBAAAxwB,EAAW,MAAK;AAAA,KAAC,GACpC8G,IAAIyN,EAAS,MAAM;;AAAA,eAAAvU,IAAAwwB,EAAM,QAAN,gBAAAxwB,EAAW,MAAK;AAAA,KAAC,GAEpC,EAAE,OAAA/C,MAAUyyB,MAEZ;AAAA,MACJ,4BAAA7R;AAAA,MACA,4BAAAC;AAAA,MACA,2BAAAC;AAAA,MACA,sBAAAX;AAAA,MACA,4BAAAG;AAAA,MACA,uBAAAS;AAAA,QACEoH,GAAkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBtB,UAAMsM,IAAQgF,MACRO,IAAsB1iB,EAAS,MAAM,mBAAmBmd,CAAK,GAC7D,EAAE,kBAAA5a,MAAqBkB,MAEvBpb,IAAU6E,MACVgV,IAAU0a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICRV+F,KAA0D;AAAA,EAC9D,CAAC36B,EAAmB,KAAK,GAAG;AAAA,EAC5B,CAACA,EAAmB,UAAU,GAAG;AAAA,EACjC,CAACA,EAAmB,IAAI,GAAG;AAAA,EAC3B,CAACA,EAAmB,UAAU,GAAG;AAAA,EACjC,CAACA,EAAmB,KAAK,GAAG;AAAA,EAC5B,CAACA,EAAmB,UAAU,GAAG;AAAA,EACjC,CAACA,EAAmB,IAAI,GAAG;AAAA,EAC3B,CAACA,EAAmB,UAAU,GAAG;AAAA,EACjC,CAACA,EAAmB,MAAM,GAAG;AAC/B,GAEM46B,KAAwD;AAAA;AAAA,EACpD,CAAC52B,GAAGwS,MAASqkB,GAAQ72B,GAAG,GAAGwS,IAAO,KAAK,EAAE;AAAA;AAAA,EACxC,CAACxS,GAAGwS,MAASqkB,GAAQ72B,GAAG,IAAIwS,IAAO,KAAK,EAAE;AAAA;AAAA,EAC3C,CAACxS,GAAGwS,MAASqkB,GAAQ72B,GAAG,IAAIwS,IAAO,KAAK,EAAE;AAAA;AAAA,EACzC,CAACxS,GAAGwS,MAASqkB,GAAQ72B,GAAG,KAAKwS,IAAO,KAAK,EAAE;AAAA;AAAA,EAC5C,CAACxS,GAAGwS,MAASqkB,GAAQ72B,GAAG,KAAKwS,IAAO,KAAK,EAAE;AAAA;AAAA,EAC1C,CAACxS,GAAGwS,MAASqkB,GAAQ72B,GAAG,KAAKwS,IAAO,KAAK,EAAE;AAAA;AAAA,EAC5C,CAACxS,GAAGwS,MAASqkB,GAAQ72B,GAAG,KAAKwS,IAAO,KAAK,EAAE;AAAA;AAAA,EAC1C,CAACxS,GAAGwS,MAASqkB,GAAQ72B,GAAG,KAAKwS,IAAO,KAAK,EAAE;AACtD;AAEO,SAASskB,GACdp4B,GACAq4B,GACAC,GACAC,GACAC,GACwB;AACpB,MAAAA,MAAqBl7B,EAAmB;AAC1C,WAAOA,EAAmB;AAI5B,QAAMm7B,IAA8B,CAAA;AAC7B,SAAA,QAAQH,CAAa,EAAE,QAAQ,CAAC,CAAC7zB,GAAQi0B,CAAY,MAAM;AAChE,QAAIC,IAAa;AACb,QAAAD,EAAa,WAAW14B,GAAQ;AAE5B,YAAA0J,IAAS6uB,EAAc9zB,CAAM;AACnC,MAAIiF,MACWivB,IAAA,IACED,IAAA1kB,GAAA9T,GAAA,IACVw4B,IADU;AAAA,QAEb,KAAK,EAAE,GAAGhvB,EAAO,GAAG,GAAGA,EAAO,EAAE;AAAA,MAAA;AAAA,IAGtC;AAIM,UAAAtC,KAASM,GAAYpB,GAASoyB,EAAa,KAAKL,CAAU,CAAC,IAAI,MAAM,MAAM;AACjF,IAAAI,EAAO,KAAK,CAACrxB,GAAOuxB,CAAU,CAAC;AAAA,EAAA,CAChC;AAEK,QAAAC,IAAiBC,GAAiBL,CAAgB,GAclDM,IAXa;AAAA,IACjBF;AAAA,KACCA,IAAiB,KAAK;AAAA;AAAA,KACtBA,IAAiB,KAAK;AAAA,KACtBA,IAAiB,IAAI,KAAK;AAAA,KAC1BA,IAAiB,KAAK;AAAA,KACtBA,IAAiB,IAAI,KAAK;AAAA,KAC1BA,IAAiB,KAAK;AAAA,KACtBA,IAAiB,IAAI,KAAK;AAAA,EAAA,EAGF,KAAK,CAAKxtB,MAC5BqtB,EAAO,MAAM,CAAKn3B,MAAA,CAAC42B,GAAW9sB,CAAC,EAAE,GAAG9J,CAAC,CAAC,CAC9C;AACD,SAAIw3B,MAAY,SACPN,IAEAO,GAAiBD,GAASN,CAAgB;AAErD;AAEA,SAASL,GAAQh7B,GAAgBuM,GAAgBsvB,GAAyB;AAC9D,EAAA77B,KAAA;AACJ,QAAAuyB,KAAOhmB,IAASsvB,IAAS,OAAO,KAChCrJ,KAAOjmB,IAASsvB,KAAU;AAChC,SAAItJ,KAAOC,IACFD,IAAMvyB,KAAUA,IAASwyB,IAEzBD,IAAMvyB,KAAUA,IAASwyB;AAEpC;AAEA,SAASkJ,GAAiB3lB,GAAmC;;AACpD,UAAAnS,IAAAk3B,GAAgB/kB,CAAS,MAAzB,OAAAnS,IAA8B;AACvC;AAEA,SAASg4B,GAAiBnsB,GAAeqsB,GAAsC;;AAC7E,UAAQ3zB,KAAAvE,IAAA,OAAO,QAAQk3B,EAAe,EAAErrB,CAAK,MAArC,gBAAA7L,EAAyC,OAAzC,OAAAuE,IAA+C2zB;AACzD;;;;;;;;;iBC/EMt7B,IAAU6E,MACV,EAAE,YAAA8N,MAAeyI,MACjB,EAAE,OAAA/a,MAAUyyB,MAEZ;AAAA,MACJ,4BAAA7R;AAAA,MACA,4BAAAC;AAAA,MACA,2BAAAC;AAAA,MACA,sBAAAX;AAAA,MACA,4BAAAG;AAAA,MACA,uBAAAS;AAAA,QACEoH,GAAkB,GAEhBve,IAAI0N,EAAS,MAAM;;AAAA,eAAAvU,IAAAwwB,EAAM,QAAN,gBAAAxwB,EAAW,MAAK;AAAA,KAAC,GACpC8G,IAAIyN,EAAS,MAAM;;AAAA,eAAAvU,IAAAwwB,EAAM,QAAN,gBAAAxwB,EAAW,MAAK;AAAA,KAAC,GAEpCuM,IAAcgI,EAAS,MACvBic,EAAM,MAAM,MAAM,cAAcj0B,EAAmB,SAC9C,IAEAi0B,EAAM,MAAM,MAAM,SAASvzB,EAAM,KAE3C,GAEKk7B,IAAc9gB,EAAI,CAAC,GACnB+gB,IAAc/gB,EAAI,CAAC,GACnBghB,IAAsBhhB,EAAI,CAAC,GAC3BihB,IAAsBjhB,EAAI,CAAC,GAE3BkhB,IAAiBhkB,EAAS,MAAM;;AAC9B,YAAApC,IAAYqe,EAAM,MAAM,MAAM,WAC9BgI,IAAiBhI,EAAM,MAAM,MAAM;AACzC,UAAIgI,MAAmB;AACd,eAAArmB;AAGT,YAAMxT,IAAM,EAAE,GAAGkI,EAAE,OAAO,GAAGC,EAAE;AAC/B,aAAI0xB,MAAmB,KACdnB;AAAA,QACL7G,EAAM,MAAM;AAAA,QACZ7xB;AAAA,QACA6xB,EAAM,MAAM;AAAA,QACZ,CAAC9sB,MAAA;;AAAmB,kBAAAa,KAAAvE,IAAAuP,EAAW7L,CAAM,MAAjB,gBAAA1D,EAAoB,SAApB,gBAAAuE,EAA0B;AAAA;AAAA,QAC9C4N;AAAA,MAAA,KAIAnS,IAAAw4B,EAAe;AAAA,QACb,QAAQhI,EAAM,MAAM;AAAA,QACpB,KAAA7xB;AAAA,QACA,eAAe6xB,EAAM,MAAM;AAAA,MAC5B,CAAA,MAJD,OAAAxwB,IAIMmS;AAAA,IAEV,CACD,GAEKsmB,IAAalkB,EAAS,MAAM;AAChC,cAAQgkB,EAAe,OAAO;AAAA,QAC5B,KAAKh8B,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AACf,iBAAA;AAAA,QACT,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AACf,iBAAA;AAAA,QACT,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AAAA,QACxB;AACS,iBAAA;AAAA,MACX;AAAA,IAAA,CACD,GAEK+4B,IAAmB/gB,EAAS,MAAM;AACtC,cAAQgkB,EAAe,OAAO;AAAA,QAC5B,KAAKh8B,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AACf,iBAAA;AAAA,QACT,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AACf,iBAAA;AAAA,QACT,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AAAA,QACxB;AACS,iBAAA;AAAA,MACX;AAAA,IAAA,CACD,GAEKm8B,IAASnkB,EAAS,MAAM;AAC5B,cAAQgkB,EAAe,OAAO;AAAA,QAC5B,KAAKh8B,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AACf,iBAAA;AAAA,QACT,KAAKA,EAAmB;AACtB,iBAAO67B,EAAY;AAAA,QACrB,KAAK77B,EAAmB;AACtB,iBAAO,CAAC67B,EAAY;AAAA,QACtB,KAAK77B,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AACtB,iBAAO+7B,EAAoB;AAAA,QAC7B,KAAK/7B,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AAAA,QACxB;AACE,iBAAO,CAAC+7B,EAAoB;AAAA,MAChC;AAAA,IAAA,CACD,GAEKK,IAASpkB,EAAS,MAAM;AAC5B,cAAQgkB,EAAe,OAAO;AAAA,QAC5B,KAAKh8B,EAAmB;AACtB,iBAAO,CAAC47B,EAAY;AAAA,QACtB,KAAK57B,EAAmB;AACtB,iBAAO47B,EAAY;AAAA,QACrB,KAAK57B,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AACf,iBAAA;AAAA,QACT,KAAKA,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AACtB,iBAAO,CAAC87B,EAAoB;AAAA,QAC9B,KAAK97B,EAAmB;AAAA,QACxB,KAAKA,EAAmB;AAAA,QACxB;AACE,iBAAO87B,EAAoB;AAAA,MAC/B;AAAA,IAAA,CACD;AAED,IAAA91B,GAAY,MAAM;AAChB,YAAMxE,IAAId,EAAM,OACVC,IAAQszB,EAAM,MAAM;AACtB,UAAAtzB,EAAM,QAAQ,UAAU;AACpB,cAAA0L,IAAS1L,EAAM,SAASa,GACxByX,IAAI5M,IAAS2D,EAAY,OACzBqsB,IAAiB,KAAK,KAAK5vB,GAAAwM,GAAK,KAAI,CAAC;AAC/B,QAAA2iB,EAAA,QAAQvvB,IAAS2D,EAAY,OAC7B6rB,EAAA,QAAQxvB,IAAS2D,EAAY,OACzC8rB,EAAoB,QAAQO,GAC5BN,EAAoB,QAAQM;AAAA,MAAA,OACvB;AACC,cAAAztB,IAAejO,EAAM,eAAea,GACpC8F,IAAQ3G,EAAM,QAAQa,GACtBurB,IAASpsB,EAAM,SAASa,GACxByX,IAAIrK,IAAeoB,EAAY,OAC/BqsB,IAAiB,KAAK,KAAK5vB,GAAAwM,GAAK,KAAI,CAAC;AAC/B,QAAA2iB,EAAA,QAAQ7O,IAAS,IAAI/c,EAAY,OACjC6rB,EAAA,QAAQv0B,IAAQ,IAAI0I,EAAY,OACxB8rB,EAAA,QAAQ/O,IAAS,IAAIne,IAAeytB,GACpCN,EAAA,QAAQz0B,IAAQ,IAAIsH,IAAeytB;AAAA,MACzD;AAAA,IAAA,CACD;AAED,UAAMC,IAAgBtkB,EAAS,MAAM,CAAC7V,MAChC9B,EAAQ,MAAM,mBACT;AAAA,MACL,aAAa,CAACqH,MAAoB;AAChC,QAAAA,EAAE,gBAAgB,GAClB4Z,EAA2Bnf,GAAIuF,CAAC;AAAA,MAClC;AAAA,MACA,cAAc,CAACA,MAAoB6Z,EAA2Bpf,GAAIuF,CAAC;AAAA,MACnE,cAAc,CAACA,MAAoB8Z,EAA0Brf,GAAIuF,CAAC;AAAA,MAClE,OAAO,CAACA,MAAkB;AACxB,QAAAA,EAAE,gBAAgB,GAClBmZ,EAAqB1e,GAAIuF,CAAC;AAAA,MAC5B;AAAA,MACA,UAAU,CAACA,MAAkB;AAC3B,QAAAA,EAAE,gBAAgB,GAClBsZ,EAA2B7e,GAAIuF,CAAC;AAAA,MAClC;AAAA,MACA,aAAa,CAACA,MAAkB;AAC9B,QAAA+Z,EAAsBtf,GAAIuF,CAAC;AAAA,MAC7B;AAAA,IAAA,IAGK,EAEV,GAEK60B,IAAevkB,EAAS,MAAM;AAC5B,YAAAwkB,IAAen8B,EAAQ,MAAM;AAC5B,aAAA;AAAA,QACL,mBAAmB;AAAA,QACnB,OAAOm8B,KAAgBvI,EAAM,MAAM;AAAA,QACnC,UAAUuI,KAAgBvI,EAAM,MAAM;AAAA,MAAA;AAAA,IACxC,CACD,GAEKwI,IAAezkB,EAAS,MAAM;AAC5B,YAAAwkB,IAAen8B,EAAQ,MAAM;AAC5B,aAAA;AAAA,QACL,WAAWm8B,KAAgBvI,EAAM,MAAM;AAAA,QACvC,YAAYuI,KAAgBvI,EAAM,MAAM;AAAA,MAAA;AAAA,IAC1C,CACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnND,UAAMkB,IAAQgF,MACRuC,IAA2B1kB,EAAS,MAAM,yBAAyBmd,CAAK,GACxE,EAAE,kBAAA5a,MAAqBkB,MAEvBpb,IAAU6E,MACVgV,IAAU0a,MAEV9hB,IAAakF,EAAS,MAAM2kB,EAAoBpiB,EAAiB,KAAK,CAAC;AAE7E,aAASoiB,EAAoBpiB,GAA4C;AAChEA,aAAAA,EAAiB,OAAO,CAASxU,MAAA;;AACtC,eAAOA,EAAM,MAAM,aAAYtC,IAAAsC,EAAM,cAAN,OAAAtC,IAAmB;AAAA,MAAA,CACnD;AAAA,IACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBCLM,EAAE,YAAAqP,GAAY,YAAAE,GAAY,SAAAkH,MAAYuB,GAAU,GAChD,EAAE,OAAA/a,MAAUyyB,MACZyJ,IAAax3B;AAEnB,aAASy3B,EAAe34B,GAAoC;AACtD,UAAAA,EAAK,MAAM,WAAW;AAAG,eAAO;AAC9B,YAAA4L,IAASlQ,EAAO,MAAMg9B,EAAW,QAAQ14B,EAAK,IAAI,IAAIxD,EAAM;AAC3D,aAAAmS;AAAA,QACL3O;AAAA,QACA4O;AAAA,QACAoH,EAAQ;AAAA,QACRlH;AAAA,QACAtS,EAAM;AAAA,QACNk8B,EAAW;AAAA,QACXA,EAAW;AAAA,QACX9sB;AAAA,MAAA;AAAA,IAEJ;AAEA,aAASgtB,EAAU54B,GAAiB;AAC5B,YAAAqD,IAASs1B,EAAe34B,CAAI;AAClC,UAAI64B,IAAO;AACJ,aAAAx1B,EACJ,IAAI,CAAK1D,MAAA;AACR,YAAIA,MAAM;AACD,UAAAk5B,IAAA;AAAA,aACT;AAAA,cAAW,OAAOl5B,KAAM;AACf,mBAAAA;AACT,cAAWA,aAAa,OAAO;AACzB,YAAAA,IAAA,CAAC,GAAGA,CAAC;AACT,kBAAMC,IAAO,CAAA;AACT,gBAAAD,EAAE,SAAS,MAAM,GAAG;AAChB,oBAAAyG,IAAIzG,EAAE,CAAC;AACT,cAAAA,IAAAA,EAAE,MAAM,CAAC,GACbC,EAAK,KAAK,KAAKwG,EAAE,CAAC,IAAIA,EAAE,CAAC,EAAE;AAAA,YAC7B;AACM,mBAAA+tB,GAAAx0B,GAAG,CAAC,EAAE,IAAI,CAAC,CAACoH,GAAIC,CAAE,MAAMpH,EAAK,KAAK,KAAKmH,EAAG,CAAC,IAAIA,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAIA,EAAG,CAAC,EAAE,CAAC,GACrEpH,EAAK,KAAK,GAAG;AAAA,UAAA,OACf;AACL,kBAAMmV,IAAI8jB;AACH,mBAAAA,IAAA,IACA,GAAG9jB,IAAI,OAAO,IAAI,GAAGpV,EAAE,CAAC,IAAIA,EAAE,CAAC;AAAA,UACxC;AAAA;AAAA,MAAA,CACD,EACA,KAAK,GAAG;AAAA,IACb;AAEM,UAAAO,IAAS4T,EAAS,MAAM;AAC5B,YAAMjS,IAAQkuB,EAAM;AACpB,aAAIluB,EAAM,WACDnG,EAAO,OAAOg9B,EAAW,UAAU72B,EAAM,IAAI,IAC3CA,EAAM,WAAW62B,EAAW,QAC9Bh9B,EAAO,OAAOg9B,EAAW,OAAO72B,EAAM,IAAI,IAE1CnG,EAAO,OAAOg9B,EAAW,QAAQ72B,EAAM,IAAI;AAAA,IACpD,CACD,GAEKwyB,IAAkBvgB,EAAS,MACxB7W,GAAsBiD,EAAO,MAAM,WAAW1D,EAAM,KAAK,CACjE,GAEK83B,IAAiBxgB,EAAS,MAAM;AACpC,YAAMygB,IAAQr0B,EAAO,MAAM,UACvB9C,GAAiB8C,EAAO,MAAM,SAAS,IAAIA,EAAO,MAAM,iBAAiB1D,EAAM,QAC/E;AACJ,aAAO+3B,IAAS,EAAE,qBAAqBA,EAA4B,IAAA;AAAA,IAAA,CACpE;;;;;;;;;;;;;;;;;;;;;;AC7EK,UAAA,EAAE,kBAAApd,MAAqBI,MACvBmhB,IAAax3B,MAEb;AAAA,MACJ,4BAAAif;AAAA,MACA,4BAAAC;AAAA,MACA,2BAAAC;AAAA,MACA,sBAAAC;AAAA,MACA,4BAAAE;AAAA,MACA,uBAAAC;AAAA,QACEkE,GAAkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBCoBhBmU,IAAe;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,GA6CI7H,IAAQgF,MAER8C,IAAW55B,GAAM4wB,GAAO,OAAO,GAC/BiJ,IAAW75B,GAAM4wB,GAAO,OAAO,GAC/B,EAAE,SAASkJ,GAAU,8BAAAnZ,EAAiC,IAAA4P;AAAA,MAC1DvwB,GAAM4wB,GAAO,OAAO;AAAA,IAAA,GAIhBlyB,IAAUinB;AACT,WAAA,QAAQiL,EAAM,aAAa,EAAE,QAAQ,CAAC,CAACnV,GAAMvb,CAAK,MAAM;AACrD,MAAAxB,EAAA,GAAG+c,GAAavb,CAAY;AAAA,IAAA,CACrC;AAGD,UAAMlD,IAAUsE,GAAetB,GAAM4wB,GAAO,SAAS,CAAC,GAGhDmJ,IAAYplB,EAAS,MAAM;AAC/B,YAAMqlB,IAAe,IAAI,IAAI,OAAO,KAAKlI,CAAK,CAAC;AAC/C,MAAA6H,EAAa,QAAQ,CAAAx7B,MAAK67B,EAAa,OAAO77B,CAAC,CAAC;AAE1C,YAAA87B,IAAS,OAAO,YAAYx+B,GAAe,IAAI,CAAK2C,MAAA,CAACA,GAAG,CAAc,CAAA,CAAC,CAAC;AACvE,oBAAA;AAAA,QACL67B;AAAA,QACA,OAAO,QAAQrJ,EAAM,MAAM,EAAE;AAAA,UAC3B,CAACsJ,GAAO,CAACl+B,GAAMyf,EAAI,OACjBue,EAAa,OAAOh+B,CAAI,GACpByf,MAAQye,IACJA,EAAAze,EAAI,EAAE,KAAKzf,CAAI,IAEfk+B,EAAAze,EAAI,IAAI,CAACzf,CAAI,GAEdk+B;AAAA,UAET,CAAC;AAAA,QACH;AAAA,MAAA,GAGFD,EAAO,KAAQ,KAAK,GAAGD,CAAY,GAC5BC;AAAA,IAAA,CACR,GAGKE,IAAaxlB,EAAS,MAAM3X,EAAQ,KAAK,KAAK,OAAO,GACrDo9B,IAA2BzlB,EAAS,MAAM;AAC9C,YAAMslB,IAASF,EAAU;AAClB,aAAAI,EAAW,SAASF,EAAO,WAAc,SAAS,KAAKA,EAAO,KAAQ,SAAS;AAAA,IAAA,CACvF,GAEKI,IAAoBxI,GAAqB70B,GAAS80B,CAAK,GAKvDpS,IAAYjI,KACZsK,IAAMtK,KACNuK,IAAWvK,KACX/U,IAAQ+U;AAAA,MAAW;AAAA;AAAA,OACnB6iB,IAAO3lB;AAAA,MAAS,MAAMjS,EAAM,UAAU;AAAA;AAAA,IAAa,GAEnDga,IAAYiU,GAASC,GAAO,aAAaC,GAAM,CAAKp0B,OACxDA,IAAI,KAAK,IAAIA,GAAGO,EAAQ,KAAK,YAAY,GACzCP,IAAI,KAAK,IAAIA,GAAGO,EAAQ,KAAK,YAAY,GAClCP,EACR,GAGK,EAAE,YAAAkC,GAAY,qBAAA47B,GAAqB,uBAAAC,EAAsB,IAAInL,GAActN,GAAK;AAAA,MACpF,kBAAkB;AAAA,MAClB,SAAS/kB,EAAQ,KAAK;AAAA;AAAA,MACtB,SAASA,EAAQ,KAAK;AAAA;AAAA,MACtB,qBAAqBy9B,GAAyBz9B,EAAQ,IAAI;AAAA,MAC1D,uBAAuB09B,GAAwB19B,EAAQ,IAAI;AAAA,MAC3D,KAAKA,EAAQ,KAAK,yBAAyB;AAAA,MAC3C,QAAQA,EAAQ,KAAK,yBAAyB;AAAA,MAC9C,aAAaA,EAAQ,KAAK;AAAA,MAC1B,2BAA2B;AAAA,MAC3B,QAAQ,CAAK6U,MAAA;;AACX,YAAInP,EAAM,UAAU;AAAgB;AACpC,cAAMuX,KAAItV,KAAAvE,IAAAzB,EAAW,UAAX,gBAAAyB,EAAkB,kBAAlB,OAAAuE,IAAmC;AAC7C,QAAI,KAAK,IAAI+X,EAAU,QAAQzC,CAAC,KAAK,SACnCyC,EAAU,QAAQzC,GACVvb,EAAA,KAAK,aAAaub,CAAC;AAAA,MAE/B;AAAA,MACA,YAAYjd,EAAQ,KAAK;AAAA,MACzB,OAAO,CAAKwD,MAAA;AACV,QAAIkC,EAAM,UAAU,KACZhE,EAAA,KAAK,YAAY8B,CAAC;AAAA,MAC5B;AAAA,IAAA,CACD;AAED,IAAAtE,GAAkB,EAAE,WAAAwjB,GAAW,KAAAqC,GAAK,UAAAC,GAAU,YAAArjB,EAAY,CAAA;AAG1D,UAAMg8B,IAAW,EAAE,OAAO,GAAG,QAAQ,EAAE,GACjCC,IAAiB,WAAW,iBAC9B,IAAI,eAAe,MAAM;;AAEnB,WADJx6B,IAAAzB,EAAW,UAAX,QAAAyB,EAAkB,UACd,CAACpD,EAAQ,KAAK;AAAiB;AAE7B,YAAA43B,KAAIjwB,IAAA+a,EAAU,UAAV,gBAAA/a,EAAiB;AAC3B,UAAIiwB,GAAG;AACL,cAAM3tB,KAAI,EAAE0zB,EAAS,QAAQ/F,EAAE,SAAS,GAClC1tB,KAAI,EAAEyzB,EAAS,SAAS/F,EAAE,UAAU;AAC1C,SAAAjxB,IAAAhF,EAAW,UAAX,QAAAgF,EAAkB,MAAM,EAAE,GAAAsD,IAAG,GAAAC,GAAG;AAC1B,cAAA,EAAE,OAAAjD,IAAO,QAAAylB,GAAW,IAAAkL;AAC1B,SAAI+F,EAAS,UAAU12B,MAAS02B,EAAS,WAAWjR,QAClD,OAAO,OAAOiR,GAAU,EAAE,OAAA12B,IAAO,QAAAylB,GAAQ,CAAA,GACjChrB,EAAA,KAAK,eAAe,EAAE,GAAGk2B,EAAE,GAAG,GAAGA,EAAE,GAAG,OAAA3wB,IAAO,QAAAylB,GAAQ,CAAA;AAAA,MAEjE;AAAA,IAAA,CACD,IACD;AACJ,IAAA6Q,EAAoB,MAAM;;AACxB,YAAM9vB,IAAI3O,EAAQ4jB,EAAU,OAAO,wBAAwB;AAC3D,MAAAkb,KAAA,QAAAA,EAAgB,QAAQnwB,KACxB9F,MAAAvE,KAAApD,EAAQ,MAAK,4BAAb,QAAA2H,GAAA,KAAAvE,IAAuCtE,EAAQ6C,EAAW,OAAO,uBAAuB;AAClF,YAAAi2B,IAAInqB,EAAE,yBACN,EAAE,OAAAxG,GAAO,QAAAylB,EAAW,IAAAkL;AAC1B,aAAO,OAAO+F,GAAU,EAAE,OAAA12B,GAAO,QAAAylB,EAAQ,CAAA,IACzC/lB,KAAAqe,EAAS,UAAT,QAAAre,GAAgB,iBAAiB,cAAck3B,IAAsB,EAAE,SAAS;IAAO,CACxF,GACDL,EAAsB,MAAM;;AAC1B,MAAAI,KAAA,QAAAA,EAAgB,eACPx6B,IAAA4hB,EAAA,UAAA,QAAA5hB,EAAO,oBAAoB,cAAcy6B;AAAA,IAAoB,CACvE;AAEK,UAAAC,IAAyB,CAACC,MAA8B;;AAC5D,OAAA36B,IAAAzB,EAAW,UAAX,QAAAyB,EAAkB;AAAA,QAChB26B;AAAA,QACA/9B,EAAQ,KAAK;AAAA,QACbA,EAAQ,KAAK;AAAA;AAAA,IACf;AAGF,IAAA2C;AAAA,MACE,MAAM3C,EAAQ,KAAK;AAAA,MACnB,CAAKP,MAAA;;AACQ,SAAA2D,IAAAzB,EAAA,UAAA,QAAAyB,EAAO,cAAc3D;AAAA,MAClC;AAAA,IAAA,GAEFkD;AAAA,MACE,MAAM;AAAA,QACJ3C,EAAQ,KAAK;AAAA,QACby9B,GAAyBz9B,EAAQ,IAAI;AAAA,QACrC09B,GAAwB19B,EAAQ,IAAI;AAAA,MACtC;AAAA,MACA,MAAM;AACJ,cAAMg+B,IAAqBr8B,EAAW;AACtC,QAAKq8B,KACLC;AAAA,UACED;AAAA,UACAh+B,EAAQ,KAAK;AAAA,UACbA,EAAQ,KAAK;AAAA,UACbA,EAAQ,KAAK;AAAA,QAAA;AAAA,MAEjB;AAAA,IAAA,GAGF2C,EAAM+c,GAAW,CAAAjgB,MAAKq+B,EAAuBr+B,CAAC,CAAC,GAC/CkD;AAAA,MACE,MAAM,CAAC3C,EAAQ,KAAK,cAAcA,EAAQ,KAAK,YAAY;AAAA,MAC3D,CAAK6U,MAAA;AACH,QAAAipB,EAAuBpe,EAAU,KAAK;AAAA,MACxC;AAAA,IAAA;AAIF,UAAM,EAAE,OAAArf,EAAM,IAAIuyB,GAAiBlT,GAAW1f,EAAQ,IAAI;AAE1D,IAAAu9B,EAAoB,MAAM;AAExB,YAAMW,IAAmBtK,EAAM;AAC/B,MAAAkK,EAAuBI,CAAgB;AAAA,IAAA,CACxC;AAID,UAAMC,IAAkB,MAAY1Z,GAAA;;AAClC,MAAI,OAAO,KAAKmP,EAAM,KAAK,EAAE,SAAS,OACpCxwB,IAAAzB,EAAW,UAAX,QAAAyB,EAAkB,cAClB,MAAMmyB,GAAc;AAAA,IACtB,IAII6I,IAAgB,MAAY3Z,GAAA;AAChC,YAAM0Z,EAAgB,GAClBx8B,EAAW,UACbA,EAAW,MAAM,iBACTD,EAAA,KAAK,YAAY,MAAS;AAAA,IACpC,IAII28B,IAAc,MAAY5Z,GAAA;;AAC9B,YAAM0Z,EAAgB,IACtB/6B,IAAAzB,EAAW,UAAX,QAAAyB,EAAkB;AAAA,IAAO,IAIrBk7B,IAAa,MACjB;;AAAA,cAAA32B,KAAAvE,IAAAzB,EAAW,UAAX,gBAAAyB,EAAkB,iBAAlB,OAAAuE,IAAkC;AAAA,QAChC,KAAK;AAAA,QACL,QAAQ;AAAA,QACR,MAAM;AAAA,QACN,OAAO;AAAA,MAAA;AAAA,OAIL42B,KAAa,CAAC/Y,MAAa;;AAAA,cAAApiB,IAAAzB,EAAW,UAAX,gBAAAyB,EAAkB,WAAWoiB;AAAA,OAKxDgZ,KAAuBvK,GAAeL,GAAO,iBAAiBgJ,GAAU/I,CAAI;AAC5E,IAAAlxB,EAAA67B,IAAsB,OAAS98B,EAAQ,KAAK,eAAe,MAAM,KAAKD,CAAK,CAAC,CAAC;AAEnF,UAAMg9B,KAAuBxK,GAAeL,GAAO,iBAAiBiJ,GAAUhJ,CAAI;AAC5E,IAAAlxB,EAAA87B,IAAsB,OAAS/8B,EAAQ,KAAK,eAAe,MAAM,KAAK+D,CAAK,CAAC,CAAC;AAEnF,UAAMi5B,KAAuBzK,GAAeL,GAAO,iBAAiBkJ,GAAUjJ,CAAI;AAC5E,IAAAlxB,EAAA+7B,IAAsB,OAASh9B,EAAQ,KAAK,eAAe,MAAM,KAAKkY,CAAK,CAAC,CAAC,GAEjEwa,GAAAoK,IAAsBC,IAAsBC,EAAoB;AAElF,UAAMlf,KAAe9gB,GAAa,oBAAA,IAAa,CAAA,GACzC4iB,KAAe5iB,GAAa,oBAAA,IAAa,CAAA,GACzC+kB,KAAe/kB,GAAa,oBAAA,IAAa,CAAA,GACzCigC,KAAiBjgC,GAAkB,EAAE,OAAO,CAAA,EAAI,CAAA;AAEtD,IAAA41B,GAAeqK,EAAc,GAG7Bh8B;AAAA,MACE,MAAMixB,EAAM;AAAA,MACZ,MAAM,OAAO,OAAO+K,IAAgB/K,EAAM,OAAO;AAAA,MACjD,EAAE,MAAM,IAAM,WAAW,GAAK;AAAA,IAAA,GAE1BjxB,EAAAg8B,IAAgB,MAAM9K,EAAK,kBAAkB8K,EAAc,GAAG,EAAE,MAAM,GAAA,CAAM;AAKlF,UAAMpmB,KAAcF,MAOdumB,KAAWnkB,EAAa,EAAK;AACnC,IAAA/Y,EAAQ,GAAG,kBAAkB,CAAMmT,MAAA+pB,GAAS,QAAQ,EAAK,GACzDl9B,EAAQ,GAAG,gBAAgB,CAAMmT,MAAA+pB,GAAS,QAAQ,EAAM,GAChDl9B,EAAA,GAAG,aAAa,CAAQ4e,MAAA;;AAE1B,MAAAtgB,EAAQ,KAAK,eACXsgB,MAAS,aACXld,IAAAzB,EAAW,UAAX,QAAAyB,EAAkB,eAElBuE,IAAAhG,EAAW,UAAX,QAAAgG,EAAkB,eAGlB3H,EAAQ,KAAK,gBACXsgB,MAAS,aACX3Z,IAAAhF,EAAW,UAAX,QAAAgF,EAAkB,gBAElBiB,KAAAjG,EAAW,UAAX,QAAAiG,GAAkB;AAAA,IAEtB,CACD;AAEK,UAAAi3B,KAAUlnB,EAAS,MAChB3X,EAAQ,KAAK,cAAcA,EAAQ,KAAK,eAAeA,EAAQ,KAAK,SAC5E,GAEK,EAAE,YAAAyS,IAAY,YAAAE,IAAY,YAAAoI,GAAe,IAAApB;AAAA,MAC7CH,GAAeojB,GAAU4B,IAAsBhf,EAAY;AAAA,MAC3DhG,GAAeqjB,GAAU4B,IAAsBnd,EAAY;AAAA,MAC3D9H,GAAesjB,GAAU4B,IAAsBjb,EAAY;AAAA,MAC3Dqb,GAAS9+B,CAAO;AAAA,MAChB2+B;AAAA,MACApmB;AAAA,MACAlY;AAAA,IAAA,GAGIsiB,KAAwBhL,EAAS,MAAM+lB,GAAwB19B,EAAQ,IAAI,CAAC,GAG5E,EAAE,oBAAA0mB,IAAoB,cAAAC,IAAc,mBAAAoB,IAAmB,kBAAAT,GAC3D,IAAAgB;AAAA,MACEvD;AAAA,MACA+Z,GAASH,EAAc;AAAA,MACvBG,GAASpf,CAAS;AAAA,MAClBjN;AAAA,MACAE;AAAA,MACAoI;AAAA,MACAyjB;AAAA,MACAC;AAAA,MACAC;AAAA,MACAlf;AAAA,MACA8B;AAAA,MACAmC;AAAA,MACAE;AAAA,MACAhB;AAAA,MACA3iB;AAAA,MACA0B;AAAA,IAAA,GAOEq9B,KAAiB,OAAO;AAAA,MAC5B,SAASrgC,GAASigC,GAAe,KAAK;AAAA;AAAA,MACtC,eAAe37B,GAAM27B,IAAgB,OAAO;AAAA,MAC5C,OAAO/B;AAAA,MACP,OAAOC;AAAA,MACP,SAASiC,GAAS9+B,CAAO;AAAA,MACzB,OAAO8+B,GAASz+B,CAAK;AAAA,MACrB,SAAAqB;AAAA,MACA,YAAY5C,EAAQ6C,EAAW,KAAK;AAAA,IAAA;AAEtC,IAAAgB;AAAA,MACE,MAAM3C,EAAQ,KAAK;AAAA,MACnB,CAACg/B,GAAYC,MAAe;AAC1B,QAAAA,EAAW,WAAW,GACXD,EAAA,SAASD,IAAgB;AAAA,MACtC;AAAA,IAAA;AAQF,UAAM,EAAE,iBAAA7L,IAAiB,kBAAAD,GAAiB,IAAIF,GAAmB,GAC3DmM,KAAmBvnB,EAAS,MAAM;AACtC,YAAMqR,IAAIiK,GAAiB;AAC3B,aACEjK,EAAE,UACE;AAAA,QACE,yBAAyBA,EAAE,WAAW;AAAA,QACtC,yBAAyBA,EAAE;AAAA,UAE7B;IAAC,CAER;AAMD,IAAAuU,EAAoB,MAAY9Y,GAAA;AAE1B,UAAAzkB,EAAQ,KAAK,wBAAwB;AACjC,cAAAszB,IAAUtzB,EAAQ,KAAK,uBAAuB;AAChD,QAAAuF,GAAU+tB,CAAO,MACb,MAAAA;AAAA,MAEV;AAGA,YAAMvO,IAAMjmB,EAAQ6C,EAAW,OAAO,cAAc;AAIpD,MAAA3B,EAAQ,KAAK,cAAc,SAAS++B,GAAgB,CAAA,GAIpD,MAAMxJ,GAAc;AAEd,YAAA4J,IAAiBn/B,EAAQ,KAAK;AACpC,UAAIA,EAAQ,KAAK,OAAOm/B,MAAmB,IAAO;AAChD,cAAMC,IAAa,OAAO,KAAKxL,EAAM,KAAK,EAAE,UAAU,GAChDyL,IAAOta,EAAI;AACb,YAAAqa,KAAcD,MAAmB,eAAe;AAClD,gBAAMhB,EAAgB;AAEhB,gBAAAlN,KAAQlM,EAAI;AAClBA,UAAAA,EAAI,IAAI;AAAA,YACN,GAAGkM,GAAM,QAAQ;AAAA,YACjB,GAAGA,GAAM,SAAS;AAAA,UAAA,CACnB;AAAA,QACQ;AAAA,UAAAkO,MAAmB,iBAAiBn/B,EAAQ,KAAK,MAC1D,MAAMo+B,EAAc,IACXe,MAAmB,mBAC5B,MAAMd,EAAY,IAElB,MAAMF,EAAgB;AAMxB,QAAA9K,GAAS,MAAM;AACP,gBAAAiM,KAAOva,EAAI;AACjB,UAAIsa,EAAK,MAAMC,GAAK,KAAKD,EAAK,MAAMC,GAAK,KAC/B59B,EAAA,KAAK,YAAY49B,EAAI;AAAA,QAC/B,CACD;AAAA,MAAA;AAED,cAAMnB,EAAgB;AAGxB,MAAAz8B,EAAQ,KAAK,WAAW,GAGxBgE,EAAM,QAAQ;AAAA,IAAA,EACf,GAED83B,EAAsB,MAAM;AAC1B,MAAA93B,EAAM,QAAQ,GACdhE,EAAQ,KAAK,aAAa,GAClB1B,EAAA,KAAK,cAAc;IAAW,CACvC;AAKD,aAASgtB,KAAS;;AAChB,OAAA5pB,IAAAzB,EAAW,UAAX,QAAAyB,EAAkB;AAAA,IACpB;AAKA,aAASmqB,KAAU;;AACjB,OAAAnqB,IAAAzB,EAAW,UAAX,QAAAyB,EAAkB;AAAA,IACpB;AAMA,aAASm8B,GAAMpwB,GAAc;;AAChB,OAAA/L,IAAAzB,EAAA,UAAA,QAAAyB,EAAO,IAAI+L;AAAA,IACxB;AAMA,aAASqwB,GAAMrwB,GAAc;;AAChB,OAAA/L,IAAAzB,EAAA,UAAA,QAAAyB,EAAO,MAAM+L;AAAA,IAC1B;AAMA,aAASswB,KAAgB;AACvB,aAAO3gC,EAAQ6C,EAAW,KAAK,EAAE,OAAO;AAAA,IAC1C;AAKA,aAAS+9B,KAAkB;AACzB,YAAMzO,IAAQnyB,EAAQ6C,EAAW,KAAK,EAAE,SAAS;AAC1C,aAAA;AAAA,QACL,OAAOsvB,EAAM;AAAA,QACb,QAAQA,EAAM;AAAA,QACd,SAASA,EAAM;AAAA,MAAA;AAAA,IAEnB;AAMA,aAASnM,GAAiCG,GAA2B;AACnE,aAAO0a;AAAAA,QACL7gC,EAAQimB,EAAI,OAAO,KAAK;AAAA,QACxBjmB,EAAQkmB,EAAS,OAAO,UAAU;AAAA,QAClCC;AAAA,MAAA;AAAA,IAEJ;AAMA,aAASE,GAAiCF,GAA2B;AACnE,aAAO2a;AAAAA,QACL9gC,EAAQimB,EAAI,OAAO,KAAK;AAAA,QACxBjmB,EAAQkmB,EAAS,OAAO,UAAU;AAAA,QAClCC;AAAA,MAAA;AAAA,IAEJ;AAOA,aAAS4a,KAAmB;AAM1B,aALexa;AAAA,QACbvmB,EAAQimB,EAAI,OAAO,KAAK;AAAA,QACxBjmB,EAAQkmB,EAAS,OAAO,UAAU;AAAA,QAClC3kB,EAAM;AAAA,MAAA,EAEM;AAAA,IAChB;AAMe,aAAAy/B,KAAuE;AAAA,aAAArb,GAAA,4BAAvD4B,IAAkC,IAAqB;AAEpF,gBAAQ,MADO0Z,GAAmB1Z,CAAO,GACnB;AAAA,MACxB;AAAA;AAMe,aAAA0Z,KAA8E;AAAA,aAAAtb,GAAA,4BAA3D4B,IAAkC,IAAyB;AACpF,eAAAJ;AAAA,UACLnnB,EAAQimB,EAAI,OAAO,KAAK;AAAA,UACxBjmB,EAAQkmB,EAAS,OAAO,UAAU;AAAA,UAClC3kB,EAAM;AAAA,UACNgmB;AAAA,QAAA;AAAA,MAEJ;AAAA;AAEa,IAAA2Z,EAAA;AAAA;AAAA,MAEX,eAAA5B;AAAA,MACA,aAAAC;AAAA,MACA,YAAAC;AAAA,MACA,YAAAC;AAAA,MACA,iBAAArL;AAAA,MACA,mBAAAnL;AAAA,MACA,kBAAAT;AAAA,MACA,QAAA0F;AAAA,MACA,SAAAO;AAAA,MACA,OAAAgS;AAAA,MACA,OAAAC;AAAA,MACA,QAAAC;AAAA,MACA,UAAAC;AAAA,MAAA,kCACA5a;AAAAA,MAAA,kCACAK;AAAAA,MACA,UAAA0a;AAAA,MACA,iBAAAC;AAAA,MACA,oBAAAC;AAAA,IAAA,CACD;AAID,aAAS9B,GACPt8B,GACAs+B,GACAC,GACAC,GACM;AACNx+B,MAAAA,EAAW,eAAes+B,CAAM,GAC5BA,KAAUC,IACZv+B,EAAW,mBAAmB,IAE9BA,EAAW,oBAAoB,GAE7Bs+B,KAAUE,IACZx+B,EAAW,qBAAqB,IAEhCA,EAAW,sBAAsB;AAAA,IAErC;AAEA,aAAS87B,GAAyB2C,GAA2B;AACpD,aAAAA,EAAK,eAAeA,EAAK;AAAA,IAClC;AAEA,aAAS1C,GAAwB0C,GAA2B;AACnD,aAAAA,EAAK,eAAeA,EAAK;AAAA,IAClC;AAEA,aAASvC,GAAqB36B,GAAc;AAC1C,MAAAA,EAAM,gBAAgB;AAAA,IACxB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;eCxpBSm9B,GAAA;AAHL,SAAAC,EAAA,GAAAC,gBAAuB;AAAA,YACbC,GAAA,OAAA,GAAA,MAAA;AAAA,eAAAC,GAAA,MAAA;AAAA;;;;;;;;;;;;;;;;;;;;iBC4BRx2B,IAAIwQ,EAAI,CAAC,GACTvQ,IAAIuQ,EAAI,CAAC,GACTohB,IAA8CphB,EAAI,QAAQ,GAC1Die,IAA4Dje,EAAI,SAAS,GACzEhR,IAAQgR,EAAI,CAAC;AAEnB,IAAA9U,GAAY,MAAM;AACV,YAAAxE,IAAIyyB,EAAM,KAAK,QACfznB,IAAIynB,EAAM,KAAK;AACjB,MAAAA,EAAM,UAAU,YACdzyB,EAAE,MAAM,KAAKgL,EAAE,MAAM,IACvB0vB,EAAW,QAAQ16B,EAAE,MAAM,IAAIgL,EAAE,MAAM,IAAI,UAAU,QAErD0vB,EAAW,QAAQ16B,EAAE,MAAM,IAAIgL,EAAE,MAAM,IAAI,UAAU,OAEnDynB,EAAM,kBAAkB,WACxB3pB,EAAA,QAAQ9I,EAAE,MAAM,GAChB+I,EAAA,QAAQ/I,EAAE,MAAM,GAClBu3B,EAAiB,QAAQ,cAChB9E,EAAM,kBAAkB,WAC/B3pB,EAAA,QAAQ9I,EAAE,MAAM,GAChB+I,EAAA,QAAQ/I,EAAE,MAAM,GAClBu3B,EAAiB,QAAQ,cAGzBzuB,EAAE,SAAS9I,EAAE,MAAM,IAAIA,EAAE,MAAM,KAAK,GACpC+I,EAAE,SAAS/I,EAAE,MAAM,IAAIA,EAAE,MAAM,KAAK,GACpCu3B,EAAiB,QAAQ,cAElB9E,EAAM,UAAU,YACrBzyB,EAAE,MAAM,KAAKgL,EAAE,MAAM,IACvB0vB,EAAW,QAAQ16B,EAAE,MAAM,IAAIgL,EAAE,MAAM,IAAI,UAAU,QAErD0vB,EAAW,QAAQ16B,EAAE,MAAM,IAAIgL,EAAE,MAAM,IAAI,UAAU,OAEnDynB,EAAM,kBAAkB,WACxB3pB,EAAA,QAAQkC,EAAE,MAAM,GAChBjC,EAAA,QAAQiC,EAAE,MAAM,GAClBusB,EAAiB,QAAQ,cAChB9E,EAAM,kBAAkB,WAC/B3pB,EAAA,QAAQkC,EAAE,MAAM,GAChBjC,EAAA,QAAQiC,EAAE,MAAM,GAClBusB,EAAiB,QAAQ,cAGzBzuB,EAAE,SAASkC,EAAE,MAAM,IAAIA,EAAE,MAAM,KAAK,GACpCjC,EAAE,SAASiC,EAAE,MAAM,IAAIA,EAAE,MAAM,KAAK,GACpCusB,EAAiB,QAAQ,eAI3BmD,EAAW,QAAQ,UACfjI,EAAM,kBAAkB,WAC1B3pB,EAAE,SAAS9I,EAAE,MAAM,IAAIgL,EAAE,MAAM,KAAK,GACpCjC,EAAE,SAAS/I,EAAE,MAAM,IAAIgL,EAAE,MAAM,KAAK,GACpCusB,EAAiB,QAAQ,cAChB9E,EAAM,kBAAkB,WACjC3pB,EAAE,SAAS9I,EAAE,MAAM,IAAIgL,EAAE,MAAM,KAAK,GACpCjC,EAAE,SAAS/I,EAAE,MAAM,IAAIgL,EAAE,MAAM,KAAK,GACpCusB,EAAiB,QAAQ,cAGzBzuB,EAAE,SAAS9I,EAAE,MAAM,IAAIgL,EAAE,MAAM,KAAK,GACpCjC,EAAE,SAAS/I,EAAE,MAAM,IAAIgL,EAAE,MAAM,KAAK,GACpCusB,EAAiB,QAAQ;AAGzB,UAAAgI,IAASt2B,EAAW,cAAcjJ,EAAE,OAAOgL,EAAE,KAAK,EAAE,EAAE;AACtD,OAAAu0B,IAAS,OAAOA,KAAU,QAC5BA,IAASA,IAAS,KACdA,IAAS,QACDA,KAAA,OAGdj3B,EAAM,QAAQi3B;AAAA,IAAA,CACf;AAIK,UAAAC,IAAgBhpB,EAAS,MACzB+gB,EAAiB,UAAU,aAAa,CAAC9E,EAAM,OAAO,aACjDvd,GAAA9T,GAAA,IACFqxB,EAAM,SADJ;AAAA,MAEL,YAAY;AAAA,QACV,SAAS;AAAA,QACT,OAAO;AAAA,QACP,SAAS;AAAA,UACP,UAAU;AAAA,UACV,YAAY;AAAA,QACd;AAAA,QACA,cAAc;AAAA,MAChB;AAAA,IAAA,KAGKA,EAAM,MAEhB;;;;;;;;;;;;;;;;;;;8CC3HKgN,KAAe;AAMd,MAAMC,WAAmBv/B,GAAa;AAAA,EAC3C,YAAoB+kB,IAAgC,IAAI;AAChD,aADY,KAAA,UAAAA;AAAA,EAEpB;AAAA,EAEU,gBAAgBvjB,GAA2Bf,GAAe;AAC5D,UAAA++B,IAAO,KAAK,QAAQ,QAAQF;AAClC,IAAA99B,EAAW,MAAM,IAAI,KAAK,MAAMf,EAAI,IAAI++B,CAAI,IAAIA,GAChDh+B,EAAW,MAAM,IAAI,KAAK,MAAMf,EAAI,IAAI++B,CAAI,IAAIA;AAAA,EAClD;AACF;ACdM,MAAAC,KAAiD,SAAUC,GAAU;AAClE,SAAA,QAAQC,EAAU,EAAE,QAAQ,CAAC,CAACC,GAAeC,CAAS,MAAM;AAC7D,IAAAH,EAAA,UAAUE,GAAeC,CAAS;AAAA,EAAA,CACvC;AACH;","x_google_ignoreList":[34,36,37,38,39,40,41]}