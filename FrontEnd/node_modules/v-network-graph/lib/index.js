var Co = Object.defineProperty, Oo = Object.defineProperties;
var To = Object.getOwnPropertyDescriptors;
var sn = Object.getOwnPropertySymbols;
var zo = Object.prototype.hasOwnProperty, Io = Object.prototype.propertyIsEnumerable;
var ae = Math.pow, rn = (e, t, n) => t in e ? Co(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, se = (e, t) => {
  for (var n in t || (t = {}))
    zo.call(t, n) && rn(e, n, t[n]);
  if (sn)
    for (var n of sn(t))
      Io.call(t, n) && rn(e, n, t[n]);
  return e;
}, Fe = (e, t) => Oo(e, To(t));
var Ee = (e, t, n) => new Promise((o, i) => {
  var s = (c) => {
    try {
      a(n.next(c));
    } catch (u) {
      i(u);
    }
  }, r = (c) => {
    try {
      a(n.throw(c));
    } catch (u) {
      i(u);
    }
  }, a = (c) => c.done ? o(c.value) : Promise.resolve(c.value).then(s, r);
  a((n = n.apply(e, t)).next());
});
import { isReactive as Lo, reactive as Ce, provide as Ae, inject as Ze, watch as F, toRef as Me, watchEffect as ge, computed as C, unref as b, ref as _, onMounted as We, onUnmounted as Je, nextTick as Dt, defineComponent as W, openBlock as M, createElementBlock as $, createBlock as R, resolveDynamicComponent as Mn, createCommentVNode as ce, Fragment as q, renderList as J, mergeProps as Pe, renderSlot as K, normalizeClass as ve, withModifiers as xe, normalizeStyle as et, useAttrs as $o, createElementVNode as Cn, createTextVNode as Ao, toDisplayString as an, createVNode as _e, withCtx as te, normalizeProps as ue, guardReactiveProps as de, useSlots as ft, createSlots as Nt, TransitionGroup as Ye, toHandlers as Zo, readonly as Xe } from "vue";
import { isEqual as Ie, round as ln, merge as On, mergeWith as Do, isPlainObject as No, debounce as _o, uniq as Bo, chunk as _t } from "lodash-es";
const jo = [
  "paths",
  "node-labels",
  "nodes",
  "focusring",
  "edge-labels",
  "edges",
  "base",
  "grid",
  "background",
  "root"
];
function ze(e) {
  return Lo(e) ? e : Ce(e);
}
function G(e, t = "Parameter") {
  if (e == null)
    throw new Error(`${t} is null`);
  return e;
}
const Tn = Symbol("containers");
function Vo(e) {
  Ae(Tn, e);
}
function Bt() {
  const e = G(Ze(Tn), "containers");
  return {
    container: e.container,
    svg: e.svg,
    viewport: e.viewport,
    svgPanZoom: e.svgPanZoom
  };
}
class L {
  static value(t, n) {
    return t instanceof Function ? t(n) : t;
  }
  static values(t, n) {
    return Object.values(t).filter((o) => o instanceof Function).length === 0 ? t : Object.fromEntries(
      Object.entries(t).map(([o, i]) => [o, i instanceof Function ? i(n) : i])
    );
  }
}
var Z = /* @__PURE__ */ ((e) => (e.CENTER = "center", e.NORTH = "north", e.NORTH_EAST = "north-east", e.EAST = "east", e.SOUTH_EAST = "south-east", e.SOUTH = "south", e.SOUTH_WEST = "south-west", e.WEST = "west", e.NORTH_WEST = "north-west", e))(Z || {});
function St(e) {
  const t = {};
  return Object.assign(t, e(t));
}
function Ar(e) {
  return e;
}
function Zr(e) {
  return e;
}
function cn(e, t, n) {
  const o = L.values(t.normal, e);
  return o.type == "circle" ? {
    width: o.radius * 2 * n,
    height: o.radius * 2 * n
  } : {
    width: o.width * n,
    height: o.height * n
  };
}
function Ro(e, t, n, o) {
  const s = Math.abs(e.x - n.x) < t.width / 2 + o.width / 2, a = Math.abs(e.y - n.y) < t.height / 2 + o.height / 2;
  return s && a;
}
function tt(e, t) {
  let n = 0;
  return t === 1 || e === void 0 || e === "none" ? n = e != null ? e : 0 : typeof e == "string" ? n = e.split(/\s+/).map((o) => parseInt(o) * t).filter((o) => !isNaN(o)).join(" ") : n = e * t, n && n !== "0" ? n : void 0;
}
function ht(e) {
  let t = 0;
  if (e === void 0 || e === "none")
    t = 0;
  else if (typeof e == "string") {
    const n = e.split(/\s+/).map((o) => parseInt(o)).filter((o) => !isNaN(o));
    n.length % 2 === 0 ? t = n.reduce((o, i) => o + i, 0) : t = n.reduce((o, i) => o + i, 0) * 2;
  } else
    t = e * 2;
  return t;
}
const un = 20;
class zn {
  activate(t) {
    const { nodePositions: n, nodes: o, configs: i, emitter: s, scale: r, svgPanZoom: a } = t, c = (h) => {
      for (const [d, v] of Object.entries(h)) {
        const x = this.getOrCreateNodePosition(n, d);
        this.setNodePosition(x, v);
      }
    }, u = (h) => {
      const d = h.filter((k) => !(k in n.value)), v = a.getViewArea(), x = r.value;
      for (const k of d) {
        const E = o.value[k], p = cn(E, i.node, x), y = se({}, v.center);
        for (; ; ) {
          let m = !1;
          for (const [f, g] of Object.entries(n.value)) {
            if (k === f)
              continue;
            const S = o.value[f];
            if (!S)
              continue;
            const O = cn(S, i.node, x);
            if (m = Ro(y, p, g, O), m)
              break;
          }
          if (m)
            y.x += p.width + un * x, y.x + p.width / 2 > v.box.right && (y.x = v.center.x, y.y += p.height + un * x);
          else
            break;
        }
        const w = this.getOrCreateNodePosition(n, k);
        this.setNodePosition(w, y);
      }
    };
    u(Object.keys(o.value));
    const l = F(
      () => Ie(new Set(Object.keys(o.value)), new Set(Object.keys(n.value))),
      (h) => {
        h || u(Object.keys(o.value));
      }
    );
    s.on("node:dragstart", c), s.on("node:pointermove", c), s.on("node:dragend", c), this.onDeactivate = () => {
      l(), s.off("node:dragstart", c), s.off("node:pointermove", c), s.off("node:dragend", c);
    };
  }
  deactivate() {
    this.onDeactivate && this.onDeactivate();
  }
  setNodePosition(t, n) {
    t.value.x = ln(n.x, 3), t.value.y = ln(n.y, 3);
  }
  getOrCreateNodePosition(t, n) {
    const o = Me(t.value, n);
    return o.value || (o.value = { x: 0, y: 0 }), o;
  }
}
function In() {
  return {
    view: {
      scalingObjects: !1,
      panEnabled: !0,
      zoomEnabled: !0,
      minZoomLevel: 0.1,
      maxZoomLevel: 64,
      doubleClickZoomEnabled: !0,
      mouseWheelZoomEnabled: !0,
      boxSelectionEnabled: !1,
      autoPanAndZoomOnLoad: "center-content",
      autoPanOnResize: !0,
      layoutHandler: new zn(),
      onSvgPanZoomInitialized: void 0,
      grid: {
        visible: !1,
        interval: 10,
        thickIncrements: 5,
        line: {
          color: "#e0e0e0",
          width: 1,
          dasharray: 1
        },
        thick: {
          color: "#cccccc",
          width: 1,
          dasharray: 0
        }
      },
      selection: {
        box: {
          color: "#0000ff20",
          strokeWidth: 1,
          strokeColor: "#aaaaff",
          strokeDasharray: 0
        },
        detector: (e) => {
          const t = /Mac OS/.test(navigator.userAgent) ? e.metaKey : e.ctrlKey;
          return e.type === "keydown" ? t : !t;
        }
      },
      builtInLayerOrder: [],
      onBeforeInitialDisplay: void 0
    },
    node: St((e) => ({
      normal: {
        type: "circle",
        radius: 16,
        // for rect -->
        width: 32,
        height: 32,
        borderRadius: 4,
        // <-- for rect
        color: "#4466cc",
        strokeWidth: 0,
        strokeColor: "#000000",
        strokeDasharray: 0
      },
      hover: {
        type: (t) => L.value(e.normal.type, t),
        radius: (t) => {
          var n;
          return ((n = L.value(e.normal.radius, t)) != null ? n : 0) + 2;
        },
        width: (t) => {
          var n;
          return ((n = L.value(e.normal.width, t)) != null ? n : 0) + 2;
        },
        height: (t) => {
          var n;
          return ((n = L.value(e.normal.height, t)) != null ? n : 0) + 2;
        },
        borderRadius: (t) => {
          var n;
          return (n = L.value(e.normal.borderRadius, t)) != null ? n : 0;
        },
        strokeWidth: (t) => L.value(e.normal.strokeWidth, t),
        strokeColor: (t) => L.value(e.normal.strokeColor, t),
        strokeDasharray: (t) => L.value(e.normal.strokeDasharray, t),
        color: "#3355bb"
      },
      selected: void 0,
      draggable: !0,
      selectable: !1,
      label: {
        visible: !0,
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        // background: {
        //   visible: true,
        //   color: "#ffffff",
        //   padding: {
        //     vertical: 1,
        //     horizontal: 4,
        //   },
        //   borderRadius: 2
        // },
        margin: 4,
        direction: Z.SOUTH,
        directionAutoAdjustment: !1,
        text: "name",
        handleNodeEvents: !0
      },
      focusring: {
        visible: !0,
        width: 4,
        padding: 3,
        color: "#eebb00"
      },
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      },
      transition: void 0
    })),
    edge: St((e) => ({
      normal: {
        width: 2,
        color: "#4466cc",
        dasharray: 0,
        linecap: "butt",
        animate: !1,
        animationSpeed: 50
      },
      hover: {
        width: (t) => L.value(e.normal.width, t) + 1,
        color: "#3355bb",
        dasharray: (t) => L.value(e.normal.dasharray, t),
        linecap: (t) => L.value(e.normal.linecap, t),
        animate: (t) => L.value(e.normal.animate, t),
        animationSpeed: (t) => L.value(e.normal.animationSpeed, t)
      },
      selected: {
        width: (t) => L.value(e.normal.width, t) + 1,
        color: "#dd8800",
        dasharray: (t) => {
          const n = L.value(e.normal.width, t);
          return `${n * 1.5} ${n * 2}`;
        },
        linecap: (t) => L.value(e.normal.linecap, t),
        animate: (t) => L.value(e.normal.animate, t),
        animationSpeed: (t) => L.value(e.normal.animationSpeed, t)
      },
      selectable: !1,
      gap: 3,
      type: "straight",
      marker: {
        source: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          offset: 0,
          units: "strokeWidth",
          color: null
        },
        target: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          offset: 0,
          units: "strokeWidth",
          color: null
        }
      },
      margin: null,
      summarize: (t, n) => n.edge.type == "curve" ? !1 : null,
      summarized: {
        label: {
          fontSize: 10,
          lineHeight: 1,
          color: "#4466cc"
        },
        shape: {
          type: "rect",
          // for circle -->
          radius: 6,
          // <-- for circle
          width: 12,
          height: 12,
          borderRadius: 3,
          color: "#ffffff",
          strokeWidth: 1,
          strokeColor: "#4466cc",
          strokeDasharray: void 0
        },
        stroke: {
          width: 5,
          color: "#4466cc",
          dasharray: void 0,
          linecap: void 0,
          animate: !1,
          animationSpeed: 50
        }
      },
      selfLoop: {
        radius: 12,
        isClockwise: !0,
        offset: 10,
        angle: 270
      },
      keepOrder: "clock",
      label: {
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        // background: {
        //   visible: true,
        //   color: "#ffffff",
        //   padding: {
        //     vertical: 1,
        //     horizontal: 4,
        //   },
        //   borderRadius: 2
        // },
        margin: 4,
        padding: 4
      },
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      }
    })),
    path: St((e) => ({
      visible: !1,
      clickable: !1,
      hoverable: !1,
      curveInNode: !1,
      end: "centerOfNode",
      margin: 0,
      // @Deprecated
      path: Ce({
        width: 6,
        color: (t) => {
          const n = [
            "#d5000088",
            "#c5116288",
            "#aa00ff88",
            "#6200ea88",
            "#304ffe88",
            "#2962ff88",
            "#0091ea88",
            "#00b8d488",
            "#00bfa588",
            "#00c85388",
            "#64dd1788",
            "#aeea0088",
            "#ffd60088",
            "#ffab0088",
            "#ff6d0088",
            "#dd2c0088"
          ], o = t.edges.map(
            (i) => i.split("").reduce((s, r) => (s = (s << 5) - s + r.charCodeAt(0), s & s), 0)
          ).reduce((i, s) => i + s, 0);
          return n[Math.abs(o) % n.length];
        },
        dasharray: void 0,
        linecap: "round",
        linejoin: "round",
        animate: !1,
        animationSpeed: 50
      }),
      normal: {
        width: (t) => L.value(e.path.width, t),
        color: (t) => L.value(e.path.color, t),
        dasharray: (t) => L.value(e.path.dasharray, t),
        linecap: (t) => L.value(e.path.linecap, t),
        linejoin: (t) => L.value(e.path.linejoin, t),
        animate: (t) => L.value(e.path.animate, t),
        animationSpeed: (t) => L.value(e.path.animationSpeed, t)
      },
      hover: {
        width: (t) => L.value(e.normal.width, t) + 2,
        color: (t) => L.value(e.normal.color, t),
        dasharray: (t) => L.value(e.normal.dasharray, t),
        linecap: (t) => L.value(e.normal.linecap, t),
        linejoin: (t) => L.value(e.normal.linejoin, t),
        animate: (t) => L.value(e.normal.animate, t),
        animationSpeed: (t) => L.value(e.normal.animationSpeed, t)
      },
      selected: {
        width: (t) => L.value(e.normal.width, t) + 2,
        color: (t) => L.value(e.normal.color, t),
        dasharray: "6 12",
        linecap: (t) => L.value(e.normal.linecap, t),
        linejoin: (t) => L.value(e.normal.linejoin, t),
        animate: (t) => L.value(e.normal.animate, t),
        animationSpeed: (t) => L.value(e.normal.animationSpeed, t)
      },
      selectable: !1,
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      },
      transition: void 0
    }))
  };
}
function Dr(e) {
  const t = In();
  return e && On(t, e), t;
}
const Ln = Symbol("style");
function Ho(e, t) {
  return No(e) ? On(e, t) : t;
}
function Wo(e) {
  const t = Ce(In()), n = Object.keys(t);
  for (const o of n)
    F(() => e.value[o], () => {
      Do(t[o], e.value[o] || {}, Ho);
    }, { immediate: !0, deep: !0 });
  return Ae(Ln, t), t;
}
function vt(e) {
  return G(Ze(Ln), `Configs(${e})`)[e];
}
function Uo() {
  return vt("view");
}
function pt() {
  return vt("node");
}
function gt() {
  return vt("edge");
}
function $n() {
  return vt("path");
}
let Fo = 1;
function Xo() {
  return Fo++;
}
function he(e) {
  return Object.entries(e);
}
function at(e, t) {
  const n = new Set(Object.keys(e));
  he(t).forEach(([o, i]) => {
    Ie(e[o], i) || (e[o] = i), n.delete(o);
  }), n.forEach((o) => delete e[o]);
}
function qo(e) {
  return e instanceof Promise || e && typeof e.then == "function";
}
function Go(e, t, n) {
  const o = ze({
    edgeLayoutPoints: {},
    edgeGroups: {},
    summarizedEdges: {}
  });
  return ge(() => {
    const { edgeLayoutPoints: i, edgeGroups: s } = Yo(
      n,
      e.value,
      t.value
    );
    at(o.edgeLayoutPoints, i), at(o.edgeGroups, s);
  }), ge(() => {
    const i = {};
    for (const [s, { edges: r, groupWidth: a }] of Object.entries(o.edgeGroups)) {
      let c = !1;
      if (a == 0)
        c = !1;
      else if (n.edge.summarize instanceof Function) {
        const u = n.edge.summarize(r, n);
        u === null ? c = dn(e.value, r, n, a) : c = u;
      } else
        n.edge.summarize ? c = dn(e.value, r, n, a) : c = !1;
      o.edgeGroups[s].summarize = c, c && Object.keys(r).forEach((u) => i[u] = !0);
    }
    at(o.summarizedEdges, i);
  }), o;
}
function Ko(e, t, n, o, i, s) {
  return e ? t ? fn(e.edge, n, o, i, 0, 0, s) : fn(
    e.edge,
    n,
    o,
    i,
    e.groupWidth,
    e.pointInGroup,
    s
  ) : { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } };
}
function Yo(e, t, n) {
  const o = {}, i = {}, s = {};
  for (const [a, c] of Object.entries(n)) {
    if (!(c.source in t && c.target in t))
      continue;
    const u = [c.source, c.target].sort().join("<=>"), l = s[u] || {};
    l[a] = c, s[u] = l;
  }
  const r = e.edge.gap instanceof Function ? e.edge.gap : (a, c) => e.edge.gap;
  for (const [a, c] of Object.entries(s)) {
    const u = Object.keys(c).length;
    if (u == 0)
      continue;
    const l = r(c, e), [h, d] = Object.entries(c)[0];
    if (u === 1)
      o[h] = { edge: d, pointInGroup: 0, groupWidth: 0 }, i[a] = { edges: c, groupWidth: 0, summarize: !1 };
    else {
      let v = 0;
      const x = Object.entries(c).map(([p, y]) => {
        let w = L.value(e.edge.normal.width, y);
        return isNaN(+w) && (console.warn(
          "[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]",
          p,
          w
        ), w = 1), w / 2;
      }), k = Object.entries(c).map(([p, y], w) => (w > 0 && (v += x[w - 1] + l + x[w]), [p, y, v])), E = v;
      k.forEach(([p, y, w]) => {
        o[p] = { edge: y, pointInGroup: w, groupWidth: E };
      }), i[a] = { edges: c, groupWidth: E, summarize: !1 };
    }
  }
  return { edgeLayoutPoints: o, edgeGroups: i };
}
function dn(e, t, n, o) {
  if (Object.entries(t).length === 1)
    return !1;
  const s = Math.min(
    ...Object.values(t).flatMap((r) => [e[r.source], e[r.target]]).filter((r) => r).map((r) => {
      const a = L.values(n.node.normal, r);
      return a.type === "circle" ? a.radius * 2 : Math.min(a.width, a.height);
    })
  );
  return o > s;
}
function fn(e, t, n, o, i, s, r) {
  var h, d, v, x, k, E, p, y;
  let a, c, u, l;
  return e.source < e.target ? [a, c, u, l] = hn(
    (h = t == null ? void 0 : t.x) != null ? h : 0,
    (d = t == null ? void 0 : t.y) != null ? d : 0,
    (v = n == null ? void 0 : n.x) != null ? v : 0,
    (x = n == null ? void 0 : n.y) != null ? x : 0,
    o,
    i,
    s,
    r
  ) : [u, l, a, c] = hn(
    (k = n == null ? void 0 : n.x) != null ? k : 0,
    (E = n == null ? void 0 : n.y) != null ? E : 0,
    (p = t == null ? void 0 : t.x) != null ? p : 0,
    (y = t == null ? void 0 : t.y) != null ? y : 0,
    o,
    i,
    s,
    r
  ), { p1: { x: a, y: c }, p2: { x: u, y: l } };
}
function hn(e, t, n, o, i, s, r, a) {
  const c = n - e, u = o - t;
  let l = (s / 2 - r) * i;
  if (l !== 0 && a !== "clock") {
    const h = Math.atan2(o - t, n - e);
    if (a === "vertical") {
      const d = Math.PI / 2;
      (h < -d || h >= d) && (l *= -1);
    } else
      a === "horizontal" && h < 0 && (l *= -1);
  }
  if (c === 0) {
    const h = u < 0 ? -1 : 1;
    return [e + l * h, t, n + l * h, o];
  } else if (u === 0) {
    const h = c < 0 ? 1 : -1;
    return [e, t + l * h, n, o + l * h];
  } else {
    const d = -1 / (u / c);
    u < 0 && (l = -l);
    const v = l / Math.sqrt(1 + Math.pow(d, 2));
    return [e + v, t + v * d, n + v, o + v * d];
  }
}
function An(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x + t.x, n.y = e.y + t.y, n;
}
function jt(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x - t.x, n.y = e.y - t.y, n;
}
function Zn(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x * t.x, n.y = e.y * t.y, n;
}
function Dn(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x * t, n.y = e.y * t, n;
}
function Vt(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x / t.x, n.y = e.y / t.y, n;
}
function Nn(e, t) {
  return e.x * t.x + e.y * t.y;
}
function _n(e, t) {
  return e.x * t.y - e.y * t.x;
}
function Rt(e) {
  return e.x * e.x + e.y * e.y;
}
function Ht(e) {
  return Math.sqrt(Rt(e));
}
function Wt(e, t) {
  const n = e.x - t.x, o = e.y - t.y;
  return n * n + o * o;
}
function Bn(e, t) {
  return Math.sqrt(Wt(e, t));
}
function jn(e, t) {
  t || (t = { x: 0, y: 0 });
  const n = Ht(e);
  return n === 0 ? (t.x = 1, t.y = 0) : Vt(e, { x: n, y: n }, t), t;
}
function ct(e, t, n) {
  n || (n = { x: 0, y: 0 });
  const o = e.x * Math.cos(t) - e.y * Math.sin(t), i = e.x * Math.sin(t) + e.y * Math.cos(t);
  return n.x = o, n.y = i, n;
}
const Qo = 180 / Math.PI;
function Jo(e) {
  return e * Qo;
}
function Ut(e) {
  return Math.atan2(e.y, e.x);
}
function Ft(e) {
  return Jo(Ut(e));
}
const ei = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: An,
  angle: Ut,
  angleDegree: Ft,
  cross: _n,
  distance: Bn,
  distanceSquared: Wt,
  divide: Vt,
  dot: Nn,
  length: Ht,
  lengthSquared: Rt,
  multiply: Zn,
  multiplyScalar: Dn,
  normalize: jn,
  rotate: ct,
  subtract: jt
}, Symbol.toStringTag, { value: "Module" }));
class V {
  static fromArray(t) {
    return new V(t[0] || 0, t[1] || 0);
  }
  static fromObject(t) {
    return new V(t.x, t.y);
  }
  constructor(t, n) {
    this.x = t, this.y = n;
  }
  // instance methods
  add(t) {
    return An(this, t, this);
  }
  subtract(t) {
    return jt(this, t, this);
  }
  multiply(t) {
    return Zn(this, t, this);
  }
  multiplyScalar(t) {
    return Dn(this, t, this);
  }
  divide(t) {
    return Vt(this, t, this);
  }
  dot(t) {
    return Nn(this, t);
  }
  cross(t) {
    return _n(this, t);
  }
  lengthSquared() {
    return Rt(this);
  }
  length() {
    return Ht(this);
  }
  distanceSquared(t) {
    return Wt(this, t);
  }
  distance(t) {
    return Bn(this, t);
  }
  normalize() {
    return jn(this, this);
  }
  angle() {
    return Ut(this);
  }
  angleDegree() {
    return Ft(this);
  }
  rotate(t) {
    return ct(this, t, this);
  }
  isEqualTo(t) {
    return this.x === t.x && this.y === t.y;
  }
  clone() {
    return new V(this.x, this.y);
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
  toArray() {
    return [this.x, this.y];
  }
}
const ee = se({
  Vector2D: V
}, ei);
class Q {
  constructor(t, n, o) {
    this.source = t, this.target = n, this.v = o;
  }
  static fromLinePosition(t) {
    const n = V.fromObject(t.p1), o = V.fromObject(t.p2);
    return new Q(n, o, Re(n, o));
  }
  static fromPositions(t, n) {
    const o = V.fromObject(t), i = V.fromObject(n);
    return new Q(o, i, Re(o, i));
  }
  static fromVectors(t, n) {
    return new Q(t, n, Re(t, n));
  }
}
function Re(e, t) {
  return t.clone().subtract(e);
}
function ti(e) {
  return [V.fromObject(e.p1), V.fromObject(e.p2)];
}
function ni(e) {
  return new V((e.p1.x + e.p2.x) / 2, (e.p1.y + e.p2.y) / 2);
}
function ut(e, t) {
  return { p1: e, p2: t };
}
function zt(e, t, n) {
  const o = Q.fromLinePosition(e);
  return oi(o, t, n);
}
function oi(e, t, n) {
  const o = e.v.clone().normalize(), i = e.source.clone().add(o.clone().multiplyScalar(t)), s = e.target.clone().subtract(o.clone().multiplyScalar(n));
  let r = i.toObject(), a = s.toObject();
  const c = Re(i, s);
  if (e.v.angle() * c.angle() < 0) {
    const u = new V((r.x + a.x) / 2, (r.y + a.y) / 2), l = u.clone().add(o.multiplyScalar(0.5));
    r = u.toObject(), a = l.toObject();
  }
  return { p1: r, p2: a };
}
function ii(e) {
  return { p1: e.p2, p2: e.p1 };
}
function qe(e) {
  const t = e.v.clone().normalize().rotate(Math.PI / 2);
  return Q.fromVectors(e.target, e.target.clone().add(t));
}
function Xt(e, t) {
  const n = t.v.clone().normalize(), o = t.source, i = ee.subtract(e, o), s = n.dot(i);
  return o.clone().add(n.multiplyScalar(s));
}
function mt(e, t, n, o) {
  if (!(ee.lengthSquared(ee.subtract(t, n)) - o * o <= Math.pow(1, -10)))
    return null;
  const r = Q.fromVectors(e, t), a = Xt(n, r), c = ee.length(ee.subtract(a, n));
  if (o < c)
    return null;
  if (o === c)
    return a;
  const u = Math.sqrt(ae(o, 2) - ae(c, 2)), l = r.v.normalize().multiplyScalar(u);
  return a.subtract(l);
}
function si(e, t, n, o, i) {
  if (!(ee.lengthSquared(ee.subtract(t, n)) - o * o <= Math.pow(1, -10)))
    return null;
  const a = Q.fromVectors(e, t), c = Xt(n, a), u = ee.length(ee.subtract(c, n));
  if (o < u)
    return null;
  if (o === u)
    return c;
  const l = Math.sqrt(ae(o, 2) - ae(u, 2)), h = a.v.normalize().multiplyScalar(l), d = c.clone().add(h), v = c.clone().subtract(h), x = i.distance(d), k = i.distance(v);
  return Math.abs(x - k) < 2 ? v : x < k ? d : v;
}
function Ne(e, t) {
  const n = ee.subtract(t.source, e.source), o = e.v, i = t.v, s = ee.cross(n, o) / ee.cross(o, i);
  return t.source.clone().add(i.clone().multiplyScalar(s));
}
function Qe(e, t, n, o, i) {
  const s = e, a = n.clone().subtract(s), c = a.length(), u = t + o;
  if (u < c)
    return null;
  const l = Math.abs(t - o);
  if (c < l)
    return null;
  if (c === u) {
    const g = a.clone().normalize(), S = e.clone().add(g.multiplyScalar(t));
    return i ? S : [S, S];
  }
  if (c === l) {
    const g = a.clone().normalize(), S = t > o, O = e.clone().add(g.multiplyScalar(S ? t : -t));
    return i ? O : [O, O];
  }
  const h = t, d = o, v = (ae(c, 2) + ae(h, 2) - ae(d, 2)) / (2 * c * h), x = h * v, k = Math.sqrt(ae(h, 2) - ae(x, 2)), E = a.clone().normalize(), p = new V(-E.y, E.x), y = E.clone().multiplyScalar(x), w = p.clone().multiplyScalar(k), m = e.clone().add(y).add(w), f = e.clone().add(y).subtract(w);
  if (i) {
    const g = m.distance(i), S = f.distance(i);
    return g < S ? m : f;
  } else
    return [m, f];
}
function vn(e, t, n, o) {
  const i = Q.fromPositions(e, t), s = (n.width + n.strokeWidth) / 2 * o, r = (n.height + n.strokeWidth) / 2 * o, a = n.borderRadius > 0 ? (n.borderRadius + n.strokeWidth / 2) * o : 0, c = (i.v.angle() - Math.PI / 2) % Math.PI, u = Math.PI / 2 - c % Math.PI, l = r * Math.abs(Math.tan(c)), h = s * Math.abs(Math.tan(u)), d = l <= s - a, v = h <= r - a;
  if (d || v || a === 0)
    return Math.sqrt(d ? ae(r, 2) + ae(l, 2) : ae(s, 2) + ae(h, 2));
  {
    const x = t.x - s + a, k = t.y - r + a, E = t.x + s - a, p = t.y + r - a, y = [
      new V(x, k),
      new V(E, k),
      new V(E, p),
      new V(x, p)
    ], w = Math.floor((i.v.angleDegree() + 360) % 360 / 90), m = y[w], f = mt(
      i.source,
      Xt(m, i),
      m,
      a
    );
    return f ? Re(f, i.target).length() : Re(m, i.target).length() + a;
  }
}
function Vn(e, t, n, o, i) {
  const s = Q.fromLinePosition(e), r = s.v.clone().normalize(), a = o === 0 ? s.source : s.source.clone().add(r.clone().multiplyScalar(o * i)), c = o === 0 ? s.target : s.target.clone().subtract(r.clone().multiplyScalar(o * i)), u = (t.width / 2 + n) * i, l = new V(-r.y, r.x).multiplyScalar(u);
  let h = ee.subtract(a, l), d = ee.add(a, l), v = ee.subtract(c, l), x = ee.add(c, l);
  const k = s.v.angleDegree();
  return (k < -90 || k >= 90) && ([h, d] = [d, h], [v, x] = [x, v]), {
    source: { above: h, below: d },
    target: { above: v, below: x }
  };
}
function ri(e, t, n, o) {
  let i;
  n.type === "circle" ? i = n.radius + n.strokeWidth / 2 : i = vn(
    t,
    e,
    n,
    1
    // scale
  );
  let s;
  return o.type === "circle" ? s = o.radius + o.strokeWidth / 2 : s = vn(
    e,
    t,
    o,
    1
    // scale
  ), [i, s];
}
function Le(e, t, n) {
  const { x: o, y: i } = e, s = o - t.x, r = i - t.y;
  return {
    x: s * Math.cos(n) - r * Math.sin(n) + t.x,
    y: s * Math.sin(n) + r * Math.cos(n) + t.y
  };
}
function It(e) {
  return e > 0 ? -(Math.PI * 2 - e) : Math.PI * 2 + e;
}
function Lt(e, t, n, o) {
  const i = [], s = Q.fromVectors(t, e), r = Q.fromVectors(t, n);
  let a = He(s, r);
  o * a < 0 && (a = It(a));
  const c = V.fromObject(Le(e, t, -a / 2)), u = Q.fromVectors(t, c), l = qe(u), h = He(s, u);
  let d = qe(s);
  if (Math.abs(h) < Math.PI / 2) {
    const x = Ne(d, l);
    i.push(x);
  } else {
    const x = V.fromObject(Le(c, t, h / 2)), k = qe(
      Q.fromVectors(t, V.fromObject(x))
    ), E = Ne(d, k), p = Ne(k, l);
    i.push(E, x, p);
  }
  i.push(c);
  const v = He(r, u);
  if (d = qe(r), Math.abs(v) < Math.PI / 2) {
    const x = Ne(d, l);
    i.push(x);
  } else {
    const x = V.fromObject(Le(c, t, v / 2)), k = qe(
      Q.fromVectors(t, V.fromObject(x))
    ), E = Ne(l, k), p = Ne(k, d);
    i.push(E, x, p);
  }
  return i;
}
function He(e, t) {
  return Math.atan2(
    e.v.y * t.v.x - e.v.x * t.v.y,
    e.v.x * t.v.x + e.v.y * t.v.y
  );
}
function ai(e, t, n) {
  const o = e.x, i = e.y, s = t.x, r = t.y, a = n.x, c = n.y, u = o - s, l = i - r, h = a - s, d = c - r;
  if (u === 0 && l === 0 || h === 0 && d === 0)
    return [e, 0];
  const v = (d * (u * (o + s) + l * (i + r)) - l * (h * (a + s) + d * (c + r))) / (2 * u * d - 2 * l * h), x = (-h * (u * (o + s) + l * (i + r)) + u * (h * (a + s) + d * (c + r))) / (2 * u * d - 2 * l * h), k = Math.sqrt(Math.pow(o - v, 2) + Math.pow(i - x, 2));
  return [new V(v, x), k];
}
function Ve(e) {
  return e.type == "circle" ? e.radius : Math.min(e.width, e.height) / 2;
}
function it(...e) {
  return e.find((t) => !!t);
}
const li = Number.EPSILON * 100;
function ci(e, t, n, o, i, s, r, a) {
  var k, E;
  const c = e.edges, u = e.directions, l = c.map((p, y) => di(p, u[y], o[p.edgeId])), h = [];
  let d = !1, v = !1;
  {
    const p = l[0];
    let y = Ve(t[p.source].shape) * i;
    const w = a + (r === "edgeOfNode" ? y : 0), m = w <= 0 ? p.line.source : gn(p, w, n, !0);
    h.push(m), y = Ve(t[p.target].shape) * i, a > 0 && ee.distance(p.line.source, p.line.target) <= w + y && (d = !0);
  }
  const x = c.length;
  for (let p = 1; p < x; p++) {
    const y = l[p - 1], w = l[p], m = w.source, f = V.fromObject((k = n[m]) != null ? k : { x: 0, y: 0 }), g = ui(y, w, f), S = Ve(t[m].shape) * i, O = Math.max(S * (2 / 3), S - 4 * i), I = $t(y), T = $t(w), z = st(y, f, O, I), A = st(w, f, O, !T), j = st(y, f, S, I), Y = st(w, f, S, !T);
    let B;
    if (g) {
      const U = ee.distance(g, f);
      if (U < O)
        B = [
          it(z, j, y.line.target),
          g,
          it(A, Y, w.line.source)
        ];
      else if (U <= S) {
        let be, oe;
        j && z ? be = ee.distance(g, z) < ee.distance(g, j) ? z : j : be = j || y.line.target, Y && A ? oe = ee.distance(g, A) < ee.distance(g, Y) ? A : Y : oe = Y || w.line.source, B = [be, g, oe];
      } else
        z && A ? B = [z, f, A] : j && Y ? B = [j, f, Y] : B = [
          it(z, j, y.line.target),
          f,
          it(A, Y, w.line.source)
        ];
    } else
      z && A ? B = [z, f, A] : j && Y ? B = [j, f, Y] : B = [y.line.target, f, w.line.source];
    if (y.curve) {
      const U = h[h.length - 1];
      if (U) {
        const be = U instanceof Array ? U[U.length - 1] : U;
        let oe;
        B instanceof Array ? oe = s ? B[0] : B[1] : oe = B;
        const ke = Lt(
          be,
          y.curve.circle.center,
          oe,
          y.curve.theta
        );
        B instanceof Array && s ? h.push([...ke, ...B]) : h.push([...ke, oe]);
      }
    } else if (y.loop) {
      const [U, be, oe] = bn(f, y, S);
      h.push(U), h.push(oe), B instanceof Array && s ? h.push([be, B[1], B[2]]) : h.push(B[2]);
    } else
      s || !(B instanceof Array) ? h.push(B) : w.curve ? h.push(B[1]) : w.loop ? h.push(B[0]) : h.push(B[0], B[2]);
  }
  {
    const p = l[l.length - 1];
    let y = Ve(t[p.target].shape) * i;
    const w = a + (r === "edgeOfNode" ? y : 0), m = w <= 0 ? p.line.target : gn(p, w, n, !1);
    if (y = Ve(t[p.source].shape) * i, p.loop) {
      const f = V.fromObject((E = n[p.target]) != null ? E : { x: 0, y: 0 }), [g, S, O] = bn(f, p, y);
      h.push(g), h.push(O);
    } else if (p.curve) {
      const f = h[h.length - 1], g = f instanceof Array ? f[f.length - 1] : f, S = Lt(
        g,
        p.curve.circle.center,
        m,
        p.curve.theta
      );
      h.push([...S, m]);
    } else
      h.push(m);
    a > 0 && ee.distance(p.line.source, p.line.target) <= w + y && (v = !0);
  }
  return d && (h.shift(), h[0] instanceof Array && h.unshift(h[0][0])), v && h.pop(), h;
}
function pn(e) {
  const t = e.length;
  if (t === 0)
    return [];
  if (t <= 1)
    return [!0];
  const n = [];
  let o = null, i = !0;
  for (let s = 0; s < t; s++) {
    const r = e[s].edge.source, a = e[s].edge.target;
    if (s === 0)
      if (t > 2) {
        const c = Rn(e, 0);
        c === null ? i = !0 : i = c === a;
      } else
        i = [e[1].edge.source, e[1].edge.target].includes(a);
    else
      r === a ? i = !0 : i = o === r;
    n.push(i), o = i ? a : r;
  }
  return n;
}
function Rn(e, t) {
  const n = e[t], o = e[t + 1], i = [n.edge.source, n.edge.target].sort(), s = [o.edge.source, o.edge.target].sort();
  if (i[0] === i[1])
    return i[0];
  if (s[0] === s[1])
    return s[0];
  if (n.edgeId === o.edgeId || i[0] === s[0] && i[1] === s[1]) {
    if (t >= e.length - 2)
      return null;
    {
      const r = Rn(e, t + 1);
      return r === null ? null : r === i[1] ? i[0] : i[1];
    }
  } else
    return s.includes(i[1]) ? i[1] : i[0];
}
function gn(e, t, n, o) {
  const i = o ? e.source : e.target, s = e.curve;
  if (s) {
    let r = t / s.circle.radius;
    return s.theta > 0 && (r *= -1), o || (r *= -1), V.fromObject(
      Le(
        o ? e.line.source : e.line.target,
        s.circle.center,
        r
      )
    );
  } else {
    let r, a;
    if (o ? (r = e.line.target, a = e.line.source) : (r = e.line.source, a = e.line.target), n[i]) {
      const c = mt(
        r,
        a,
        V.fromObject(n[i]),
        t
      );
      return c === null ? r : c;
    } else
      return r;
  }
}
function ui(e, t, n) {
  let o = null;
  if (e.loop || t.loop)
    o = null;
  else if (e.curve)
    if (t.curve) {
      if (e.line.target.isEqualTo(t.line.source))
        return e.line.target.clone();
      o = Qe(
        e.curve.circle.center,
        e.curve.circle.radius,
        t.curve.circle.center,
        t.curve.circle.radius,
        e.curve.center
      );
    } else
      o = si(
        t.line.target,
        t.line.source,
        e.curve.circle.center,
        e.curve.circle.radius,
        n
      );
  else if (t.curve)
    o = mt(
      e.line.source,
      e.line.target,
      t.curve.circle.center,
      t.curve.circle.radius
    );
  else {
    const i = mn(e.line), s = mn(t.line);
    !isFinite(i) && !isFinite(s) || Math.abs(i - s) < li ? o = null : o = Ne(e.line, t.line);
  }
  return o;
}
function st(e, t, n, o) {
  if (e.loop) {
    const i = Qe(
      t,
      n,
      e.loop.center,
      e.loop.radius[0]
    );
    return i ? o ? i[0] : i[1] : null;
  } else
    return e.curve ? Qe(
      t,
      n,
      e.curve.circle.center,
      e.curve.circle.radius,
      V.fromObject(e.curve.center)
    ) : mt(
      o ? e.line.source : e.line.target,
      o ? e.line.target : e.line.source,
      t,
      n
    );
}
function di(e, t, n) {
  let o = n.origin, i = e.edge.source, s = e.edge.target, r = n.curve;
  const a = n.loop;
  a ? o = n.position : t || (o = ii(o), i = e.edge.target, s = e.edge.source, r && (r = Fe(se({}, r), { theta: -r.theta })));
  const c = Q.fromLinePosition(o);
  return {
    edgeId: e.edgeId,
    source: i,
    target: s,
    line: c,
    direction: t,
    curve: r,
    loop: a
  };
}
function mn(e) {
  return (e.target.y - e.source.y) / (e.target.x - e.source.x);
}
function bn(e, t, n) {
  const { radius: o, center: i } = G(t.loop, "Loop of edge parameter"), [s, r] = o, a = Qe(e, n, i, o[0]);
  let [c, u] = a ? a.reverse() : [t.line.source, t.line.target];
  const l = $t(t);
  l || ([c, u] = [u, c]);
  const h = c, d = u, v = V.fromObject(h).subtract(i).angleDegree();
  let E = (V.fromObject(d).subtract(i).angleDegree() + 360 - v) % 360 >= 180;
  return E = l ? E : !E, [h, d, `A ${s} ${r} 0 ${E ? 1 : 0} ${l ? 1 : 0} ${d.x} ${d.y}`];
}
function $t(e) {
  return e.loop ? e.direction ? e.loop.isClockwise : !e.loop.isClockwise : !0;
}
function Mt(e, t, n, o, i, s, r) {
  const a = Ce({});
  F(
    () => new Set(Object.keys(e.value)),
    (u, l) => {
      l || (l = /* @__PURE__ */ new Set([]));
      for (const h of u)
        l.has(h) || fi(e, a, h, !1, t, i);
      for (const h of l)
        u.has(h) || (n.delete(h), o.delete(h), s == null || s(h, a[h]), delete a[h]);
    },
    { immediate: !0 }
  ), F(
    () => [...n],
    (u, l) => {
      const h = l ? u.filter((v) => !l.includes(v)) : u, d = l ? l.filter((v) => !u.includes(v)) : [];
      h.forEach((v) => {
        const x = a[v];
        x && !x.selected && (x.selected = !0);
      }), d.forEach((v) => {
        const x = a[v];
        x && x.selected && (x.selected = !1);
      });
    },
    { immediate: !0 }
    // for specified from the beginning
  ), F(
    () => [...o],
    (u, l) => {
      const h = u.filter((v) => !l.includes(v)), d = l.filter((v) => !u.includes(v));
      h.forEach((v) => {
        const x = a[v];
        x && !x.hovered && (x.hovered = !0);
      }), d.forEach((v) => {
        const x = a[v];
        x && x.hovered && (x.hovered = !1);
      });
    }
  );
  const c = C(() => {
    const u = r ? r() : Object.values(a);
    return t.zOrder.enabled ? hi(u, t.zOrder, o, n) : u;
  });
  return { states: a, zOrderedList: c };
}
function fi(e, t, n, o, i, s) {
  const r = {
    id: n,
    selected: o,
    hovered: !1,
    selectable: C(() => e.value[n] ? L.value(i.selectable, e.value[n]) : b(r.selectable)),
    zIndex: C(() => e.value[n] ? L.value(i.zOrder.zIndex, e.value[n]) : b(r.zIndex))
  };
  t[n] = r, s(
    e,
    n,
    t[n]
    /* get reactive object */
  );
}
function hi(e, t, n, o) {
  return t.bringToFrontOnHover && t.bringToFrontOnSelected ? e.sort((i, s) => {
    const r = n.has(i.id), a = n.has(s.id);
    if (r != a)
      return r ? 1 : -1;
    const c = o.has(i.id), u = o.has(s.id);
    return c != u ? c ? 1 : -1 : i.zIndex - s.zIndex;
  }) : t.bringToFrontOnHover ? e.sort((i, s) => {
    const r = n.has(i.id), a = n.has(s.id);
    return r != a ? r ? 1 : -1 : i.zIndex - s.zIndex;
  }) : t.bringToFrontOnSelected ? e.sort((i, s) => {
    const r = o.has(i.id), a = o.has(s.id);
    return r != a ? r ? 1 : -1 : i.zIndex - s.zIndex;
  }) : e.sort((i, s) => i.zIndex - s.zIndex);
}
function vi(e) {
  return typeof btoa === void 0 ? Buffer.from(e).toString("base64").replaceAll("=", "") : btoa(e).replaceAll("=", "");
}
function pi() {
  return { markers: Ce({}), referenceCount: {} };
}
function gi(e) {
  const { markers: t, referenceCount: n } = e;
  function o(a, c) {
    var l;
    const u = (l = n[a]) != null ? l : 0;
    n[a] = u + 1, u || (t[a] = c);
  }
  function i(a) {
    var u;
    const c = (u = n[a]) != null ? u : 0;
    c && (c - 1 === 0 ? (delete t[a], delete n[a]) : n[a] = c - 1);
  }
  function s(a) {
    a && i(a);
  }
  function r(a, c, u, l, h) {
    if (a.type === "none") {
      s(u);
      return;
    }
    if (a.type === "custom")
      return s(u), a.customId;
    const d = mi(a, c, l), v = bi(d, h);
    return v === u || (s(u), o(v, d)), v;
  }
  return {
    makeMarker: r,
    clearMarker: s
  };
}
function mi(e, t, n) {
  var o;
  return Fe(se({}, e), {
    color: (o = e.color) != null ? o : n,
    isSource: t
  });
}
function bi(e, t) {
  const n = vi(e.color), o = e.isSource ? "L" : "R", i = e.units === "strokeWidth" ? "rel" : "abs";
  return `marker_${t}_${e.type}_${e.width}_${e.height}_${e.margin}_${e.offset}_${n}_${o}_${i}`;
}
function Ct(e, t, n) {
  return {
    objects: e,
    selected: t,
    hovered: n
  };
}
const Hn = Symbol("states"), yi = {
  type: "none",
  width: 0,
  height: 0,
  margin: 0,
  offset: 0,
  units: "strokeWidth",
  color: null
};
function wi(e, t, n, o, i, s, r) {
  const a = Ce({}), c = ze({});
  ge(() => {
    const w = Object.fromEntries(
      Object.keys(e.objects.value).map((m) => [m, {}])
    );
    Object.entries(t.objects.value).forEach(([m, f]) => {
      w != null && w[f.source] || (w[f.source] = {}), w != null && w[f.target] || (w[f.target] = {}), w[f.source][m] = f.target, w[f.target][m] = f.source;
    }), at(c, w);
  });
  const {
    states: u,
    zOrderedList: l
    //
  } = Mt(
    e.objects,
    o.node,
    e.selected,
    e.hovered,
    (w, m, f) => {
      ki(
        w,
        m,
        f,
        o.node,
        c,
        i
      );
    },
    (w, m) => {
      const f = i.nodes;
      delete f[w];
    }
  ), h = Xo(), d = Go(e.objects, t.objects, o), v = _([]), {
    states: x,
    zOrderedList: k
    //
  } = Mt(
    t.objects,
    o.edge,
    t.selected,
    t.hovered,
    (w, m, f) => {
      Si(
        w,
        m,
        f,
        o.edge,
        s,
        u,
        d,
        i,
        r,
        h
      );
    },
    (w, m) => {
      var f;
      (f = m.stopWatchHandle) == null || f.call(m);
    },
    () => v.value
  );
  ge(() => {
    v.value = Mi(d.edgeGroups, x);
  }), F(
    d.edgeGroups,
    (w) => Ti(a, d, o),
    { immediate: !0 }
  );
  const {
    states: E,
    zOrderedList: p
    //
  } = Mt(
    n.objects,
    o.path,
    n.selected,
    n.hovered,
    (w, m, f) => {
      const g = f;
      g.clickable = C(() => w.value[m] ? L.value(o.path.clickable, w.value[m]) : !1), g.hoverable = C(() => w.value[m] ? L.value(o.path.hoverable, w.value[m]) : !1), g.path = w.value[m], g.edges = wn(g.path, t), g.directions = pn(g.edges), g.stopWatchHandle = F(
        () => w.value[m].edges,
        () => {
          g.edges = wn(g.path, t), g.directions = pn(g.edges);
        }
      );
    },
    (w, m) => {
      var f;
      (f = m.stopWatchHandle) == null || f.call(m);
    }
  ), y = {
    nodeStates: u,
    edgeStates: x,
    edgeGroupStates: d,
    summarizedEdgeStates: a,
    pathStates: E,
    layouts: i,
    nodeZOrderedList: l,
    edgeZOrderedList: k,
    pathZOrderedList: p
  };
  return Ae(Hn, y), y;
}
function Ei(e) {
  return e.summarized;
}
function Se() {
  return G(Ze(Hn), "states");
}
function xi(e, t, n, o) {
  return n && o.hover ? L.values(o.hover, e) : Wn(e, t, o);
}
function Wn(e, t, n) {
  return t && n.selected ? L.values(n.selected, e) : L.values(n.normal, e);
}
function ki(e, t, n, o, i, s) {
  n.shape = C(() => e.value[t] ? xi(e.value[t], n.selected, n.hovered, o) : b(n.shape)), n.staticShape = C(() => e.value[t] ? Wn(e.value[t], n.selected, o) : b(n.staticShape)), n.label = C(() => e.value[t] ? L.values(o.label, e.value[t]) : b(n.label)), n.labelText = C(() => {
    var r, a;
    return o.label.text instanceof Function ? b(n.label).text : e.value[t] ? (a = (r = e.value[t]) == null ? void 0 : r[b(n.label).text]) != null ? a : "" : b(n.labelText);
  }), n.draggable = C(() => e.value[t] ? L.value(o.draggable, e.value[t]) : b(n.draggable)), n.oppositeNodeIds = Me(i, t), n.oppositeNodes = C(() => Object.entries(n.oppositeNodeIds).reduce(
    (r, a) => {
      const [c, u] = a, l = s.nodes[u];
      return l && (r[c] = { nodeId: u, pos: se({}, l) }), r;
    },
    {}
  ));
}
function Pi(e, t, n, o) {
  return t ? L.values(o.selected, e) : n && o.hover ? L.values(o.hover, e) : L.values(o.normal, e);
}
function yn(e) {
  return e.type === "none" ? yi : e;
}
function Si(e, t, n, o, i, s, r, a, c, u) {
  const { makeMarker: l, clearMarker: h } = gi(i);
  Object.assign(n, {
    origin: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    labelPosition: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    position: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }
  }), n.label = C(() => e.value[t] ? L.values(o.label, e.value[t]) : b(n.label));
  const d = C(() => {
    const p = e.value[t], y = Pi(p, n.selected, n.hovered, o);
    isNaN(+y.width) && (console.warn(
      "[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]",
      t,
      y.width
    ), y.width = 1), (y.color === void 0 || y.color === null) && (console.warn(
      "[v-network-graph] Edge color is invalid value. id=[%s] value=[%s]",
      t,
      y.color
    ), y.color = "#000000");
    let w = L.value(o.normal.width, p);
    isNaN(+w) && (w = 1);
    const m = yn(L.values(o.marker.source, [p, y])), f = yn(L.values(o.marker.target, [p, y]));
    return { stroke: y, normalWidth: w, source: m, target: f };
  });
  n.line = d;
  const v = Me(
    r.edgeLayoutPoints,
    t
  ), x = Me(r.summarizedEdges, t), k = ge(() => {
    var B, U, be, oe, ke, De, Ue;
    const p = e.value[t];
    if (!p)
      return;
    const y = (B = s[p.source]) == null ? void 0 : B.staticShape, w = (U = s[p.target]) == null ? void 0 : U.staticShape;
    if (!y || !w)
      return;
    const m = (be = a.nodes[p == null ? void 0 : p.source]) != null ? be : { x: 0, y: 0 }, f = (oe = a.nodes[p == null ? void 0 : p.target]) != null ? oe : { x: 0, y: 0 }, g = Ko(
      v.value,
      (ke = x.value) != null ? ke : !1,
      m,
      f,
      c.value,
      o.keepOrder
    ), [S, O] = ri(m, f, y, w), I = c.value;
    n.labelPosition = zt(
      g,
      S * I,
      O * I
    );
    let T = 0, z = 0;
    const A = d.value;
    if (A.source.type !== "none") {
      const le = A.source;
      T = le.margin + le.width, le.units === "strokeWidth" && (T *= A.normalWidth);
    }
    if (A.target.type !== "none") {
      const le = A.target;
      z = le.margin + le.width, le.units === "strokeWidth" && (z *= A.normalWidth);
    }
    o.margin && (T += o.margin, z += o.margin);
    const j = !!o.margin || A.source.type !== "none" || A.target.type !== "none";
    if (p.source === p.target) {
      n.origin = ut(m, f);
      const le = L.values(o.selfLoop, p), [Be, ye] = Oi(
        m,
        y,
        le,
        j,
        T,
        z,
        (Ue = (De = v.value) == null ? void 0 : De.pointInGroup) != null ? Ue : 0,
        I
      );
      n.position = Be, n.loop = ye, n.curve = void 0;
      return;
    } else
      n.loop = void 0;
    if (j && (T += S, z += O), o.type === "straight" || x.value)
      n.origin = g, n.curve = void 0, T === 0 && z === 0 ? n.position = n.origin : n.position = zt(n.origin, T * I, z * I);
    else {
      n.origin = ut(m, f);
      const le = v.value ? v.value.groupWidth / 2 - v.value.pointInGroup : 0, [Be, ye] = Ci(
        n.origin,
        g,
        le,
        T * I,
        z * I
      );
      n.position = Be, n.curve = ye;
    }
  }), E = ge(() => {
    e.value[t] && (n.sourceMarkerId = l(
      d.value.source,
      !0,
      n.sourceMarkerId,
      d.value.stroke.color,
      u
    ), n.targetMarkerId = l(
      d.value.target,
      !1,
      n.targetMarkerId,
      d.value.stroke.color,
      u
    ));
  });
  n.stopWatchHandle = () => {
    k(), E(), h(n.sourceMarkerId), h(n.targetMarkerId);
  };
}
function Mi(e, t) {
  return Object.entries(e).map(([n, o]) => {
    var i;
    return o.summarize ? {
      id: (i = Object.keys(o.edges)[0]) != null ? i : n,
      summarized: !0,
      key: n,
      group: o,
      zIndex: Object.keys(o.edges).map((s) => {
        var r, a;
        return (a = (r = t[s]) == null ? void 0 : r.zIndex) != null ? a : 0;
      }).reduce((s, r) => Math.max(s, r))
    } : Object.entries(o.edges).map(
      ([s, r]) => {
        var a, c;
        return {
          id: s,
          summarized: !1,
          key: s,
          edge: r,
          zIndex: (c = (a = t[s]) == null ? void 0 : a.zIndex) != null ? c : 0
        };
      }
    );
  }).flat();
}
function Ci(e, t, n, o, i) {
  const s = Q.fromLinePosition(e), r = Q.fromLinePosition(t), a = ni(t), [c, u] = ai(
    s.source,
    s.target,
    a
  );
  let l, h;
  if (u === 0)
    return [e, h];
  if (n === 0)
    return o === 0 && i === 0 ? l = e : l = zt(e, o, i), [l, h];
  const d = Q.fromVectors(c, a), v = He(
    Q.fromVectors(c, s.source),
    d
  );
  if (o === 0 && i === 0)
    l = e;
  else {
    let p = o / u, y = i / u;
    v > 0 && (p *= -1, y *= -1), l = ut(
      Le(s.source, c, p),
      Le(s.target, c, -y)
    );
    let w = He(
      Q.fromVectors(c, s.source),
      Q.fromVectors(c, s.target)
    ), m = He(
      Q.fromPositions(c, l.p1),
      Q.fromPositions(c, l.p2)
    );
    if (v * w < 0 && (w = It(w), v * m < 0 && (m = It(m))), w * m < 0) {
      const f = a.clone().add(r.v.normalize().multiplyScalar(0.5));
      return l = ut(a, f), [l, h];
    }
  }
  const [x, k] = ti(l), E = Lt(x, c, k, v).map((p) => p.toObject());
  return h = {
    center: a,
    theta: v,
    circle: { center: c, radius: u },
    control: E
  }, [l, h];
}
function Oi(e, t, n, o, i, s, r, a) {
  const c = a, u = (n.radius + r / 2) * c, l = n.offset * c + u, h = (n.angle - 90) * (Math.PI / 180), d = V.fromObject({
    x: e.x + l * Math.cos(h),
    y: e.y + l * Math.sin(h)
  }), v = n.isClockwise;
  let x, k;
  if (o) {
    const m = Qe(
      d,
      u,
      V.fromObject(e),
      Ve(t) * c
    );
    if (m) {
      [x, k] = m;
      let f = 1;
      if (v || ([x, k] = [k, x], f = -1), i !== 0 || s !== 0) {
        const g = i * c / u * f, S = s * c / u * f;
        x = Le(x, d, g), k = Le(k, d, -S);
      }
    }
  }
  if (x === void 0 || k === void 0) {
    const m = V.fromObject(e).subtract(d).normalize().multiplyScalar(u);
    let f = 1 * (Math.PI / 180);
    v || (f *= -1), x = d.clone().add(ct(m, f)), k = d.clone().add(ct(m, -f));
  }
  const E = V.fromObject(x).subtract(d).angleDegree(), w = (V.fromObject(k).subtract(d).angleDegree() + 360 - E) % 360 >= 180;
  return [
    { p1: x, p2: k },
    {
      center: d,
      radius: [u, u],
      isLargeArc: v ? w : !w,
      isClockwise: v
    }
  ];
}
function Ti(e, t, n) {
  const o = t.edgeGroups;
  Object.entries(o).filter(([i, s]) => s.summarize && !(i in e)).forEach(([i, s]) => {
    const r = { stroke: void 0 };
    r.stroke = C(
      () => L.values(n.edge.summarized.stroke, s.edges)
    ), e[i] = r;
  }), Object.keys(e).forEach((i) => {
    var s;
    (s = t.edgeGroups[i]) != null && s.summarize || delete e[i];
  });
}
function wn(e, t) {
  return e.edges.map((n) => ({ edgeId: n, edge: t.objects.value[n] })).filter((n) => n.edge);
}
class Ke {
  static valueOf(t) {
    return Array.from(t.values());
  }
}
const zi = 3, Ii = 6, Un = 500;
function lt(e) {
  return e === "touch" ? Ii : zi;
}
function qt(e, t, n, o) {
  let i = e.get(t);
  if (i)
    i.id !== n && (i = void 0);
  else {
    const a = Array.from(e.entries()).find(([c, u]) => u.id === n);
    if (a) {
      const [c, u] = a;
      e.delete(c), i = u;
    }
  }
  let s, r;
  return [i, s, r] = Fn(i, o, n), e.set(t, i), [s, r];
}
function Fn(e, t, n) {
  const o = Date.now();
  e && o - e.lastTime <= Un ? (e.count++, e.lastTime = o) : e = { count: 1, lastTime: o, id: n };
  const i = {
    view: window,
    screenX: t.screenX,
    screenY: t.screenY,
    clientX: t.clientX,
    clientY: t.clientY,
    ctrlKey: t.ctrlKey,
    shiftKey: t.shiftKey,
    altKey: t.altKey,
    metaKey: t.metaKey,
    button: t.button,
    buttons: t.buttons,
    detail: e.count
  };
  let s, r;
  return t instanceof PointerEvent ? (Object.assign(i, {
    pointerId: t.pointerId,
    width: t.width,
    height: t.height,
    pressure: t.pressure,
    tangentialPressure: t.tangentialPressure,
    tiltX: t.tiltX,
    tiltY: t.tiltY,
    twist: t.twist,
    pointerType: t.pointerType,
    isPrimary: t.isPrimary
  }), s = new PointerEvent("click", i), e.count === 2 && (r = new PointerEvent("dblclick", i))) : (s = new MouseEvent("click", i), e.count === 2 && (r = new MouseEvent("dblclick", i))), [e, s, r];
}
function Gt(e) {
  const t = Date.now();
  Array.from(e.entries()).filter(([n, o]) => t - o.lastTime > Un).map(([n, o]) => e.delete(n));
}
function Li(e, t, n, o, i, s, r) {
  const a = {
    pointers: /* @__PURE__ */ new Map(),
    follow: {
      followedPointerId: -1,
      nodeBasePositions: {}
    },
    hoveredNodesPre: /* @__PURE__ */ new Set(),
    clicks: /* @__PURE__ */ new Map()
  }, c = {
    pointermove: v,
    pointerup: k,
    pointercancel: x
  };
  function u(m) {
    const f = a.follow.followedPointerId === m.pointerId, g = i.has(m.nodeId), S = !(m.pointerId in a.pointers);
    if (f && S || f && !g) {
      const O = Ke.valueOf(a.pointers).find((I) => i.has(I.nodeId));
      if (!O) {
        a.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      m = O, a.follow.followedPointerId = m.pointerId;
    } else {
      const O = a.pointers.get(a.follow.followedPointerId);
      if (!O) {
        a.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      m = O;
    }
    if (f || g) {
      const O = Ke.valueOf(a.pointers).map((I) => I.nodeId);
      a.follow.nodeBasePositions = Object.fromEntries(
        Array.from(i).filter((I) => !O.includes(I)).filter((I) => {
          var T;
          return (T = e[I]) == null ? void 0 : T.draggable;
        }).map((I) => [I, Ot(t.nodes, I)])
      ), m.dragBasePosition = se({}, m.latestPosition), m.nodeBasePosition = Ot(t.nodes, m.nodeId);
    }
  }
  F(i, (m) => {
    const f = a.pointers.get(a.follow.followedPointerId);
    f && u(f), m.size > 0 && n.selectionMode.value !== "node" ? n.selectionMode.value = "node" : m.size === 0 && n.selectionMode.value === "node" && (n.selectionMode.value = "container");
  }), F(n.selectionMode, (m) => {
    m !== "node" && i.clear();
  });
  function l(m, f) {
    const g = m.dragBasePosition.x - f.pageX, S = m.dragBasePosition.y - f.pageY, O = a.follow.followedPointerId == m.pointerId ? se({
      [m.nodeId]: m.nodeBasePosition
    }, a.follow.nodeBasePositions) : { [m.nodeId]: m.nodeBasePosition }, I = s.value;
    return Object.fromEntries(
      Object.entries(O).map(([T, z]) => [
        T,
        {
          x: z.x - g / I,
          y: z.y - S / I
        }
      ])
    );
  }
  function h(m, f) {
    var S, O;
    if (f.isTrusted || f.shiftKey && !["container", "node"].includes(n.selectionMode.value))
      return;
    n.selectionMode.value = "node";
    const g = (O = (S = e[m]) == null ? void 0 : S.selectable) != null ? O : !1;
    if (g) {
      const I = Ke.valueOf(a.pointers).filter((T) => i.has(T.nodeId)).length > 0;
      f.shiftKey || I ? i.has(m) ? i.delete(m) : typeof g == "number" && i.size >= g || i.add(m) : i.has(m) || (i.clear(), i.add(m));
    }
    r.emit("node:click", { node: m, event: f });
  }
  function d(m, f) {
    f.isTrusted || r.emit("node:dblclick", { node: m, event: f });
  }
  function v(m) {
    var O;
    m.stopPropagation();
    const f = a.pointers.get(m.pointerId);
    if (!f)
      return;
    f.latestPosition = { x: m.pageX, y: m.pageY }, f.moveCounter++;
    const g = lt(m.pointerType);
    if (f.moveCounter <= g || !((O = e[f.nodeId]) != null && O.draggable))
      return;
    if (f.moveCounter === g + 1) {
      const I = l(f, {
        pointerId: f.pointerId,
        pageX: f.dragBasePosition.x,
        pageY: f.dragBasePosition.y
      });
      r.emit("node:dragstart", I);
    }
    const S = l(f, m);
    r.emit("node:pointermove", S);
  }
  function x(m) {
    m.stopPropagation();
    let f = a.pointers.get(m.pointerId);
    if (f) {
      for (f of a.pointers.values()) {
        const g = f.nodeId, S = lt(m.pointerType);
        if (f.moveCounter > S) {
          const I = l(f, {
            pointerId: f.pointerId,
            pageX: f.latestPosition.x,
            pageY: f.latestPosition.y
          });
          r.emit("node:dragend", I);
        }
        r.emit("node:pointerup", { node: g, event: m });
      }
      a.pointers.clear(), a.follow = { followedPointerId: -1, nodeBasePositions: {} }, he(c).forEach(([g, S]) => {
        document.removeEventListener(g, S);
      }), n.viewMode.value = "default";
    }
  }
  function k(m) {
    var I, T, z;
    m.stopPropagation();
    const f = a.pointers.get(m.pointerId);
    if (!f)
      return;
    a.pointers.delete(m.pointerId);
    const g = f.nodeId, S = lt(m.pointerType), O = f.moveCounter > S;
    if (O) {
      if ((I = e[f.nodeId]) != null && I.draggable) {
        const A = l(f, m);
        r.emit("node:dragend", A), r.emit("node:pointerup", { node: g, event: m });
      }
    } else
      r.emit("node:pointerup", { node: g, event: m });
    if (!O) {
      const [A, j] = qt(
        a.clicks,
        f.pointerId,
        g,
        m
      );
      (T = f.eventTarget) == null || T.dispatchEvent(A), j && ((z = f.eventTarget) == null || z.dispatchEvent(j));
    }
    a.pointers.size === 0 ? (a.follow = { followedPointerId: -1, nodeBasePositions: {} }, he(c).forEach(([A, j]) => {
      document.removeEventListener(A, j);
    }), Gt(a.clicks), n.viewMode.value = "default") : u(f), o.clear(), a.hoveredNodesPre.forEach(o.add, o);
  }
  function E(m, f) {
    if (f.button == 2 || (f.stopPropagation(), !["default", "node"].includes(n.viewMode.value)))
      return;
    a.pointers.size == 0 && (n.viewMode.value = "node", he(c).forEach(([S, O]) => {
      document.addEventListener(S, O);
    }));
    const g = {
      pointerId: f.pointerId,
      nodeId: m,
      moveCounter: 0,
      nodeBasePosition: Ot(t.nodes, m),
      dragBasePosition: { x: f.pageX, y: f.pageY },
      latestPosition: { x: f.pageX, y: f.pageY },
      eventTarget: f.currentTarget
    };
    a.pointers.set(f.pointerId, g), i.has(m) && (a.follow.followedPointerId < 0 ? (a.follow.followedPointerId = f.pointerId, u(g)) : delete a.follow.nodeBasePositions[g.nodeId]), r.emit("node:pointerdown", { node: m, event: f });
  }
  function p(m, f) {
    a.hoveredNodesPre.add(m), !(a.pointers.size > 0) && (o.add(m), r.emit("node:pointerover", { node: m, event: f }));
  }
  function y(m, f) {
    a.hoveredNodesPre.delete(m), !(a.pointers.size > 0) && (o.delete(m), r.emit("node:pointerout", { node: m, event: f }));
  }
  function w(m, f) {
    f.stopPropagation(), r.emit("node:contextmenu", { node: m, event: f });
  }
  return {
    handleNodePointerDownEvent: E,
    handleNodePointerOverEvent: p,
    handleNodePointerOutEvent: y,
    handleNodeClickEvent: h,
    handleNodeDoubleClickEvent: d,
    handleNodeContextMenu: w
  };
}
function Ot(e, t) {
  var o;
  const n = (o = e[t]) != null ? o : { x: 0, y: 0 };
  return se({}, n);
}
function $i(e, t, n, o, i) {
  const s = {
    pointers: /* @__PURE__ */ new Map(),
    // <PointerId, ...>
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  }, r = {
    pointerup: c,
    pointercancel: u
  };
  F(o, (f) => {
    f.size > 0 && t.selectionMode.value !== "edge" ? t.selectionMode.value = "edge" : f.size === 0 && t.selectionMode.value === "edge" && (t.selectionMode.value = "container");
  }), F(t.selectionMode, (f) => {
    f !== "edge" && o.clear();
  });
  function a(f, g) {
    if (g.button == 2 || (g.stopPropagation(), !["default", "edge"].includes(t.viewMode.value)))
      return;
    s.pointers.size == 0 && (t.viewMode.value = "edge", he(r).forEach(([O, I]) => {
      document.addEventListener(O, I);
    }), s.pointerPeekCount = 0), s.pointerPeekCount++;
    const S = {
      pointerId: g.pointerId,
      id: f,
      eventTarget: g.currentTarget
    };
    s.pointers.set(g.pointerId, S), i.emit("edge:pointerdown", we(f, g));
  }
  function c(f) {
    var T, z;
    f.stopPropagation();
    const g = s.pointers.get(f.pointerId);
    if (!g)
      return;
    s.pointers.delete(f.pointerId);
    const S = g.id;
    i.emit("edge:pointerup", we(S, f));
    const [O, I] = qt(
      s.clicks,
      g.pointerId,
      S instanceof Array ? S.join(",") : S,
      f
    );
    (T = g.eventTarget) == null || T.dispatchEvent(O), I && ((z = g.eventTarget) == null || z.dispatchEvent(I)), s.pointers.size === 0 && (s.pointerPeekCount = 0, he(r).forEach(([A, j]) => {
      document.removeEventListener(A, j);
    }), Gt(s.clicks), t.viewMode.value = "default");
  }
  function u(f) {
    if (f.stopPropagation(), !!s.pointers.get(f.pointerId)) {
      for (const S of s.pointers.values()) {
        const O = S.id;
        i.emit("edge:pointerup", we(O, f));
      }
      s.pointers.clear(), s.pointerPeekCount = 0, he(r).forEach(([S, O]) => {
        document.removeEventListener(S, O);
      }), i.emit("view:mode", "default");
    }
  }
  function l(f, g) {
    var I;
    if (g.isTrusted || g.shiftKey && !["container", "edge"].includes(t.selectionMode.value))
      return;
    t.selectionMode.value = "edge";
    const S = f instanceof Array ? f : [f], O = Ke.valueOf(s.pointers).filter((T) => (T.id instanceof Array ? T.id : [T.id]).every((A) => o.has(A))).length > 0;
    if (f instanceof Array)
      S.find((z) => {
        var A;
        return (A = e[z]) == null ? void 0 : A.selectable;
      }) && (g.shiftKey || O ? S.some((z) => o.has(z)) ? S.forEach((z) => o.delete(z)) : S.forEach((z) => {
        var j;
        const A = (j = e[z]) == null ? void 0 : j.selectable;
        typeof A == "number" && o.size >= A || o.add(z);
      }) : (o.clear(), S.forEach((z) => o.add(z))));
    else {
      const T = (I = e[f]) == null ? void 0 : I.selectable;
      T && (g.shiftKey || O ? o.has(f) ? o.delete(f) : typeof T == "number" && o.size >= T || o.add(f) : o.has(f) || (o.clear(), o.add(f)));
    }
    i.emit("edge:click", we(f, g));
  }
  function h(f, g) {
    g.isTrusted || i.emit("edge:dblclick", we(f, g));
  }
  function d(f, g) {
    n.add(f), i.emit("edge:pointerover", we(f, g));
  }
  function v(f, g) {
    n.delete(f), i.emit("edge:pointerout", we(f, g));
  }
  function x(f, g) {
    g.stopPropagation(), i.emit("edge:contextmenu", we(f, g));
  }
  function k(f, g) {
    if (g.button == 2 || (g.stopPropagation(), !["default", "edge"].includes(t.viewMode.value)))
      return;
    s.pointers.size == 0 && (t.viewMode.value = "edge", he(r).forEach(([O, I]) => {
      document.addEventListener(O, I);
    }), s.pointerPeekCount = 0), s.pointerPeekCount++;
    const S = {
      pointerId: g.pointerId,
      id: f,
      eventTarget: g.currentTarget
    };
    s.pointers.set(g.pointerId, S), i.emit("edge:pointerdown", we(f, g));
  }
  function E(f, g) {
    f.forEach((S) => n.add(S)), i.emit("edge:pointerover", we(f, g));
  }
  function p(f, g) {
    f.forEach((S) => n.delete(S)), i.emit("edge:pointerout", we(f, g));
  }
  function y(f, g) {
    l(f, g);
  }
  function w(f, g) {
    h(f, g);
  }
  function m(f, g) {
    g.stopPropagation(), i.emit("edge:contextmenu", we(f, g));
  }
  return {
    handleEdgePointerDownEvent: a,
    handleEdgePointerOverEvent: d,
    handleEdgePointerOutEvent: v,
    handleEdgeClickEvent: l,
    handleEdgeDoubleClickEvent: h,
    handleEdgeContextMenu: x,
    handleEdgesPointerDownEvent: k,
    handleEdgesPointerOverEvent: E,
    handleEdgesPointerOutEvent: p,
    handleEdgesClickEvent: y,
    handleEdgesDoubleClickEvent: w,
    handleEdgesContextMenu: m
  };
}
function we(e, t) {
  return e instanceof Array ? {
    edges: e,
    event: t,
    summarized: !0
  } : {
    edge: e,
    edges: [e],
    event: t,
    summarized: !1
  };
}
function Ai(e, t, n, o) {
  const i = {
    moveCounter: 0,
    pointerCounter: 0,
    clickState: void 0
  }, s = {
    pointermove: a,
    pointerup: c,
    pointercancel: c
  };
  function r(v) {
    i.moveCounter = 0, i.pointerCounter === 0 && he(s).forEach(([x, k]) => {
      document.addEventListener(x, k, { passive: !0 });
    }), i.pointerCounter++;
  }
  function a(v) {
    i.moveCounter++;
  }
  function c(v) {
    if (i.pointerCounter--, i.pointerCounter <= 0) {
      i.pointerCounter = 0, he(s).forEach(([k, E]) => {
        document.removeEventListener(k, E);
      });
      const x = lt(v.pointerType);
      if (i.moveCounter <= x) {
        if (v.shiftKey && t.selectionMode.value !== "container")
          return;
        t.selectionMode.value = "container";
        const [k, E, p] = Fn(
          i.clickState,
          v,
          "view"
        );
        i.clickState = k, e.value.dispatchEvent(E), p && e.value.dispatchEvent(p);
      }
    }
  }
  function u(v) {
    v.isTrusted || (v.stopPropagation(), o.emit("view:click", { event: v }));
  }
  function l(v) {
    v.isTrusted || (v.stopPropagation(), o.emit("view:dblclick", { event: v }));
  }
  function h(v) {
    o.emit("view:contextmenu", { event: v }), i.pointerCounter > 0 && (i.pointerCounter = 0, he(s).forEach(([x, k]) => {
      var E;
      (E = e.value) == null || E.removeEventListener(x, k);
    }));
  }
  const d = (v) => {
    v.preventDefault();
  };
  We(() => {
    const v = e.value;
    v && (v.addEventListener("pointerdown", r, { passive: !0 }), v.addEventListener("click", u, { passive: !1 }), v.addEventListener("dblclick", l, { passive: !1 }), v.addEventListener("contextmenu", h, { passive: !1 }), n.value && v.addEventListener("wheel", d, { passive: !1 }));
  }), Je(() => {
    const v = e.value;
    v && (v.removeEventListener("pointerdown", r), v.removeEventListener("click", u), v.removeEventListener("dblclick", l), v.removeEventListener("contextmenu", h), n.value && v.removeEventListener("wheel", d));
  }), F(n, (v, x) => {
    const k = e.value;
    !k || v === x || (v ? k.addEventListener("wheel", d, { passive: !1 }) : k.removeEventListener("wheel", d));
  });
}
function Zi(e, t, n, o, i, s) {
  const r = {
    pointers: /* @__PURE__ */ new Map(),
    // <PointerId, ...>
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  };
  function a(p, y) {
    var w, m;
    return i.value ? { path: (m = (w = e[p]) == null ? void 0 : w.path) != null ? m : p, event: y } : { path: p, event: y };
  }
  const c = {
    pointerup: l,
    pointercancel: h
  };
  F(o, (p) => {
    p.size > 0 && t.selectionMode.value !== "path" ? t.selectionMode.value = "path" : p.size === 0 && t.selectionMode.value === "path" && (t.selectionMode.value = "container");
  }), F(t.selectionMode, (p) => {
    p !== "path" && o.clear();
  });
  function u(p, y) {
    var m;
    if (!((m = e[p]) != null && m.clickable) || y.button == 2 || (y.stopPropagation(), !["default", "path"].includes(t.viewMode.value)))
      return;
    r.pointers.size == 0 && (t.viewMode.value = "path", he(c).forEach(([f, g]) => {
      document.addEventListener(f, g);
    }), r.pointerPeekCount = 0), r.pointerPeekCount++;
    const w = {
      pointerId: y.pointerId,
      id: p,
      eventTarget: y.currentTarget
    };
    r.pointers.set(y.pointerId, w), s.emit("path:pointerdown", a(p, y));
  }
  function l(p) {
    var g, S;
    const y = r.pointers.get(p.pointerId);
    if (!y)
      return;
    p.stopPropagation(), r.pointers.delete(p.pointerId);
    const w = y.id;
    s.emit("path:pointerup", a(w, p));
    const [m, f] = qt(
      r.clicks,
      y.pointerId,
      w,
      p
    );
    (g = y.eventTarget) == null || g.dispatchEvent(m), f && ((S = y.eventTarget) == null || S.dispatchEvent(f)), r.pointers.size === 0 && (r.pointerPeekCount = 0, he(c).forEach(([O, I]) => {
      document.removeEventListener(O, I);
    }), Gt(r.clicks), t.viewMode.value = "default");
  }
  function h(p) {
    if (r.pointers.get(p.pointerId)) {
      p.stopPropagation();
      for (const w of r.pointers.values()) {
        const m = w.id;
        s.emit("path:pointerup", a(m, p));
      }
      r.pointers.clear(), r.pointerPeekCount = 0, he(c).forEach(([w, m]) => {
        document.removeEventListener(w, m);
      }), s.emit("view:mode", "default");
    }
  }
  function d(p, y) {
    var w;
    (w = e[p]) != null && w.hoverable && (n.add(p), s.emit("path:pointerover", a(p, y)));
  }
  function v(p, y) {
    var w;
    (w = e[p]) != null && w.hoverable && (n.delete(p), s.emit("path:pointerout", a(p, y)));
  }
  function x(p, y) {
    var m, f, g;
    if (y.isTrusted || !((m = e[p]) != null && m.clickable) || y.shiftKey && !["container", "path"].includes(t.selectionMode.value))
      return;
    t.selectionMode.value = "path";
    const w = (g = (f = e[p]) == null ? void 0 : f.selectable) != null ? g : !1;
    if (w) {
      const S = Ke.valueOf(r.pointers).filter((O) => o.has(O.id)).length > 0;
      y.shiftKey || S ? o.has(p) ? o.delete(p) : typeof w == "number" && o.size >= w || o.add(p) : o.has(p) || (o.clear(), o.add(p));
    }
    s.emit("path:click", a(p, y));
  }
  function k(p, y) {
    var w;
    y.isTrusted || (w = e[p]) != null && w.clickable && s.emit("path:dblclick", a(p, y));
  }
  function E(p, y) {
    var w;
    (w = e[p]) != null && w.clickable && (y.stopPropagation(), s.emit("path:contextmenu", a(p, y)));
  }
  return {
    handlePathPointerDownEvent: u,
    handlePathPointerOverEvent: d,
    handlePathPointerOutEvent: v,
    handlePathClickEvent: x,
    handlePathDoubleClickEvent: k,
    handlePathContextMenu: E
  };
}
function Di(e) {
  return Ee(this, null, function* () {
    const n = yield (yield fetch(e)).blob();
    return new Promise((o, i) => {
      try {
        const s = new FileReader();
        s.onload = function() {
          o(this.result);
        }, s.readAsDataURL(n);
      } catch (s) {
        i(s);
      }
    });
  });
}
function At(e, t, n) {
  var s;
  const o = e.createSVGPoint();
  o.x = n.x, o.y = n.y;
  const i = o.matrixTransform((s = t.getCTM()) == null ? void 0 : s.inverse());
  return { x: i.x, y: i.y };
}
function Ni(e, t, n) {
  const o = e.createSVGPoint();
  o.x = n.x, o.y = n.y;
  const i = o.matrixTransform(t.getCTM());
  return { x: i.x, y: i.y };
}
function Xn(e, t, n) {
  var u;
  const o = e.cloneNode(!0), i = t.getBBox(), s = 1 / n, r = {
    x: Math.floor((i.x - 10) * s),
    y: Math.floor((i.y - 10) * s),
    width: Math.ceil((i.width + 20) * s),
    height: Math.ceil((i.height + 20) * s)
  };
  o.setAttribute("width", r.width.toString()), o.setAttribute("height", r.height.toString());
  const a = o.querySelector(".v-ng-viewport");
  a.setAttribute("transform", `translate(${-r.x} ${-r.y}), scale(${s})`), a.removeAttribute("style"), o.setAttribute("viewBox", `0 0 ${r.width} ${r.height}`), o.removeAttribute("style");
  const c = document.createNodeIterator(o, NodeFilter.SHOW_COMMENT);
  for (; c.nextNode(); ) {
    const l = c.referenceNode;
    (u = l.parentNode) == null || u.removeChild(l);
  }
  return o;
}
function _i(e) {
  return Ee(this, null, function* () {
    let t = !1, n = e.getAttribute("href");
    if (n || (t = !0, n = e.getAttribute("xlink:href")), !(!n || n.startsWith("data:")))
      try {
        const o = yield Di(n);
        e.setAttribute(t ? "xlink:href" : "href", o);
      } catch (o) {
        console.warn("Image download failed.", n);
        return;
      }
  });
}
function Bi(i, s, r) {
  return Ee(this, arguments, function* (e, t, n, o = {}) {
    const a = Xn(e, t, n);
    if (o.embedImages) {
      const u = Array.from(a.querySelectorAll("image")).map((l) => _i(l));
      yield Promise.all(u);
    }
    return a;
  });
}
function ji(e, t, n, o, i, s) {
  const r = C(
    () => !!s.node.selectable && s.view.boxSelectionEnabled
  ), a = C(() => t.viewMode.value === "box-selection"), c = _(), u = _(), l = {
    pointers: /* @__PURE__ */ new Set(),
    // Set of pointers being pressed
    points: /* @__PURE__ */ new Map(),
    // Point indicated by each pointer
    startPoint: null,
    // Point where the drag started
    selectedNodesAtSelectStarted: /* @__PURE__ */ new Set(),
    // Nodes selected at the start of the selection
    selectionType: "append",
    // Selection method for nodes included in the dragged range
    options: {
      // options specified by user at start of selection mode
      stopTrigger: "pointerup",
      selectionType: "append",
      selectionTypeWithShiftKey: "same"
    }
  }, h = _o(
    () => {
      Vi(
        G(e.value, "container"),
        G(c.value, "viewport"),
        u,
        n.nodes,
        o,
        i,
        l.selectedNodesAtSelectStarted,
        l.selectionType
      );
    },
    50,
    { maxWait: 100 }
  ), d = new Ri(
    e,
    x,
    k,
    E,
    v,
    p
  );
  function v(g) {
    if (l.options.stopTrigger !== "click" || l.pointers.size > 0)
      return;
    const S = { x: g.offsetX, y: g.offsetY };
    l.startPoint && V.fromObject(l.startPoint).distance(S) > 10 || f();
  }
  function x(g) {
    g.stopPropagation();
    const S = { x: g.offsetX, y: g.offsetY };
    l.pointers.size === 0 && (l.startPoint = S, d.activate(), l.selectedNodesAtSelectStarted.clear(), i.forEach((O) => l.selectedNodesAtSelectStarted.add(O)), l.options.selectionTypeWithShiftKey === "same" ? l.selectionType = l.options.selectionType : l.selectionType = g.shiftKey ? l.options.selectionTypeWithShiftKey : l.options.selectionType), l.pointers.has(g.pointerId) || l.pointers.add(g.pointerId), l.points.set(g.pointerId, S), y();
  }
  function k(g) {
    if (l.pointers.delete(g.pointerId), l.pointers.size === 1) {
      const S = G(e.value).getBoundingClientRect(), O = { x: g.x - S.x, y: g.y - S.y };
      l.startPoint = O;
    } else
      l.pointers.size === 0 && (d.deactivate(), l.options.stopTrigger === "pointerup" && f(), l.selectedNodesAtSelectStarted.clear());
    y();
  }
  function E(g) {
    const S = G(e.value).getBoundingClientRect(), O = { x: g.x - S.x, y: g.y - S.y };
    l.points.set(g.pointerId, O), y(), h();
  }
  function p(g) {
    g.key === "Escape" && l.options.stopTrigger !== "manual" && (g.stopPropagation(), f());
  }
  function y() {
    let g, S;
    const O = Array.from(l.pointers);
    if (O.length >= 2) {
      const I = O[0], T = O[O.length - 1];
      g = l.points.get(I), S = l.points.get(T);
    } else if (l.startPoint && O.length === 1) {
      const I = O[0];
      g = l.startPoint, S = l.points.get(I);
    } else
      g = void 0, S = void 0;
    g && S ? (u.value = {
      pos: {
        x: Math.min(g.x, S.x),
        y: Math.min(g.y, S.y)
      },
      size: {
        width: Math.abs(S.x - g.x),
        height: Math.abs(S.y - g.y)
      }
    }, u.value.size.width === 0 && (u.value.size.width = 1), u.value.size.height === 0 && (u.value.size.height = 1)) : u.value && (u.value = void 0);
  }
  const w = new Hi(
    e,
    // key down
    (g) => {
      r.value && s.view.selection.detector(g) && (m({
        stop: "manual",
        type: "append",
        withShiftKey: "invert"
      }), w.activate());
    },
    // key up
    (g) => {
      r.value && s.view.selection.detector(g) && (l.pointers.size === 0 ? f() : l.options.stopTrigger = "pointerup", w.deactivate());
    }
  );
  F(r, (g) => {
    g ? w.register() : w.unregister();
  }), We(() => {
    var g;
    c.value = (g = e.value) == null ? void 0 : g.querySelector(".v-ng-viewport"), r.value && w.register();
  }), Je(() => {
    f(), r.value && w.unregister();
  });
  function m(g = {}) {
    var S, O, I;
    l.options = {
      stopTrigger: (S = g.stop) != null ? S : "pointerup",
      selectionType: (O = g.type) != null ? O : "append",
      selectionTypeWithShiftKey: (I = g.withShiftKey) != null ? I : "same"
    }, t.viewMode.value !== "box-selection" && (t.viewMode.value = "box-selection", l.pointers.clear(), d.register());
  }
  function f() {
    t.viewMode.value === "box-selection" && (t.viewMode.value = "default", d.unregister());
  }
  return { isBoxSelectionMode: a, selectionBox: u, startBoxSelection: m, stopBoxSelection: f };
}
function Vi(e, t, n, o, i, s, r, a) {
  if (!n.value)
    return;
  const c = n.value, u = At(e, t, c.pos), l = At(e, t, {
    x: c.pos.x + c.size.width,
    y: c.pos.y + c.size.height
  }), h = new Set(
    Object.entries(o).filter(([d, v]) => u.x <= v.x && v.x <= l.x && u.y <= v.y && v.y <= l.y).map(([d, v]) => d)
  );
  if (a === "append")
    s.forEach((d) => {
      h.has(d) || s.delete(d);
    }), h.forEach((d) => {
      var x, k;
      const v = (k = (x = i[d]) == null ? void 0 : x.selectable) != null ? k : !1;
      (v === !0 || typeof v == "number" && s.size < v) && s.add(d);
    });
  else {
    const d = new Set(r);
    d.forEach((v) => {
      h.has(v) && d.delete(v);
    }), h.forEach((v) => {
      var x, k;
      if (!r.has(v)) {
        const E = (k = (x = i[v]) == null ? void 0 : x.selectable) != null ? k : !1;
        (E === !0 || typeof E == "number" && d.size < E) && d.add(v);
      }
    }), s.clear(), d.forEach((v) => s.add(v));
  }
}
class Ri {
  constructor(t, n, o, i, s, r) {
    this._container = t, this._handlePointerDownEvent = n, this._handlePointerUpEvent = o, this._handlePointerMoveEvent = i, this._handleClickEvent = s, this._handleKeyDownEvent = r, this._ignoreEvent = (a) => a.stopPropagation();
  }
  register() {
    const t = { capture: !0, passive: !1 }, n = G(this._container.value, "container");
    n.addEventListener("pointerdown", this._handlePointerDownEvent, t), n.addEventListener("click", this._handleClickEvent, t), n.addEventListener("pointerenter", this._ignoreEvent, t), n.addEventListener("pointerleave", this._ignoreEvent, t), document.addEventListener("keydown", this._handleKeyDownEvent, t);
  }
  activate() {
    const t = { capture: !0, passive: !1 };
    document.addEventListener("pointermove", this._handlePointerMoveEvent, t), document.addEventListener("pointerup", this._handlePointerUpEvent, t);
  }
  deactivate() {
    const t = { capture: !0 };
    document.removeEventListener("pointermove", this._handlePointerMoveEvent, t), document.removeEventListener("pointerup", this._handlePointerUpEvent, t);
  }
  unregister() {
    this.deactivate();
    const t = { capture: !0 };
    if (this._container.value) {
      const n = this._container.value;
      n.removeEventListener("pointerdown", this._handlePointerDownEvent, t), n.removeEventListener("click", this._handleClickEvent, t), n.removeEventListener("pointerenter", this._ignoreEvent, t), n.removeEventListener("pointerleave", this._ignoreEvent, t), document.removeEventListener("keydown", this._handleKeyDownEvent, t);
    }
  }
}
class Hi {
  constructor(t, n, o) {
    this._container = t, this._handleKeyDownEvent = n, this._handleKeyUpEvent = o, this._preventDefault = (i) => {
      i.stopPropagation(), i.preventDefault();
    };
  }
  register() {
    document.addEventListener("keydown", this._handleKeyDownEvent, { capture: !0, passive: !0 });
  }
  activate() {
    document.addEventListener("keyup", this._handleKeyUpEvent, { capture: !0, passive: !0 }), G(this._container.value, "container").addEventListener("contextmenu", this._preventDefault, { passive: !1 });
  }
  deactivate() {
    document.removeEventListener("keyup", this._handleKeyUpEvent, { capture: !0 }), this._container.value && this._container.value.removeEventListener("contextmenu", this._preventDefault);
  }
  unregister() {
    this.deactivate(), document.removeEventListener("keydown", this._handleKeyDownEvent, { capture: !0 });
  }
}
const qn = Symbol("mouseEventHandlers");
function Wi(e, t, n, o, i, s, r, a, c, u, l, h, d, v, x, k) {
  const E = {
    selectionMode: _("container"),
    viewMode: _("default")
  };
  r.size > 0 ? E.selectionMode.value = "node" : a.size > 0 ? E.selectionMode.value = "edge" : c.size > 0 && (E.selectionMode.value = "path"), F(E.viewMode, (y) => {
    k.emit("view:mode", y);
  }), Ai(e, E, v, k);
  const p = se(se(se(se({
    selectedNodes: r,
    hoveredNodes: u,
    selectedEdges: a,
    hoveredEdges: l,
    selectedPaths: c,
    hoveredPaths: h
  }, Li(
    o,
    t,
    E,
    u,
    r,
    n,
    k
  )), $i(i, E, l, a, k)), Zi(
    s,
    E,
    h,
    c,
    d,
    k
  )), ji(
    e,
    E,
    t,
    o,
    r,
    x
  ));
  return Ae(qn, p), p;
}
function nt() {
  return G(Ze(qn), "mouseEventHandlers");
}
function Ui(e) {
  return { all: e = e || /* @__PURE__ */ new Map(), on: function(t, n) {
    var o = e.get(t);
    o ? o.push(n) : e.set(t, [n]);
  }, off: function(t, n) {
    var o = e.get(t);
    o && (n ? o.splice(o.indexOf(n) >>> 0, 1) : e.set(t, []));
  }, emit: function(t, n) {
    var o = e.get(t);
    o && o.slice().map(function(i) {
      i(n);
    }), (o = e.get("*")) && o.slice().map(function(i) {
      i(t, n);
    });
  } };
}
const Gn = Symbol("emitter");
function Fi() {
  const e = Ui();
  return Ae(Gn, e), e;
}
function Xi() {
  return G(Ze(Gn), "event emitter");
}
var dt = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function qi(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var bt = {
  /**
   * Get global this object
   *
   * @return {Object}        global this object
   */
  getGlobalThis: function() {
    if (typeof globalThis != "undefined")
      return globalThis;
    if (typeof self != "undefined")
      return self;
    if (typeof window != "undefined")
      return window;
    if (typeof dt != "undefined")
      return dt;
    if (typeof this != "undefined")
      return this;
    throw new Error("Unable to locate global `this`");
  },
  /**
   * Extends an object
   *
   * @param  {Object} target object to extend
   * @param  {Object} source object to take properties from
   * @return {Object}        extended object
   */
  extend: function(e, t) {
    e = e || {};
    for (var n in t)
      this.isObject(t[n]) ? e[n] = this.extend(e[n], t[n]) : e[n] = t[n];
    return e;
  },
  /**
   * Checks if an object is a DOM element
   *
   * @param  {Object}  o HTML element or String
   * @return {Boolean}   returns true if object is a DOM element
   */
  isElement: function(e) {
    return e instanceof HTMLElement || e instanceof SVGElement || e instanceof SVGSVGElement || //DOM2
    e && typeof e == "object" && e !== null && e.nodeType === 1 && typeof e.nodeName == "string";
  },
  /**
   * Checks if an object is an Object
   *
   * @param  {Object}  o Object
   * @return {Boolean}   returns true if object is an Object
   */
  isObject: function(e) {
    return Object.prototype.toString.call(e) === "[object Object]";
  },
  /**
   * Checks if variable is Number
   *
   * @param  {Integer|Float}  n
   * @return {Boolean}   returns true if variable is Number
   */
  isNumber: function(e) {
    return !isNaN(parseFloat(e)) && isFinite(e);
  },
  /**
   * Search for an SVG element
   *
   * @param  {Object|String} elementOrSelector DOM Element or selector String
   * @return {Object|Null}                   SVG or null
   */
  getSvg: function(e) {
    var t, n;
    if (this.isElement(e))
      t = e;
    else if (typeof e == "string" || e instanceof String) {
      if (t = document.querySelector(e), !t)
        throw new Error(
          "Provided selector did not find any elements. Selector: " + e
        );
    } else
      throw new Error("Provided selector is not an HTML object nor String");
    if (t.tagName.toLowerCase() === "svg")
      n = t;
    else if (t.tagName.toLowerCase() === "object")
      n = t.contentDocument.documentElement;
    else if (t.tagName.toLowerCase() === "embed")
      n = t.getSVGDocument().documentElement;
    else
      throw t.tagName.toLowerCase() === "img" ? new Error(
        'Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.'
      ) : new Error("Cannot get SVG.");
    return n;
  },
  /**
   * Attach a given context to a function
   * @param  {Function} fn      Function
   * @param  {Object}   context Context
   * @return {Function}           Function with certain context
   */
  proxy: function(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  },
  /**
   * Returns object type
   * Uses toString that returns [object SVGPoint]
   * And than parses object type from string
   *
   * @param  {Object} o Any object
   * @return {String}   Object type
   */
  getType: function(e) {
    return Object.prototype.toString.apply(e).replace(/^\[object\s/, "").replace(/\]$/, "");
  },
  /**
   * If it is a touch event than add clientX and clientY to event object
   *
   * @param  {Event} evt
   * @param  {SVGSVGElement} svg
   */
  mouseAndTouchNormalize: function(e, t) {
    if (e.clientX === void 0 || e.clientX === null)
      if (e.clientX = 0, e.clientY = 0, e.touches !== void 0 && e.touches.length) {
        if (e.touches[0].clientX !== void 0)
          e.clientX = e.touches[0].clientX, e.clientY = e.touches[0].clientY;
        else if (e.touches[0].pageX !== void 0) {
          var n = t.getBoundingClientRect();
          e.clientX = e.touches[0].pageX - n.left, e.clientY = e.touches[0].pageY - n.top;
        }
      } else
        e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY);
  },
  /**
   * If it is a touch event than add clientX and clientY to event object
   *
   * @param  {Event} evt
   * @param  {SVGSVGElement} svg
   * @param  {Number} touch
   */
  touchNormalize: function(e, t, n) {
    if (e.touches !== void 0 && e.touches.length) {
      if (e.touches[n].clientX !== void 0)
        e.clientX = e.touches[n].clientX, e.clientY = e.touches[n].clientY;
      else if (e.touches[n].pageX !== void 0) {
        var o = t.getBoundingClientRect();
        e.clientX = e.touches[n].pageX - o.left, e.clientY = e.touches[n].pageY - o.top;
      }
    } else
      (e.clientX === void 0 || e.clientX === null) && (e.clientX = 0, e.clientY = 0, e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY));
  },
  /**
   * Check if an event is a double click/tap
   * TODO: For touch gestures use a library (hammer.js) that takes in account other events
   * (touchmove and touchend). It should take in account tap duration and traveled distance
   *
   * @param  {Event}  evt
   * @param  {Event}  prevEvt Previous Event
   * @return {Boolean}
   */
  isDblClick: function(e, t) {
    if (e.detail === 2)
      return !0;
    if (t != null) {
      var n = e.timeStamp - t.timeStamp, o = Math.sqrt(
        Math.pow(e.clientX - t.clientX, 2) + Math.pow(e.clientY - t.clientY, 2)
      );
      return n < 250 && o < 10;
    }
    return !1;
  },
  /**
   * Returns current timestamp as an integer
   *
   * @return {Number}
   */
  now: Date.now || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  },
  // From underscore.
  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  throttle: function(e, t, n) {
    var o = this, i, s, r, a = null, c = 0;
    n || (n = {});
    var u = function() {
      c = n.leading === !1 ? 0 : o.now(), a = null, r = e.apply(i, s), a || (i = s = null);
    };
    return function() {
      var l = o.now();
      !c && n.leading === !1 && (c = l);
      var h = t - (l - c);
      return i = this, s = arguments, h <= 0 || h > t ? (clearTimeout(a), a = null, c = l, r = e.apply(i, s), a || (i = s = null)) : !a && n.trailing !== !1 && (a = setTimeout(u, h)), r;
    };
  },
  /**
   * Create a requestAnimationFrame simulation
   *
   * @param  {Number|String} refreshRate
   * @return {Function}
   */
  createRequestAnimationFrame: function(e) {
    var t = null;
    return e !== "auto" && e < 60 && e > 1 && (t = Math.floor(1e3 / e)), t === null ? window.requestAnimationFrame || En(33) : En(t);
  },
  /**
   * Calculate distance of points
   *
   * @param  {SVGPoint} point1
   * @param  {SVGPoint} point2
   * @return {Number}
   */
  calculateDistance: function(e, t) {
    var n = e.x - t.x, o = e.y - t.y;
    return Math.sqrt(n * n + o * o);
  }
};
function En(e) {
  return function(t) {
    window.setTimeout(t, e);
  };
}
var Gi = bt, Ki = function() {
  var e = "", t, n, o, i = [], s = { passive: !0 }, r = { passive: !1 };
  Gi.getGlobalThis().addEventListener ? (t = "addEventListener", n = "removeEventListener") : (t = "attachEvent", n = "detachEvent", e = "on");
  function a() {
    return o || (o = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll"), o;
  }
  function c(k, E) {
    var p = function(y) {
      !y && (y = window.event);
      var w = {
        // keep a ref to the original event object
        originalEvent: y,
        target: y.target || y.srcElement,
        type: "wheel",
        deltaMode: y.type == "MozMousePixelScroll" ? 0 : 1,
        deltaX: 0,
        delatZ: 0,
        preventDefault: function() {
          y.preventDefault ? y.preventDefault() : y.returnValue = !1;
        }
      };
      return a() == "mousewheel" ? (w.deltaY = -0.025 * y.wheelDelta, y.wheelDeltaX && (w.deltaX = -0.025 * y.wheelDeltaX)) : w.deltaY = y.detail, E(w);
    };
    return i.push({
      element: k,
      fn: p
    }), p;
  }
  function u(k) {
    for (var E = 0; E < i.length; E++)
      if (i[E].element === k)
        return i[E].fn;
    return function() {
    };
  }
  function l(k) {
    for (var E = 0; E < i.length; E++)
      if (i[E].element === k)
        return i.splice(E, 1);
  }
  function h(k, E, p, y) {
    var w;
    a() === "wheel" ? w = p : w = c(k, p), k[t](
      e + E,
      w,
      y ? s : r
    );
  }
  function d(k, E, p, y) {
    var w;
    a() === "wheel" ? w = p : w = u(k), k[n](
      e + E,
      w,
      y ? s : r
    ), l(k);
  }
  function v(k, E, p) {
    h(k, a(), E, p), a() == "DOMMouseScroll" && h(
      k,
      "MozMousePixelScroll",
      E,
      p
    );
  }
  function x(k, E, p) {
    d(k, a(), E, p), a() == "DOMMouseScroll" && d(
      k,
      "MozMousePixelScroll",
      E,
      p
    );
  }
  return {
    on: v,
    off: x
  };
}(), rt = bt, Kn = "unknown";
/*@cc_on!@*/
typeof document != "undefined" && document.documentMode && (Kn = "ie");
var Kt = {
  svgNS: "http://www.w3.org/2000/svg",
  xmlNS: "http://www.w3.org/XML/1998/namespace",
  xmlnsNS: "http://www.w3.org/2000/xmlns/",
  xlinkNS: "http://www.w3.org/1999/xlink",
  evNS: "http://www.w3.org/2001/xml-events",
  /**
   * Get svg dimensions: width and height
   *
   * @param  {SVGSVGElement} svg
   * @return {Object}     {width: 0, height: 0}
   */
  getBoundingClientRectNormalized: function(e) {
    if (e.clientWidth && e.clientHeight)
      return { width: e.clientWidth, height: e.clientHeight };
    if (e.getBoundingClientRect())
      return e.getBoundingClientRect();
    throw new Error("Cannot get BoundingClientRect for SVG.");
  },
  /**
   * Gets g element with class of "viewport" or creates it if it doesn't exist
   *
   * @param  {SVGSVGElement} svg
   * @return {SVGElement}     g (group) element
   */
  getOrCreateViewport: function(e, t) {
    var n = null;
    if (rt.isElement(t) ? n = t : n = e.querySelector(t), !n) {
      var o = Array.prototype.slice.call(e.childNodes || e.children).filter(function(c) {
        return c.nodeName !== "defs" && c.nodeName !== "#text";
      });
      o.length === 1 && o[0].nodeName === "g" && o[0].getAttribute("transform") === null && (n = o[0]);
    }
    if (!n) {
      var i = "viewport-" + (/* @__PURE__ */ new Date()).toISOString().replace(/\D/g, "");
      n = document.createElementNS(this.svgNS, "g"), n.setAttribute("id", i);
      var s = e.childNodes || e.children;
      if (s && s.length > 0)
        for (var r = s.length; r > 0; r--)
          s[s.length - r].nodeName !== "defs" && n.appendChild(s[s.length - r]);
      e.appendChild(n);
    }
    var a = [];
    return n.getAttribute("class") && (a = n.getAttribute("class").split(" ")), ~a.indexOf("svg-pan-zoom_viewport") || (a.push("svg-pan-zoom_viewport"), n.setAttribute("class", a.join(" "))), n;
  },
  /**
   * Set SVG attributes
   *
   * @param  {SVGSVGElement} svg
   */
  setupSvgAttributes: function(e) {
    if (e.setAttribute("xmlns", this.svgNS), e.setAttributeNS(this.xmlnsNS, "xmlns:xlink", this.xlinkNS), e.setAttributeNS(this.xmlnsNS, "xmlns:ev", this.evNS), e.parentNode !== null) {
      var t = e.getAttribute("style") || "";
      t.toLowerCase().indexOf("overflow") === -1 && e.setAttribute("style", "overflow: hidden; " + t);
    }
  },
  /**
   * How long Internet Explorer takes to finish updating its display (ms).
   */
  internetExplorerRedisplayInterval: 300,
  /**
   * Forces the browser to redisplay all SVG elements that rely on an
   * element defined in a 'defs' section. It works globally, for every
   * available defs element on the page.
   * The throttling is intentionally global.
   *
   * This is only needed for IE. It is as a hack to make markers (and 'use' elements?)
   * visible after pan/zoom when there are multiple SVGs on the page.
   * See bug report: https://connect.microsoft.com/IE/feedback/details/781964/
   * also see svg-pan-zoom issue: https://github.com/ariutta/svg-pan-zoom/issues/62
   */
  refreshDefsGlobal: rt.throttle(
    function() {
      for (var e = document.querySelectorAll("defs"), t = e.length, n = 0; n < t; n++) {
        var o = e[n];
        o.parentNode.insertBefore(o, o);
      }
    },
    dt ? dt.internetExplorerRedisplayInterval : null
  ),
  /**
   * Sets the current transform matrix of an element
   *
   * @param {SVGElement} element
   * @param {SVGMatrix} matrix  CTM
   * @param {SVGElement} defs
   */
  setCTM: function(e, t, n) {
    var o = this, i = "matrix(" + t.a + "," + t.b + "," + t.c + "," + t.d + "," + t.e + "," + t.f + ")";
    e.setAttributeNS(null, "transform", i), "transform" in e.style ? e.style.transform = i : "-ms-transform" in e.style ? e.style["-ms-transform"] = i : "-webkit-transform" in e.style && (e.style["-webkit-transform"] = i), Kn === "ie" && n && (n.parentNode.insertBefore(n, n), window.setTimeout(function() {
      o.refreshDefsGlobal();
    }, o.internetExplorerRedisplayInterval));
  },
  /**
   * Instantiate an SVGPoint object with given event coordinates
   *
   * @param {Event} evt
   * @param  {SVGSVGElement} svg
   * @return {SVGPoint}     point
   */
  getEventPoint: function(e, t) {
    var n = t.createSVGPoint();
    return rt.mouseAndTouchNormalize(e, t), n.x = e.clientX, n.y = e.clientY, n;
  },
  /**
   * Instantiate an SVGPoint object with given touch event coordinates
   *
   * @param {Event} evt
   * @param  {SVGSVGElement} svg
   * @param  {Number} touch
   * @return {SVGPoint}     point
   */
  getTouchPoint: function(e, t, n) {
    var o = t.createSVGPoint();
    return rt.touchNormalize(e, t, n), o.x = e.clientX, o.y = e.clientY, o;
  },
  /**
   * Get SVG center point
   *
   * @param  {SVGSVGElement} svg
   * @return {SVGPoint}
   */
  getSvgCenterPoint: function(e, t, n) {
    return this.createSVGPoint(e, t / 2, n / 2);
  },
  /**
   * Create a SVGPoint with given x and y
   *
   * @param  {SVGSVGElement} svg
   * @param  {Number} x
   * @param  {Number} y
   * @return {SVGPoint}
   */
  createSVGPoint: function(e, t, n) {
    var o = e.createSVGPoint();
    return o.x = t, o.y = n, o;
  }
}, pe = Kt, Yi = {
  enable: function(e) {
    var t = e.svg.querySelector("defs");
    t || (t = document.createElementNS(pe.svgNS, "defs"), e.svg.appendChild(t));
    var n = t.querySelector("style#svg-pan-zoom-controls-styles");
    if (!n) {
      var o = document.createElementNS(pe.svgNS, "style");
      o.setAttribute("id", "svg-pan-zoom-controls-styles"), o.setAttribute("type", "text/css"), o.textContent = ".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }", t.appendChild(o);
    }
    var i = document.createElementNS(pe.svgNS, "g");
    i.setAttribute("id", "svg-pan-zoom-controls"), i.setAttribute(
      "transform",
      "translate(" + (e.width - 70) + " " + (e.height - 76) + ") scale(0.75)"
    ), i.setAttribute("class", "svg-pan-zoom-control"), i.appendChild(this._createZoomIn(e)), i.appendChild(this._createZoomReset(e)), i.appendChild(this._createZoomOut(e)), e.svg.appendChild(i), e.controlIcons = i;
  },
  _createZoomIn: function(e) {
    var t = document.createElementNS(pe.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-zoom-in"), t.setAttribute("transform", "translate(30.5 5) scale(0.015)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().zoomIn();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().zoomIn();
      },
      !1
    );
    var n = document.createElementNS(pe.svgNS, "rect");
    n.setAttribute("x", "0"), n.setAttribute("y", "0"), n.setAttribute("width", "1500"), n.setAttribute("height", "1400"), n.setAttribute("class", "svg-pan-zoom-control-background"), t.appendChild(n);
    var o = document.createElementNS(pe.svgNS, "path");
    return o.setAttribute(
      "d",
      "M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z"
    ), o.setAttribute("class", "svg-pan-zoom-control-element"), t.appendChild(o), t;
  },
  _createZoomReset: function(e) {
    var t = document.createElementNS(pe.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-reset-pan-zoom"), t.setAttribute("transform", "translate(5 35) scale(0.4)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().reset();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().reset();
      },
      !1
    );
    var n = document.createElementNS(
      pe.svgNS,
      "rect"
    );
    n.setAttribute("x", "2"), n.setAttribute("y", "2"), n.setAttribute("width", "182"), n.setAttribute("height", "58"), n.setAttribute(
      "class",
      "svg-pan-zoom-control-background"
    ), t.appendChild(n);
    var o = document.createElementNS(
      pe.svgNS,
      "path"
    );
    o.setAttribute(
      "d",
      "M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z"
    ), o.setAttribute(
      "class",
      "svg-pan-zoom-control-element"
    ), t.appendChild(o);
    var i = document.createElementNS(
      pe.svgNS,
      "path"
    );
    return i.setAttribute(
      "d",
      "M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z"
    ), i.setAttribute(
      "class",
      "svg-pan-zoom-control-element"
    ), t.appendChild(i), t;
  },
  _createZoomOut: function(e) {
    var t = document.createElementNS(pe.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-zoom-out"), t.setAttribute("transform", "translate(30.5 70) scale(0.015)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().zoomOut();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().zoomOut();
      },
      !1
    );
    var n = document.createElementNS(pe.svgNS, "rect");
    n.setAttribute("x", "0"), n.setAttribute("y", "0"), n.setAttribute("width", "1500"), n.setAttribute("height", "1400"), n.setAttribute("class", "svg-pan-zoom-control-background"), t.appendChild(n);
    var o = document.createElementNS(pe.svgNS, "path");
    return o.setAttribute(
      "d",
      "M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z"
    ), o.setAttribute("class", "svg-pan-zoom-control-element"), t.appendChild(o), t;
  },
  disable: function(e) {
    e.controlIcons && (e.controlIcons.parentNode.removeChild(e.controlIcons), e.controlIcons = null);
  }
}, Qi = Kt, $e = bt, ne = function(e, t) {
  this.init(e, t);
};
ne.prototype.init = function(e, t) {
  this.viewport = e, this.options = t, this.originalState = { zoom: 1, x: 0, y: 0 }, this.activeState = { zoom: 1, x: 0, y: 0 }, this.updateCTMCached = $e.proxy(this.updateCTM, this), this.requestAnimationFrame = $e.createRequestAnimationFrame(
    this.options.refreshRate
  ), this.viewBox = { x: 0, y: 0, width: 0, height: 0 }, this.cacheViewBox();
  var n = this.processCTM();
  this.setCTM(n), this.updateCTM();
};
ne.prototype.cacheViewBox = function() {
  var e = this.options.svg.getAttribute("viewBox");
  if (e) {
    var t = e.split(/[\s\,]/).filter(function(o) {
      return o;
    }).map(parseFloat);
    this.viewBox.x = t[0], this.viewBox.y = t[1], this.viewBox.width = t[2], this.viewBox.height = t[3];
    var n = Math.min(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    );
    this.activeState.zoom = isFinite(n) ? n : 1, this.activeState.x = (this.options.width - this.viewBox.width * n) / 2, this.activeState.y = (this.options.height - this.viewBox.height * n) / 2, this.updateCTMOnNextFrame(), this.options.svg.removeAttribute("viewBox");
  } else
    this.simpleViewBoxCache();
};
ne.prototype.simpleViewBoxCache = function() {
  var e = this.viewport.getBBox();
  this.viewBox.x = e.x, this.viewBox.y = e.y, this.viewBox.width = e.width, this.viewBox.height = e.height;
};
ne.prototype.getViewBox = function() {
  return $e.extend({}, this.viewBox);
};
ne.prototype.processCTM = function() {
  var e = this.getCTM();
  if (this.options.fit || this.options.contain) {
    var t;
    this.options.fit ? t = Math.min(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    ) : t = Math.max(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    ), t = isFinite(t) ? t : 1, e.a = t, e.d = t, e.e = -this.viewBox.x * t, e.f = -this.viewBox.y * t;
  }
  if (this.options.center) {
    var n = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * e.a) * 0.5, o = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * e.a) * 0.5;
    e.e = n, e.f = o;
  }
  return this.originalState.zoom = e.a, this.originalState.x = e.e, this.originalState.y = e.f, e;
};
ne.prototype.getOriginalState = function() {
  return $e.extend({}, this.originalState);
};
ne.prototype.getState = function() {
  return $e.extend({}, this.activeState);
};
ne.prototype.getZoom = function() {
  return this.activeState.zoom;
};
ne.prototype.getRelativeZoom = function() {
  return this.activeState.zoom / this.originalState.zoom;
};
ne.prototype.computeRelativeZoom = function(e) {
  return e / this.originalState.zoom;
};
ne.prototype.getPan = function() {
  return { x: this.activeState.x, y: this.activeState.y };
};
ne.prototype.getCTM = function() {
  var e = this.options.svg.createSVGMatrix();
  return e.a = this.activeState.zoom, e.b = 0, e.c = 0, e.d = this.activeState.zoom, e.e = this.activeState.x, e.f = this.activeState.y, e;
};
ne.prototype.setCTM = function(e) {
  var t = this.isZoomDifferent(e), n = this.isPanDifferent(e);
  if (t || n) {
    if (t && (this.options.beforeZoom(
      this.getRelativeZoom(),
      this.computeRelativeZoom(e.a)
    ) === !1 ? (e.a = e.d = this.activeState.zoom, t = !1) : (this.updateCache(e), this.options.onZoom(this.getRelativeZoom()))), n) {
      var o = this.options.beforePan(this.getPan(), {
        x: e.e,
        y: e.f
      }), i = !1, s = !1;
      o === !1 ? (e.e = this.getPan().x, e.f = this.getPan().y, i = s = !0) : $e.isObject(o) && (o.x === !1 ? (e.e = this.getPan().x, i = !0) : $e.isNumber(o.x) && (e.e = o.x), o.y === !1 ? (e.f = this.getPan().y, s = !0) : $e.isNumber(o.y) && (e.f = o.y)), i && s || !this.isPanDifferent(e) ? n = !1 : (this.updateCache(e), this.options.onPan(this.getPan()));
    }
    (t || n) && this.updateCTMOnNextFrame();
  }
};
ne.prototype.isZoomDifferent = function(e) {
  return this.activeState.zoom !== e.a;
};
ne.prototype.isPanDifferent = function(e) {
  return this.activeState.x !== e.e || this.activeState.y !== e.f;
};
ne.prototype.updateCache = function(e) {
  this.activeState.zoom = e.a, this.activeState.x = e.e, this.activeState.y = e.f;
};
ne.prototype.pendingUpdate = !1;
ne.prototype.updateCTMOnNextFrame = function() {
  this.pendingUpdate || (this.pendingUpdate = !0, this.requestAnimationFrame.call(window, this.updateCTMCached));
};
ne.prototype.updateCTM = function() {
  var e = this.getCTM();
  Qi.setCTM(this.viewport, e, this.defs), this.pendingUpdate = !1, this.options.onUpdatedCTM && this.options.onUpdatedCTM(e);
};
var Ji = function(e, t) {
  return new ne(e, t);
}, Yn = Ki, Zt = Yi, fe = bt, re = Kt, es = Ji, X = function(e, t) {
  this.init(e, t);
}, ts = {
  viewportSelector: ".svg-pan-zoom_viewport",
  // Viewport selector. Can be querySelector string or SVGElement
  panEnabled: !0,
  // enable or disable panning (default enabled)
  controlIconsEnabled: !1,
  // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)
  zoomEnabled: !0,
  // enable or disable zooming (default enabled)
  dblClickZoomEnabled: !0,
  // enable or disable zooming by double clicking (default enabled)
  mouseWheelZoomEnabled: !0,
  // enable or disable zooming by mouse wheel (default enabled)
  preventMouseEventsDefault: !0,
  // enable or disable preventDefault for mouse events
  zoomScaleSensitivity: 0.1,
  // Zoom sensitivity
  minZoom: 0.5,
  // Minimum Zoom level
  maxZoom: 10,
  // Maximum Zoom level
  fit: !0,
  // enable or disable viewport fit in SVG (default true)
  contain: !1,
  // enable or disable viewport contain the svg (default false)
  center: !0,
  // enable or disable viewport centering in SVG (default true)
  refreshRate: "auto",
  // Maximum number of frames per second (altering SVG's viewport)
  beforeZoom: null,
  onZoom: null,
  beforePan: null,
  onPan: null,
  customEventsHandler: null,
  eventsListenerElement: null,
  onUpdatedCTM: null
}, Qn = { passive: !0 }, Jn = { passive: !1 };
X.prototype.init = function(e, t) {
  var n = this;
  this.svg = e, this.defs = e.querySelector("defs"), re.setupSvgAttributes(this.svg), this.options = fe.extend(fe.extend({}, ts), t), this.state = "none";
  var o = re.getBoundingClientRectNormalized(e);
  this.width = o.width, this.height = o.height, this.viewport = es(
    re.getOrCreateViewport(this.svg, this.options.viewportSelector),
    {
      svg: this.svg,
      width: this.width,
      height: this.height,
      fit: this.options.fit,
      contain: this.options.contain,
      center: this.options.center,
      refreshRate: this.options.refreshRate,
      // Put callbacks into functions as they can change through time
      beforeZoom: function(s, r) {
        if (n.viewport && n.options.beforeZoom)
          return n.options.beforeZoom(s, r);
      },
      onZoom: function(s) {
        if (n.viewport && n.options.onZoom)
          return n.options.onZoom(s);
      },
      beforePan: function(s, r) {
        if (n.viewport && n.options.beforePan)
          return n.options.beforePan(s, r);
      },
      onPan: function(s) {
        if (n.viewport && n.options.onPan)
          return n.options.onPan(s);
      },
      onUpdatedCTM: function(s) {
        if (n.viewport && n.options.onUpdatedCTM)
          return n.options.onUpdatedCTM(s);
      }
    }
  );
  var i = this.getPublicInstance();
  i.setBeforeZoom(this.options.beforeZoom), i.setOnZoom(this.options.onZoom), i.setBeforePan(this.options.beforePan), i.setOnPan(this.options.onPan), i.setOnUpdatedCTM(this.options.onUpdatedCTM), this.options.controlIconsEnabled && Zt.enable(this), this.lastMouseWheelEventTime = Date.now(), this.setupHandlers();
};
X.prototype.setupHandlers = function() {
  var e = this, t = null;
  if (this.eventListeners = {
    // Mouse down group
    pointerdown: function(s) {
      if (s.pointerType !== "touch") {
        var r = e.handleMouseDown(s, t);
        return t = s, r;
      }
    },
    touchstart: function(s) {
      var r = e.handleTouchStart(s, t);
      return t = s, r;
    },
    // Mouse up group
    pointerup: function(s) {
      if (s.pointerType !== "touch")
        return e.handleMouseUp(s);
    },
    touchend: function(s) {
      return e.handleTouchEnd(s);
    },
    // Mouse move group
    pointermove: function(s) {
      if (s.pointerType !== "touch")
        return e.handleMouseMove(s);
    },
    touchmove: function(s) {
      return e.handleTouchMove(s);
    },
    // Mouse leave group
    pointerleave: function(s) {
      if (s.pointerType !== "touch")
        return e.handleMouseUp(s);
    },
    pointercancel: function(s) {
      if (s.pointerType !== "touch")
        return e.handleMouseUp(s);
    },
    touchleave: function(s) {
      return e.handleTouchEnd(s);
    },
    touchcancel: function(s) {
      return e.handleTouchEnd(s);
    }
  }, this.options.customEventsHandler != null) {
    this.options.customEventsHandler.init({
      svgElement: this.svg,
      eventsListenerElement: this.options.eventsListenerElement,
      instance: this.getPublicInstance()
    });
    var n = this.options.customEventsHandler.haltEventListeners;
    if (n && n.length)
      for (var o = n.length - 1; o >= 0; o--)
        this.eventListeners.hasOwnProperty(n[o]) && delete this.eventListeners[n[o]];
  }
  for (var i in this.eventListeners)
    (this.options.eventsListenerElement || this.svg).addEventListener(
      i,
      this.eventListeners[i],
      this.options.preventMouseEventsDefault ? Jn : Qn
    );
  this.options.mouseWheelZoomEnabled && (this.options.mouseWheelZoomEnabled = !1, this.enableMouseWheelZoom());
};
X.prototype.enableMouseWheelZoom = function() {
  if (!this.options.mouseWheelZoomEnabled) {
    var e = this;
    this.wheelListener = function(n) {
      return e.handleMouseWheel(n);
    };
    var t = !this.options.preventMouseEventsDefault;
    Yn.on(
      this.options.eventsListenerElement || this.svg,
      this.wheelListener,
      t
    ), this.options.mouseWheelZoomEnabled = !0;
  }
};
X.prototype.disableMouseWheelZoom = function() {
  if (this.options.mouseWheelZoomEnabled) {
    var e = !this.options.preventMouseEventsDefault;
    Yn.off(
      this.options.eventsListenerElement || this.svg,
      this.wheelListener,
      e
    ), this.options.mouseWheelZoomEnabled = !1;
  }
};
X.prototype.handleMouseWheel = function(e) {
  if (!(!this.options.zoomEnabled || this.state !== "none")) {
    this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1);
    var t = e.deltaY || 1, n = Date.now() - this.lastMouseWheelEventTime, o = 3 + Math.max(0, 30 - n);
    this.lastMouseWheelEventTime = Date.now(), "deltaMode" in e && e.deltaMode === 0 && e.wheelDelta && (t = e.deltaY === 0 ? 0 : Math.abs(e.wheelDelta) / e.deltaY), t = -0.3 < t && t < 0.3 ? t : (t > 0 ? 1 : -1) * Math.log(Math.abs(t) + 10) / o;
    var i = this.svg.getScreenCTM().inverse(), s = re.getEventPoint(e, this.svg).matrixTransform(
      i
    ), r = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * t);
    this.zoomAtPoint(r, s);
  }
};
X.prototype.zoomAtPoint = function(e, t, n) {
  var o = this.viewport.getOriginalState();
  n ? (e = Math.max(
    this.options.minZoom * o.zoom,
    Math.min(this.options.maxZoom * o.zoom, e)
  ), e = e / this.getZoom()) : this.getZoom() * e < this.options.minZoom * o.zoom ? e = this.options.minZoom * o.zoom / this.getZoom() : this.getZoom() * e > this.options.maxZoom * o.zoom && (e = this.options.maxZoom * o.zoom / this.getZoom());
  var i = this.viewport.getCTM(), s = t.matrixTransform(i.inverse()), r = this.svg.createSVGMatrix().translate(s.x, s.y).scale(e).translate(-s.x, -s.y), a = i.multiply(r);
  a.a !== i.a && this.viewport.setCTM(a);
};
X.prototype.zoom = function(e, t) {
  this.zoomAtPoint(
    e,
    re.getSvgCenterPoint(this.svg, this.width, this.height),
    t
  );
};
X.prototype.publicZoom = function(e, t) {
  t && (e = this.computeFromRelativeZoom(e)), this.zoom(e, t);
};
X.prototype.publicZoomAtPoint = function(e, t, n) {
  if (n && (e = this.computeFromRelativeZoom(e)), fe.getType(t) !== "SVGPoint")
    if ("x" in t && "y" in t)
      t = re.createSVGPoint(this.svg, t.x, t.y);
    else
      throw new Error("Given point is invalid");
  this.zoomAtPoint(e, t, n);
};
X.prototype.getZoom = function() {
  return this.viewport.getZoom();
};
X.prototype.getRelativeZoom = function() {
  return this.viewport.getRelativeZoom();
};
X.prototype.computeFromRelativeZoom = function(e) {
  return e * this.viewport.getOriginalState().zoom;
};
X.prototype.resetZoom = function() {
  var e = this.viewport.getOriginalState();
  this.zoom(e.zoom, !0);
};
X.prototype.resetPan = function() {
  this.pan(this.viewport.getOriginalState());
};
X.prototype.reset = function() {
  this.resetZoom(), this.resetPan();
};
X.prototype.handleDblClick = function(e) {
  if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.options.controlIconsEnabled) {
    var t = e.target.getAttribute("class") || "";
    if (t.indexOf("svg-pan-zoom-control") > -1)
      return !1;
  }
  var n;
  e.shiftKey ? n = 1 / ((1 + this.options.zoomScaleSensitivity) * 2) : n = (1 + this.options.zoomScaleSensitivity) * 2;
  var o = re.getEventPoint(e, this.svg).matrixTransform(
    this.svg.getScreenCTM().inverse()
  );
  this.zoomAtPoint(n, o);
};
X.prototype.handleMouseDown = function(e, t) {
  this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), fe.mouseAndTouchNormalize(e, this.svg), this.options.dblClickZoomEnabled && fe.isDblClick(e, t) ? this.handleDblClick(e) : (this.state = "pan", this.firstEventCTM = this.viewport.getCTM(), this.stateOrigin = re.getEventPoint(e, this.svg).matrixTransform(
    this.firstEventCTM.inverse()
  ));
};
X.prototype.handleMouseMove = function(e) {
  if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.state === "pan" && this.options.panEnabled) {
    var t = re.getEventPoint(e, this.svg).matrixTransform(
      this.firstEventCTM.inverse()
    ), n = this.firstEventCTM.translate(
      t.x - this.stateOrigin.x,
      t.y - this.stateOrigin.y
    );
    this.viewport.setCTM(n);
  }
};
X.prototype.handleMouseUp = function(e) {
  this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.state === "pan" && (this.state = "none");
};
X.prototype.handleTouchStart = function(e, t) {
  if (e.touches.length == 1)
    this.handleMouseDown(e, t);
  else {
    this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.firstEventCTM = this.viewport.getCTM();
    var n = re.getTouchPoint(e, this.svg, 0), o = re.getTouchPoint(e, this.svg, 1);
    this.firstDistance = fe.calculateDistance(n, o), n.x = (n.x + o.x) / 2, n.y = (n.y + o.y) / 2, this.stateOrigin = n.matrixTransform(this.firstEventCTM.inverse()), this.firstZoomLevel = this.getZoom();
  }
};
X.prototype.handleTouchMove = function(e) {
  if (e.touches.length == 1)
    this.handleMouseMove(e);
  else {
    if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), !this.options.panEnabled && !this.options.zoomEnabled)
      return;
    var t = re.getTouchPoint(e, this.svg, 0), n = re.getTouchPoint(e, this.svg, 1), o = this.svg.createSVGPoint();
    if (o.x = (t.x + n.x) / 2, o.y = (t.y + n.y) / 2, this.state === "pan" && this.options.panEnabled) {
      var i = o.matrixTransform(this.firstEventCTM.inverse()), s = this.firstEventCTM.translate(
        i.x - this.stateOrigin.x,
        i.y - this.stateOrigin.y
      );
      this.viewport.setCTM(s);
    }
    if (this.options.zoomEnabled) {
      var r = fe.calculateDistance(t, n), a = r / this.firstDistance, c = this.svg.getScreenCTM().inverse(), u = o.matrixTransform(c);
      this.zoomAtPoint(this.firstZoomLevel * a, u, !0);
    }
  }
};
X.prototype.handleTouchEnd = function(e) {
  if (e.touches.length == 0)
    this.handleMouseUp(e);
  else if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.firstEventCTM = this.viewport.getCTM(), e.touches.length == 1)
    this.stateOrigin = re.getEventPoint(e, this.svg).matrixTransform(
      this.firstEventCTM.inverse()
    );
  else {
    var t = re.getTouchPoint(e, this.svg, 0), n = re.getTouchPoint(e, this.svg, 1);
    this.firstDistance = fe.calculateDistance(t, n), t.x = (t.x + n.x) / 2, t.y = (t.y + n.y) / 2, this.stateOrigin = t.matrixTransform(this.firstEventCTM.inverse());
  }
};
X.prototype.fit = function() {
  var e = this.viewport.getViewBox(), t = Math.min(
    this.width / e.width,
    this.height / e.height
  );
  this.zoom(t, !0);
};
X.prototype.contain = function() {
  var e = this.viewport.getViewBox(), t = Math.max(
    this.width / e.width,
    this.height / e.height
  );
  this.zoom(t, !0);
};
X.prototype.center = function() {
  var e = this.viewport.getViewBox(), t = (this.width - (e.width + e.x * 2) * this.getZoom()) * 0.5, n = (this.height - (e.height + e.y * 2) * this.getZoom()) * 0.5;
  this.getPublicInstance().pan({ x: t, y: n });
};
X.prototype.updateBBox = function() {
  this.viewport.simpleViewBoxCache();
};
X.prototype.pan = function(e) {
  var t = this.viewport.getCTM();
  t.e = e.x, t.f = e.y, this.viewport.setCTM(t);
};
X.prototype.panBy = function(e) {
  var t = this.viewport.getCTM();
  t.e += e.x, t.f += e.y, this.viewport.setCTM(t);
};
X.prototype.getPan = function() {
  var e = this.viewport.getState();
  return { x: e.x, y: e.y };
};
X.prototype.resize = function() {
  var e = re.getBoundingClientRectNormalized(
    this.svg
  );
  this.width = e.width, this.height = e.height;
  var t = this.viewport;
  t.options.width = this.width, t.options.height = this.height, t.processCTM(), this.options.controlIconsEnabled && (this.getPublicInstance().disableControlIcons(), this.getPublicInstance().enableControlIcons());
};
X.prototype.destroy = function() {
  var e = this;
  this.beforeZoom = null, this.onZoom = null, this.beforePan = null, this.onPan = null, this.onUpdatedCTM = null, this.options.customEventsHandler != null && this.options.customEventsHandler.destroy({
    svgElement: this.svg,
    eventsListenerElement: this.options.eventsListenerElement,
    instance: this.getPublicInstance()
  });
  for (var t in this.eventListeners)
    (this.options.eventsListenerElement || this.svg).removeEventListener(
      t,
      this.eventListeners[t],
      this.options.preventMouseEventsDefault ? Jn : Qn
    );
  this.disableMouseWheelZoom(), this.getPublicInstance().disableControlIcons(), Te = Te.filter(function(n) {
    return n.svg !== e.svg;
  }), delete this.options, delete this.viewport, delete this.publicInstance, delete this.pi, this.getPublicInstance = function() {
    return null;
  };
};
X.prototype.getPublicInstance = function() {
  var e = this;
  return this.publicInstance || (this.publicInstance = this.pi = {
    // Pan
    enablePan: function() {
      return e.options.panEnabled = !0, e.pi;
    },
    disablePan: function() {
      return e.options.panEnabled = !1, e.pi;
    },
    isPanEnabled: function() {
      return !!e.options.panEnabled;
    },
    pan: function(t) {
      return e.pan(t), e.pi;
    },
    panBy: function(t) {
      return e.panBy(t), e.pi;
    },
    getPan: function() {
      return e.getPan();
    },
    // Pan event
    setBeforePan: function(t) {
      return e.options.beforePan = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;
    },
    setOnPan: function(t) {
      return e.options.onPan = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;
    },
    // Zoom and Control Icons
    enableZoom: function() {
      return e.options.zoomEnabled = !0, e.pi;
    },
    disableZoom: function() {
      return e.options.zoomEnabled = !1, e.pi;
    },
    isZoomEnabled: function() {
      return !!e.options.zoomEnabled;
    },
    enableControlIcons: function() {
      return e.options.controlIconsEnabled || (e.options.controlIconsEnabled = !0, Zt.enable(e)), e.pi;
    },
    disableControlIcons: function() {
      return e.options.controlIconsEnabled && (e.options.controlIconsEnabled = !1, Zt.disable(e)), e.pi;
    },
    isControlIconsEnabled: function() {
      return !!e.options.controlIconsEnabled;
    },
    // Double click zoom
    enableDblClickZoom: function() {
      return e.options.dblClickZoomEnabled = !0, e.pi;
    },
    disableDblClickZoom: function() {
      return e.options.dblClickZoomEnabled = !1, e.pi;
    },
    isDblClickZoomEnabled: function() {
      return !!e.options.dblClickZoomEnabled;
    },
    // Mouse wheel zoom
    enableMouseWheelZoom: function() {
      return e.enableMouseWheelZoom(), e.pi;
    },
    disableMouseWheelZoom: function() {
      return e.disableMouseWheelZoom(), e.pi;
    },
    isMouseWheelZoomEnabled: function() {
      return !!e.options.mouseWheelZoomEnabled;
    },
    // Zoom scale and bounds
    setZoomScaleSensitivity: function(t) {
      return e.options.zoomScaleSensitivity = t, e.pi;
    },
    setMinZoom: function(t) {
      return e.options.minZoom = t, e.pi;
    },
    setMaxZoom: function(t) {
      return e.options.maxZoom = t, e.pi;
    },
    // Zoom event
    setBeforeZoom: function(t) {
      return e.options.beforeZoom = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;
    },
    setOnZoom: function(t) {
      return e.options.onZoom = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;
    },
    // Zooming
    zoom: function(t) {
      return e.publicZoom(t, !0), e.pi;
    },
    zoomBy: function(t) {
      return e.publicZoom(t, !1), e.pi;
    },
    zoomAtPoint: function(t, n) {
      return e.publicZoomAtPoint(t, n, !0), e.pi;
    },
    zoomAtPointBy: function(t, n) {
      return e.publicZoomAtPoint(t, n, !1), e.pi;
    },
    zoomIn: function() {
      return this.zoomBy(1 + e.options.zoomScaleSensitivity), e.pi;
    },
    zoomOut: function() {
      return this.zoomBy(1 / (1 + e.options.zoomScaleSensitivity)), e.pi;
    },
    getZoom: function() {
      return e.getRelativeZoom();
    },
    // CTM update
    setOnUpdatedCTM: function(t) {
      return e.options.onUpdatedCTM = t === null ? null : fe.proxy(t, e.publicInstance), e.pi;
    },
    // Reset
    resetZoom: function() {
      return e.resetZoom(), e.pi;
    },
    resetPan: function() {
      return e.resetPan(), e.pi;
    },
    reset: function() {
      return e.reset(), e.pi;
    },
    // Fit, Contain and Center
    fit: function() {
      return e.fit(), e.pi;
    },
    contain: function() {
      return e.contain(), e.pi;
    },
    center: function() {
      return e.center(), e.pi;
    },
    // Size and Resize
    updateBBox: function() {
      return e.updateBBox(), e.pi;
    },
    resize: function() {
      return e.resize(), e.pi;
    },
    getSizes: function() {
      return {
        width: e.width,
        height: e.height,
        realZoom: e.getZoom(),
        viewBox: e.viewport.getViewBox()
      };
    },
    // Destroy
    destroy: function() {
      return e.destroy(), e.pi;
    }
  }), this.publicInstance;
};
var Te = [], ns = function(e, t) {
  var n = fe.getSvg(e);
  if (n === null)
    return null;
  for (var o = Te.length - 1; o >= 0; o--)
    if (Te[o].svg === n)
      return Te[o].instance.getPublicInstance();
  return Te.push({
    svg: n,
    instance: new X(n, t)
  }), Te[Te.length - 1].instance.getPublicInstance();
}, os = ns;
const is = /* @__PURE__ */ qi(os), ss = {
  fitToContents() {
    return this.fit().center().zoomOut().zoomOut(), this;
  },
  getViewArea() {
    const e = this.getSizes(), t = this.getPan(), n = e.realZoom;
    t.x /= n, t.y /= n;
    const o = {
      width: e.width / n,
      height: e.height / n
    };
    return {
      box: {
        top: -t.y,
        bottom: o.height - t.y,
        left: -t.x,
        right: o.width - t.x
      },
      center: {
        x: o.width / 2 - t.x,
        y: o.height / 2 - t.y
      }
    };
  },
  getViewBox() {
    return this.getViewArea().box;
  },
  setViewBox(e) {
    const t = e.right - e.left, n = e.bottom - e.top, { width: o, height: i } = this.getSizes(), s = t / n, r = o / i, a = s < r ? n * r : t, c = s > r ? t / r : n, u = Math.min(
      o / a,
      i / c
    ), l = this.getRealZoom(), h = this.getZoom(), d = l / h;
    this.zoom(u / d);
    const v = {
      x: (e.left + t / 2) * u,
      y: (e.top + n / 2) * u
    };
    this.pan({
      x: -v.x + a / 2 * u,
      y: -v.y + c / 2 * u
    });
  },
  getRealZoom() {
    return this.getSizes().realZoom;
  },
  applyAbsoluteZoomLevel(e, t, n) {
    const o = Math.max(1e-4, t), i = Math.max(o, n), s = Math.max(Math.min(i, e), o), r = this.getRealZoom(), a = this.getZoom(), c = r / a;
    this.setMinZoom(o / c).setMaxZoom(i / c).zoom(s / c);
  },
  isPanEnabled() {
    return this._isPanEnabled;
  },
  enablePan() {
    return this._isPanEnabled = !0, this._internalEnablePan(), this;
  },
  disablePan() {
    return this._isPanEnabled = !1, this._internalDisablePan(), this;
  },
  isZoomEnabled() {
    return this._isZoomEnabled;
  },
  enableZoom() {
    return this._isZoomEnabled = !0, this._internalEnableZoom(), this;
  },
  disableZoom() {
    return this._isZoomEnabled = !1, this._internalDisableZoom(), this;
  },
  setPanEnabled(e) {
    return e ? this.enablePan() : this.disablePan(), this;
  },
  setZoomEnabled(e) {
    return e ? (this.enableZoom(), this.enableDblClickZoom()) : (this.disableZoom(), this.disableDblClickZoom()), this;
  }
};
function rs(e, t) {
  var o, i;
  const n = e;
  return n._isPanEnabled = (o = t.panEnabled) != null ? o : !0, n._isZoomEnabled = (i = t == null ? void 0 : t.zoomEnabled) != null ? i : !0, n._internalIsPanEnabled = n.isPanEnabled, n._internalEnablePan = n.enablePan, n._internalDisablePan = n.disablePan, n._internalIsZoomEnabled = n.isZoomEnabled, n._internalEnableZoom = n.enableZoom, n._internalDisableZoom = n.disableZoom, Object.assign(e, ss), n;
}
function as(e, t) {
  var s, r, a, c, u, l;
  const n = (r = (s = t.customEventsHandler) == null ? void 0 : s.init) != null ? r : (h) => {
  }, o = (c = (a = t.customEventsHandler) == null ? void 0 : a.destroy) != null ? c : (h) => {
  }, i = (l = (u = t.customEventsHandler) == null ? void 0 : u.haltEventListeners) != null ? l : [];
  return t.mouseWheelZoomEnabled === void 0 && (t.mouseWheelZoomEnabled = t.zoomEnabled), t.customEventsHandler = {
    init: (h) => {
      rs(h.instance, t), n(h);
    },
    destroy: (h) => o(h),
    haltEventListeners: i
  }, is(e, t);
}
function ls(e, t) {
  const n = _();
  let o = 0;
  const i = [], s = [], r = () => {
    o = 1, i.forEach((l) => l()), i.length = 0;
  }, a = () => {
    o = 2, s.forEach((l) => l()), s.length = 0;
  };
  return We(() => {
    var k, E, p, y, w, m;
    const l = G(e.value, "<svg>"), h = (E = (k = t.customEventsHandler) == null ? void 0 : k.init) != null ? E : (f) => {
    }, d = (y = (p = t.customEventsHandler) == null ? void 0 : p.destroy) != null ? y : (f) => {
    }, v = (m = (w = t.customEventsHandler) == null ? void 0 : w.haltEventListeners) != null ? m : [];
    t.customEventsHandler = {
      init: (f) => {
        n.value = f.instance, h(f), r();
      },
      destroy: (f) => {
        a(), d(f);
      },
      haltEventListeners: v
    };
    const x = () => {
      const f = l.getBoundingClientRect();
      f.width !== 0 && f.height !== 0 ? as(l, t) : setTimeout(x, 200);
    };
    x();
  }), Je(() => {
    var l;
    (l = n.value) == null || l.destroy(), n.value = void 0;
  }), { svgPanZoom: n, onSvgPanZoomMounted: (l) => {
    o === 0 ? i.push(l) : o === 1 && l();
  }, onSvgPanZoomUnmounted: (l) => {
    o === 0 || o === 1 ? s.push(l) : l();
  } };
}
const eo = Symbol("zoomLevel");
function cs(e, t) {
  const n = C(() => t.scalingObjects ? 1 : 1 / e.value);
  return Ae(eo, {
    zoomLevel: e,
    scale: n
  }), { scale: n };
}
function me() {
  return G(Ze(eo), "zoomLevel");
}
function us(e) {
  return e instanceof Promise || e && typeof e.then == "function";
}
function ds() {
  let e = null;
  const t = _({
    enabled: !1,
    duration: 300,
    timingFunction: "linear"
  });
  function n(o, i = 300, s = "linear") {
    e && (clearTimeout(e), e = null), t.value = {
      enabled: !0,
      duration: i,
      timingFunction: s
    }, Dt(() => Ee(this, null, function* () {
      const r = o();
      us(r) && (yield r), e && clearTimeout(e), e = window == null ? void 0 : window.setTimeout(() => {
        t.value.enabled = !1, e = null;
      }, i);
    }));
  }
  return { transitionWhile: n, transitionOption: t };
}
function fs(e) {
  const t = _({}), n = _(!1);
  let o = 1;
  const i = /* @__PURE__ */ new Map();
  return ge(() => {
    if (e.value instanceof Array) {
      const s = /* @__PURE__ */ new Set([]);
      if (t.value = Object.fromEntries(
        e.value.map((r) => {
          let a = r.id;
          return a || (n.value || (n.value = !0, console.warn(
            "[v-network-graph] Please specify the `id` field for the `Path` object. Currently, this works for compatibility, but in the future, the id field will be required."
          )), a = i.get(r), a || (a = "path-" + o++, i.set(r, a))), s.add(a), [a, r];
        })
      ), n.value)
        for (const [r, a] of Array.from(i.entries()))
          s.has(a) || i.delete(r);
    } else
      t.value = e.value;
  }), { objects: t, isInCompatibilityModeForPath: n };
}
function hs(e, t, n, o) {
  if (o) {
    const s = _(o(e[t])), r = (a) => {
      Ie(a, s.value) || (s.value = a), Ie(a, e[t]) || n(`update:${t}`, a);
    };
    return F(() => o(s.value), r), F(() => e[t], (a) => r(o(a))), s.value !== e[t] && n(`update:${t}`, s.value), s;
  }
  const i = _(e[t]);
  return F(
    () => e[t],
    (s) => {
      Ie(s, i.value) || (i.value = s);
    }
  ), F(i, (s) => {
    Ie(s, e[t]) || n(`update:${t}`, s);
  }), i;
}
function Tt(e, t, n, o) {
  const i = Ce(/* @__PURE__ */ new Set());
  return F(
    () => e[t],
    () => {
      const r = e[t].filter((a) => a in n.value);
      Ie(r, Array.from(i)) || (i.clear(), r.forEach(i.add, i));
    },
    { deep: !0, immediate: !0 }
  ), F(i, () => {
    const s = Array.from(i);
    Ie(e[t], s) || o(`update:${t}`, s);
  }), ze(i);
}
const to = Symbol("selection");
function vs(e, t, n) {
  Ae(to, {
    selectedNodes: e,
    selectedEdges: t,
    selectedPaths: n
  });
}
function ps() {
  return G(Ze(to), "Selections");
}
const no = Symbol("layouts");
function gs(e) {
  Ae(no, e);
}
function Yt() {
  return G(Ze(no), "Layouts");
}
function ms(e, t) {
  for (let n = 0; n < e.length - 1; n++)
    t(e[n], e[n + 1]);
}
function Ge(e, t) {
  const n = e.indexOf(t);
  n >= 0 && e.splice(n, 1);
}
function bs(e, t, n) {
  const o = e.indexOf(t);
  o < 0 || e.splice(o + 1, 0, n);
}
function ys(e, t) {
  const n = [
    "edges",
    "edge-labels",
    "focusring",
    "nodes",
    "node-labels",
    "paths"
  ];
  return C(() => {
    const o = Bo(e.view.builtInLayerOrder).filter((s) => {
      const r = n.includes(s);
      return r || console.warn(`Layer ${s} is not a built-in layer.`), r;
    }).reverse(), i = [...n];
    return ms(o, (s, r) => {
      Ge(i, r), bs(i, s, r);
    }), "edge-label" in t || "edges-label" in t || Ge(i, "edge-labels"), e.node.focusring.visible || Ge(i, "focusring"), e.node.label.visible === !1 && Ge(i, "node-labels"), e.path.visible || Ge(i, "paths"), i;
  });
}
const xn = () => new Promise((e) => Dt(e)), ws = ["x", "y", "width", "height", "fill", "stroke", "stroke-width", "stroke-dasharray"], Es = /* @__PURE__ */ W({
  __name: "VSelectionBox",
  props: {
    box: null,
    config: null
  },
  setup(e) {
    return (t, n) => (M(), $("rect", {
      class: "v-ng-selection-box",
      x: Math.round(e.box.pos.x),
      y: Math.round(e.box.pos.y),
      width: Math.ceil(e.box.size.width),
      height: Math.ceil(e.box.size.height),
      fill: e.config.color,
      stroke: e.config.strokeColor,
      "stroke-width": e.config.strokeWidth,
      "stroke-dasharray": e.config.strokeDasharray
    }, null, 8, ws));
  }
});
const xs = ["points", "fill"], ks = /* @__PURE__ */ W({
  __name: "VMarkerHeadArrow",
  props: {
    width: null,
    height: null,
    refX: null,
    color: null,
    isSource: { type: Boolean },
    units: null
  },
  setup(e) {
    const t = e, n = C(() => {
      const o = t.width, i = t.height;
      return t.isSource ? `${o} ${i}, 0 ${i / 2}, ${o} 0` : `0 0, ${o} ${i / 2}, 0 ${i}`;
    });
    return (o, i) => (M(), $("polygon", {
      points: b(n),
      fill: e.color
    }, null, 8, xs));
  }
}), Ps = ["points", "stroke-width", "stroke"], Ss = /* @__PURE__ */ W({
  __name: "VMarkerHeadAngle",
  props: {
    width: null,
    height: null,
    refX: null,
    color: null,
    isSource: { type: Boolean },
    units: null
  },
  setup(e) {
    const t = e, n = C(() => t.units === "strokeWidth" ? 1 : Math.min(t.width, t.height) / 5), o = C(() => {
      const i = n.value / 2, s = t.width, r = t.height;
      return t.isSource ? `${s - i} ${r - i}, ${i} ${r / 2}, ${s - i} ${i}` : `${i} ${i}, ${s - i} ${r / 2}, ${i} ${r - i}`;
    });
    return (i, s) => (M(), $("polyline", {
      points: b(o),
      fill: "none",
      "stroke-width": b(n),
      stroke: e.color,
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, 8, Ps));
  }
}), Ms = ["fill", "cx", "cy", "rx", "ry"], Cs = /* @__PURE__ */ W({
  __name: "VMarkerHeadCircle",
  props: {
    width: null,
    height: null,
    refX: null,
    color: null,
    isSource: { type: Boolean },
    units: null
  },
  setup(e) {
    return (t, n) => (M(), $("ellipse", {
      fill: e.color,
      cx: e.width / 2,
      cy: e.height / 2,
      rx: e.width / 2,
      ry: e.height / 2
    }, null, 8, Ms));
  }
}), Os = ["id", "markerWidth", "markerHeight", "refX", "refY", "markerUnits"], Ts = /* @__PURE__ */ W({
  __name: "VMarkerHead",
  props: {
    id: null,
    marker: null,
    scale: null
  },
  setup(e) {
    const t = e, n = {
      arrow: ks,
      angle: Ss,
      circle: Cs
    }, o = C(
      () => t.marker.width * (t.marker.units === "strokeWidth" ? 1 : t.scale)
    ), i = C(
      () => t.marker.height * (t.marker.units === "strokeWidth" ? 1 : t.scale)
    ), s = C(() => {
      const a = t.marker.margin * (t.marker.units === "strokeWidth" ? 1 : t.scale);
      return t.marker.isSource ? o.value + a : -a;
    }), r = C(() => {
      const a = t.marker.offset * (t.marker.units === "strokeWidth" ? 1 : t.scale);
      return t.marker.isSource ? a : -a;
    });
    return (a, c) => e.marker.type !== "none" && e.marker.type !== "custom" ? (M(), $("marker", {
      key: 0,
      id: e.id,
      markerWidth: b(o),
      markerHeight: b(i),
      refX: b(s),
      refY: b(i) / 2 + b(r),
      orient: "auto",
      markerUnits: e.marker.units,
      class: "v-ng-marker"
    }, [
      (M(), R(Mn(n[e.marker.type]), {
        width: b(o),
        height: b(i),
        refX: b(s),
        color: e.marker.color,
        "is-source": e.marker.isSource,
        units: e.marker.units
      }, null, 8, ["width", "height", "refX", "color", "is-source", "units"]))
    ], 8, Os)) : ce("", !0);
  }
}), zs = {
  class: "v-ng-background-grid",
  "shape-rendering": "crispEdges"
}, Is = ["d"], Ls = ["d"], $s = ["d"], As = ["d"], Zs = /* @__PURE__ */ W({
  __name: "VBackgroundGrid",
  setup(e) {
    const { container: t, svgPanZoom: n } = Bt(), { zoomLevel: o } = me(), i = Xi(), s = Uo(), r = _({ x: 0, y: 0 }), a = _({ width: 500, height: 500 });
    We(() => {
      var x;
      const d = (x = n.value) == null ? void 0 : x.getPan();
      d && (r.value = {
        x: -d.x,
        y: -d.y
      });
      const v = t.value.getBoundingClientRect();
      a.value = {
        width: v.width,
        height: v.height
      };
    }), i.on("view:resize", (d) => {
      a.value = { width: d.width, height: d.height };
    }), i.on("view:pan", (d) => {
      r.value = { x: -d.x, y: -d.y };
    }), i.on("view:zoom", () => {
      var v;
      const d = (v = n.value) == null ? void 0 : v.getPan();
      d && (r.value = { x: -d.x, y: -d.y });
    });
    const c = _([]), u = _([]), l = _([]), h = _([]);
    return ge(() => {
      const d = [], v = [], x = [], k = [], E = 1 / o.value, p = s.grid.interval, y = r.value.x * E, w = r.value.y * E, m = Math.floor(a.value.width / p + 1) * p, f = Math.floor(a.value.height / p + 1) * p, g = (r.value.x + m) * E, S = (r.value.y + f) * E, O = s.grid.thickIncrements, I = s.grid.line.dasharray, T = s.grid.thick.dasharray;
      let z = {
        stroke: s.grid.thick.color,
        "stroke-width": s.grid.thick.width,
        "stroke-dasharray": T,
        "stroke-dashoffset": T ? y / E : void 0
      }, A = {
        stroke: s.grid.line.color,
        "stroke-width": s.grid.line.width,
        "stroke-dasharray": I,
        "stroke-dashoffset": I ? y / E : void 0
      };
      const j = (r.value.x + m) * E;
      for (let B = w; B <= S; B += p) {
        const U = Math.floor(B / p);
        O && U % O === 0 ? d.push([U, U * p, y, j, z]) : x.push([U, U * p, y, j, A]);
      }
      z = se({}, z), z["stroke-dashoffset"] = T ? w / E : void 0, A = se({}, A), A["stroke-dashoffset"] = I ? w / E : void 0;
      const Y = (r.value.y + f) * E;
      for (let B = y; B <= g; B += p) {
        const U = Math.floor(B / p);
        O && U % O === 0 ? v.push([U, U * p, w, Y, z]) : k.push([U, U * p, w, Y, A]);
      }
      u.value = d, c.value = v, h.value = x, l.value = k;
    }), (d, v) => (M(), $("g", zs, [
      (M(!0), $(q, null, J(h.value, ([x, k, E, p, y]) => (M(), $("path", Pe({
        key: `nv${x}`,
        d: `M ${E} ${k} L ${p} ${k}`
      }, y, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Is))), 128)),
      (M(!0), $(q, null, J(l.value, ([x, k, E, p, y]) => (M(), $("path", Pe({
        key: `nh${x}`,
        d: `M ${k} ${E} L ${k} ${p}`
      }, y, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Ls))), 128)),
      (M(!0), $(q, null, J(u.value, ([x, k, E, p, y]) => (M(), $("path", Pe({
        key: `tv${x}`,
        d: `M ${E} ${k} L ${p} ${k}`
      }, y, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, $s))), 128)),
      (M(!0), $(q, null, J(c.value, ([x, k, E, p, y]) => (M(), $("path", Pe({
        key: `th${x}`,
        d: `M ${k} ${E} L ${k} ${p}`
      }, y, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, As))), 128))
    ]));
  }
});
const Ds = /* @__PURE__ */ W({
  __name: "VBackgroundViewport",
  setup(e) {
    const { viewport: t } = Bt(), n = _(), o = (s, r, a) => {
      s.forEach((c) => {
        var u;
        return r.setAttribute(c, (u = a.getAttribute(c)) != null ? u : "");
      });
    }, i = new MutationObserver((s) => {
      if (!n.value)
        return;
      const r = s.map((a) => {
        var c;
        return (c = a.attributeName) != null ? c : "";
      }).filter(Boolean);
      o(r, n.value, t.value);
    });
    return We(() => {
      const s = ["transform", "style"];
      i.observe(t.value, {
        attributes: !0,
        attributeFilter: s
      }), n.value && o(s, n.value, t.value);
    }), Je(() => {
      i.disconnect();
    }), (s, r) => (M(), $("g", {
      ref_key: "background",
      ref: n,
      class: "v-ng-background-viewport"
    }, [
      K(s.$slots, "default")
    ], 512));
  }
}), Ns = ["d", "stroke-width"], _s = /* @__PURE__ */ W({
  __name: "VEdgeBackground",
  props: {
    id: null,
    state: null,
    sourcePos: { default: void 0 },
    targetPos: { default: void 0 }
  },
  setup(e) {
    const t = e, { scale: n } = me(), o = gt(), {
      handleEdgePointerDownEvent: i,
      handleEdgePointerOverEvent: s,
      handleEdgePointerOutEvent: r,
      handleEdgeClickEvent: a,
      handleEdgeDoubleClickEvent: c,
      handleEdgeContextMenu: u
    } = nt(), l = C(() => {
      const d = t.state.position;
      if (t.state.loop) {
        const { radius: v, isLargeArc: x, isClockwise: k } = t.state.loop, [E, p] = v, y = x ? 1 : 0, w = k ? 1 : 0;
        return `M ${d.p1.x} ${d.p1.y} A ${E} ${p} 0 ${y} ${w} ${d.p2.x} ${d.p2.y}`;
      } else {
        if (o.type === "straight" || !t.state.curve)
          return `M ${d.p1.x} ${d.p1.y} L ${d.p2.x} ${d.p2.y}`;
        {
          const v = [...t.state.curve.control, { x: d.p2.x, y: d.p2.y }], x = [];
          return x.push(`M ${d.p1.x} ${d.p1.y}`), _t(v, 2).forEach(([k, E]) => x.push(`Q ${k.x} ${k.y} ${E.x} ${E.y}`)), x.join(" ");
        }
      }
    }), h = C(() => (t.state.line.stroke.width + 10) * n.value);
    return (d, v) => (M(), $("path", {
      class: ve({ "v-ng-line-background": !0, selectable: e.state.selectable }),
      d: b(l),
      stroke: "transparent",
      "stroke-width": b(h),
      fill: "none",
      onPointerdown: v[0] || (v[0] = xe((x) => b(i)(e.id, x), ["stop"])),
      onPointerenterPassive: v[1] || (v[1] = (x) => b(s)(e.id, x)),
      onPointerleavePassive: v[2] || (v[2] = (x) => b(r)(e.id, x)),
      onClick: v[3] || (v[3] = xe((x) => b(a)(e.id, x), ["stop"])),
      onDblclick: v[4] || (v[4] = xe((x) => b(c)(e.id, x), ["stop"])),
      onContextmenu: v[5] || (v[5] = (x) => b(u)(e.id, x))
    }, null, 42, Ns));
  }
});
const Bs = /* @__PURE__ */ W({
  __name: "VEdgeBackgrounds",
  setup(e) {
    const { edgeStates: t, edgeGroupStates: n, layouts: o } = Se();
    return (i, s) => (M(!0), $(q, null, J(b(n).edgeGroups, ({ summarize: r, edges: a }) => (M(), $(q, null, [
      r ? ce("", !0) : (M(!0), $(q, { key: 0 }, J(a, (c, u) => (M(), R(_s, {
        key: u,
        id: u,
        state: b(t)[u],
        "source-pos": b(o).nodes[c.source],
        "target-pos": b(o).nodes[c.target]
      }, null, 8, ["id", "state", "source-pos", "target-pos"]))), 128))
    ], 64))), 256));
  }
}), js = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"], oo = /* @__PURE__ */ W({
  __name: "VLine",
  props: {
    p1: null,
    p2: null,
    config: null
  },
  setup(e) {
    const t = e, { scale: n } = me(), o = C(() => t.config.width * n.value), i = C(() => tt(t.config.dasharray, n.value)), s = C(() => {
      const r = t.config.animate ? ht(t.config.dasharray) * t.config.animationSpeed * n.value : !1;
      return r ? { "--animation-speed": r } : void 0;
    });
    return (r, a) => (M(), $("path", {
      class: ve({ "v-ng-line": !0, animate: e.config.animate }),
      d: `M ${e.p1.x} ${e.p1.y} L ${e.p2.x} ${e.p2.y}`,
      stroke: e.config.color,
      "stroke-width": b(o),
      "stroke-dasharray": b(i),
      "stroke-linecap": e.config.linecap,
      style: et(b(s))
    }, null, 14, js));
  }
}), Vs = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"], Rs = /* @__PURE__ */ W({
  __name: "VArc",
  props: {
    p1: null,
    p2: null,
    radius: null,
    isLargeArc: { type: Boolean },
    isClockwise: { type: Boolean },
    config: null
  },
  setup(e) {
    const t = e, { scale: n } = me(), o = C(() => t.config.width * n.value), i = C(() => tt(t.config.dasharray, n.value)), s = C(() => {
      const a = t.config.animate ? ht(t.config.dasharray) * t.config.animationSpeed * n.value : !1;
      return a ? { "--animation-speed": a } : void 0;
    }), r = C(() => {
      const { p1: a, p2: c, radius: u, isLargeArc: l, isClockwise: h } = t, [d, v] = u, x = l ? 1 : 0, k = h ? 1 : 0;
      return `M ${a.x} ${a.y} A ${d} ${v} 0 ${x} ${k} ${c.x} ${c.y}`;
    });
    return (a, c) => (M(), $("path", {
      class: ve({ "v-ng-line": !0, animate: e.config.animate }),
      d: b(r),
      stroke: e.config.color,
      "stroke-width": b(o),
      "stroke-dasharray": b(i),
      "stroke-linecap": e.config.linecap,
      style: et(b(s)),
      fill: "none"
    }, null, 14, Vs));
  }
}), Hs = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "marker-start", "marker-end"], Ws = /* @__PURE__ */ W({
  __name: "VEdgeCurved",
  props: {
    state: null,
    config: null,
    markerStart: { default: void 0 },
    markerEnd: { default: void 0 }
  },
  setup(e) {
    const t = e, { scale: n } = me(), o = C(() => {
      var l, h;
      const a = t.state.position, c = [...(h = (l = t.state.curve) == null ? void 0 : l.control) != null ? h : [], { x: a.p2.x, y: a.p2.y }], u = [];
      return u.push(`M ${a.p1.x} ${a.p1.y}`), _t(c, 2).forEach(([d, v]) => u.push(`Q ${d.x} ${d.y} ${v.x} ${v.y}`)), u.join(" ");
    }), i = C(() => t.config.width * n.value), s = C(() => tt(t.config.dasharray, n.value)), r = C(() => {
      const a = t.config.animate ? ht(t.config.dasharray) * t.config.animationSpeed * n.value : !1;
      return a ? { "--animation-speed": a } : void 0;
    });
    return (a, c) => (M(), $("path", {
      class: ve({ "v-ng-line": !0, animate: e.config.animate }),
      d: b(o),
      fill: "none",
      stroke: e.config.color,
      "stroke-width": b(i),
      "stroke-dasharray": b(s),
      "stroke-linecap": e.config.linecap,
      style: et(b(r)),
      "marker-start": e.markerStart,
      "marker-end": e.markerEnd
    }, null, 14, Hs));
  }
}), Us = /* @__PURE__ */ W({
  __name: "VEdge",
  props: {
    id: null,
    state: null,
    sourcePos: { default: void 0 },
    targetPos: { default: void 0 }
  },
  setup(e) {
    const t = gt();
    return (n, o) => e.state.loop ? (M(), R(Rs, Pe({ key: 0 }, e.state.position, {
      radius: e.state.loop.radius,
      "is-large-arc": e.state.loop.isLargeArc,
      "is-clockwise": e.state.loop.isClockwise,
      class: [{ selectable: e.state.selectable, hover: e.state.hovered, selected: e.state.selected }, "v-ng-edge"],
      config: e.state.line.stroke,
      "marker-start": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,
      "marker-end": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0
    }), null, 16, ["radius", "is-large-arc", "is-clockwise", "class", "config", "marker-start", "marker-end"])) : b(t).type == "straight" || !e.state.curve ? (M(), R(oo, Pe({
      key: 1,
      "data-edge-id": e.id
    }, e.state.position, {
      class: [{ selectable: e.state.selectable, hover: e.state.hovered, selected: e.state.selected }, "v-ng-edge"],
      config: e.state.line.stroke,
      "marker-start": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,
      "marker-end": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0
    }), null, 16, ["data-edge-id", "class", "config", "marker-start", "marker-end"])) : (M(), R(Ws, {
      key: 2,
      "data-edge-id": e.id,
      class: ve([{ selectable: e.state.selectable, hover: e.state.hovered, selected: e.state.selected }, "v-ng-edge"]),
      state: e.state,
      config: e.state.line.stroke,
      "marker-start": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,
      "marker-end": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0
    }, null, 8, ["data-edge-id", "class", "state", "config", "marker-start", "marker-end"]));
  }
});
const Fs = ["cx", "cy", "r", "fill", "stroke", "stroke-width", "stroke-dasharray"], Xs = ["x", "y", "width", "height", "rx", "ry", "fill", "stroke", "stroke-width", "stroke-dasharray"], yt = /* @__PURE__ */ W({
  __name: "VShape",
  props: {
    baseX: { default: 0 },
    baseY: { default: 0 },
    config: null
  },
  setup(e) {
    const t = e, { scale: n } = me(), o = _(t.baseX), i = _(t.baseY), s = _(0), r = _("#000000"), a = _(void 0), c = _(0), u = _(0), l = _(0), h = _(0);
    return ge(() => {
      var v;
      const d = n.value;
      s.value = t.config.strokeWidth * d, r.value = (v = t.config.strokeColor) != null ? v : "none", a.value = tt(t.config.strokeDasharray, d), t.config.type === "circle" ? (o.value = t.baseX, i.value = t.baseY, c.value = t.config.radius * d) : (u.value = t.config.width * d, l.value = t.config.height * d, h.value = t.config.borderRadius * d, o.value = t.baseX - u.value / 2, i.value = t.baseY - l.value / 2);
    }), (d, v) => e.config.type === "circle" ? (M(), $("circle", {
      key: 0,
      class: "v-ng-shape-circle",
      cx: o.value,
      cy: i.value,
      r: c.value,
      fill: e.config.color,
      stroke: r.value,
      "stroke-width": s.value,
      "stroke-dasharray": a.value
    }, null, 8, Fs)) : (M(), $("rect", {
      key: 1,
      class: "v-ng-shape-rect",
      x: o.value,
      y: i.value,
      width: u.value,
      height: l.value,
      rx: h.value,
      ry: h.value,
      fill: e.config.color,
      stroke: r.value,
      "stroke-width": s.value,
      "stroke-dasharray": a.value
    }, null, 8, Xs));
  }
}), qs = ["rx", "ry", "fill", "transform"], Gs = ["x", "y", "dominant-baseline", "font-family", "font-size", "fill"], Ks = ["x", "dy", "dominant-baseline"], wt = /* @__PURE__ */ W({
  __name: "VLabelText",
  props: {
    text: null,
    x: { default: 0 },
    y: { default: 0 },
    dominantBaseline: { default: "central" },
    config: null
  },
  setup(e) {
    const t = e, n = $o(), { scale: o } = me(), i = C(() => {
      var E, p;
      return (p = (E = t.text) == null ? void 0 : E.toString().split(/\r?\n/)) != null ? p : "";
    }), s = C(() => {
      var E;
      return (E = n["font-size"]) != null ? E : t.config.fontSize * o.value;
    }), r = C(() => s.value * t.config.lineHeight), a = C(() => {
      const E = t.dominantBaseline;
      return E === "hanging" ? 0 : E === "central" ? -(r.value * (i.value.length - 1)) / 2 : -r.value * (i.value.length - 1);
    }), c = _(), u = _(""), l = Ce({ x: 0, y: 0, width: 0, height: 0 }), h = C(() => {
      var m, f;
      const E = t.config.background;
      if (!E)
        return l;
      let p, y;
      E.padding instanceof Object ? (p = E.padding.vertical, y = E.padding.horizontal) : (p = (m = E.padding) != null ? m : 0, y = (f = E.padding) != null ? f : 0);
      const w = r.value - s.value;
      return {
        x: l.x - y * o.value,
        y: l.y - p * o.value - w / 2,
        width: l.width + y * 2 * o.value,
        height: l.height + p * 2 * o.value + w
      };
    });
    let d;
    const v = () => {
      t.config.background && t.config.background.visible ? !d && c.value && (d = k(c.value, l, u)) : (d == null || d.disconnect(), d = void 0);
    };
    We(() => v()), F(
      () => t.config.background && t.config.background.visible,
      (E, p) => {
        E != p && v();
      }
    ), Je(() => {
      d == null || d.disconnect(), d = void 0;
    });
    function x(E, p, y) {
      var m;
      const w = E.getBBox();
      p.x = w.x, p.y = w.y, p.width = w.width, p.height = w.height, y.value = (m = E.getAttribute("transform")) != null ? m : void 0;
    }
    function k(E, p, y) {
      const w = new MutationObserver(() => {
        x(E, p, y);
      });
      return w.observe(E, {
        attributes: !0,
        attributeFilter: ["x", "y", "transform", "font-size"]
      }), x(E, p, y), w;
    }
    return (E, p) => {
      var y, w, m, f, g, S;
      return M(), $(q, null, [
        e.config.background && e.config.background.visible ? (M(), $("rect", Pe({
          key: 0,
          class: "v-ng-text-background"
        }, b(h), {
          rx: ((w = (y = e.config.background) == null ? void 0 : y.borderRadius) != null ? w : 0) * b(o),
          ry: ((f = (m = e.config.background) == null ? void 0 : m.borderRadius) != null ? f : 0) * b(o),
          fill: (S = (g = e.config.background) == null ? void 0 : g.color) != null ? S : "#ffffff",
          transform: u.value
        }), null, 16, qs)) : ce("", !0),
        Cn("text", Pe({
          ref_key: "element",
          ref: c,
          class: "v-ng-text"
        }, E.$attrs, {
          x: e.x,
          y: e.y,
          "dominant-baseline": e.dominantBaseline,
          "font-family": E.$attrs["font-family"] ? `${E.$attrs["font-family"]}` : e.config.fontFamily,
          "font-size": b(s),
          fill: E.$attrs.fill ? `${E.$attrs.fill}` : e.config.color
        }), [
          b(i).length <= 1 ? (M(), $(q, { key: 0 }, [
            Ao(an(e.text), 1)
          ], 64)) : (M(!0), $(q, { key: 1 }, J(b(i), (O, I) => (M(), $("tspan", {
            key: I,
            x: e.x,
            dy: I == 0 ? b(a) : b(r),
            "dominant-baseline": e.dominantBaseline
          }, an(O), 9, Ks))), 128))
        ], 16, Gs)
      ], 64);
    };
  }
}), Ys = /* @__PURE__ */ W({
  __name: "VEdgeSummarized",
  props: {
    edges: null,
    layouts: null
  },
  setup(e) {
    const t = e, n = gt(), {
      handleEdgesPointerDownEvent: o,
      handleEdgesPointerOverEvent: i,
      handleEdgesPointerOutEvent: s,
      handleEdgesClickEvent: r,
      handleEdgesDoubleClickEvent: a,
      handleEdgesContextMenu: c
    } = nt(), { edgeStates: u } = Se(), l = _({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }), h = _({ x: 0, y: 0 });
    ge(() => {
      const w = Object.keys(t.edges).find((m) => m in u);
      w && (l.value = u[w].position, h.value = {
        x: (l.value.p1.x + l.value.p2.x) / 2,
        y: (l.value.p1.y + l.value.p2.y) / 2
      });
    });
    const d = C(() => Object.keys(t.edges)), v = C(() => L.values(n.summarized.label, t.edges)), x = C(() => L.values(n.summarized.shape, t.edges)), k = C(() => L.values(n.summarized.stroke, t.edges)), E = C(() => d.value.some((w) => u[w].hovered)), p = C(() => d.value.some((w) => u[w].selectable)), y = C(() => d.value.some((w) => u[w].selected));
    return (w, m) => (M(), $("g", {
      class: ve({ "v-ng-line-summarized": !0, hovered: b(E), selectable: b(p), selected: b(y) }),
      onPointerdown: m[0] || (m[0] = xe((f) => b(o)(b(d), f), ["stop"])),
      onPointerenterPassive: m[1] || (m[1] = (f) => b(i)(b(d), f)),
      onPointerleavePassive: m[2] || (m[2] = (f) => b(s)(b(d), f)),
      onClick: m[3] || (m[3] = xe((f) => b(r)(b(d), f), ["stop"])),
      onDblclick: m[4] || (m[4] = xe((f) => b(a)(b(d), f), ["stop"])),
      onContextmenu: m[5] || (m[5] = (f) => b(c)(b(d), f))
    }, [
      _e(oo, Pe(l.value, {
        config: b(k),
        "data-edge-id": b(d)[0]
      }), null, 16, ["config", "data-edge-id"]),
      _e(yt, {
        "base-x": h.value.x,
        "base-y": h.value.y,
        config: b(x)
      }, null, 8, ["base-x", "base-y", "config"]),
      _e(wt, {
        text: Object.keys(e.edges).length.toString(),
        x: h.value.x,
        y: h.value.y,
        config: b(v),
        "text-anchor": "middle",
        "dominant-baseline": "central"
      }, null, 8, ["text", "x", "y", "config"])
    ], 34));
  }
});
const Qs = { class: "v-ng-edge-overlay" }, kn = /* @__PURE__ */ W({
  __name: "VEdgeOverlay",
  props: {
    edgeId: { default: void 0 },
    edge: { default: void 0 },
    edges: { default: () => ({}) },
    state: null,
    isSummarized: { type: Boolean }
  },
  setup(e) {
    const t = e, { svg: n } = Bt(), { scale: o } = me(), i = gt();
    function s() {
      return t.isSummarized ? L.values(i.summarized.stroke, t.edges) : t.state.line.stroke;
    }
    function r(l) {
      return { source: l.p1, target: l.p2 };
    }
    function a(l) {
      if (l.curve)
        return l.curve.center;
      {
        const h = l.origin.p1, d = l.origin.p2;
        return {
          x: (h.x + d.x) / 2,
          y: (h.y + d.y) / 2
        };
      }
    }
    function c() {
      var d;
      if (!n.value)
        return 0;
      const l = (d = t.edgeId) != null ? d : Object.keys(t.edges)[0], h = n.value.querySelector(`path[data-edge-id="${l}"]`);
      return h ? h.getTotalLength() : 0;
    }
    function u(l) {
      var x;
      if (!n.value || !isFinite(l))
        return t.state.position.p1;
      t.state;
      const h = (x = t.edgeId) != null ? x : Object.keys(t.edges)[0], d = n.value.querySelector(`path[data-edge-id="${h}"]`);
      if (!d)
        return t.state.position.p1;
      const v = d.getPointAtLength(l);
      return { x: v.x, y: v.y };
    }
    return (l, h) => (M(), $("g", Qs, [
      e.isSummarized ? K(l.$slots, "default", {
        key: 0,
        edges: e.edges,
        isSummarized: e.isSummarized,
        stroke: s(),
        position: r(e.state.origin),
        center: a(e.state),
        hovered: e.state.hovered,
        selected: e.state.selected,
        scale: b(o),
        length: c(),
        pointAtLength: u
      }) : K(l.$slots, "default", {
        key: 1,
        edgeId: e.edgeId,
        edge: e.edge,
        edges: { [e.edgeId]: e.edge },
        isSummarized: e.isSummarized,
        stroke: s(),
        position: r(e.state.origin),
        center: a(e.state),
        hovered: e.state.hovered,
        selected: e.state.selected,
        scale: b(o),
        length: c(),
        pointAtLength: u
      })
    ]));
  }
}), Js = /* @__PURE__ */ W({
  __name: "VEdgeGroups",
  props: {
    hasEdgeOverlaySlot: { type: Boolean }
  },
  setup(e) {
    const { edgeStates: t, edgeZOrderedList: n, layouts: o } = Se();
    return (i, s) => (M(!0), $(q, null, J(b(n), (r) => (M(), $(q, null, [
      b(Ei)(r) ? (M(), $(q, { key: 0 }, [
        (M(), R(Ys, {
          key: r.key,
          edges: r.group.edges,
          layouts: b(o).nodes
        }, null, 8, ["edges", "layouts"])),
        e.hasEdgeOverlaySlot ? (M(), R(kn, {
          key: r.key,
          edges: r.group.edges,
          state: b(t)[Object.keys(r.group.edges)[0]],
          "is-summarized": !0
        }, {
          default: te((a) => [
            K(i.$slots, "default", ue(de(a)))
          ]),
          _: 2
        }, 1032, ["edges", "state"])) : ce("", !0)
      ], 64)) : (M(), $(q, { key: 1 }, [
        (M(), R(Us, {
          id: r.key,
          key: r.key,
          state: b(t)[r.key],
          "source-pos": b(o).nodes[r.edge.source],
          "target-pos": b(o).nodes[r.edge.target]
        }, null, 8, ["id", "state", "source-pos", "target-pos"])),
        e.hasEdgeOverlaySlot ? (M(), R(kn, {
          key: r.key,
          "edge-id": r.key,
          edge: r.edge,
          state: b(t)[r.key],
          "is-summarized": !1
        }, {
          default: te((a) => [
            K(i.$slots, "default", ue(de(a)))
          ]),
          _: 2
        }, 1032, ["edge-id", "edge", "state"])) : ce("", !0)
      ], 64))
    ], 64))), 256));
  }
}), er = { class: "v-ng-layer-edges" }, tr = /* @__PURE__ */ W({
  __name: "VEdgesLayer",
  setup(e) {
    const t = ft(), n = C(() => "edge-overlay" in t);
    return (o, i) => (M(), $("g", er, [
      _e(Bs),
      _e(Js, { "has-edge-overlay-slot": b(n) }, Nt({ _: 2 }, [
        b(n) ? {
          name: "default",
          fn: te((s) => [
            K(o.$slots, "edge-overlay", ue(de(s)))
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["has-edge-overlay-slot"])
    ]));
  }
}), nr = /* @__PURE__ */ W({
  __name: "VEdgeLabelPlace",
  props: {
    edgeId: null,
    edge: null,
    state: null
  },
  setup(e) {
    const t = e, { scale: n } = me(), o = C(() => Vn(
      t.state.labelPosition,
      t.state.line.stroke,
      t.state.label.margin,
      t.state.label.padding,
      n.value
    ));
    return (i, s) => e.state.loop ? ce("", !0) : K(i.$slots, "default", {
      key: 0,
      edgeId: e.edgeId,
      edge: e.edge,
      config: e.state.label,
      area: b(o),
      hovered: e.state.hovered,
      selected: e.state.selected,
      scale: b(n)
    });
  }
}), or = /* @__PURE__ */ W({
  __name: "VEdgeLabelsPlace",
  props: {
    edges: null,
    state: null,
    summarizeState: null
  },
  setup(e) {
    const t = e, { scale: n } = me(), o = C(() => {
      var i, s;
      return Vn(
        t.state.labelPosition,
        (s = (i = t.summarizeState) == null ? void 0 : i.stroke) != null ? s : t.state.line.stroke,
        t.state.label.margin,
        t.state.label.padding,
        n.value
      );
    });
    return (i, s) => e.state.loop ? ce("", !0) : K(i.$slots, "default", {
      key: 0,
      edges: e.edges,
      config: e.state.label,
      area: b(o),
      hovered: e.state.hovered,
      selected: e.state.selected,
      scale: b(n)
    });
  }
}), ir = { class: "v-ng-edge-labels" }, sr = /* @__PURE__ */ W({
  __name: "VEdgeLabels",
  props: {
    enableEdgeLabel: { type: Boolean, default: !1 },
    enableEdgesLabel: { type: Boolean, default: !1 }
  },
  setup(e) {
    const { edgeStates: t, edgeGroupStates: n, summarizedEdgeStates: o } = Se(), i = C(() => {
      const r = {}, a = {};
      return Object.entries(n.edgeGroups).forEach(([c, u]) => {
        Object.keys(u.edges).length > 0 && (u.summarize ? a[c] = u : r[c] = u);
      }), { individual: r, summarized: a };
    });
    function s(r) {
      return Object.keys(r.edges)[0];
    }
    return (r, a) => (M(), $("g", ir, [
      e.enableEdgeLabel ? (M(!0), $(q, { key: 0 }, J(b(i).individual, (c, u) => (M(), $(q, { key: u }, [
        (M(!0), $(q, null, J(c.edges, (l, h) => (M(), R(nr, {
          key: h,
          "edge-id": h,
          edge: l,
          state: b(t)[h]
        }, {
          default: te((d) => [
            K(r.$slots, "edge-label", ue(de(d)))
          ]),
          _: 2
        }, 1032, ["edge-id", "edge", "state"]))), 128))
      ], 64))), 128)) : ce("", !0),
      e.enableEdgesLabel ? (M(!0), $(q, { key: 1 }, J(b(i).summarized, (c, u) => (M(), R(or, {
        key: u,
        edges: c.edges,
        state: b(t)[s(c)],
        "summarize-state": b(o)[s(c)]
      }, {
        default: te((l) => [
          K(r.$slots, "edges-label", ue(de(l)))
        ]),
        _: 2
      }, 1032, ["edges", "state", "summarize-state"]))), 128)) : ce("", !0)
    ]));
  }
});
const rr = /* @__PURE__ */ W({
  __name: "VEdgeLabelsLayer",
  props: {
    enableEdgeLabel: { type: Boolean, default: !1 },
    enableEdgesLabel: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, n) => (M(), R(sr, {
      "enable-edge-label": e.enableEdgeLabel,
      "enable-edges-label": e.enableEdgesLabel,
      class: "v-ng-layer-edge-labels"
    }, Nt({ _: 2 }, [
      e.enableEdgeLabel ? {
        name: "edge-label",
        fn: te((o) => [
          K(t.$slots, "edge-label", ue(de(o)))
        ]),
        key: "0"
      } : void 0,
      e.enableEdgesLabel ? {
        name: "edges-label",
        fn: te((o) => [
          K(t.$slots, "edges-label", ue(de(o)))
        ]),
        key: "1"
      } : void 0
    ]), 1032, ["enable-edge-label", "enable-edges-label"]));
  }
}), ar = /* @__PURE__ */ W({
  __name: "VNodeFocusRing",
  props: {
    id: null,
    state: null,
    pos: { default: void 0 }
  },
  setup(e) {
    const t = e, n = C(() => {
      var r;
      return ((r = t.pos) == null ? void 0 : r.x) || 0;
    }), o = C(() => {
      var r;
      return ((r = t.pos) == null ? void 0 : r.y) || 0;
    }), i = pt(), s = Ce({});
    return ge(() => {
      var a, c, u;
      const r = t.state.shape;
      if (r.type === "circle") {
        const l = {
          type: "circle",
          radius: r.radius + ((a = r.strokeWidth) != null ? a : 0) / 2 + i.focusring.padding + i.focusring.width / 2,
          color: "none",
          strokeWidth: i.focusring.width,
          strokeColor: i.focusring.color,
          strokeDasharray: i.focusring.dasharray
        };
        Object.assign(s, l);
      } else {
        const l = {
          type: "rect",
          width: r.width + ((c = r.strokeWidth) != null ? c : 0) + i.focusring.padding * 2 + i.focusring.width,
          height: r.height + ((u = r.strokeWidth) != null ? u : 0) + i.focusring.padding * 2 + i.focusring.width,
          borderRadius: r.borderRadius > 0 ? r.borderRadius + i.focusring.padding : 0,
          color: "none",
          strokeWidth: i.focusring.width,
          strokeColor: i.focusring.color,
          strokeDasharray: i.focusring.dasharray
        };
        Object.assign(s, l);
      }
    }), (r, a) => (M(), R(yt, {
      class: "v-ng-node-focusring",
      "base-x": b(n),
      "base-y": b(o),
      config: s
    }, null, 8, ["base-x", "base-y", "config"]));
  }
});
const lr = { class: "v-ng-layer-nodes-selections" }, cr = /* @__PURE__ */ W({
  __name: "VFocusringLayer",
  setup(e) {
    const { nodeStates: t } = Se(), { selectedNodes: n } = ps(), o = Yt();
    return (i, s) => (M(), $("g", lr, [
      (M(!0), $(q, null, J(b(n), (r) => (M(), R(ar, {
        id: r,
        key: r,
        state: b(t)[r],
        pos: b(o).nodes[r]
      }, null, 8, ["id", "state", "pos"]))), 128))
    ]));
  }
}), ur = ["transform"], Pn = /* @__PURE__ */ W({
  __name: "VNode",
  props: {
    id: null,
    state: null,
    pos: { default: void 0 }
  },
  setup(e) {
    const t = e, n = C(() => {
      var h;
      return ((h = t.pos) == null ? void 0 : h.x) || 0;
    }), o = C(() => {
      var h;
      return ((h = t.pos) == null ? void 0 : h.y) || 0;
    }), { scale: i } = me(), {
      handleNodePointerDownEvent: s,
      handleNodePointerOverEvent: r,
      handleNodePointerOutEvent: a,
      handleNodeClickEvent: c,
      handleNodeDoubleClickEvent: u,
      handleNodeContextMenu: l
    } = nt();
    return (h, d) => (M(), $("g", {
      class: ve({ "v-ng-node": !0, hover: e.state.hovered, selected: e.state.selected }),
      transform: `translate(${b(n)} ${b(o)})`,
      onPointerdown: d[0] || (d[0] = xe((v) => b(s)(e.id, v), ["stop"])),
      onPointerenterPassive: d[1] || (d[1] = (v) => b(r)(e.id, v)),
      onPointerleavePassive: d[2] || (d[2] = (v) => b(a)(e.id, v)),
      onClick: d[3] || (d[3] = xe((v) => b(c)(e.id, v), ["stop"])),
      onDblclick: d[4] || (d[4] = xe((v) => b(u)(e.id, v), ["stop"])),
      onContextmenu: d[5] || (d[5] = (v) => b(l)(e.id, v))
    }, [
      K(h.$slots, "override-node", {
        nodeId: e.id,
        scale: b(i),
        config: e.state.shape,
        class: ve({ draggable: e.state.draggable, selectable: e.state.selectable })
      }, () => [
        _e(yt, {
          config: e.state.shape,
          class: ve({
            "v-ng-node-default": !0,
            draggable: e.state.draggable,
            selectable: e.state.selectable
          })
        }, null, 8, ["config", "class"])
      ])
    ], 42, ur));
  }
});
const dr = /* @__PURE__ */ W({
  __name: "VNodesLayer",
  setup(e) {
    const t = ft(), n = C(() => "override-node" in t), { nodeZOrderedList: o } = Se(), i = pt(), s = Yt();
    return (r, a) => b(n) ? (M(), R(Ye, {
      key: 0,
      name: b(i).transition,
      css: !!b(i).transition,
      tag: "g",
      class: "v-ng-layer-nodes"
    }, {
      default: te(() => [
        (M(!0), $(q, null, J(b(o), (c) => (M(), R(Pn, {
          id: c.id,
          key: c.id,
          state: c,
          pos: b(s).nodes[c.id]
        }, {
          "override-node": te((u) => [
            K(r.$slots, "override-node", ue(de(u)))
          ]),
          _: 2
        }, 1032, ["id", "state", "pos"]))), 128))
      ]),
      _: 3
    }, 8, ["name", "css"])) : (M(), R(Ye, {
      key: 1,
      name: b(i).transition,
      css: !!b(i).transition,
      tag: "g",
      class: "v-ng-layer-nodes"
    }, {
      default: te(() => [
        (M(!0), $(q, null, J(b(o), (c) => (M(), R(Pn, {
          id: c.id,
          key: c.id,
          state: c,
          pos: b(s).nodes[c.id]
        }, null, 8, ["id", "state", "pos"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), io = {
  [Z.NORTH]: 0,
  [Z.NORTH_EAST]: 1,
  [Z.EAST]: 2,
  [Z.SOUTH_EAST]: 3,
  [Z.SOUTH]: 4,
  [Z.SOUTH_WEST]: 5,
  [Z.WEST]: 6,
  [Z.NORTH_WEST]: 7,
  [Z.CENTER]: -1
}, fr = [
  /* N */
  (e, t) => Oe(e, 0, t ? 90 : 60),
  /* NE */
  (e, t) => Oe(e, 45, t ? 90 : 45),
  /* E */
  (e, t) => Oe(e, 90, t ? 60 : 30),
  /* SE */
  (e, t) => Oe(e, 135, t ? 90 : 45),
  /* S */
  (e, t) => Oe(e, 180, t ? 90 : 60),
  /* SW */
  (e, t) => Oe(e, 225, t ? 90 : 45),
  /* W */
  (e, t) => Oe(e, 270, t ? 60 : 30),
  /* NW */
  (e, t) => Oe(e, 315, t ? 90 : 45)
];
function hr(e, t, n, o, i) {
  if (i === Z.CENTER)
    return Z.CENTER;
  const s = [];
  Object.entries(n).forEach(([u, l]) => {
    let h = !1;
    if (l.nodeId === e) {
      const v = o(u);
      v && (h = !0, l = Fe(se({}, l), {
        pos: { x: v.x, y: v.y }
      }));
    }
    const d = (Ft(jt(l.pos, t)) + 360 + 90) % 360;
    s.push([d, h]);
  });
  const r = vr(i), c = [
    r,
    (r + 4) % 8,
    // priority is given to diagonals
    (r + 2) % 8,
    (r - 2 + 8) % 8,
    (r + 1) % 8,
    (r - 1 + 8) % 8,
    (r + 3) % 8,
    (r - 3 + 8) % 8
  ].find((u) => s.every((l) => !fr[u](...l)));
  return c === void 0 ? i : pr(c, i);
}
function Oe(e, t, n) {
  e %= 360;
  const o = (t - n + 360) % 360, i = (t + n) % 360;
  return o <= i ? o < e && e < i : o < e || e < i;
}
function vr(e) {
  var t;
  return (t = io[e]) != null ? t : 0;
}
function pr(e, t) {
  var n, o;
  return (o = (n = Object.entries(io)[e]) == null ? void 0 : n[0]) != null ? o : t;
}
const gr = ["transform"], Sn = /* @__PURE__ */ W({
  __name: "VNodeLabel",
  props: {
    id: null,
    state: null,
    pos: { default: void 0 }
  },
  setup(e) {
    const t = e, n = pt(), { edgeStates: o } = Se(), { scale: i } = me(), {
      handleNodePointerDownEvent: s,
      handleNodePointerOverEvent: r,
      handleNodePointerOutEvent: a,
      handleNodeClickEvent: c,
      handleNodeDoubleClickEvent: u,
      handleNodeContextMenu: l
    } = nt(), h = C(() => {
      var T;
      return ((T = t.pos) == null ? void 0 : T.x) || 0;
    }), d = C(() => {
      var T;
      return ((T = t.pos) == null ? void 0 : T.y) || 0;
    }), v = C(() => t.state.label.direction === Z.CENTER ? 0 : t.state.label.margin * i.value), x = _(0), k = _(0), E = _(0), p = _(0), y = C(() => {
      var j;
      const T = t.state.label.direction, z = t.state.label.directionAutoAdjustment;
      if (z === !1)
        return T;
      const A = { x: h.value, y: d.value };
      return z === !0 ? hr(
        t.state.id,
        A,
        t.state.oppositeNodes,
        (Y) => {
          var B, U;
          return (U = (B = o[Y]) == null ? void 0 : B.loop) == null ? void 0 : U.center;
        },
        T
      ) : (j = z({
        nodeId: t.state.id,
        pos: A,
        oppositeNodes: t.state.oppositeNodes
      })) != null ? j : T;
    }), w = C(() => {
      switch (y.value) {
        case Z.CENTER:
        case Z.NORTH:
        case Z.SOUTH:
          return "middle";
        case Z.EAST:
        case Z.NORTH_EAST:
        case Z.SOUTH_EAST:
          return "start";
        case Z.WEST:
        case Z.NORTH_WEST:
        case Z.SOUTH_WEST:
        default:
          return "end";
      }
    }), m = C(() => {
      switch (y.value) {
        case Z.NORTH:
        case Z.NORTH_EAST:
        case Z.NORTH_WEST:
          return "text-top";
        case Z.SOUTH:
        case Z.SOUTH_EAST:
        case Z.SOUTH_WEST:
          return "hanging";
        case Z.CENTER:
        case Z.EAST:
        case Z.WEST:
        default:
          return "central";
      }
    }), f = C(() => {
      switch (y.value) {
        case Z.CENTER:
        case Z.NORTH:
        case Z.SOUTH:
          return 0;
        case Z.EAST:
          return k.value;
        case Z.WEST:
          return -k.value;
        case Z.NORTH_EAST:
        case Z.SOUTH_EAST:
          return p.value;
        case Z.NORTH_WEST:
        case Z.SOUTH_WEST:
        default:
          return -p.value;
      }
    }), g = C(() => {
      switch (y.value) {
        case Z.NORTH:
          return -x.value;
        case Z.SOUTH:
          return x.value;
        case Z.CENTER:
        case Z.EAST:
        case Z.WEST:
          return 0;
        case Z.NORTH_EAST:
        case Z.NORTH_WEST:
          return -E.value;
        case Z.SOUTH_EAST:
        case Z.SOUTH_WEST:
        default:
          return E.value;
      }
    });
    ge(() => {
      const T = i.value, z = t.state.shape;
      if (z.type == "circle") {
        const A = z.radius * T, j = A + v.value, Y = Math.sqrt(ae(j, 2) / 2);
        x.value = A + v.value, k.value = A + v.value, E.value = Y, p.value = Y;
      } else {
        const A = z.borderRadius * T, j = z.width * T, Y = z.height * T, B = A + v.value, U = Math.sqrt(ae(B, 2) / 2);
        x.value = Y / 2 + v.value, k.value = j / 2 + v.value, E.value = Y / 2 - A + U, p.value = j / 2 - A + U;
      }
    });
    const S = C(() => (T) => n.label.handleNodeEvents ? {
      pointerdown: (z) => {
        z.stopPropagation(), s(T, z);
      },
      pointerenter: (z) => r(T, z),
      pointerleave: (z) => a(T, z),
      click: (z) => {
        z.stopPropagation(), c(T, z);
      },
      dblclick: (z) => {
        z.stopPropagation(), u(T, z);
      },
      contextmenu: (z) => {
        l(T, z);
      }
    } : {}), O = C(() => {
      const T = n.label.handleNodeEvents;
      return {
        "v-ng-node-label": !0,
        hover: T && t.state.hovered,
        selected: T && t.state.selected
      };
    }), I = C(() => {
      const T = n.label.handleNodeEvents;
      return {
        draggable: T && t.state.draggable,
        selectable: T && t.state.selectable
      };
    });
    return (T, z) => (M(), $("g", Pe({
      class: b(O),
      transform: `translate(${b(h)} ${b(d)})`
    }, Zo(b(S)(e.id), !0)), [
      K(T.$slots, "override-node-label", {
        nodeId: e.id,
        scale: b(i),
        text: e.state.labelText,
        x: b(f),
        y: b(g),
        config: e.state.label,
        shape: e.state.shape,
        textAnchor: b(w),
        dominantBaseline: b(m),
        class: ve(b(I))
      }, () => [
        _e(wt, {
          text: e.state.labelText,
          x: 0,
          y: 0,
          config: e.state.label,
          "text-anchor": b(w),
          "dominant-baseline": b(m),
          class: ve(b(I)),
          transform: `translate(${b(f)} ${b(g)})`
        }, null, 8, ["text", "config", "text-anchor", "dominant-baseline", "class", "transform"])
      ])
    ], 16, gr));
  }
});
const mr = /* @__PURE__ */ W({
  __name: "VNodeLabelsLayer",
  setup(e) {
    const t = ft(), n = C(() => "override-node-label" in t), { nodeZOrderedList: o } = Se(), i = pt(), s = Yt(), r = C(() => a(o.value));
    function a(c) {
      return c.filter((u) => {
        var l;
        return u.label.visible && ((l = u.labelText) != null ? l : !1);
      });
    }
    return (c, u) => b(n) ? (M(), R(Ye, {
      key: 0,
      name: b(i).transition,
      css: !!b(i).transition,
      tag: "g",
      class: "v-ng-layer-node-labels"
    }, {
      default: te(() => [
        (M(!0), $(q, null, J(b(r), (l) => (M(), R(Sn, {
          id: l.id,
          key: l.id,
          state: l,
          pos: b(s).nodes[l.id]
        }, {
          "override-node-label": te((h) => [
            K(c.$slots, "override-node-label", ue(de(h)))
          ]),
          _: 2
        }, 1032, ["id", "state", "pos"]))), 128))
      ]),
      _: 3
    }, 8, ["name", "css"])) : (M(), R(Ye, {
      key: 1,
      name: b(i).transition,
      css: !!b(i).transition,
      tag: "g",
      class: "v-ng-layer-node-labels"
    }, {
      default: te(() => [
        (M(!0), $(q, null, J(b(r), (l) => (M(), R(Sn, {
          id: l.id,
          key: l.id,
          state: l,
          pos: b(s).nodes[l.id]
        }, null, 8, ["id", "state", "pos"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), br = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin"], yr = /* @__PURE__ */ W({
  __name: "VPath",
  props: {
    path: null
  },
  setup(e) {
    const t = e, { nodeStates: n, edgeStates: o, layouts: i } = Se(), { scale: s } = me(), r = $n();
    function a(d) {
      if (d.edges.length === 0)
        return [];
      const v = L.value(r.margin, d.path) * s.value;
      return ci(
        d,
        n,
        i.nodes,
        o,
        s.value,
        r.curveInNode,
        r.end,
        v
      );
    }
    function c(d) {
      const v = a(d);
      let x = !0;
      return v.map((k) => {
        if (k === null)
          x = !0;
        else {
          if (typeof k == "string")
            return k;
          if (k instanceof Array) {
            k = [...k];
            const E = [];
            if (k.length % 2 === 1) {
              const p = k[0];
              k = k.slice(1), E.push(`L ${p.x} ${p.y}`);
            }
            return _t(k, 2).map(([p, y]) => E.push(`Q ${p.x} ${p.y} ${y.x} ${y.y}`)), E.join(" ");
          } else {
            const E = x;
            return x = !1, `${E ? "M " : "L "}${k.x} ${k.y}`;
          }
        }
      }).join(" ");
    }
    const u = C(() => {
      const d = t.path;
      return d.selected ? L.values(r.selected, d.path) : d.hovered && r.hover ? L.values(r.hover, d.path) : L.values(r.normal, d.path);
    }), l = C(() => tt(u.value.dasharray, s.value)), h = C(() => {
      const d = u.value.animate ? ht(u.value.dasharray) * u.value.animationSpeed * s.value : !1;
      return d ? { "--animation-speed": d } : void 0;
    });
    return (d, v) => (M(), $("path", {
      class: ve({
        "v-ng-path": !0,
        animate: b(u).animate,
        clickable: e.path.clickable,
        hoverable: e.path.hoverable
      }),
      d: c(e.path),
      fill: "none",
      stroke: b(u).color,
      "stroke-width": b(u).width * b(s),
      "stroke-dasharray": b(l),
      "stroke-linecap": b(u).linecap,
      "stroke-linejoin": b(u).linejoin,
      style: et(b(h))
    }, null, 14, br));
  }
});
const wr = /* @__PURE__ */ W({
  __name: "VPaths",
  setup(e) {
    const { pathZOrderedList: t } = Se(), n = $n(), {
      handlePathPointerDownEvent: o,
      handlePathPointerOverEvent: i,
      handlePathPointerOutEvent: s,
      handlePathClickEvent: r,
      handlePathDoubleClickEvent: a,
      handlePathContextMenu: c
    } = nt();
    return (u, l) => (M(), R(Ye, {
      name: b(n).transition,
      css: !!b(n).transition,
      tag: "g",
      class: "v-ng-paths"
    }, {
      default: te(() => [
        (M(!0), $(q, null, J(b(t), (h) => (M(), R(yr, {
          key: h.id,
          path: h,
          onPointerdown: (d) => b(o)(h.id, d),
          onPointerenterPassive: (d) => b(i)(h.id, d),
          onPointerleavePassive: (d) => b(s)(h.id, d),
          onClick: xe((d) => b(r)(h.id, d), ["stop"]),
          onDblclick: xe((d) => b(a)(h.id, d), ["stop"]),
          onContextmenu: (d) => b(c)(h.id, d)
        }, null, 8, ["path", "onPointerdown", "onPointerenterPassive", "onPointerleavePassive", "onClick", "onDblclick", "onContextmenu"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), Er = /* @__PURE__ */ W({
  __name: "VPathsLayer",
  setup(e) {
    return (t, n) => (M(), R(wr));
  }
}), xr = { key: 0 }, kr = /* @__PURE__ */ W({
  __name: "VNetworkGraph",
  props: {
    nodes: { default: () => ({}) },
    edges: { default: () => ({}) },
    paths: { default: () => ({}) },
    layouts: { default: () => ({}) },
    zoomLevel: { default: 1 },
    selectedNodes: { default: () => [] },
    selectedEdges: { default: () => [] },
    selectedPaths: { default: () => [] },
    configs: { default: () => ({}) },
    layers: { default: () => ({}) },
    eventHandlers: { default: () => ({}) }
  },
  emits: ["update:zoomLevel", "update:selectedNodes", "update:selectedEdges", "update:selectedPaths", "update:layouts"],
  setup(e, { expose: t, emit: n }) {
    const o = e, i = [
      "override-node",
      "override-node-label",
      "edge-overlay",
      "edge-label",
      "edges-label"
    ], s = ft(), r = Me(o, "nodes"), a = Me(o, "edges"), { objects: c, isInCompatibilityModeForPath: u } = fs(
      Me(o, "paths")
    ), l = Fi();
    Object.entries(o.eventHandlers).forEach(([P, N]) => {
      l.on(P, N);
    });
    const h = Wo(Me(o, "configs")), d = C(() => {
      const P = new Set(Object.keys(s));
      i.forEach((D) => P.delete(D));
      const N = Object.fromEntries(jo.map((D) => [D, []]));
      return Object.assign(
        N,
        Object.entries(o.layers).reduce(
          (D, [H, ie]) => (P.delete(H), ie in D ? D[ie].push(H) : D[ie] = [H], D),
          {}
        )
      ), N.root.push(...P), N;
    }), v = C(() => h.view.grid.visible), x = C(() => {
      const P = d.value;
      return v.value || P.background.length > 0 || P.grid.length > 0;
    }), k = ys(h, s), E = _(), p = _(), y = _(), w = _(
      0
      /* INITIAL */
    ), m = C(
      () => w.value !== 0
      /* INITIAL */
    ), f = hs(o, "zoomLevel", n, (P) => (P = Math.max(P, h.view.minZoomLevel), P = Math.min(P, h.view.maxZoomLevel), P)), { svgPanZoom: g, onSvgPanZoomMounted: S, onSvgPanZoomUnmounted: O } = ls(p, {
      viewportSelector: ".v-ng-viewport",
      minZoom: h.view.minZoomLevel,
      // temporary
      maxZoom: h.view.maxZoomLevel,
      // temporary
      dblClickZoomEnabled: nn(h.view),
      mouseWheelZoomEnabled: kt(h.view),
      fit: h.view.autoPanAndZoomOnLoad === "fit-content",
      center: h.view.autoPanAndZoomOnLoad !== !1,
      zoomEnabled: h.view.zoomEnabled,
      preventMouseEventsDefault: !1,
      onZoom: (P) => {
        var D, H;
        if (w.value === 2)
          return;
        const N = (H = (D = g.value) == null ? void 0 : D.getRealZoom()) != null ? H : 1;
        Math.abs(f.value - N) >= 1e-6 && (f.value = N, l.emit("view:zoom", N));
      },
      panEnabled: h.view.panEnabled,
      onPan: (P) => {
        w.value !== 2 && l.emit("view:pan", P);
      }
    });
    Vo({ container: E, svg: p, viewport: y, svgPanZoom: g });
    const I = { width: 0, height: 0 }, T = globalThis.ResizeObserver ? new ResizeObserver(() => {
      var N, D, H;
      if ((N = g.value) == null || N.resize(), !h.view.autoPanOnResize)
        return;
      const P = (D = E.value) == null ? void 0 : D.getBoundingClientRect();
      if (P) {
        const ie = -(I.width - P.width) / 2, ot = -(I.height - P.height) / 2;
        (H = g.value) == null || H.panBy({ x: ie, y: ot });
        const { width: je, height: Pt } = P;
        (I.width !== je || I.height !== Pt) && (Object.assign(I, { width: je, height: Pt }), l.emit("view:resize", { x: P.x, y: P.y, width: je, height: Pt }));
      }
    }) : void 0;
    S(() => {
      var ie, ot, je;
      const P = G(E.value, "svg-pan-zoom container");
      T == null || T.observe(P), (ot = (ie = h.view).onSvgPanZoomInitialized) == null || ot.call(ie, G(g.value, "svg-pan-zoom instance"));
      const N = P.getBoundingClientRect(), { width: D, height: H } = N;
      Object.assign(I, { width: D, height: H }), (je = y.value) == null || je.addEventListener("touchstart", on, { passive: !1 });
    }), O(() => {
      var P;
      T == null || T.disconnect(), (P = y.value) == null || P.removeEventListener("touchstart", on);
    });
    const z = (P) => {
      var N;
      (N = g.value) == null || N.applyAbsoluteZoomLevel(
        P,
        h.view.minZoomLevel,
        h.view.maxZoomLevel
      );
    };
    F(
      () => h.view.panEnabled,
      (P) => {
        var N;
        (N = g.value) == null || N.setPanEnabled(P);
      }
    ), F(
      () => [
        h.view.zoomEnabled,
        nn(h.view),
        kt(h.view)
      ],
      () => {
        const P = g.value;
        P && Mo(
          P,
          h.view.zoomEnabled,
          h.view.doubleClickZoomEnabled,
          h.view.mouseWheelZoomEnabled
        );
      }
    ), F(f, (P) => z(P)), F(
      () => [h.view.minZoomLevel, h.view.maxZoomLevel],
      (P) => {
        z(f.value);
      }
    );
    const { scale: A } = cs(f, h.view);
    S(() => {
      const P = o.zoomLevel;
      z(P);
    });
    const j = () => Ee(this, null, function* () {
      var P;
      Object.keys(o.nodes).length > 0 && ((P = g.value) == null || P.updateBBox(), yield xn());
    }), Y = () => Ee(this, null, function* () {
      yield j(), g.value && (g.value.fitToContents(), l.emit("view:fit", void 0));
    }), B = () => Ee(this, null, function* () {
      var P;
      yield j(), (P = g.value) == null || P.center();
    }), U = () => {
      var P, N;
      return (N = (P = g.value) == null ? void 0 : P.getViewBox()) != null ? N : {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }, be = (P) => {
      var N;
      return (N = g.value) == null ? void 0 : N.setViewBox(P);
    }, oe = Tt(o, "selectedNodes", r, n);
    F(oe, (P) => l.emit("node:select", Array.from(P)));
    const ke = Tt(o, "selectedEdges", a, n);
    F(ke, (P) => l.emit("edge:select", Array.from(P)));
    const De = Tt(o, "selectedPaths", c, n);
    F(De, (P) => l.emit("path:select", Array.from(P))), vs(oe, ke, De);
    const Ue = ze(/* @__PURE__ */ new Set()), le = ze(/* @__PURE__ */ new Set()), Be = ze(/* @__PURE__ */ new Set()), ye = ze({ nodes: {} });
    gs(ye), F(
      () => o.layouts,
      () => Object.assign(ye, o.layouts),
      { deep: !0, immediate: !0 }
    ), F(ye, () => n("update:layouts", ye), { deep: !0 });
    const Et = pi(), xt = _(!1);
    l.on("node:dragstart", (P) => xt.value = !0), l.on("node:dragend", (P) => xt.value = !1), l.on("view:mode", (P) => {
      var N, D, H, ie;
      h.view.panEnabled && (P === "default" ? (N = g.value) == null || N.enablePan() : (D = g.value) == null || D.disablePan()), h.view.zoomEnabled && (P === "default" ? (H = g.value) == null || H.enableZoom() : (ie = g.value) == null || ie.disableZoom());
    });
    const so = C(() => h.view.panEnabled || h.view.zoomEnabled || h.node.draggable), { nodeStates: ro, edgeStates: ao, pathStates: lo } = wi(
      Ct(r, oe, Ue),
      Ct(a, ke, le),
      Ct(c, De, Be),
      Xe(h),
      ye,
      Et,
      A
    ), co = C(() => kt(h.view)), { isBoxSelectionMode: uo, selectionBox: Qt, startBoxSelection: fo, stopBoxSelection: ho } = Wi(
      p,
      Xe(ye),
      Xe(f),
      ro,
      ao,
      lo,
      oe,
      ke,
      De,
      Ue,
      le,
      Be,
      u,
      co,
      h,
      l
    ), Jt = () => ({
      layouts: ze(ye.nodes),
      // deprecated parameter.
      nodePositions: Me(ye, "nodes"),
      nodes: r,
      edges: a,
      configs: Xe(h),
      scale: Xe(A),
      emitter: l,
      svgPanZoom: G(g.value)
    });
    F(
      () => h.view.layoutHandler,
      (P, N) => {
        N.deactivate(), P.activate(Jt());
      }
    );
    const { transitionWhile: vo, transitionOption: en } = ds(), po = C(() => {
      const P = en.value;
      return P.enabled ? {
        "--transition-duration": P.duration + "ms",
        "--transition-function": P.timingFunction
      } : {};
    });
    S(() => Ee(this, null, function* () {
      if (h.view.onBeforeInitialDisplay) {
        const D = h.view.onBeforeInitialDisplay();
        qo(D) && (yield D);
      }
      const P = G(g.value, "svg-pan-zoom");
      h.view.layoutHandler.activate(Jt()), yield xn();
      const N = h.view.autoPanAndZoomOnLoad;
      if (h.view.fit || N !== !1) {
        const D = Object.keys(o.nodes).length == 0, H = P.getPan();
        if (D || N === "center-zero") {
          yield j();
          const ie = P.getSizes();
          P.pan({
            x: ie.width / 2,
            y: ie.height / 2
          });
        } else
          N === "fit-content" || h.view.fit ? yield Y() : N === "center-content" ? yield B() : yield j();
        Dt(() => {
          const ie = P.getPan();
          H.x === ie.x && H.y === ie.y && l.emit("view:pan", ie);
        });
      } else
        yield j();
      l.emit("view:load"), w.value = 1;
    })), O(() => {
      w.value = 2, l.emit("view:unload"), h.view.layoutHandler.deactivate();
    });
    function go() {
      var P;
      (P = g.value) == null || P.zoomIn();
    }
    function mo() {
      var P;
      (P = g.value) == null || P.zoomOut();
    }
    function bo(P) {
      var N;
      (N = g.value) == null || N.pan(P);
    }
    function yo(P) {
      var N;
      (N = g.value) == null || N.panBy(P);
    }
    function wo() {
      return G(g.value).getPan();
    }
    function Eo() {
      const P = G(g.value).getSizes();
      return {
        width: P.width,
        height: P.height,
        viewBox: P.viewBox
      };
    }
    function xo(P) {
      return At(
        G(p.value, "svg"),
        G(y.value, "viewport"),
        P
      );
    }
    function ko(P) {
      return Ni(
        G(p.value, "svg"),
        G(y.value, "viewport"),
        P
      );
    }
    function Po() {
      return Xn(
        G(p.value, "svg"),
        G(y.value, "viewport"),
        A.value
      ).outerHTML;
    }
    function So() {
      return Ee(this, arguments, function* (P = {}) {
        return (yield tn(P)).outerHTML;
      });
    }
    function tn() {
      return Ee(this, arguments, function* (P = {}) {
        return Bi(
          G(p.value, "svg"),
          G(y.value, "viewport"),
          A.value,
          P
        );
      });
    }
    t({
      // methods
      fitToContents: Y,
      panToCenter: B,
      getViewBox: U,
      setViewBox: be,
      transitionWhile: vo,
      startBoxSelection: fo,
      stopBoxSelection: ho,
      zoomIn: go,
      zoomOut: mo,
      panTo: bo,
      panBy: yo,
      getPan: wo,
      getSizes: Eo,
      translateFromDomToSvgCoordinates: xo,
      translateFromSvgToDomCoordinates: ko,
      getAsSvg: Po,
      exportAsSvgText: So,
      exportAsSvgElement: tn
    });
    function Mo(P, N, D, H) {
      P.setZoomEnabled(N), N && D ? P.enableDblClickZoom() : P.disableDblClickZoom(), N && H ? P.enableMouseWheelZoom() : P.disableMouseWheelZoom();
    }
    function nn(P) {
      return P.zoomEnabled && P.doubleClickZoomEnabled;
    }
    function kt(P) {
      return P.zoomEnabled && P.mouseWheelZoomEnabled;
    }
    function on(P) {
      P.stopPropagation();
    }
    return (P, N) => (M(), $("div", {
      ref_key: "container",
      ref: E,
      class: "v-network-graph v-ng-container"
    }, [
      (M(), $("svg", {
        ref_key: "svg",
        ref: p,
        class: ve(["v-ng-canvas", { show: b(m), dragging: xt.value, touches: b(so), "box-selection-mode": b(uo) }]),
        width: "100%",
        height: "100%"
      }, [
        (M(!0), $(q, null, J(b(d).root, (D) => K(P.$slots, D, {
          key: D,
          scale: b(A)
        })), 128)),
        Object.keys(b(Et).markers).length > 0 ? (M(), $("defs", xr, [
          (M(!0), $(q, null, J(b(Et).markers, (D, H) => (M(), R(Ts, {
            id: H,
            key: H,
            marker: D,
            scale: b(A)
          }, null, 8, ["id", "marker", "scale"]))), 128))
        ])) : ce("", !0),
        b(x) ? (M(), R(Ds, { key: 1 }, {
          default: te(() => [
            (M(!0), $(q, null, J(b(d).background, (D) => (M(), $("g", {
              key: D,
              class: "v-ng-layer"
            }, [
              K(P.$slots, D, { scale: b(A) })
            ]))), 128)),
            b(v) ? (M(), R(Zs, { key: 0 })) : ce("", !0),
            (M(!0), $(q, null, J(b(d).grid, (D) => (M(), $("g", {
              key: D,
              class: "v-ng-layer"
            }, [
              K(P.$slots, D, { scale: b(A) })
            ]))), 128))
          ]),
          _: 3
        })) : ce("", !0),
        Cn("g", {
          ref_key: "viewport",
          ref: y,
          class: ve(["v-ng-viewport", { "v-ng-transition": b(en).enabled }]),
          style: et(b(po))
        }, [
          (M(!0), $(q, null, J(b(d).base, (D) => (M(), $("g", {
            key: D,
            class: "v-ng-layer"
          }, [
            K(P.$slots, D, { scale: b(A) })
          ]))), 128)),
          (M(!0), $(q, null, J(b(k), (D) => (M(), $(q, { key: D }, [
            D === "edges" ? (M(), R(tr, { key: 0 }, Nt({ _: 2 }, [
              "edge-overlay" in b(s) ? {
                name: "edge-overlay",
                fn: te((H) => [
                  K(P.$slots, "edge-overlay", ue(de(H)))
                ]),
                key: "0"
              } : void 0
            ]), 1024)) : D === "edge-labels" ? (M(), R(rr, {
              key: 1,
              "enable-edge-label": "edge-label" in b(s),
              "enable-edges-label": "edges-label" in b(s)
            }, {
              "edge-label": te((H) => [
                K(P.$slots, "edge-label", ue(de(H)))
              ]),
              "edges-label": te((H) => [
                K(P.$slots, "edges-label", ue(de(H)))
              ]),
              _: 3
            }, 8, ["enable-edge-label", "enable-edges-label"])) : D === "focusring" ? (M(), R(cr, { key: 2 })) : D === "nodes" ? (M(), R(dr, { key: 3 }, {
              "override-node": te((H) => [
                K(P.$slots, "override-node", ue(de(H)))
              ]),
              _: 3
            })) : D === "node-labels" ? (M(), R(mr, { key: 4 }, {
              "override-node-label": te((H) => [
                K(P.$slots, "override-node-label", ue(de(H)))
              ]),
              _: 3
            })) : D === "paths" ? (M(), R(Er, { key: 5 })) : ce("", !0),
            (M(!0), $(q, null, J(b(d)[D], (H) => (M(), $("g", {
              key: H,
              class: "v-ng-layer"
            }, [
              K(P.$slots, H, { scale: b(A) })
            ]))), 128))
          ], 64))), 128))
        ], 6),
        b(Qt) ? (M(), R(Es, {
          key: 2,
          box: b(Qt),
          config: b(h).view.selection.box
        }, null, 8, ["box", "config"])) : ce("", !0)
      ], 2))
    ], 512));
  }
});
const Pr = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, i] of t)
    n[o] = i;
  return n;
}, Sr = {};
function Mr(e, t) {
  return M(), $("defs", null, [
    (M(), R(Mn("style"), null, {
      default: te(() => [
        K(e.$slots, "default")
      ]),
      _: 3
    }))
  ]);
}
const Cr = /* @__PURE__ */ Pr(Sr, [["render", Mr]]), Or = /* @__PURE__ */ W({
  __name: "VEdgeLabel",
  props: {
    area: null,
    config: null,
    text: { default: "" },
    align: { default: "center" },
    verticalAlign: { default: "center" },
    edge: { default: void 0 },
    hovered: { type: Boolean, default: void 0 },
    selected: { type: Boolean, default: void 0 },
    scale: { default: void 0 }
  },
  setup(e) {
    const t = e, n = _(0), o = _(0), i = _("middle"), s = _("central"), r = _(0);
    ge(() => {
      const c = t.area.source, u = t.area.target;
      t.align === "source" ? (c.above.x == u.above.x ? i.value = c.above.y > u.above.y ? "start" : "end" : i.value = c.above.x < u.above.x ? "start" : "end", t.verticalAlign === "above" ? (n.value = c.above.x, o.value = c.above.y, s.value = "text-top") : t.verticalAlign === "below" ? (n.value = c.below.x, o.value = c.below.y, s.value = "hanging") : (n.value = (c.above.x + c.below.x) / 2, o.value = (c.above.y + c.below.y) / 2, s.value = "central")) : t.align === "target" ? (c.above.x == u.above.x ? i.value = c.above.y < u.above.y ? "start" : "end" : i.value = c.above.x > u.above.x ? "start" : "end", t.verticalAlign === "above" ? (n.value = u.above.x, o.value = u.above.y, s.value = "text-top") : t.verticalAlign === "below" ? (n.value = u.below.x, o.value = u.below.y, s.value = "hanging") : (n.value = (u.above.x + u.below.x) / 2, o.value = (u.above.y + u.below.y) / 2, s.value = "central")) : (i.value = "middle", t.verticalAlign === "above" ? (n.value = (c.above.x + u.above.x) / 2, o.value = (c.above.y + u.above.y) / 2, s.value = "text-top") : t.verticalAlign === "below" ? (n.value = (c.below.x + u.below.x) / 2, o.value = (c.below.y + u.below.y) / 2, s.value = "hanging") : (n.value = (c.above.x + u.below.x) / 2, o.value = (c.above.y + u.below.y) / 2, s.value = "central"));
      let l = Q.fromPositions(c.above, u.above).v.angleDegree();
      (l < -90 || l >= 90) && (l = l + 180, l > 180 && (l -= 360)), r.value = l;
    });
    const a = C(() => s.value === "central" && !t.config.background ? Fe(se({}, t.config), {
      background: {
        visible: !0,
        color: "#ffffff",
        padding: {
          vertical: 1,
          horizontal: 4
        },
        borderRadius: 2
      }
    }) : t.config);
    return (c, u) => (M(), R(wt, {
      class: "v-ng-edge-label",
      text: e.text,
      x: n.value,
      y: o.value,
      config: b(a),
      "text-anchor": i.value,
      "dominant-baseline": s.value,
      transform: `rotate(${r.value} ${n.value} ${o.value})`
    }, null, 8, ["text", "x", "y", "config", "text-anchor", "dominant-baseline", "transform"]));
  }
}), Tr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VEdgeLabel: Or,
  VLabelText: wt,
  VNetworkGraph: kr,
  VShape: yt,
  VStyle: Cr
}, Symbol.toStringTag, { value: "Module" })), zr = 10;
class Nr extends zn {
  constructor(t = {}) {
    super(), this.options = t;
  }
  setNodePosition(t, n) {
    const o = this.options.grid || zr;
    t.value.x = Math.floor(n.x / o) * o, t.value.y = Math.floor(n.y / o) * o;
  }
}
const _r = function(e) {
  Object.entries(Tr).forEach(([t, n]) => {
    e.component(t, n);
  });
};
export {
  L as Config,
  Nr as GridLayout,
  jo as LayerPositions,
  Z as NodeLabelDirection,
  zn as SimpleLayout,
  Or as VEdgeLabel,
  wt as VLabelText,
  kr as VNetworkGraph,
  yt as VShape,
  Cr as VStyle,
  V as Vector2D,
  Ar as configsWithType,
  _r as default,
  Zr as defineConfigs,
  Dr as getFullConfigs,
  Se as useStates,
  St as withSelf
};
//# sourceMappingURL=index.js.map
