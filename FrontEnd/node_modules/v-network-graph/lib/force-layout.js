var D = Object.defineProperty, T = Object.defineProperties;
var C = Object.getOwnPropertyDescriptors;
var j = Object.getOwnPropertySymbols;
var P = Object.prototype.hasOwnProperty, w = Object.prototype.propertyIsEnumerable;
var O = (u, t, e) => t in u ? D(u, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : u[t] = e, k = (u, t) => {
  for (var e in t || (t = {}))
    P.call(t, e) && O(u, e, t[e]);
  if (j)
    for (var e of j(t))
      w.call(t, e) && O(u, e, t[e]);
  return u;
}, N = (u, t) => T(u, C(t));
import { watch as A, toRef as B } from "vue";
import * as x from "d3-force";
class K {
  constructor(t = {}) {
    this.options = t;
  }
  activate(t) {
    const { nodePositions: e, nodes: i, edges: a, emitter: n } = t;
    let { nodeLayouts: d, nodeLayoutMap: y } = this.buildNodeLayouts(i.value, e);
    const h = this.createSimulation(
      d,
      this.forceLayoutEdges(a.value, i.value)
    );
    this.onTick = () => {
      var s, l, c, o, f;
      for (const r of d) {
        const g = (s = e.value) == null ? void 0 : s[r.id];
        if (g) {
          const m = (l = r.x) != null ? l : 0, E = (c = r.y) != null ? c : 0;
          (g.x !== m || g.y !== m) && Object.assign(g, { x: m, y: E });
        } else
          e.value[r.id] = {
            x: (o = r.x) != null ? o : 0,
            y: (f = r.y) != null ? f : 0
          };
      }
    }, h.on("tick", this.onTick), this.onTick();
    const v = () => {
      this.options.noAutoRestartSimulation || h.alpha(0.1).restart();
    }, p = (s) => {
      var l;
      if (this.options.noAutoRestartSimulation)
        for (const [c, o] of Object.entries(s)) {
          const f = (l = e.value) == null ? void 0 : l[c];
          f.x = o.x, f.y = o.y;
        }
      else {
        for (const [c, o] of Object.entries(s)) {
          const f = y[c];
          f.fx = o.x, f.fy = o.y;
        }
        v();
      }
    }, b = (s) => {
      var l;
      for (const [c, o] of Object.entries(s)) {
        const f = this.getNodeLayout(e, c), r = (l = y == null ? void 0 : y[c]) != null ? l : { x: 0, y: 0 };
        f.value.fixed || this.options.positionFixedByDrag ? (r.fx = o.x, r.fy = o.y, f.value.fixed = !0) : (r.x = o.x, r.y = o.y, delete r.fx, delete r.fy);
      }
      v();
    }, L = ({ node: s, event: l }) => {
      if (this.options.positionFixedByClickWithAltKey && l.altKey) {
        const c = this.getNodeLayout(e, s);
        let o = y == null ? void 0 : y[s];
        o || (o = { id: s, x: 0, y: 0 }, y[s] = o), c.value.fixed ? (delete c.value.fixed, o.x = o.fx || o.x, o.y = o.fy || o.y, delete o.fx, delete o.fy) : (c.value.fixed = !0, o.fx = o.x, o.fy = o.y), v();
      }
    }, S = A(
      () => [
        Object.keys(i.value),
        Object.keys(e.value),
        // Watch only for changes in links, not all properties of the edge objects.
        Object.values(a.value).map((s) => `${s.source}=${s.target}`)
      ],
      () => {
        ({ nodeLayouts: d, nodeLayoutMap: y } = this.buildNodeLayouts(i.value, e)), h.nodes(d);
        const s = h.force("edge");
        s && s.links(this.forceLayoutEdges(a.value, i.value)), v();
      }
    );
    n.on("node:dragstart", p), n.on("node:pointermove", p), n.on("node:dragend", b), n.on("node:click", L), this.onDeactivate = () => {
      h.stop(), S(), n.off("node:dragstart", p), n.off("node:pointermove", p), n.off("node:dragend", b), n.off("node:click", L);
    };
  }
  deactivate() {
    this.onDeactivate && this.onDeactivate(), this.onTick = void 0;
  }
  ticked() {
    var t;
    (t = this.onTick) == null || t.call(this);
  }
  createSimulation(t, e) {
    if (this.options.createSimulation)
      return this.options.createSimulation(x, t, e);
    {
      const i = x.forceLink(e).id((a) => a.id);
      return x.forceSimulation(t).force("edge", i.distance(100)).force("charge", x.forceManyBody()).force("collide", x.forceCollide(50).strength(0.2)).force("center", x.forceCenter().strength(0.05)).alphaMin(1e-3);
    }
  }
  buildNodeLayouts(t, e) {
    const i = Object.keys(t).filter((d) => !(d in e.value)), a = this.forceNodeLayouts(e.value, i), n = Object.fromEntries(a.map((d) => [d.id, d]));
    return { nodeLayouts: a, nodeLayoutMap: n };
  }
  forceNodeLayouts(t, e) {
    const i = Object.entries(t).map(([a, n]) => n.fixed ? N(k({ id: a }, n), { fx: n.x, fy: n.y }) : k({ id: a }, n));
    return e.map((a) => ({ id: a })).forEach((a) => i.push(a)), i;
  }
  forceLayoutEdges(t, e) {
    return Object.values(t).filter((i) => i.source in e && i.target in e).map((i) => ({
      source: i.source,
      target: i.target
    }));
  }
  getNodeLayout(t, e) {
    const i = B(t.value, e);
    return i.value || (i.value = { x: 0, y: 0 }), i;
  }
}
export {
  K as ForceLayout
};
//# sourceMappingURL=force-layout.js.map
